{"id": "Herstein|exercise_2_1_18", "nl_statement": "If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$.", "nl_proof": "\\begin{proof}\n\n    First note that $a=a^{-1}$ is the same as saying $a^2=e$, where $e$ is the identity. I.e. the statement is that there exists at least one element of order 2 in $G$.\n\nEvery element $a$ of $G$ of order at least 3 has an inverse $a^{-1}$ that is not itself -- that is, $a \\neq a^{-1}$. So the subset of all such elements has an even cardinality (/size). There's exactly one element with order 1 : the identity $e^1=e$. So $G$ contains an even number of elements -call it $2 k$-- of which an even number are elements of order 3 or above -- call that $2 n$ where $n<k$-- and exactly one element of order 1 . Hence the number of elements of order 2 is\n\n$$\n\n2 k-2 n-1=2(k-n)-1\n\n$$\n\nThis cannot equal 0 as $2(k-n)$ is even and 1 is odd. Hence there's at least one element of order 2 in $G$, which concludes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_1_18 {G : Type*} [group G] \n  [fintype G] (hG2 : even (fintype.card G)) :\n  \u2203 (a : G), a \u2260 1 \u2227 a = a\u207b\u00b9 :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_inv_eq_of_even_order {G : Type*} [group G] (hG : fintype G)\n  (hG2 : 2 \u2223 fintype.card G) :\n  \u2203 (a : G), a \u2260 1 \u2227 a = a\u207b\u00b9 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem inv_ne_zero {G\u2080 : Type*} [group_with_zero G\u2080] {a : G\u2080} (h : a \u2260 0) :\n\ta\u207b\u00b9 \u2260 0\n\ntheorem inv_mul_cancel {G\u2080 : Type*} [group_with_zero G\u2080] {a : G\u2080} (h : a \u2260 0) :\n\ta\u207b\u00b9 * a = 1\n\ntheorem mul_inv_cancel {G\u2080 : Type u} [group_with_zero G\u2080] {a : G\u2080} (h : a \u2260 0) :\n\ta * a\u207b\u00b9 = 1\n\ntheorem is_group_hom.inv_ker_one' {G H : Type*} [group G] [group H] {f : G \u2192 H}\n\t(hf : is_group_hom f) {a b : G} (h : f a = f b) :\n\tf (a\u207b\u00b9 * b) = 1\n\nThe following is the natural language theorem statement: \"If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_inv_of_even_order_of_finite_group {G : Type*} [group G] \n  [fintype G] (hG : 2 \u2223 fintype.card G) :\n  \u2203 (a : G), a \u2260 1 \u2227 a = a\u207b\u00b9 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_1_26", "nl_statement": "If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.", "nl_proof": "\\begin{proof}\n\n    Because there are only a finite number of elements of $G$, it's clear that the set $\\left\\{a, a^2, a^3, \\ldots\\right\\}$ must be a finite set and in particular, there should exist some $i$ and $j$ such that $i \\neq j$ and $a^i=a^j$. WLOG suppose further that $i>j$ (just reverse the roles of $i$ and $j$ otherwise). Then multiply both sides by $\\left(a^j\\right)^{-1}=a^{-j}$ to get\n\n$$\n\na^i * a^{-j}=a^{i-j}=e\n\n$$\n\nThus the $n=i-j$ is a positive integer such that $a^n=e$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_1_26 {G : Type*} [group G] \n  [fintype G] (a : G) : \u2203 (n : \u2115), a ^ n = 1 :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_npow_eq_one_of_finite_group {G : Type*} [group G] [finite G]\n  (x : G) : \u2203 (n : \u2115), 0 < n \u2227 x ^ n = 1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem exists_npow_eq_one_of_zpow_eq_one {G : Type*} [group G] {n : \u2124}\n\t(hn : n \u2260 0) {x : G} (h : x ^ n = 1) :\n\t\u2203 (n : \u2115), 0 < n \u2227 x ^ n = 1\n\ntheorem exists_zpow_eq_one {G : Type u} [group G] [finite G] (x : G) :\n\t\u2203 (i : \u2124) (H : i \u2260 0), x ^ i = 1\n\ntheorem finite_field.pow_card_sub_one_eq_one {K : Type*} [group_with_zero K]\n\t[fintype K] (a : K) (ha : a \u2260 0) :\n\ta ^ (fintype.card K - 1) = 1\n\ntheorem finite_field.pow_card_pow {K : Type*} [group_with_zero K] [fintype K]\n\t(n : \u2115) (a : K) :\n\ta ^ fintype.card K ^ n = a\n\nThe following is the natural language theorem statement: \"If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_pow_eq_one_of_fintype {G : Type*} [group G] [fintype G] \n  (a : G) : \u2203 (n : \u2115), a ^ n = 1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_2_3", "nl_statement": "If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be a group, $a, b \\in G$ and $i$ be any integer. Then from given condition,\n\n$$\n\n\\begin{aligned}\n\n(a b)^i & =a^i b^i \\\\\n\n(a b)^{i+1} & =a^{i+1} b^{i+1} \\\\\n\n(a b)^{i+2} & =a^{i+2} b^{i+2}\n\n\\end{aligned}\n\n$$\n\nFrom first and second, we get\n\n$$\n\na^{i+1} b^{i+1}=(a b)^i(a b)=a^i b^i a b \\Longrightarrow b^i a=a b^i\n\n$$\n\nFrom first and third, we get\n\n$$\n\na^{i+2} b^{i+2}=(a b)^i(a b)^2=a^i b^i a b a b \\Longrightarrow a^2 b^{i+1}=b^i a b a\n\n$$\n\nThis gives\n\n$$\n\na^2 b^{i+1}=a\\left(a b^i\\right) b=a b^i a b=b^i a^2 b\n\n$$\n\nFinally, we get\n\n$$\n\nb^i a b a=b^i a^2 b \\Longrightarrow b a=a b\n\n$$\n\nThis shows that $G$ is Abelian.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_2_3 {G : Type*} [group G]\n  {P : \u2115 \u2192 Prop} {hP : P = \u03bb i, \u2200 a b : G, (a*b)^i = a^i * b^i}\n  (hP1 : \u2203 n : \u2115, P n \u2227 P (n+1) \u2227 P (n+2)) : comm_group G :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " abelian_of_consecutive_powers_eq {G : Type*} [group G] {a b : G}\n  (h : (a * b) ^ 1 = a ^ 1 * b ^ 1 \u2227 (a * b) ^ 2 = a ^ 2 * b ^ 2 \u2227\n    (a * b) ^ 3 = a ^ 3 * b ^ 3) :\n  \u2200 (x y : G), x * y = y * x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem eq_inv_mul_of_mul_eq {G : Type*} [group G] {a b c : G} (h : b * a = c) :\n\ta = b\u207b\u00b9 * c\n\ntheorem mul_eq_of_eq_inv_mul {G : Type*} [group G] {a b c : G} (h : b = a\u207b\u00b9 * c) :\n\ta * b = c\n\ntheorem mul_eq_of_eq_mul_inv {G : Type*} [group G] {a b c : G} (h : a = c * b\u207b\u00b9) :\n\ta * b = c\n\ntheorem eq_mul_of_mul_inv_eq {G : Type*} [group G] {a b c : G} (h : a * c\u207b\u00b9 = b) :\n\ta = b * c\n\nThe following is the natural language theorem statement: \"If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abelian_of_consecutive_powers_eq {G : Type*} [group G] \n  (a b : G) (i j k : \u2115) (h : (a * b) ^ i = a ^ i * b ^ i) \n  (h' : (a * b) ^ j = a ^ j * b ^ j) (h'' : (a * b) ^ k = a ^ k * b ^ k) :\n  comm_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_2_6c", "nl_statement": "Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$.", "nl_proof": "\\begin{proof}\n\n    We start with the following two intermediate results.\n\n(1) $(a b)^{n-1}=b^{n-1} a^{n-1}$.\n\n(2) $a^n b^{n-1}=b^{n-1} a^n$.\n\nTo prove (1), notice by the given condition for all $a, b \\in G$\n\n$(b a)^n=b^n a^n$, for some fixed integers $n>1$.\n\nThen,\n\n$(b a)^n=b^n a^n \\Longrightarrow b .(a b)(a b) \\ldots .(a b) . a=b\\left(b^{n-1} a^{n-1}\\right) a$, where $(a b)$ occurs $n-1$ times $\\Longrightarrow(a b)^{n-1}=b^{n-1} a^{n-1}$, by cancellation law.\n\nHence, for all $a, b \\in G$\n\n$$\n\n(a b)^{n-1}=b^{n-1} a^{n-1} .\n\n$$\n\nTo prove (2), notice by the given condition for all $a, b \\in G$\n\n$(b a)^n=b^n a^n$, for some fixed integers $n>1$.\n\nThen we have\n\n$$\n\n\\begin{aligned}\n\n& (b a)^n=b^n a^n \\\\\n\n\\Longrightarrow & b \\cdot(a b)(a b) \\ldots(a b) \\cdot a=b\\left(b^{n-1} a^{n-1}\\right) a, \\text { where }(a b) \\text { occurs } n-1 \\text { times } \\\\\n\n\\Longrightarrow & (a b)^{n-1}=b^{n-1} a^{n-1}, \\text { by cancellation law } \\\\\n\n\\Longrightarrow & (a b)^{n-1}(a b)=\\left(b^{n-1} a^{n-1}\\right)(a b) \\\\\n\n\\Longrightarrow & (a b)^n=b^{n-1} a^n b \\\\\n\n\\Longrightarrow & a^n b^n=b^{n-1} a^n b, \\text { given condition } \\\\\n\n\\Longrightarrow & a^n b^{n-1}=b^{n-1} a^n, \\text { by cancellation law. }\n\n\\end{aligned}\n\n$$\n\nTherefore for all $a, b \\in G$ we have\n\n$$\n\na^n b^{n-1}=b^{n-1} a^n\n\n$$\n\nIn order to show that\n\n$$\n\n\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e, \\text { for all } a, b \\in G\n\n$$\n\nit is enough to show that\n\n$$\n\n(a b)^{n(n-1)}=(b a)^{n(n-1)}, \\quad \\forall x, y \\in G .\n\n$$\n\nStep 3\n\nThis is because of\n\n$$\n\n\\begin{aligned}\n\n(a b)^{n(n-1)}=(b a)^{n(n-1)} & \\left.\\Longrightarrow(b a)^{-1}\\right)^{n(n-1)}(a b)^{n(n-1)}=e \\\\\n\n& \\Longrightarrow\\left(a^{-1} b^{-1}\\right)^{n(n-1)}(a b)^{n(n-1)}=e \\\\\n\n& \\Longrightarrow\\left(\\left(a^{-1} b^{-1}\\right)^n\\right)^{n-1}\\left((a b)^n\\right)(n-1)=e \\\\\n\n& \\Longrightarrow\\left((a b)^n\\left(a^{-1} b^{-1}\\right)^n\\right)^{n-1}=e, \\text { by }(1) \\\\\n\n& \\Longrightarrow\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e, \\text { ( given condition) }\n\n\\end{aligned}\n\n$$\n\nNow, it suffices to show that\n\n$$\n\n(a b)^{n(n-1)}=(b a)^{n(n-1)}, \\quad \\forall x, y \\in G .\n\n$$\n\nNow, we have\n\n$$\n\n\\begin{aligned}\n\n(a b)^{n(n-1)} & =\\left(a^n b^n\\right)^{n-1}, \\text { by the given condition } \\\\\n\n& =\\left(a^n b^{n-1} b\\right)^{n-1} \\\\\n\n& =\\left(b^{n-1} a^n b\\right)^{n-1}, \\text { by }(2) \\\\\n\n& =\\left(a^n b\\right)^{n-1}\\left(b^{n-1}\\right)^{n-1}, \\text { by }(1) \\\\\n\n& =b^{n-1}\\left(a^n\\right)^{n-1}\\left(b^{n-1}\\right)^{n-1}, \\text { by }(1) \\\\\n\n& =\\left(b^{n-1}\\left(a^{n-1}\\right)^n\\right)\\left(b^{n-1}\\right)^{n-1} \\\\\n\n& =\\left(a^{n-1}\\right)^n b^{n-1}\\left(b^{n-1}\\right)^{n-1}, \\text { by }(2) \\\\\n\n& =\\left(a^{n-1}\\right)^n\\left(b^{n-1}\\right)^n \\\\\n\n& =\\left(a^{n-1} b^{n-1}\\right)^n, \\text { by }(1) \\\\\n\n& =(b a)^{n(n-1)}, \\text { by }(1) .\n\n\\end{aligned}\n\n$$\n\nThis completes our proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_2_6c {G : Type*} [group G] {n : \u2115} (hn : n > 1) \n  (h : \u2200 (a b : G), (a * b) ^ n = a ^ n * b ^ n) :\n  \u2200 (a b : G), (a * b * a\u207b\u00b9 * b\u207b\u00b9) ^ (n * (n - 1)) = 1 :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " pow_coprime_one {n : \u2115} {G : Type*} [group G]\n  (h : (nat.card G).coprime n) :\n  \u21d1(pow_coprime h) 1 = 1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem pow_coprime_one {n : \u2115} {G : Type*} [group G]\n\t(h : (nat.card G).coprime n) :\n\t\u21d1(pow_coprime h) 1 = 1\n\ntheorem exists_npow_eq_one_of_zpow_eq_one {G : Type*} [group G] {n : \u2124}\n\t(hn : n \u2260 0) {x : G} (h : x ^ n = 1) :\n\t\u2203 (n : \u2115), 0 < n \u2227 x ^ n = 1\n\ntheorem pow_coprime_inv {n : \u2115} {G : Type*} [group G]\n\t(h : (nat.card G).coprime n) {g : G} :\n\t\u21d1(pow_coprime h) g\u207b\u00b9 = (\u21d1(pow_coprime h) g)\u207b\u00b9\n\ntheorem inv_pow_sub_of_lt {G\u2080 : Type*} [group_with_zero G\u2080] {m n : \u2115} (a : G\u2080)\n\t(h : n < m) :\n\ta\u207b\u00b9 ^ (m - n) = (a ^ m)\u207b\u00b9 * a ^ n\n\nThe following is the natural language theorem statement: \"Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " eq_one_of_comm_pow_eq_pow_of_comm_pow_eq_pow {G : Type*} [group G]\n  (n : \u2115) (hn : n > 1) (h : \u2200 a b : G, (a * b) ^ n = a ^ n * b ^ n) :\n  \u2200 a b : G, (a * b * a\u207b\u00b9 * b\u207b\u00b9) ^ (n * (n - 1)) = 1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_3_16", "nl_statement": "If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number.", "nl_proof": "\\begin{proof}\n\n    Case-1: $G=(e), e$ being the identity element in $G$. Then trivially $G$ is cyclic.\n\n    Case-2: $G \\neq(e)$. Then there exists an non-identity element in $G.$ Let us consider an non-identity element in $G$, say $a\\neq (e)$. Now look at the cyclic subgroup generated by $a$, that is, $\\langle a\\rangle$. Since\n\n    $a\\neq (e) \\in G,\\langle a\\rangle$ is a subgroup of $G$.\n\nIf $G \\neq\\langle a\\rangle$ then $\\langle a\\rangle$ is a proper non-trivial subgroup of $G$, which is an impossibility. Therfore we must have\n\n$$\n\nG=\\langle a\\rangle .\n\n$$\n\nThis implies, $G$ is a cyclic group generated by $a$. Then it follows that every non-identity element of $G$ is a generator of $G$. Now we claim that $G$ is finite.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_3_16 {G : Type*} [group G]\n  (hG : \u2200 H : subgroup G, H = \u22a4 \u2228 H = \u22a5) :\n  is_cyclic G \u2227 \u2203 (p : \u2115) (fin : fintype G), nat.prime p \u2227 @card G fin = p :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_p_group_of_no_proper_subgroups {G : Type*} [group G]\n  (hG : \u2200 (H : subgroup G), H = \u22a5 \u2228 H = \u22a4) [nontrivial G] [finite G] :\n  \u2203 (p : \u2115), nat.prime p \u2227 is_p_group p G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_p_group.index {p : \u2115} {G : Type*} [group G] (hG : is_p_group p G)\n\t[hp : fact (nat.prime p)] (H : subgroup G) [H.finite_index] :\n\t\u2203 (n : \u2115), H.index = p ^ n\n\ntheorem is_p_group.to_subgroup {p : \u2115} {G : Type*} [group G]\n\t(hG : is_p_group p G) (H : subgroup G) :\n\tis_p_group p \u21a5H\n\ntheorem is_p_group.is_nilpotent {G : Type*} [hG : group G] [finite G] {p : \u2115}\n\t[hp : fact (nat.prime p)] (h : is_p_group p G) :\n\tgroup.is_nilpotent G\n\ntheorem is_p_group.center_nontrivial {p : \u2115} {G : Type*} [group G]\n\t(hG : is_p_group p G) [hp : fact (nat.prime p)] [nontrivial G] [finite G] :\n\tnontrivial \u21a5(subgroup.center G)\n\nThe following is the natural language theorem statement: \"If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_cyclic_of_no_proper_subgroups {G : Type*} [group G] \n  (hG : \u2200 (H : subgroup G), H = \u22a5 \u2228 H = \u22a4) :\n  \u2203 (p : \u2115) (hp : nat.prime p), is_cyclic G p ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_5_23", "nl_statement": "Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be a group where each subgroup is normal in $G$. let $a, b \\in G$.\n\n$$\n\n\\begin{aligned}\n\n    \\langle a\\rangle\\triangleright  G  &\\Rightarrow b \\cdot\\langle a\\rangle=\\langle a\\rangle \\cdot b . \\\\\n\n& \\Rightarrow \\quad b \\cdot a=a^j \\cdot b \\text { for some } j \\in \\mathbb{Z}.\n\n\\end{aligned}\n\n$$\n\n(hence for $a_1 b \\in G \\quad a^j b=b \\cdot a$ ).\n\n\\end{proof}", "formal_statement": "theorem exercise_2_5_23 {G : Type*} [group G] \n  (hG : \u2200 (H : subgroup G), H.normal) (a b : G) :\n  \u2203 (j : \u2124) , b*a = a^j * b:=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " subgroup.normal.mem_comm {G : Type*} [group G] {H : subgroup G}\n  (hH : \u2200 (H : subgroup G), H.normal) {a b : G} (h : a * b \u2208 H) :\n  b * a \u2208 H ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.normal.mem_comm {G : Type*} [group G] {H : subgroup G}\n\t(nH : H.normal) {a b : G} (h : a * b \u2208 H) :\n\tb * a \u2208 H\n\ntheorem subgroup.subgroup_normal.mem_comm {G : Type*} [group G]\n\t{H K : subgroup G} (hK : H \u2264 K) [hN : (H.subgroup_of K).normal] {a b : G}\n\t(hb : b \u2208 K) (h : a * b \u2208 H) :\n\tb * a \u2208 H\n\ntheorem subgroup.subgroup_of_normalizer_eq {G : Type*} [group G]\n\t{H N : subgroup G} (h : H.normalizer \u2264 N) :\n\tH.normalizer.subgroup_of N = (H.subgroup_of N).normalizer\n\ntheorem subgroup.exists_smul_eq {G : Type*} [group G] {H : subgroup G}\n\t[H.is_commutative] [H.finite_index] [H.normal]\n\t(hH : (nat.card \u21a5H).coprime H.index) (\u03b1 \u03b2 : H.quotient_diff) :\n\t\u2203 (h : \u21a5H), h \u2022 \u03b1 = \u03b2\n\nThe following is the natural language theorem statement: \"Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_j_of_all_subgroups_normal {G : Type*} [group G]\n  (hG : \u2200 (H : subgroup G), H \u2264 normalizer G H) (a b : G) :\n  \u2203 (j : \u2124), b * a = a ^ j * b ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_5_31", "nl_statement": "Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be an abelian group of order $p^n m$, such that $p \\nmid m$. Now, Given that $H$ is a subgroup of order $p^n$. Since $G$ is abelian $H$ is normal. Now we want to prove that $H$ is a characterestic subgroup, that is $\\phi(H)=H$ for any automorphism $\\phi$ of $G$. Now consider $\\phi(H)$. Clearly $|\\phi(H)|=p^n$. Suppose $\\phi(H) \\neq H$, then $|H \\cap \\phi(H)|=p^s$, where $s<n$. Consider $H \\phi(H)$, this is a subgroup of $G$ as $H$ is normal. Also $|H \\phi(H)|=\\frac{|H||\\phi(H)|}{|H \\cap \\phi(H)|}=\\frac{p^{2 n}}{p^s}=p^{2 n-s}$, where $2 n-s>n$. By lagrange's theorem then $p^{2 n-s}\\left|p^n m \\Longrightarrow p^{n-s}\\right| m \\Longrightarrow p \\mid m$-contradiction. So $\\phi(H)=H$, and $H$ is characterestic subgroup of $G$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_5_31 {G : Type*} [comm_group G] [fintype G]\n  {p m n : \u2115} (hp : nat.prime p) (hp1 : \u00ac p \u2223 m) (hG : card G = p^n*m)\n  {H : subgroup G} [fintype H] (hH : card H = p^n) : \n  characteristic H :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " char_p.subgroup_of_order_p_pow_n_of_order_p_pow_n_m\n  {G : Type*} [group G] (p : \u2115) (n m : \u2115) (hG : G.card = p ^ n * m)\n  (hG' : nat.prime p) (hG'' : p \u2223 m) (H : subgroup G)\n  (hH : H.card = p ^ n) : H.characteristic ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef char_p.subring' (R : Type u) [comm_ring R] (p : \u2115) [char_p R p]\n\t(S : subring R) :\n\tchar_p \u21a5S p\n\ndef char_p.subring (R : Type u) [ring R] (p : \u2115) [char_p R p] (S : subring R) :\n\tchar_p \u21a5S p\n\ndef subgroup.commutator_characteristic {G : Type*} [group G]\n\t(H\u2081 H\u2082 : subgroup G) [h\u2081 : H\u2081.characteristic] [h\u2082 : H\u2082.characteristic] :\n\t\u2045H\u2081, H\u2082\u2046.characteristic\n\ndef char_p.subsemiring (R : Type u) [semiring R] (p : \u2115) [char_p R p]\n\t(S : subsemiring R) :\n\tchar_p \u21a5S p\n\nThe following is the natural language theorem statement: \"Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " char_of_order_pow_mul_of_order_pow {G : Type*} [group G] [fintype G]\n  {p n m : \u2115} [hp : fact (nat.prime p)] (hG : card G = p ^ n * m)\n  (H : subgroup G) (hH : card H = p ^ n) :\n  char_subgroup G H ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_5_43", "nl_statement": "Prove that a group of order 9 must be abelian.", "nl_proof": "\\begin{proof}\n\n    We use the result from problem 40 which is as follows: Suppose $G$ is a group, $H$ is a subgroup and $|G|=n$ and $n \\nmid\\left(i_G(H)\\right) !$. Then there exists a normal subgroup $\\$ K \\backslash$ neq $\\{$ e $\\} \\$$ and $K \\subseteq H$.\n\nSo, we have now a group $G$ of order 9. Suppose that $G$ is cyclic, then $G$ is abelian and there is nothing more to prove. Suppose that $G$ s not cyclic,then there exists an element $a$ of order 3 , and $A=\\langle a\\rangle$. Now $i_G(A)=3$, now $9 \\nmid 3$ !, hence by the above result there is a normal subgroup $K$, non-trivial and $K \\subseteq A$. But $|A|=3$, a prime order subgroup, hence has no non-trivial subgroup, so $K=A$. So $A$ is normal subgroup. Now since $G$ is not cyclic any non-identity element is of order 3.So Let $a(\\neq$ $e) \\in G$.Consider $A=\\langle a\\rangle$. As shown before $A$ is normal. $a$ commutes with any if its powers. Now Let $b \\in G$ such that $b \\notin A$. Then $b a b^{-1} \\in A$ and hence $b a b^{-1}=a^i$.This implies $a=b^3 a b^{-3}=a^{i^3} \\Longrightarrow a^{i^3-1}=e$. So, 3 divides $i^3-1$. Also by fermat's little theorem 3 divides $i^2-1$.So 3 divides $i-1$. But $0 \\leq i \\leq 2$. So $i=1$, is the only possibility and hence $a b=b a$. So $a \\in Z(G)$ as $b$ was arbitrary. Since $a$ was arbitrary $G=Z(G)$. Hence $G$ is abelian.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_5_43 (G : Type*) [group G] [fintype G]\n  (hG : card G = 9) :\n  comm_group G :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " comm_group.of_order_9 (G : Type*) [group G] [fintype G]\n  (hG : fintype.card G = 9) : comm_group G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_comm_group.finite_of_fg_torsion (G : Type u) [add_comm_group G]\n\t[hG' : add_group.fg G] (hG : add_monoid.is_torsion G) :\n\tfinite G\n\ntheorem comm_group.finite_of_fg_torsion (G : Type u) [comm_group G] [group.fg G]\n\t(hG : monoid.is_torsion G) :\n\tfinite G\n\ntheorem add_subgroup.eq_bot_of_card_eq {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem is_nilpotent_of_product_of_sylow_group {G : Type*} [hG : group G]\n\t[fintype G]\n\t(e : (\u03a0 (p : \u21a5((fintype.card G).factorization.support)) (P : sylow \u2191p G), \u21a5\u2191P) \u2243* G) :\n\tgroup.is_nilpotent G\n\nThe following is the natural language theorem statement: \"Prove that a group of order 9 must be abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abelian_of_order_9 {G : Type*} [group G] (hG : fintype.card G = 9) :\n  abelian_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that a group of order 9 must be abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_5_52", "nl_statement": "Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian.", "nl_proof": "\\begin{proof}\n\nLet us start with considering $b$ to be an arbitrary element in $A$. \n\n\n\n1. Show that $\\left|A \\cap\\left(b^{-1} A\\right)\\right|>\\frac{|G|}{2}$, where\n\n$$\n\nb^{-1} A=\\left\\{b^{-1} a \\mid a \\in A\\right\\}\n\n$$\n\nFirst notice that if we consider a map $f: A \\rightarrow b^{-1} A$ defined by $f(a)=b^{-1} a$, for all $a \\in A$, then $f$ is a 1-1 map and so $\\left|b^{-1} A\\right| \\geq|A|>\\frac{3}{4}|G|$. Now using inclusion-exclusion principle we have\n\n$$\n\n\\left|A \\cap\\left(b^{-1} A\\right)\\right|=|A|+\\left|b^{-1} A\\right|-\\left|A \\cup\\left(b^{-1} A\\right)\\right|>\\frac{3}{4}|G|+\\frac{3}{4}|G|-|G|=\\frac{1}{2}|G|\n\n$$\n\n2. Argue that $A \\cap\\left(b^{-1} A\\right) \\subseteq C(b)$, where $C(b)$ is the centralizer of $b$ in $G$.\n\n\n\nSuppose $x \\in A \\cap\\left(b^{-1} A\\right)$, that means, $x \\in A$ and $x \\in b^{-1} A$. Thus there exist an element $a \\in A$ such that $x=$ $b^{-1} a$, which gives us $x b=a \\in A$. Now notice that $x, b \\in A$ and $x b \\in A$, therefore we get\n\n$$\n\n\\phi(x b)=(x b)^{-1} \\Longrightarrow \\phi(x) \\phi(b)=(x b)^{-1} \\Longrightarrow x^{-1} b^{-1}=b^{-1} x^{-1} \\Longrightarrow x b=b x\n\n$$\n\nTherefore, we get $x b=b x$, for any $x \\in A \\cap\\left(b^{-1} A\\right)$, that means, $x \\in C(b)$.\n\n\n\n3. Argue that $C(b)=G$.\n\nWe know that centralizer of an element in a group $G$ is a subgroup (See Page 53). Therefore $C(b)$ is a subgroup of $G$. From statements $\\mathbf{1}$ and $\\mathbf{2}$, we have\n\n$$\n\n|C(b)| \\geq\\left|A \\cap\\left(b^{-1} A\\right)\\right|>\\frac{|G|}{2}\n\n$$\n\nWe need to use the following remark to argue $C(b)=G$ from the above step.\n\nRemark. Let $G$ be a finite group and $H$ be a subgroup with more then $|G| / 2$ elements then $H=G$.\n\n\n\nProof of Remark. Suppose $|H|=p$ Then by Lagrange Theorem, there exist an $n \\in \\mathbb{N}$, such that $|G|=n p$, as $|H|$ divide $|G|$. Now by hypothesis $p>\\frac{G]}{2}$ gives us,\n\n$$\n\np>\\frac{|G|}{2} \\Longrightarrow n p>\\frac{n|G|}{2} \\Longrightarrow n<2 \\Longrightarrow n=1\n\n$$\n\nTherefore we get $H=G$.\n\n\n\nNow notice that $C(b)$ is a subgroup of $G$ with $C(b)$ having more than $|G| / 2$ elements. Therefore, $C(b)=G$.\n\n\n\n4. Show that $A \\in Z(G)$.\n\n\n\nWe know that $x \\in Z(G)$ if and only if $C(a)=G$. Now notice that, for any $b \\in A$ we have $C(b)=G$. Therefore, every element of $A$ is in the center of $G$, that means, $A \\subseteq Z(G)$.\n\n\n\n5. 5how that $Z(G)=G$.\n\n\n\nAs it is given that $|A|>\\frac{3|G|}{4}$ and $A \\leq|Z(G)|$, therefore we get\n\n$$\n\n|Z(G)|>\\frac{3}{4}|G|>\\frac{1}{2}|G| .\n\n$$\n\nAs $Z(G)$ is a subgroup of $G$, so by the above Remark we have $Z(G)=G$. Hence $G$ is abelian.\n\n\n\n6. Finally show that $A=G$.\n\n\n\nFirst notice that $A$ is a subgroup of $G$. To show this let $p, q \\in A$. Then we have\n\n$$\n\n\\phi(p q)=\\phi(p) \\phi(q)=p^{-1} q^{-1}=(q p)^{-1}=(p q)^{-1}, \\quad \\text { As } G \\text { is abelian. }\n\n$$\n\nTherefore, $p q \\in A$ and so we have $A$ is a subgroup of $G$. Again by applying the above remark. we get $A=G$. Therefore we have\n\n$$\n\n\\phi(y)=y^{-1}, \\quad \\text { for all } y \\in G\n\n$$\n\n\n\n\\end{proof}", "formal_statement": "theorem exercise_2_5_52 {G : Type*} [group G] [fintype G]\n  (\u03c6 : G \u2243* G) {I : finset G} (hI : \u2200 x \u2208 I, \u03c6 x = x\u207b\u00b9)\n  (hI1 : 0.75 * card G \u2264 card I) : \n  \u2200 x : G, \u03c6 x = x\u207b\u00b9 \u2227 \u2200 x y : G, x*y = y*x :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " automorphism.inverse_of_three_fourths_of_elements_of_finite_group_is_inverse_of_all_elements\n  {G : Type*} [fintype G] [group G] (\u03c6 : G \u2192* G) (h\u03c6 : function.bijective \u03c6)\n  (h : \u2203 (x : G), (3 : \u2115) / 4 * fintype.card G \u2264\n    (finset.univ.filter (\u03bb (y : G), \u03c6 y = y\u207b\u00b9)).card) :\n  \u2200 (y : G), \u03c6 y = y\u207b\u00b9 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem quotient_group.quotient_ker_equiv_of_right_inverse_apply {G : Type u}\n\t[group G] {H : Type v} [group H] (\u03c6 : G \u2192* H) (\u03c8 : H \u2192 G)\n\t(h\u03c6 : function.right_inverse \u03c8 \u21d1\u03c6) (\u1fb0 : G \u29f8 \u03c6.ker) :\n\t\u21d1(quotient_group.quotient_ker_equiv_of_right_inverse \u03c6 \u03c8 h\u03c6) \u1fb0 = \u21d1(quotient_group.ker_lift \u03c6) \u1fb0\n\ntheorem quotient_group.quotient_ker_equiv_of_right_inverse_symm_apply\n\t{G : Type u} [group G] {H : Type v} [group H] (\u03c6 : G \u2192* H) (\u03c8 : H \u2192 G)\n\t(h\u03c6 : function.right_inverse \u03c8 \u21d1\u03c6) (\u1fb0 : H) :\n\t\u21d1((quotient_group.quotient_ker_equiv_of_right_inverse \u03c6 \u03c8 h\u03c6).symm) \u1fb0 = (quotient_group.mk \u2218 \u03c8) \u1fb0\n\ntheorem alternating_group.nontrivial_of_three_le_card {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] (h3 : 3 \u2264 fintype.card \u03b1) :\n\tnontrivial \u21a5(alternating_group \u03b1)\n\ntheorem alternating_group.is_three_cycle_is_conj {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] (h5 : 5 \u2264 fintype.card \u03b1) {\u03c3 \u03c4 : \u21a5(alternating_group \u03b1)}\n\t(h\u03c3 : \u2191\u03c3.is_three_cycle) (h\u03c4 : \u2191\u03c4.is_three_cycle) :\n\tis_conj \u03c3 \u03c4\n\nThe following is the natural language theorem statement: \"Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abelian_of_inverse_automorphism_of_three_fourths {G : Type*} [group G]\n  [fintype G] (\u03c6 : G \u2192* G) (h\u03c6 : \u2200 x : G, \u03c6 x = x\u207b\u00b9)\n  (h : (3 : \u2115) / 4 < fintype.card G) :\n  \u2200 y : G, \u03c6 y = y\u207b\u00b9 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_7_7", "nl_statement": "If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$.", "nl_proof": "\\begin{proof}\n\nWe first claim that $\\varphi(N)$ is a subgroup of $G'$. To see this, note that since $N$ is a subgroup of $G$, the identity element $e_G$ of $G$ belongs to $N$. Therefore, the element $\\varphi(e_G) \\in \\varphi(N)$, so $\\varphi(N)$ is a non-empty subset of $G'$.\n\n\n\nNow, let $a', b' \\in \\varphi(N)$. Then there exist elements $a, b \\in N$ such that $\\varphi(a) = a'$ and $\\varphi(b) = b'$. Since $N$ is a subgroup of $G$, we have $a, b \\in N$, so $ab^{-1} \\in N$. Thus, we have\n\n$$\\varphi(ab^{-1}) = \\varphi(a) \\varphi(b^{-1}) = a'b'^{-1} \\in \\varphi(N),$$\n\nwhich shows that $a', b' \\in \\varphi(N)$ implies $a'b'^{-1} \\in \\varphi(N)$. Therefore, $\\varphi(N)$ is a subgroup of $G'$.\n\n\n\nNext, we will show that $\\varphi(N)$ is a normal subgroup of $G'$. Let $\\varphi(N) = N'$, a subgroup of $G'$. Let $x' \\in G'$ and $h' \\in N'$. Since $\\varphi$ is onto, there exist elements $x \\in G$ and $h \\in N$ such that $\\varphi(x) = x'$ and $\\varphi(h) = h'$.\n\n\n\nSince $N$ is a normal subgroup of $G$, we have $xhx^{-1} \\in N$. Thus,\n\n$$\\varphi(xhx^{-1}) = \\varphi(x)\\varphi(h)\\varphi(x^{-1}) = x'h'x'^{-1} \\in \\varphi(N),$$\n\nwhich shows that $x' \\in G'$ and $h' \\in N'$ implies $x'h'x'^{-1} \\in \\varphi(N)$. Therefore, $\\varphi(N)$ is a normal subgroup of $G'$. This completes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_7_7 {G : Type*} [group G] {G' : Type*} [group G']\n  (\u03c6 : G \u2192* G') (N : subgroup G) [N.normal] : \n  (map \u03c6 N).normal  :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " normal.map {G : Type*} [group G] {N : Type*} [group N] {H : subgroup G}\n  (h : H.normal) (f : G \u2192* N) (hf : function.surjective \u21d1f) :\n  (subgroup.map f H).normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.normal.map {G : Type*} [group G] {N : Type*} [group N]\n\t{H : subgroup G} (h : H.normal) (f : G \u2192* N) (hf : function.surjective \u21d1f) :\n\t(subgroup.map f H).normal\n\ntheorem subgroup.normal.comap {G : Type*} [group G] {N : Type*} [group N]\n\t{H : subgroup N} (hH : H.normal) (f : G \u2192* N) :\n\t(subgroup.comap f H).normal\n\ntheorem add_subgroup.normal.map {G : Type*} [add_group G] {N : Type*}\n\t[add_group N] {H : add_subgroup G} (h : H.normal) (f : G \u2192+ N)\n\t(hf : function.surjective \u21d1f) :\n\t(add_subgroup.map f H).normal\n\ntheorem add_subgroup.normal.comap {G : Type*} [add_group G] {N : Type*}\n\t[add_group N] {H : add_subgroup N} (hH : H.normal) (f : G \u2192+ N) :\n\t(add_subgroup.comap f H).normal\n\nThe following is the natural language theorem statement: \"If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " normal_of_hom_normal {G G' : Type*} [group G] [group G']\n  (f : G \u2192* G') (hf : function.surjective f) (N : subgroup G)\n  (hN : N.normal) :\n  (f '' N).normal ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_8_15", "nl_statement": "Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.", "nl_proof": "\\begin{proof}\n\n    For a nonabelian group of order $p q$, the structure of the group $G$ is set by determining the relation $a b a^{-1}=b^{k^{\\frac{p-1}{q}}}$ for some generator $k$ of the cyclic group. Here we are using the fact that $k^{\\frac{p-1}{q}}$ is a generator for the unique subgroup of order $q$ in $U_p$ (a cyclic group of order $m$ has a unique subgroup of order $d$ for each divisor $d$ of $m$ ). The other possible generators of this subgroup are $k^{\\frac{l(p-1)}{q}}$ for each $1 \\leq l \\leq q-1$, so these give potentially new group structures. Let $G^{\\prime}$ be a group with an element $c$ of order $q$, an element $d$ of order $p$ with structure defined by the relation $c d c^{-1}=d^{k^{\\frac{l(p-1)}{q}}}$. We may then define\n\n$$\n\n\\begin{aligned}\n\n\\phi: G^{\\prime} & \\rightarrow G \\\\\n\nc & \\mapsto a^l \\\\\n\nd & \\mapsto b\n\n\\end{aligned}\n\n$$\n\nsince $c$ and $a^l$ have the same order and $b$ and $d$ have the same order this is a well defined function.\n\nSince\n\n$$\n\n\\begin{aligned}\n\n\\phi(c) \\phi(d) \\phi(c)^{-1} & =a^l b a^{-l} \\\\\n\n& =b^{\\left(k^{\\frac{p-1}{q}}\\right)^l} \\\\\n\n& =b^{k^{\\frac{l(p-1)}{q}}} \\\\\n\n& =\\phi(d)^{k^{\\frac{l(p-1)}{q}}}\n\n\\end{aligned}\n\n$$\n\n$\\phi\\left(c^i d^j\\right)=a^{l i} b^j=e$ only if $i=j=0$, so $\\phi$ is 1-to-l. Therefore $G$ and $G^{\\prime}$ are isomorphic and so up to isomorphism there is only one nonabelian group of order $p q$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_8_15 {G H: Type*} [fintype G] [group G] [fintype H]\n  [group H] {p q : \u2115} (hp : nat.prime p) (hq : nat.prime q) \n  (h : p > q) (h1 : q \u2223 p - 1) (hG : card G = p*q) (hH : card G = p*q) :\n  G \u2243* H :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_p_group.nontrivial_iff_card {p : \u2115} {G : Type*} [group G]\n  (hG : is_p_group p G) [hp : fact (nat.prime p)] [fintype G] :\n  nontrivial G \u2194 \u2203 (n : \u2115) (H : n > 0), fintype.card G = p ^ n ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_p_group.nontrivial_iff_card {p : \u2115} {G : Type*} [group G]\n\t(hG : is_p_group p G) [hp : fact (nat.prime p)] [fintype G] :\n\tnontrivial G \u2194 \u2203 (n : \u2115) (H : n > 0), fintype.card G = p ^ n\n\ntheorem is_p_group.coprime_card_of_ne {G : Type*} [group G] {G\u2082 : Type*}\n\t[group G\u2082] (p\u2081 p\u2082 : \u2115) [hp\u2081 : fact (nat.prime p\u2081)] [hp\u2082 : fact (nat.prime p\u2082)]\n\t(hne : p\u2081 \u2260 p\u2082) (H\u2081 : subgroup G) (H\u2082 : subgroup G\u2082) [fintype \u21a5H\u2081]\n\t[fintype \u21a5H\u2082] (hH\u2081 : is_p_group p\u2081 \u21a5H\u2081) (hH\u2082 : is_p_group p\u2082 \u21a5H\u2082) :\n\t(fintype.card \u21a5H\u2081).coprime (fintype.card \u21a5H\u2082)\n\ntheorem is_p_group.is_nilpotent {G : Type*} [hG : group G] [finite G] {p : \u2115}\n\t[hp : fact (nat.prime p)] (h : is_p_group p G) :\n\tgroup.is_nilpotent G\n\ntheorem sylow.card_quotient_normalizer_modeq_card_quotient {G : Type u}\n\t[group G] [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G}\n\t(hH : fintype.card \u21a5H = p ^ n) :\n\tfintype.card (\u21a5(H.normalizer) \u29f8 subgroup.comap H.normalizer.subtype H) \u2261 fintype.card (G \u29f8 H) [MOD p]\n\nThe following is the natural language theorem statement: \"Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " nonabelian_group_of_order_pq_is_isomorphic {p q : \u2115} (hp : nat.prime p)\n  (hq : nat.prime q) (hqp : q \u2223 p - 1) (hqp' : q < p) :\n  \u2200 (G\u2081 G\u2082 : Type*) [group G\u2081] [group G\u2082] [fintype G\u2081] [fintype G\u2082]\n  (hG\u2081 : nonabelian_group G\u2081) (hG\u2082 : nonabelian_group G\u2082)\n  (hG\u2081_card : fintype.card G\u2081 = p * q) (hG\u2082_card : fintype.card G\u2082 = p * q),\n  G\u2081 \u2243* G\u2082 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_10_1", "nl_statement": "Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$.", "nl_proof": "\\begin{proof}\n\nIf $b \\in G$ has order $p$, then $(b)$ is a cyclic group of order $p$. Since $A$ is a subgroup of $G$, we have $A \\cap (b)$ is a subgroup of $G$. Also, $A \\cap (b) \\subseteq (b)$. So $A \\cap (b)$ is a subgroup of $(b)$. Since $(b)$ is a cyclic group of order $p$, the only subgroups of $(b)$ are $(e)$ and $(b)$ itself.\n\n\n\nTherefore, either $A \\cap (b) = (e)$ or $A \\cap (b) = (b)$. If $A \\cap (b) = (e)$, then we are done. Otherwise, if $A \\cap (b) = (b)$, then $A \\subseteq (b)$. Since $A$ is a subgroup of $G$ and $A \\subseteq (b)$, it follows that $A$ is a subgroup of $(b)$.\n\n\n\nSince the only subgroups of $(b)$ are $(e)$ and $(b)$ itself, we have either $A = (e)$ or $A = (b)$. If $A = (e)$, then $A \\cap (b) = (e)$ and we are done. But if $A = (b)$, then $b \\in A$ as $b \\in (b)$, which contradicts our hypothesis that $b \\notin A$. So $A \\neq (b)$.\n\n\n\nHence $A \\cap (b) \\neq (b)$. Therefore, $A \\cap (b) = (e)$. This completes our proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_10_1 {G : Type*} [group G] (A : subgroup G) \n  [A.normal] {b : G} (hp : nat.prime (order_of b)) :\n  A \u2293 (closure {b}) = \u22a5 :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " subgroup.inf_subgroup_of_inf_normal_of_right {G : Type*} [group G]\n  (A B' B : subgroup G) (hB : B' \u2264 B) [hN : (B'.subgroup_of B).normal] :\n  ((A \u2293 B').subgroup_of (A \u2293 B)).normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.inf_subgroup_of_inf_normal_of_left {G : Type*} [group G]\n\t{A' A : subgroup G} (B : subgroup G) (hA : A' \u2264 A)\n\t[hN : (A'.subgroup_of A).normal] :\n\t((A' \u2293 B).subgroup_of (A \u2293 B)).normal\n\ntheorem add_subgroup.inf_add_subgroup_of_inf_normal_of_left {G : Type*}\n\t[add_group G] {A' A : add_subgroup G} (B : add_subgroup G) (hA : A' \u2264 A)\n\t[hN : (A'.add_subgroup_of A).normal] :\n\t((A' \u2293 B).add_subgroup_of (A \u2293 B)).normal\n\ntheorem subgroup.inf_subgroup_of_inf_normal_of_right {G : Type*} [group G]\n\t(A B' B : subgroup G) (hB : B' \u2264 B) [hN : (B'.subgroup_of B).normal] :\n\t((A \u2293 B').subgroup_of (A \u2293 B)).normal\n\ntheorem subgroup.subgroup_normal.mem_comm {G : Type*} [group G]\n\t{H K : subgroup G} (hK : H \u2264 K) [hN : (H.subgroup_of K).normal] {a b : G}\n\t(hb : b \u2208 K) (h : a * b \u2208 H) :\n\tb * a \u2208 H\n\nThe following is the natural language theorem statement: \"Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " prime_order_not_in_normal_subgroup_intersection_trivial {G : Type*} \n  [group G] {A : subgroup G} (hA : A.normal) {b : G} (hb : b.order = nat.prime.prime) \n  (hbA : b \u2209 A) :\n  A \u2229 (b) = (1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_2_11_7", "nl_statement": "If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$.", "nl_proof": "\\begin{proof}\n\n    Let $\\phi$ be an automorphism of $G$. Let $P$ be a normal sylow p-subgroup. $\\phi(P)$ is also a sylow-p subgroup. But since $P$ is normal, it is unique. Hence $\\phi(P)=P$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_11_7 {G : Type*} [group G] {p : \u2115} (hp : nat.prime p)\n  {P : sylow p G} (hP : P.normal) : \n  characteristic (P : subgroup G) :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " sylow.characteristic_of_normal {G : Type u} [group G] {p : \u2115}\n  [fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n  \u2191P.characteristic ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem sylow.subsingleton_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\tsubsingleton (sylow p G)\n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _\n\ntheorem sylow.normal_of_all_max_subgroups_normal {G : Type u} [group G]\n\t[finite G] (hnc : \u2200 (H : subgroup G), is_coatom H \u2192 H.normal) {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) :\n\t\u2191P.normal\n\ntheorem sylow.characteristic_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\t\u2191P.characteristic\n\nThe following is the natural language theorem statement: \"If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sylow_p_subgroup_of_automorphism_is_fixed {G : Type*} [group G] \n  {p : \u2115} [hp : fact (nat.prime p)] {P : subgroup G} (hP : is_p_group p P) \n  (hP_normal : P \u2264 G.normalizer P) (hP_sylow : is_sylow p G P) \n  (\u03c6 : G \u2192* G) (h\u03c6 : is_group_hom \u03c6) : \u03c6 P = P ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_3_2_21", "nl_statement": "If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$.", "nl_proof": "\\begin{proof}\n\n    Note that $\\sigma \\tau=e$ can equivalentnly be phrased as $\\tau$ being the inverse of $\\sigma$. Our statement is then equivalent to the statement that an inverse of a nonidentity permutation disturbs at least one same element as that permutation. To prove this, let $\\sigma$ be a nonidentity permutation, then let $\\left(i_1 \\cdots i_n\\right)$ be a cycle in $\\sigma$. Then we have that\n\n$$\n\n\\sigma\\left(i_1\\right)=i_2, \\sigma\\left(i_2\\right)=i_2, \\ldots, \\sigma\\left(i_{n-1}\\right)=i_n, \\sigma\\left(i_n\\right)=i_1,\n\n$$\n\nbut then also\n\n$$\n\ni_1=\\tau\\left(i_2\\right), i_2=\\tau\\left(i_3\\right), \\ldots, i_{n-1}=\\tau\\left(i_n\\right), i_n=\\tau\\left(i_1\\right),\n\n$$\n\ni.e. its inverse disturbs $i_1, \\ldots, i_n$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_2_21 {\u03b1 : Type*} [fintype \u03b1] {\u03c3 \u03c4: equiv.perm \u03b1} \n  (h1 : \u2200 a : \u03b1, \u03c3 a = a \u2194 \u03c4 a \u2260 a) (h2 : \u03c4 \u2218 \u03c3 = id) : \n  \u03c3 = 1 \u2227 \u03c4 = 1 :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " equiv.perm.disjoint.mul_eq_one_iff {\u03b1 : Type*} {\u03c3 \u03c4 : equiv.perm \u03b1}\n  (h\u03c3\u03c4 : \u03c3.disjoint \u03c4) :\n  \u03c3 * \u03c4 = 1 \u2194 \u03c3 = 1 \u2227 \u03c4 = 1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem equiv.perm.disjoint.mul_eq_one_iff {\u03b1 : Type*} {\u03c3 \u03c4 : equiv.perm \u03b1}\n\t(h\u03c3\u03c4 : \u03c3.disjoint \u03c4) :\n\t\u03c3 * \u03c4 = 1 \u2194 \u03c3 = 1 \u2227 \u03c4 = 1\n\ntheorem equiv.perm.disjoint.mul_apply_eq_iff {\u03b1 : Type*} {\u03c3 \u03c4 : equiv.perm \u03b1}\n\t(h\u03c3\u03c4 : \u03c3.disjoint \u03c4) {a : \u03b1} :\n\t\u21d1(\u03c3 * \u03c4) a = a \u2194 \u21d1\u03c3 a = a \u2227 \u21d1\u03c4 a = a\n\ntheorem equiv.perm.disjoint.is_conj_mul {\u03b1 : Type*} [finite \u03b1]\n\t{\u03c3 \u03c4 \u03c0 \u03c1 : equiv.perm \u03b1} (hc1 : is_conj \u03c3 \u03c0) (hc2 : is_conj \u03c4 \u03c1)\n\t(hd1 : \u03c3.disjoint \u03c4) (hd2 : \u03c0.disjoint \u03c1) :\n\tis_conj (\u03c3 * \u03c4) (\u03c0 * \u03c1)\n\ntheorem equiv.perm.disjoint.cycle_type {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1]\n\t{\u03c3 \u03c4 : equiv.perm \u03b1} (h : \u03c3.disjoint \u03c4) :\n\t(\u03c3 * \u03c4).cycle_type = \u03c3.cycle_type + \u03c4.cycle_type\n\nThe following is the natural language theorem statement: \"If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " perm.eq_one_of_mul_eq_one_of_disjoint {\u03b1 : Type*} [fintype \u03b1]\n  (\u03c3 \u03c4 : perm \u03b1) (h\u03c3\u03c4 : \u03c3 * \u03c4 = 1) (hdisj : \u2200 a : \u03b1, \u03c3 a \u2260 \u03c4 a) :\n  \u03c3 = 1 \u2227 \u03c4 = 1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_4_1_34", "nl_statement": "Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3.", "nl_proof": "\\begin{proof}\n\n    The order of $T$ is $2^4-2^3-2^2+2=6$; we now find those six matrices:\n\n$$\n\n\\begin{array}{ll}\n\nA_1=\\left(\\begin{array}{ll}\n\n1 & 0 \\\\\n\n0 & 1\n\n\\end{array}\\right), & A_2=\\left(\\begin{array}{ll}\n\n0 & 1 \\\\\n\n1 & 0\n\n\\end{array}\\right) \\\\\n\nA_3=\\left(\\begin{array}{ll}\n\n1 & 0 \\\\\n\n1 & 1\n\n\\end{array}\\right), & A_4=\\left(\\begin{array}{ll}\n\n1 & 1 \\\\\n\n0 & 1\n\n\\end{array}\\right) \\\\\n\nA_5=\\left(\\begin{array}{ll}\n\n0 & 1 \\\\\n\n1 & 1\n\n\\end{array}\\right), & A_6=\\left(\\begin{array}{ll}\n\n1 & 1 \\\\\n\n1 & 0\n\n\\end{array}\\right)\n\n\\end{array}\n\n$$\n\nwith orders $1,2,2,2,3,3$ respectively.\n\nNote that $S_3$ is composed of elements\n\n$$\n\n\\text{ id, (1 2), (1 3), (2 3), (1 2 3), (1 3 2)} \n\n$$\n\nwith orders 1, 2, 2, 2, 3, 3 respectively. Also note that, by Problem 17 of generate $S_3$. We also have that $\\left(\\begin{array}{llll}1 & 3 & 2\\end{array}\\right)=\\left(\\begin{array}{llll}1 & 2 & 3\\end{array}\\right)\\left(\\begin{array}{lll}1 & 2 & 3\\end{array}\\right)$, that $\\left(\\begin{array}{lll}1 & 3\\end{array}\\right)=\\left(\\begin{array}{lll}1 & 2 & 3\\end{array}\\right)\\left(\\begin{array}{ll}1 & 2\\end{array}\\right)$, $\\left(\\begin{array}{ll}1 & 2\\end{array}\\right)\\left(\\begin{array}{lll}1 & 2 & 3\\end{array}\\right)=\\left(\\begin{array}{ll}2 & 3\\end{array}\\right)$ and $\\left(\\begin{array}{lll}1 & 2\\end{array}\\right)\\left(\\begin{array}{ll}1 & 2\\end{array}\\right)=\\mathrm{id}$\n\n\n\nNow we can check that $\\tau\\left(A_2\\right)=\\left(\\begin{array}{ll}1 & 2\\end{array}\\right), \\tau\\left(A_5\\right)=\\left(\\begin{array}{lll}1 & 2 & 3\\end{array}\\right)$ induces an isomorphism. We compute\n\n$$\n\n\\begin{aligned}\n\n& \\tau\\left(A_1\\right)=\\tau\\left(A_2 A_2\\right)=\\tau\\left(A_2\\right) \\tau\\left(A_2\\right)=\\mathrm{id} \\\\\n\n& \\tau\\left(A_3\\right)=\\tau\\left(A_5 A_2\\right)=\\tau\\left(A_5\\right) \\tau\\left(A_2\\right)=\\left(\\begin{array}{llll}\n\n1 & 2 & 3\n\n\\end{array}\\right)\\left(\\begin{array}{lll}\n\n1 & 2\n\n\\end{array}\\right)=\\left(\\begin{array}{ll}\n\n1 & 3\n\n\\end{array}\\right) \\\\\n\n& \\tau\\left(A_4\\right)=\\tau\\left(A_2 A_5\\right)=\\tau\\left(A_2\\right) \\tau\\left(A_5\\right)=\\left(\\begin{array}{lll}\n\n1 & 2\n\n\\end{array}\\right)\\left(\\begin{array}{lll}\n\n1 & 2 & 3\n\n\\end{array}\\right)=\\left(\\begin{array}{ll}\n\n2 & 3\n\n\\end{array}\\right) \\\\\n\n& \\tau\\left(A_6\\right)=\\tau\\left(A_5 A_5\\right)=\\tau\\left(A_5\\right) \\tau\\left(A_5\\right)=\\left(\\begin{array}{lll}\n\n1 & 3 & 2\n\n\\end{array}\\right)\n\n\\end{aligned}\n\n$$\n\nThus we see that $\\tau$ extendeds to an isomorphism, since $A_2$ and $A_5$ generate $T$, so that $\\tau\\left(A_i A_j\\right)=\\tau\\left(A_i\\right) \\tau\\left(A_j\\right)$ follows from writing $A_i$ and $A_j$ in terms of $A_2$ and $A_5$ and using the equlities and relations shown above.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_1_34 : equiv.perm (fin 3) \u2243* general_linear_group (fin 2) (zmod 2) :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_isomorphic_alternating_group_three (T : Type*) [group T]\n  (hT : \u2200 (A : T), \u2203 (a b c d : \u2124), A = \u27e8\u27e8a, b\u27e9, \u27e8c, d\u27e9\u27e9 \u2227 a * d \u2260 b * c) :\n  is_isomorphic T (alternating_group 3) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem alternating_group.is_three_cycle_is_conj {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] (h5 : 5 \u2264 fintype.card \u03b1) {\u03c3 \u03c4 : \u21a5(alternating_group \u03b1)}\n\t(h\u03c3 : \u2191\u03c3.is_three_cycle) (h\u03c4 : \u2191\u03c4.is_three_cycle) :\n\tis_conj \u03c3 \u03c4\n\ntheorem equiv.perm.is_three_cycle.mem_alternating_group {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] {f : equiv.perm \u03b1} (h : f.is_three_cycle) :\n\tf \u2208 alternating_group \u03b1\n\ntheorem alternating_group.nontrivial_of_three_le_card {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] (h3 : 3 \u2264 fintype.card \u03b1) :\n\tnontrivial \u21a5(alternating_group \u03b1)\n\ntheorem equiv.perm.is_three_cycle.inv {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1]\n\t{f : equiv.perm \u03b1} (h : f.is_three_cycle) :\n\tf\u207b\u00b9.is_three_cycle\n\nThe following is the natural language theorem statement: \"Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_isomorphic_to_symmetric_group_3 (T : Type*) [group T] \n  [fintype T] [decidable_eq T] (hT : \u2200 (A : T), A \u2260 1) :\n  T \u2243 symmetric_group 3 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_4_2_6", "nl_statement": "If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$.", "nl_proof": "\\begin{proof}\n\nWe need to show that\n\n$$\n\na(a x+x a)=(a x+x a) a \\text { for } a, x \\in R .\n\n$$\n\nNow,\n\n$$\n\n\\begin{gathered}\n\na(a x+x a)=a(a x)+a(x a) \\\\\n\n=a^2 x+a x a \\\\\n\n=0+a x a=a x a .\n\n\\end{gathered}\n\n$$\n\nAgain,\n\n$$\n\n\\begin{gathered}\n\n(a x+x a) a=(a x) a+(x a) a \\\\\n\n=a x a+x a^2 \\\\\n\n=a x a+0=a x a .\n\n\\end{gathered}\n\n$$\n\nIt follows that,\n\n$$\n\na(a x+x a)=(a x+x a) a, \\text { for } x, a \\in R .\n\n$$\n\nThis shows that $a x+x a$ commutes with $a$. This completes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_2_6 {R : Type*} [ring R] (a x : R) \n  (h : a ^ 2 = 0) : a * (a * x + x * a) = (x + x * a) * a :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " comm_of_sq_eq_zero {R : Type*} [comm_ring R] (a : R) (h : a ^ 2 = 0) :\n  \u2200 (x : R), a * x + x * a = x * a + a * x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem quaternion.eq_re_of_eq_coe {R : Type*} [comm_ring R] {a : quaternion R}\n\t{x : R} (h : a = \u2191x) :\n\ta = \u2191(a.re)\n\ntheorem quaternion_algebra.eq_re_of_eq_coe {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R}\n\t{a : quaternion_algebra R c\u2081 c\u2082} {x : R} (h : a = \u2191x) :\n\ta = \u2191(a.re)\n\ntheorem eq_zero_of_mul_self_add_mul_self_eq_zero {\u03b1 : Type u}\n\t[linear_ordered_ring \u03b1] {a b : \u03b1} (h : a * a + b * b = 0) :\n\ta = 0\n\ntheorem sq_pos_of_ne_zero {R : Type*} [linear_ordered_ring R] (a : R)\n\t(h : a \u2260 0) :\n\t0 < a ^ 2\n\nThe following is the natural language theorem statement: \"If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " comm_of_square_eq_zero {R : Type*} [ring R] (a x : R) (h : a ^ 2 = 0) :\n  a * x + x * a = a * (x + x) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_4_3_1", "nl_statement": "If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.", "nl_proof": "\\begin{proof}\n\n    First, note that if $x \\in L(a)$ and $y \\in L(a)$ then $x a=0$ and $y a=0$, so that\n\n$$\n\n\\begin{aligned}\n\nx a-y a & =0 \\\\\n\n(x-y) a & =0,\n\n\\end{aligned}\n\n$$\n\ni.e. $L(a)$ is an additive subgroup of $R$. (We have used the criterion that $H$ is a subgroup of $G$ if for any $h_1, h_2 \\in H$ we have that $h_1 h_2^{-1} \\in H$. \n\n\n\nNow we prove the conclusion. Let $r \\in R$ and $b \\in L(a)$, then $b a=0$, and so $x b a=0$ which by associativity of multiplication in $R$ is equivalent to\n\n$$\n\n(x b) a=0,\n\n$$\n\nso that $x b \\in L(a)$. Since $R$ is commutative, (1) implies that $(bx)a=0$, so that $b x \\in L(a)$, which concludes the proof that $L(a)$ is an ideal.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_3_1 {R : Type*} [comm_ring R] (a : R) :\n  \u2203 I : ideal R, {x : R | x*a=0} = I :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " ideal.quotient.eq_zero_iff_mem {R : Type u} [comm_ring R] {a : R}\n  {I : ideal R} :\n  \u21d1(ideal.quotient.mk I) a = 0 \u2194 a \u2208 I ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef polynomial.ann_ideal (R : Type*) {A : Type*} [comm_semiring R] [semiring A]\n\t[algebra R A] (a : A) :\n\tideal (polynomial R)\n\ntheorem polynomial.ann_ideal_generator_mem (\ud835\udd5c : Type*) {A : Type*} [field \ud835\udd5c]\n\t[ring A] [algebra \ud835\udd5c A] (a : A) :\n\tpolynomial.ann_ideal_generator \ud835\udd5c a \u2208 polynomial.ann_ideal \ud835\udd5c a\n\ntheorem ideal.quotient.eq_zero_iff_mem {R : Type u} [comm_ring R] {a : R}\n\t{I : ideal R} :\n\t\u21d1(ideal.quotient.mk I) a = 0 \u2194 a \u2208 I\n\ntheorem ideal.quotient.exists_inv {R : Type u} [comm_ring R] {I : ideal R}\n\t[hI : I.is_maximal] {a : R \u29f8 I} :\n\ta \u2260 0 \u2192 (\u2203 (b : R \u29f8 I), a * b = 1)\n\nThe following is the natural language theorem statement: \"If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " ideal_of_comm_ring_of_annihilator {R : Type*} [comm_ring R] (a : R) :\n  ideal R (annihilator a) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_4_4_9", "nl_statement": "Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$.", "nl_proof": "\\begin{proof}\n\n    To find all the quadratic residues $\\bmod p$ among the integers $1,2, \\ldots, p-1$, we compute the least positive residues modulo $p$ of the squares of the integers $1,2, \\ldots, p-1\\}$.\n\n\n\nSince there are $p-1$ squares to consider, and since each congruence $x^2 \\equiv a (\\bmod p)$ has either zero or two solutions, there must be exactly $\\frac{(p-1)}{2}$ quadratic residues mod $p$ among the integers $1,2, \\ldots, p-1$.\n\nThe remaining\n\n$$\n\n(p-1)-\\frac{(p-1)}{2}=\\frac{(p-1)}{2}\n\n$$\n\npositive integers less than $p-1$ are quadratic non-residues of $\\bmod p$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_4_9 (p : \u2115) (hp : nat.prime p) :\n  \u2203 S : finset (zmod p), S.card = (p-1)/2 \u2227 \u2203 x : zmod p, x^2 = p \u2227 \n  \u2203 S : finset (zmod p), S.card = (p-1)/2 \u2227 \u00ac \u2203 x : zmod p, x^2 = p :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " zmod.card_units_half_p_sub_one (p : \u2115) [fact (nat.prime p)] :\n  fintype.card (zmod p)\u02e3 = (p - 1) / 2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.modeq.pow_card_sub_one_eq_one {p : \u2115} (hp : nat.prime p) {n : \u2124}\n\t(hpn : is_coprime n \u2191p) :\n\tn ^ (p - 1) \u2261 1 [ZMOD \u2191p]\n\ntheorem nat.card_units_zmod_lt_sub_one {p : \u2115} (hp : 1 < p) [fintype (zmod p)\u02e3] :\n\tfintype.card (zmod p)\u02e3 \u2264 p - 1\n\ntheorem zmod.card_units (p : \u2115) [fact (nat.prime p)] :\n\tfintype.card (zmod p)\u02e3 = p - 1\n\ntheorem nat.arithmetic_function.card_factors_apply_prime {p : \u2115}\n\t(hp : nat.prime p) :\n\t\u21d1nat.arithmetic_function.card_factors p = 1\n\nThe following is the natural language theorem statement: \"Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " card_quadratic_residues_modeq_half_card_units_of_prime {p : \u2115} \n  (hp : nat.prime p) :\n  card {x : units \u2124 | x.val ^ 2 = 1 [ZMOD p]} \u2261 (p - 1) / 2 [MOD 2] ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_4_5_23", "nl_statement": "Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic.", "nl_proof": "\\begin{proof}\n\n    We have that $p(x)$ and $q(x)$ are irreducible if they have no roots in $\\mathbb{Z}_7$, which can easily be checked. E.g. for $p(x)$ we have that $p(0)=5, p(1)=6, p(2)=6, p(3)=4, p(4)=6$, $p(5)=4, p(6)=4$, and similarly for $q(x)$.\n\n\n\nWe have that every element of $F[x] /(p(x))$ is equal to $a x^2+b x+c+(p(x))$, and likewise for $F[x] /(q(x))$. We consider a map $\\tau$ : $F[x] /(p(x)) \\rightarrow F[x] /(q(x))$ given by\n\n$$\n\n\\tau\\left(a x^2+b x+c+(p(x))\\right)=a x^2-b x+c+(q(x)) .\n\n$$\n\nThis map is obviously onto, and since $|F[x] /(p(x))|=|F[x] /(q(x))|=7^3$ by Problem 16, it is also one-to-one. We claim that it is a homomorphism. Additivity of $\\tau$ is immediate by the linearity of addition of polynomial coefficient, so we just have to check the multiplicativity; if $n=a x^2+b x+$ $c+(p(x))$ and $m=d x^2+e x+f+(p(x))$ then\n\n$$\n\n\\begin{aligned}\n\n\\tau(n m) & =\\tau\\left(a d x^4+(a e+b d) x^3+(a f+b e+c d) x^2+(b f+c e) x+c f+(p(x))\\right) \\\\\n\n& =\\tau\\left(2 a d x+2(a e+b d)+(a f+b e+c d) x^2+(b f+c e) x+c f+(p(x))\\right) \\\\\n\n& =\\tau\\left((a f+b e+c d) x^2+(b f+c e+2 a d) x+(c f+2 a e+2 b d)+(p(x))\\right) \\\\\n\n& =(a f+b e+c d) x^2-(b f+c e+2 a d) x+c f+2 a e+2 b d+(q(x)) \\\\\n\n& =a d x^4-(a e+b d) x^3+(a f+b e+c d) x^2-(b f+c e) x+c f+(q(x)) \\\\\n\n& =\\left(a x^2-b x+c+(q(x))\\right)\\left(d x^2-e x+f+(q(x))\\right) \\\\\n\n& =\\tau(n) \\tau(m) .\n\n\\end{aligned}\n\n$$\n\nwhere in the second equality we used that $x^3+p(x)=2+p(x)$ and in the fifth we used that $x^3+$ $q(x)=-2+q(x)$\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_23 {p q: polynomial (zmod 7)} \n  (hp : p = X^3 - 2) (hq : q = X^3 + 2) : \n  irreducible p \u2227 irreducible q \u2227 \n  (nonempty $ polynomial (zmod 7) \u29f8 ideal.span ({p} : set $ polynomial $ zmod 7) \u2243+*\n  polynomial (zmod 7) \u29f8 ideal.span ({q} : set $ polynomial $ zmod 7)) :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_domain.irreducible_of_degree_one_of_degree_three_of_degree_three\n  {F : Type*} [field F] (p : polynomial F) (q : polynomial F)\n  (h : p.degree = 1 \u2227 q.degree = 3 \u2227 p.degree = 3) :\n  is_domain F ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef complex.field :\n\tfield \u2102\n\ndef number_field.infinite_place.has_coe_to_fun {K : Type*} [field K] :\n\thas_coe_to_fun (number_field.infinite_place K) (\u03bb (_x : number_field.infinite_place K), K \u2192 \u211d)\n\ndef field.is_domain {K : Type*} [field K] :\n\tis_domain K\n\ndef rat.field :\n\tfield \u211a\n\nThe following is the natural language theorem statement: \"Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_of_is_field_", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_4_6_2", "nl_statement": "Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$.", "nl_proof": "\\begin{proof}    \n\nLet us assume that $f(x)$ is reducible over $\\mathbb{Q}[x]$.\n\nThen there exists a rational root of $f(x)$.\n\nLet $p / q$ be a rational root of $f(x)$, where $\\operatorname{gcd}(p, q)=1$.\n\nThen $f(p / q)=0$.\n\nNow,\n\n$$\n\n\\begin{aligned}\n\n& f(p / q)=(p / q)^3+3(p / q)+2 \\\\\n\n\\Longrightarrow & (p / q)^3+3(p / q)+2=0 \\\\\n\n\\Longrightarrow & p^3+3 p q^2=-2 q^3 \\\\\n\n\\Longrightarrow & p\\left(p^2+3 q^2\\right)=-q^3\n\n\\end{aligned}\n\n$$\n\nIt follows that, $p$ divides $q$ which is a contradiction to the fact that $\\operatorname{gcd}(p, q)=1$.\n\nThis implies that $f(x)$ has no rational root.\n\nNow we know that, a polynomial of degree two or three over a field $F$ is reducible if and only if it has a root in $F$.\n\nNow $f(x)$ is a 3 degree polynomial having no root in $\\mathbb{Q}$.\n\nSo, $f(x)$ is irreducible in $\\mathbb{Q}[x]$.\n\nThis completes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_6_2 : irreducible (X^3 + 3*X + 2 : polynomial \u211a) :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_of_roots_empty {F : Type*} [field F] {P : polynomial F}\n  (h : P.roots = \u2205) : irreducible P ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem polynomial.cyclotomic_three (R : Type*) [ring R] :\n\tpolynomial.cyclotomic 3 R = polynomial.X ^ 2 + polynomial.X + 1\n\ntheorem polynomial.not_irreducible_C {R : Type u} [field R] (x : R) :\n\t\u00acirreducible (\u21d1polynomial.C x)\n\ntheorem polynomial.irreducible_X {R : Type u} [comm_ring R] [is_domain R] :\n\tirreducible polynomial.X\n\ntheorem cubic.eq_prod_three_roots {F K : Type*} {P : cubic F} [field F]\n\t[field K] {\u03c6 : F \u2192+* K} {x y z : K} (ha : P.a \u2260 0)\n\t(h3 : (cubic.map \u03c6 P).roots = {x, y, z}) :\n\t(cubic.map \u03c6 P).to_poly = \u21d1polynomial.C (\u21d1\u03c6 P.a) * (polynomial.X - \u21d1polynomial.C x) * (polynomial.X - \u21d1polynomial.C y) * (polynomial.X - \u21d1polynomial.C z)\n\nThe following is the natural language theorem statement: \"Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_of_degree_three_polynomial (x : polynomial \u211a) :\n  irreducible (x^3 + 3*x + 2) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_5_1_8", "nl_statement": "If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$.", "nl_proof": "\\begin{proof}\n\n    Since $F$ is of characteristic $p$ and we have considered arbitrary two elements $a, b$ in $F$ we have\n\n$$\n\n\\begin{aligned}\n\n& p a=p b=0 \\\\\n\n& \\Longrightarrow p^n a=p^n b=0 \\\\\n\n& \\Longrightarrow m a=m b=0 \\text {. } \\\\\n\n&\n\n\\end{aligned}\n\n$$\n\nNow we know from Binomial Theorem that\n\n$$\n\n(a+b)^m=\\sum_{i=0}^m\\left(\\begin{array}{c}\n\nm \\\\\n\ni\n\n\\end{array}\\right) a^i b^{m-i}\n\n$$\n\nHere\n\n$$\n\n\\left(\\begin{array}{c}\n\nm \\\\\n\ni\n\n\\end{array}\\right)=\\frac{m !}{i !(m-i) !} .\n\n$$\n\nNow we know that for any integer $n$ and any integer $k$ satisfying $1 \\leq k<n, n$ always divides $\\left(\\begin{array}{l}n \\\\ k\\end{array}\\right)$. So in our case for $i$ in the range $1 \\leq i<m, m$ divides $\\left(\\begin{array}{c}m \\\\ i\\end{array}\\right)$. It follows that $p$ divides $\\left(\\begin{array}{c}m \\\\ i\\end{array}\\right)$, for $i$ satisfying $1 \\leq i<m$, since $m=p^n$ for any integer $n$. Therefore other than the terms $a^m$ and $b^m$ in the expansion $\\sum_{i=0}^m\\left(\\begin{array}{c}m \\\\ i\\end{array}\\right) a^i b^{m-i}$ will vanish due to char $p$ nature of $F$.\n\nHence we have\n\n$$\n\n\\sum_{i=0}^m\\left(\\begin{array}{c}\n\nm \\\\\n\ni\n\n\\end{array}\\right) a^i b^{m-i}=a^m+b^m\n\n$$\n\nThis follows that, for all $a, b \\in F$\n\n$$\n\n(a+b)^m=a^m+b^m .\n\n$$\n\nThis completes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_1_8 {p m n: \u2115} {F : Type*} [field F] \n  (hp : nat.prime p) (hF : char_p F p) (a b : F) (hm : m = p ^ n) : \n  (a + b) ^ m = a^m + b^m :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " add_pow_char_pow (R : Type u) [comm_semiring R] {p : \u2115}\n  [fact (nat.prime p)] [char_p R p] {n : \u2115} (x y : R) :\n  (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_pow_char_pow (R : Type u) [comm_semiring R] {p : \u2115}\n\t[fact (nat.prime p)] [char_p R p] {n : \u2115} (x y : R) :\n\t(x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n\n\ntheorem add_pow_char_pow_of_commute (R : Type u) [semiring R] {p : \u2115}\n\t[fact (nat.prime p)] [char_p R p] {n : \u2115} (x y : R) (h : commute x y) :\n\t(x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n\n\ntheorem add_pow_char (R : Type u) [comm_semiring R] {p : \u2115} [fact (nat.prime p)]\n\t[char_p R p] (x y : R) :\n\t(x + y) ^ p = x ^ p + y ^ p\n\ntheorem ennreal.rpow_add_le_add_rpow {p : \u211d} (a b : ennreal) (hp : 0 \u2264 p)\n\t(hp1 : p \u2264 1) :\n\t(a + b) ^ p \u2264 a ^ p + b ^ p\n\nThe following is the natural language theorem statement: \"If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " eq_add_of_pow_eq_pow_of_char_ne_zero {F : Type*} [field F] \n  (p : \u2115) (hp : fact (nat.prime p)) (hF : char_p F \u2260 0) (a b : F) (m : \u2115) :\n  (a + b) ^ m = a ^ m + b ^ m ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_5_3_7", "nl_statement": "If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$.", "nl_proof": "\\begin{proof}\n\n    Since $a^2$ is algebraic over $F$, there exist a non-zero polynomial $f(x)$ in $F[x]$ such that $f\\left(a^2\\right)=0$. Consider a new polynomial $g(x)$ defined as $g(x)=f\\left(x^2\\right)$. Clearly $g(x) \\in F[x]$ and $g(a)=f\\left(a^2\\right)= 0$.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_3_7 {K : Type*} [field K] {F : subfield K} \n  {a : K} (ha : is_algebraic F (a ^ 2)) : is_algebraic F a :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_algebraic_of_is_algebraic_pow_two {F K : Type*} [field F] [field K]\n  [algebra F K] (h : normal F K) (x : K) (hx : is_algebraic F (x ^ 2)) :\n  is_algebraic F x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem quadratic_char_eq_pow_of_char_ne_two' {F : Type*} [field F] [fintype F]\n\t[decidable_eq F] (hF : ring_char F \u2260 2) (a : F) :\n\t\u2191(\u21d1(quadratic_char F) a) = a ^ (fintype.card F / 2)\n\ntheorem normal.is_algebraic {F K : Type*} [field F] [field K] [algebra F K]\n\t(h : normal F K) (x : K) :\n\tis_algebraic F x\n\ntheorem finite_field.is_square_of_char_two {F : Type*} [field F] [finite F]\n\t(hF : ring_char F = 2) (a : F) :\n\tis_square a\n\ntheorem finite_field.is_square_iff {F : Type*} [field F] [fintype F]\n\t(hF : ring_char F \u2260 2) {a : F} (ha : a \u2260 0) :\n\tis_square a \u2194 a ^ (fintype.card F / 2) = 1\n\nThe following is the natural language theorem statement: \"If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_polynomial_of_algebraic_of_algebraic_sq {K : Type*} [field K]\n  {F : Type*} [field F] (a : K) (h : is_algebraic F (a ^ 2)) :\n  is_algebraic F a ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_5_4_3", "nl_statement": "If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.", "nl_proof": "\\begin{proof}\n\n    Given $a \\in \\mathbb{C}$ such that $p(a)=0$, where\n\n$$\n\np(x)=x^5+\\sqrt{2} x^3+\\sqrt{5} x^2+\\sqrt{7} x+\\sqrt{11}\n\n$$\n\nHere, we note that $p(x) \\in \\mathbb{Q}(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11})$ and\n\n$$\n\n\\begin{aligned}\n\n    {[Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11}): \\mathbb{Q}] } & =[Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11}): Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7})] \\cdot[\\mathbb{Q}(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}): \\mathbb{Q}(\\sqrt{2}, \\sqrt{5})] \\\\\n\n& \\cdot[\\mathbb{Q}(\\sqrt{2}, \\sqrt{5}): \\mathbb{Q}(\\sqrt{2})] \\cdot[\\mathbb{Q}(\\sqrt{2}): \\mathbb{Q}] \\\\\n\n& =2 \\cdot 2 \\cdot 2 \\cdot 2 \\\\\n\n& =16\n\n\\end{aligned}\n\n$$\n\nHere, we note that $p(x)$ is of degree 5 over $\\mathbb{Q}(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11})$. If $a$ is root of $p(x)$, then\n\n$$\n\n[Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11}, a): \\mathbb{Q}]=[Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11}): Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11})] \\cdot 15\n\n$$\n\nand $[Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11}): Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11})] \\leq 5$. We get equality if $p(x)$ is irreducible over $Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11})$. This gives\n\n$$\n\n[Q(\\sqrt{2}, \\sqrt{5}, \\sqrt{7}, \\sqrt{11}, a): \\mathbb{Q}] \\leq 16 \\cdot 5=80\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_5_4_3 {a : \u2102} {p : \u2102 \u2192 \u2102} \n  (hp : p = \u03bb x, x^5 + real.sqrt 2 * x^3 + real.sqrt 5 * x^2 + \n  real.sqrt 7 * x + 11)\n  (ha : p a = 0) : \n  \u2203 p : polynomial \u2102 , p.degree < 80 \u2227 a \u2208 p.roots \u2227 \n  \u2200 n : p.support, \u2203 a b : \u2124, p.coeff n = a / b :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " polynomial.degree_C_mul_X_sq_lt_degree_C_mul_X_pow_5\n  {R : Type u} {a b c d e : R} [semiring R] (ha : a \u2260 0) :\n  (\u21d1polynomial.C b * polynomial.X ^ 2 + \u21d1polynomial.C c * polynomial.X + \u21d1polynomial.C d).degree < (\u21d1polynomial.C a * polynomial.X ^ 5).degree ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem polynomial.degree_C_mul_X {R : Type u} {a : R} [semiring R] (ha : a \u2260 0) :\n\t(\u21d1polynomial.C a * polynomial.X).degree = 1\n\ntheorem polynomial.nat_degree_C_mul_X {R : Type u} [semiring R] (a : R)\n\t(ha : a \u2260 0) :\n\t(\u21d1polynomial.C a * polynomial.X).nat_degree = 1\n\ntheorem polynomial.degree_C_lt_degree_C_mul_X {R : Type u} {a b : R}\n\t[semiring R] (ha : a \u2260 0) :\n\t(\u21d1polynomial.C b).degree < (\u21d1polynomial.C a * polynomial.X).degree\n\ntheorem polynomial.degree_linear_lt_degree_C_mul_X_sq {R : Type u} {a b c : R}\n\t[semiring R] (ha : a \u2260 0) :\n\t(\u21d1polynomial.C b * polynomial.X + \u21d1polynomial.C c).degree < (\u21d1polynomial.C a * polynomial.X ^ 2).degree\n\nThe following is the natural language theorem statement: \"If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " degree_le_80_of_polynomial_root {a : \u2102} (ha : polynomial.eval \u2102 (X^5 + \u221a2*X^3 + \u221a5*X^2 + \u221a7*X + \u221a11) a = 0) :\n  algebraic_closure.degree \u211a a \u2264 80 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Herstein|exercise_5_6_14", "nl_statement": "If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.", "nl_proof": "\\begin{proof}\n\n    Let us consider $f(x)=x^m-x$. Then $f \\in F[x]$.\n\nClaim: $f(x)$ has a multiple root in some extension of $F$ if and only if $f(x)$ is not relatively prime to its formal derivative, $f^{\\prime}(x)$. \n\n\n\nProof of the Claim: Let us assume that $f(x)$ has a multiple root in some extension of $F$. Let $y$ be a multiple root of $f(x)$. Then over a splitting field, we have\n\n$$\n\nf(x)=(x-y)^n g(x), \\text { for some integer } n \\geq 2 .\n\n$$\n\nHere $g(x)$ is a polynomial such that $g(y) \\neq 0$. Now taking derivative of $f$ we get\n\n$$\n\nf^{\\prime}(x)=n \\cdot(x-y)^{n-1} g(x)+(x-y)^n g^{\\prime}(x)\n\n$$\n\nhere $g^{\\prime}(x)$ implies derivative of $g$ with respect to $x$. Since we have $n \\geq 2$, this implies $(n-1) \\geq 1$. Hence, (1) shows that $f^{\\prime}(x)$ has $y$ as a root. Therefore, $f(x)$ is not relatively prime to $f^{\\prime}(x)$. We now prove the other direction.\n\nConversely, let us assume that $f(x)$ is not relatively prime to $f^{\\prime}(x)$. Let $y$ is a root of both $f(x)$ and $f^{\\prime}(x)$. Since $y$ is a root of $f(x)$, we can write\n\n$$\n\nf(x)=(x-y) \\cdot g(x)\n\n$$\n\nfor some polynomial $g(x)$. then taking derivative of $f(x)$ we have\n\n$$\n\nf^{\\prime}(x)=g(x)+(x-y) \\cdot g^{\\prime}(x)\n\n$$\n\nwhere $g^{\\prime}(x)$ is the derivative of $g(x)$ with respect to $x$. Since $y$ is a root of $f^{\\prime}(x)$ also we have\n\n$$\n\nf^{\\prime}(y)=0\n\n$$\n\nThen we have\n\n$$\n\n\\begin{aligned}\n\n& f^{\\prime}(y)=g(y)+(y-y) \\cdot g^{\\prime}(y) \\\\\n\n\\Longrightarrow & f^{\\prime}(y)=g(y) \\\\\n\n\\Longrightarrow & g(y)=0 .\n\n\\end{aligned}\n\n$$\n\nThis implies $y$ is a root of $g(x)$ also. Therefore we have\n\n$$\n\ng(x)=(x-y) \\cdot h(x)\n\n$$\n\nfor some polynomial $h(x)$. Now form (2) we have\n\n$$\n\nf(x)=(x-y)^2 \\cdot h(x) .\n\n$$\n\nThis follows that $y$ is a multiple root of $f(x)$. Therefore, $f(x)$ has a multiple root in some extension of the field $F$. This completes the proof of the Claim.\n\n\n\nIn our case, $f(x)=x^m-x$, where $m=p^n$. Now we calculate the derivative of $f$. That is\n\n$$\n\nf^{\\prime}(x)=m x^{m-1}-1=-1(\\bmod p) .\n\n$$\n\nBy the above condition it follows that, $f^{\\prime}$ has no root same as $f$, that is, $f(x)$ and $f^{\\prime}(x)$ are relatively prime. Hence, $f(x)$ has no multiple root in $F$. Since $f(x)=x^m-x$ is a polynomial of degree $m$, it follows that $f(x)$ has $m$ distinct roots in $F$, where $m=p^n$. This completes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_6_14 {p m n: \u2115} (hp : nat.prime p) {F : Type*} \n  [field F] [char_p F p] (hm : m = p ^ n) : \n  card (root_set (X ^ m - X : polynomial F) F) = m :=", "src_header": "import .common \n\nopen set function nat fintype real subgroup ideal polynomial submodule zsqrtd \nopen char_p mul_aut matrix\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " multiplicity.pow_sub_pow_of_prime {R : Type*} [comm_ring R]\n  [is_domain R] [decidable_rel has_dvd.dvd] {p : R} (hp : prime p) {x y : R}\n  (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) {n : \u2115} (hn : \u00acp \u2223 \u2191n) :\n  multiplicity p (x ^ n - y ^ n) = multiplicity p (x - y) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem sub_pow_char_pow (R : Type u) [comm_ring R] {p : \u2115} [fact (nat.prime p)]\n\t[char_p R p] {n : \u2115} (x y : R) :\n\t(x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n\n\ntheorem sub_pow_char_pow_of_commute (R : Type u) [ring R] {p : \u2115}\n\t[fact (nat.prime p)] [char_p R p] {n : \u2115} (x y : R) (h : commute x y) :\n\t(x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n\n\ntheorem multiplicity.nat.pow_sub_pow {p : \u2115} (hp : nat.prime p) (hp1 : odd p)\n\t{x y : \u2115} (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) (n : \u2115) :\n\tmultiplicity p (x ^ n - y ^ n) = multiplicity p (x - y) + multiplicity p n\n\ntheorem multiplicity.pow_sub_pow_of_prime {R : Type*} [comm_ring R]\n\t[is_domain R] [decidable_rel has_dvd.dvd] {p : R} (hp : prime p) {x y : R}\n\t(hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) {n : \u2115} (hn : \u00acp \u2223 \u2191n) :\n\tmultiplicity p (x ^ n - y ^ n) = multiplicity p (x - y)\n\nThe following is the natural language theorem statement: \"If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " distinct_roots_of_x_pow_m_sub_x_of_char_p {F : Type*} [field F] \n  (p : \u2115) (hp : fact (nat.prime p)) (n : \u2115) (h : char_p F = p) :\n  \u2200 (x y : F), x ^ p ^ n - x = 0 \u2192 y ^ p ^ n - y = 0 \u2192 x \u2260 y ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_2_26", "nl_statement": "Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement.", "nl_proof": "\\begin{proof}\n\n    Assume that none of the points of $U$ are limits of its complement, and let us prove that $U$ is open. Assume by contradiction that $U$ is not open, so there exists $p \\in M$ so that $\\forall r>0$ there exists $q \\in M$ with $d(p, q)<r$ but $q \\notin U$. Applying this to $r=1 / n$ we obtain $q_n \\in U^c$ such that $d\\left(q_n, p\\right)<1 / n$. But then $q_n \\rightarrow p$ and $p$ is a limit of a sequence of points in $U^c$, a contradiction.\n\n\n\nAssume now that $U$ is open. Assume by contradiction there exists $p \\in U$ and $p_n \\in U^c$ such that $p_n \\rightarrow p$. Since $U$ is open, there exists $r>0$ such that $d(p, x)<r$ for $x \\in M$ implies $x \\in U$. But since $p_n \\rightarrow p$, there exists $n_0 \\in \\mathbb{N}$ such that $n \\geq n_0$ implies $d\\left(p_n, p\\right)<r$, therefore $p_n \\in U$ for $n \\geq n_0$, a contradiction since $p_n \\in U^c$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_26 {M : Type*} [topological_space M]\n  (U : set M) : is_open U \u2194 \u2200 x \u2208 U, \u00ac cluster_pt x (\ud835\udcdf U\u1d9c) :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " is_open_iff_ultrafilter {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1]\n  [compact_space \u03b1] (U : set \u03b1) :\n  is_open U \u2194 \u2200 (F : ultrafilter \u03b1), F.Lim \u2208 U \u2192 U \u2208 F.to_filter ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem topological_space.opens.ext_iff {\u03b1 : Type*} [topological_space \u03b1]\n\t{U V : topological_space.opens \u03b1} :\n\t\u2191U = \u2191V \u2194 U = V\n\ntheorem is_open_iff_ultrafilter' {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1]\n\t[compact_space \u03b1] (U : set \u03b1) :\n\tis_open U \u2194 \u2200 (F : ultrafilter \u03b1), F.Lim \u2208 U \u2192 U \u2208 F.to_filter\n\ntheorem open_subgroup.ext_iff {G : Type*} [group G] [topological_space G]\n\t{U V : open_subgroup G} :\n\tU = V \u2194 \u2200 (x : G), x \u2208 U \u2194 x \u2208 V\n\ntheorem algebraic_geometry.is_compact_open_iff_eq_basic_open_union\n\t{X : algebraic_geometry.Scheme} [algebraic_geometry.is_affine X]\n\t(U : set \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)) :\n\tis_compact U \u2227 is_open U \u2194 \u2203 (s : set \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op \u22a4))), s.finite \u2227 U = \u22c3 (i : \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op \u22a4))) (h : i \u2208 s), \u2191(X.basic_open i)\n\nThe following is the natural language theorem statement: \"Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_open_iff_no_limit_point_of_compl {M : Type*} [topological_space M]\n  (U : set M) : is_open U \u2194 \u2200 (x : M), x \u2208 U \u2192 \u00ac x \u2208 closure (set.compl U) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_2_32a", "nl_statement": "Show that every subset of $\\mathbb{N}$ is clopen.", "nl_proof": "\\begin{proof}\n\n    32. The one-point set $\\{n\\} \\subset \\mathbb{N}$ is open, since it contains all $m \\in \\mathbb{N}$ that satisfy $d(m, n)<\\frac{1}{2}$. Every subset of $\\mathbb{N}$ is a union of one-point sets, hence is open. Then every set it closed, since its complement is necessarily open.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_32a (A : set \u2115) : is_clopen A :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " is_clopen_of_subset_nat {s : set \u2115} : is_clopen s ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem topological_space.clopens.clopen {\u03b1 : Type*} [topological_space \u03b1]\n\t(s : topological_space.clopens \u03b1) :\n\tis_clopen \u2191s\n\ntheorem clopen_upper_set.clopen {\u03b1 : Type*} [topological_space \u03b1] [has_le \u03b1]\n\t(s : clopen_upper_set \u03b1) :\n\tis_clopen \u2191s\n\ntheorem nat.coe_order_embedding_of_set {s : set \u2115} [infinite \u21a5s] :\n\t\u21d1(nat.order_embedding_of_set s) = coe \u2218 nat.subtype.of_nat s\n\ndef nat.subtype.order_iso_of_nat (s : set \u2115) [infinite \u21a5s] :\n\t\u2115 \u2243o \u21a5s\n\nThe following is the natural language theorem statement: \"Show that every subset of $\\mathbb{N}$ is clopen.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_clopen_of_subset_nat (s : set \u2115) : is_clopen s ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that every subset of $\\mathbb{N}$ is clopen.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_2_46", "nl_statement": "Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$.", "nl_proof": "\\begin{proof}\n\nLet $A$ and $B$ be compact, disjoint and non-empty subsets of $M$. We want to show that there exist $a_0 \\in A, b_0 \\in B$ such that for all $a \\in A, b \\in B$,\n\n$$\n\nd\\left(a_0, b_0\\right) \\leq d(a, b) .\n\n$$\n\nWe saw in class that the distance function $d: M \\times M \\rightarrow \\mathbb{R}$ is continuous. We also saw in class that any continuous, real-valued function assumes maximum and minimum values on a compact set. Since $A$ and $B$ are compact, $A \\times B$ is (non-empty) compact in $M \\times M$. Therefore there exists $\\left(a_0, b_0\\right) \\in A \\times B$ such that $d\\left(a_0, b_0\\right) \\leq d(a, b), \\forall(a, b) \\in A \\times B$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_46 {M : Type*} [metric_space M]\n  {A B : set M} (hA : is_compact A) (hB : is_compact B)\n  (hAB : disjoint A B) (hA\u2080 : A \u2260 \u2205) (hB\u2080 : B \u2260 \u2205) :\n  \u2203 a\u2080 b\u2080, a\u2080 \u2208 A \u2227 b\u2080 \u2208 B \u2227 \u2200 (a : M) (b : M),\n  a \u2208 A \u2192 b \u2208 B \u2192 dist a\u2080 b\u2080 \u2264 dist a b :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " exists_inf_dist_eq_dist {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n  {s : set \u03b1} (h : is_compact s) (hne : s.nonempty) (x : \u03b1) :\n  \u2203 (y : \u03b1) (H : y \u2208 s), metric.inf_dist x s = has_dist.dist x y ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem disjoint.exists_uniform_thickening {\u03b1 : Type*} [uniform_space \u03b1]\n\t{A B : set \u03b1} (hA : is_compact A) (hB : is_closed B) (h : disjoint A B) :\n\t\u2203 (V : set (\u03b1 \u00d7 \u03b1)) (H : V \u2208 uniformity \u03b1), disjoint (\u22c3 (x : \u03b1) (H : x \u2208 A), uniform_space.ball x V) (\u22c3 (x : \u03b1) (H : x \u2208 B), uniform_space.ball x V)\n\ntheorem is_compact.exists_inf_dist_eq_dist {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{s : set \u03b1} (h : is_compact s) (hne : s.nonempty) (x : \u03b1) :\n\t\u2203 (y : \u03b1) (H : y \u2208 s), metric.inf_dist x s = has_dist.dist x y\n\ntheorem measure_theory.vector_measure.of_nonneg_disjoint_union_eq_zero\n\t{\u03b1 : Type*} {m : measurable_space \u03b1} {s : measure_theory.signed_measure \u03b1}\n\t{A B : set \u03b1} (h : disjoint A B) (hA\u2081 : measurable_set A)\n\t(hB\u2081 : measurable_set B) (hA\u2082 : 0 \u2264 \u21d1s A) (hB\u2082 : 0 \u2264 \u21d1s B)\n\t(hAB : \u21d1s (A \u222a B) = 0) :\n\t\u21d1s A = 0\n\ntheorem measure_theory.vector_measure.of_nonpos_disjoint_union_eq_zero\n\t{\u03b1 : Type*} {m : measurable_space \u03b1} {s : measure_theory.signed_measure \u03b1}\n\t{A B : set \u03b1} (h : disjoint A B) (hA\u2081 : measurable_set A)\n\t(hB\u2081 : measurable_set B) (hA\u2082 : \u21d1s A \u2264 0) (hB\u2082 : \u21d1s B \u2264 0)\n\t(hAB : \u21d1s (A \u222a B) = 0) :\n\t\u21d1s A = 0\n\nThe following is the natural language theorem statement: \"Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_min_dist_of_disjoint_compact {M : Type*} [metric_space M]\n  {A B : set M} (hA : compact A) (hB : compact B) (hAB : disjoint A B)\n  (hA0 : A \u2260 \u2205) (hB0 : B \u2260 \u2205) :\n  \u2203 (a0 : M) (b0 : M), a0 \u2208 A \u2227 b0 \u2208 B \u2227 \u2200 (a : M) (b : M), a \u2208 A \u2192 b \u2208 B \u2192 dist a0 b0 \u2264 dist a b ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_2_92", "nl_statement": "Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty.", "nl_proof": "\\begin{proof}\n\n    Let\n\n$$\n\nA_1 \\supset A_2 \\supset \\cdots \\supset A_n \\supset \\cdots\n\n$$\n\nbe a nested decreasing sequence of compacts. Suppose that $\\bigcap A_n=\\emptyset$. Take $U_n=A_n^c$, then\n\n$$\n\n\\bigcup U_n=\\bigcup A_n^c=\\left(\\bigcap A_n\\right)^c=A_1 .\n\n$$\n\nHere, I'm thinking of $A_1$ as the main metric space. Since $\\left\\{U_n\\right\\}$ is an open covering of $A_1$, we can extract a finite subcovering, that is,\n\n$$\n\nA_{\\alpha_1}^c \\cup A_{\\alpha_2}^c \\cup \\cdots \\cup A_{\\alpha_m}^c \\supset A_1\n\n$$\n\nor\n\n$$\n\n\\left(A_1 \\backslash A_{\\alpha_1}\\right) \\cup\\left(A_1 \\backslash A_{\\alpha_2}\\right) \\cup \\cdots \\cup\\left(A_1 \\backslash A_{\\alpha_m}\\right) \\supset A_1 .\n\n$$\n\nBut, this is true only if $A_{\\alpha_i}=\\emptyset$ for some $i$, a contradiction.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_92 {\u03b1 : Type*} [topological_space \u03b1]\n  {s : \u2115 \u2192 set \u03b1}\n  (hs : \u2200 i, is_compact (s i))\n  (hs : \u2200 i, (s i).nonempty)\n  (hs : \u2200 i, (s i) \u2283 (s (i + 1))) :\n  (\u22c2 i, s i).nonempty :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " is_compact.elim_nhds_subcover' {\u03b1 : Type u} [topological_space \u03b1]\n  {s : set \u03b1} (hs : is_compact s) (U : \u03a0 (x : \u03b1), x \u2208 s \u2192 set \u03b1)\n  (hU : \u2200 (x : \u03b1) (H : x \u2208 s), U x H \u2208 nhds x) :\n  \u2203 (t : finset \u21a5s), s \u2286 \u22c3 (x : \u21a5s) (H : x \u2208 t), U \u2191x _ ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_compact.elim_nhds_subcover' {\u03b1 : Type u} [topological_space \u03b1]\n\t{s : set \u03b1} (hs : is_compact s) (U : \u03a0 (x : \u03b1), x \u2208 s \u2192 set \u03b1)\n\t(hU : \u2200 (x : \u03b1) (H : x \u2208 s), U x H \u2208 nhds x) :\n\t\u2203 (t : finset \u21a5s), s \u2286 \u22c3 (x : \u21a5s) (H : x \u2208 t), U \u2191x _\n\ntheorem is_compact.elim_nhds_subcover {\u03b1 : Type u} [topological_space \u03b1]\n\t{s : set \u03b1} (hs : is_compact s) (U : \u03b1 \u2192 set \u03b1)\n\t(hU : \u2200 (x : \u03b1), x \u2208 s \u2192 U x \u2208 nhds x) :\n\t\u2203 (t : finset \u03b1), (\u2200 (x : \u03b1), x \u2208 t \u2192 x \u2208 s) \u2227 s \u2286 \u22c3 (x : \u03b1) (H : x \u2208 t), U x\n\ntheorem is_compact.elim_finite_subcover_image {\u03b1 : Type u} {\u03b9 : Type*}\n\t[topological_space \u03b1] {s : set \u03b1} {b : set \u03b9} { : \u03b9 \u2192 set \u03b1}\n\t(hs : is_compact s) (hc\u2081 : \u2200 (i : \u03b9), i \u2208 b \u2192 is_open (c i))\n\t(hc\u2082 : s \u2286 \u22c3 (i : \u03b9) (H : i \u2208 b), c i) :\n\t\u2203 (b' : set \u03b9) (H : b' \u2286 b), b'.finite \u2227 s \u2286 \u22c3 (i : \u03b9) (H : i \u2208 b'), c i\n\ntheorem local_compact_nhds {\u03b1 : Type u} [topological_space \u03b1]\n\t[locally_compact_space \u03b1] {x : \u03b1} {n : set \u03b1} (h : n \u2208 nhds x) :\n\t\u2203 (s : set \u03b1) (H : s \u2208 nhds x), s \u2286 n \u2227 is_compact s\n\nThe following is the natural language theorem statement: \"Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " compact_of_nested_inter_of_covering_compact {X : Type*} [topological_space X]\n  [compact_space X] {I : Type*} [fintype I] {s : I \u2192 set X}\n  (h : \u2200 i j : I, i \u2264 j \u2192 s i \u2286 s j) (hc : \u2200 i : I, is_compact (s i))\n  (hnc : \u2200 i : I, s i \u2260 \u2205) :\n  \u2203 x : X, \u2200 i : I, x \u2208 s i ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_3_1", "nl_statement": "Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.", "nl_proof": "\\begin{proof}\n\n    We have $|f(t)-f(x)| \\leq|t-x|^2, \\forall t, x \\in \\mathbb{R}$. Fix $x \\in \\mathbb{R}$ and let $t \\neq x$. Then\n\n$$\n\n\\left|\\frac{f(t)-f(x)}{t-x}\\right| \\leq|t-x| \\text {, hence } \\lim _{t \\rightarrow x}\\left|\\frac{f(t)-f(x)}{t-x}\\right|=0 \\text {, }\n\n$$\n\nso $f$ is differentiable in $\\mathbb{R}$ and $f^{\\prime}=0$. This implies that $f$ is constant, as seen in class.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_1 {f : \u211d \u2192 \u211d}\n  (hf : \u2200 x y, |f x - f y| \u2264 |x - y| ^ 2) :\n  \u2203 c, f = \u03bb x, c :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " continuous_of_dist_le_two_norm {f : \u211d \u2192 \u211d} (hf : \u2200 (t x : \u211d),\n  dist (f t) (f x) \u2264 (t - x) ^ 2) : continuous f ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem bounded_continuous_function.dist_le_two_norm' {\u03b2 : Type v} {\u03b3 : Type w}\n\t[seminormed_add_comm_group \u03b2] {f : \u03b3 \u2192 \u03b2} {C : \u211d} (hC : \u2200 (x : \u03b3), \u2016f x\u2016 \u2264 C)\n\t(x y : \u03b3) :\n\thas_dist.dist (f x) (f y) \u2264 2 * C\n\ntheorem strict_convex_on_univ_of_deriv2_pos {f : \u211d \u2192 \u211d} (hf : continuous f)\n\t(hf'' : \u2200 (x : \u211d), 0 < deriv^[2] f x) :\n\tstrict_convex_on \u211d set.univ f\n\ntheorem continuous.bounded_above_of_compact_support {\u03b1 E : Type*}\n\t[normed_add_group E] [topological_space \u03b1] {f : \u03b1 \u2192 E} (hf : continuous f)\n\t(h : has_compact_support f) :\n\t\u2203 (C : \u211d), \u2200 (x : \u03b1), \u2016f x\u2016 \u2264 C\n\ntheorem monoid_hom_class.uniform_continuous_of_bound {\ud835\udcd5 E F : Type*}\n\t[seminormed_group E] [seminormed_group F] [monoid_hom_class \ud835\udcd5 E F] (f : \ud835\udcd5)\n\t(C : \u211d) (h : \u2200 (x : E), \u2016\u21d1f x\u2016 \u2264 C * \u2016x\u2016) :\n\tuniform_continuous \u21d1f\n\nThe following is the natural language theorem statement: \"Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " const_of_uniform_continuous_of_order_two {f : \u211d \u2192 \u211d}\n  (hf : uniform_continuous f) (hf' : \u2200 x t, abs (f t - f x) \u2264 abs (t - x) ^ 2) :\n  \u2203 c : \u211d, f = function.const \u211d c ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_3_63a", "nl_statement": "Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$.", "nl_proof": "\\begin{proof}\n\n    Using the integral test, for a set $a$, we see\n\n$$\n\n\\lim _{b \\rightarrow \\infty} \\int_a^b \\frac{1}{x \\log (x)^c} d x=\\lim _{b \\rightarrow \\infty}\\left(\\frac{\\log (b)^{1-c}}{1-c}-\\frac{\\log (a)^{1-c}}{1-c}\\right)\n\n$$\n\nwhich goes to infinity if $c \\leq 1$ and converges if $c>1$. Thus,\n\n$$\n\n\\sum_{n=2}^{\\infty} \\frac{1}{n \\log (n)^c}\n\n$$\n\nconverges if and only if $c>1$. \n\n\\end{proof}", "formal_statement": "theorem exercise_3_63a (p : \u211d) (f : \u2115 \u2192 \u211d) (hp : p > 1)\n  (h : f = \u03bb k, (1 : \u211d) / (k * (log k) ^ p)) :\n  \u2203 l, tendsto f at_top (\ud835\udcdd l) :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " summable_one_div_nat_log_pow {p : \u211d} :\n  summable (\u03bb (n : \u2115), 1 / (\u2191n * (log \u2191n) ^ p)) \u2194 1 < p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nnreal.summable_one_div_rpow {p : \u211d} :\n\tsummable (\u03bb (n : \u2115), 1 / \u2191n ^ p) \u2194 1 < p\n\ntheorem real.summable_one_div_nat_pow {p : \u2115} :\n\tsummable (\u03bb (n : \u2115), 1 / \u2191n ^ p) \u2194 1 < p\n\ntheorem real.summable_one_div_nat_rpow {p : \u211d} :\n\tsummable (\u03bb (n : \u2115), 1 / \u2191n ^ p) \u2194 1 < p\n\ntheorem lp.norm_le_of_forall_sum_le {\u03b1 : Type*} {E : \u03b1 \u2192 Type u_2} {p : ennreal}\n\t[\u03a0 (i : \u03b1), normed_add_comm_group (E i)] (hp : 0 < p.to_real) {C : \u211d}\n\t(hC : 0 \u2264 C) {f : \u21a5(lp E p)}\n\t(hf : \u2200 (s : finset \u03b1), s.sum (\u03bb (i : \u03b1), \u2016\u21d1f i\u2016 ^ p.to_real) \u2264 C ^ p.to_real) :\n\t\u2016f\u2016 \u2264 C\n\nThe following is the natural language theorem statement: \"Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sum_one_div_k_log_k_p_converges (p : \u211d) (hp : p > 1) :\n  \u2203 (N : \u2115), \u2200 (n : \u2115), n \u2265 N \u2192 (\u2211 k in finset.range n, 1 / (k * (log k) ^ p)) < \u221e ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Pugh|exercise_4_15a", "nl_statement": "A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity.", "nl_proof": "\\begin{proof}\n\n    Suppose there exists a modulus of continuity $w$ for $f$, then fix $\\varepsilon>0$, since $\\lim _{s \\rightarrow 0} w(s)=0$, there exists $\\delta>0$ such that for any $|s|<\\delta$, we have $w(s)<\\varepsilon$, then we have for any $x, z \\in X$ such that $d_X(x, z)<\\delta$, we have $d_Y(f(x), f(z)) \\leq w\\left(d_X(x, z)\\right)<\\varepsilon$, which means $f$ is uniformly continuous.\n\n\n\nSuppose $f:\\left(X, d_X\\right) \\rightarrow\\left(Y, d_Y\\right)$ is uniformly continuous.\n\nLet $\\delta_1>0$ be such that $d_X(a, b)<\\delta_1$ implies $d_Y(f(a), f(b))<1$.\n\nDefine $w:[0, \\infty) \\rightarrow[0, \\infty]$ by\n\n$$\n\nw(s)= \\begin{cases}\\left.\\sup \\left\\{d_Y(f(a), f(b))\\right\\} \\mid d_X(a, b) \\leq s\\right\\} & \\text { if } s \\leq \\delta_1 \\\\ \\infty & \\text { if } s>\\delta_1\\end{cases}\n\n$$\n\nWe'll show that $w$ is a modulus of continuity for $f \\ldots$\n\nBy definition of $w$, it's immediate that $w(0)=0$ and it's clear that\n\n$$\n\nd_Y(f(a), f(b)) \\leq w\\left(d_X(a, b)\\right)\n\n$$\n\nfor all $a, b \\in X$.\n\nIt remains to show $\\lim _{s \\rightarrow 0^{+}} w(s)=0$.\n\nIt's easily seen that $w$ is nonnegative and non-decreasing, hence $\\lim _{s \\rightarrow 0^{+}}=L$ for some $L \\geq 0$, where $L=\\inf w((0, \\infty))$\n\nLet $\\epsilon>0$.\n\nBy uniform continuity of $f$, there exists $\\delta>0$ such that $d_X(a, b)<\\delta$ implies $d_Y(f(a), f(b))<\\epsilon$, hence by definition of $w$, we get $w(\\delta) \\leq \\epsilon$.\n\nThus $L \\leq \\epsilon$ for all $\\epsilon>0$, hence $L=0$.\n\nThis completes the proof.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_15a {\u03b1 : Type*}\n  (a b : \u211d) (F : set (\u211d \u2192 \u211d)) :\n  (\u2200 (x : \u211d) (\u03b5 > 0), \u2203 (U \u2208 (\ud835\udcdd x)),\n  (\u2200 (y z \u2208 U) (f : \u211d \u2192 \u211d), f \u2208 F \u2192 (dist (f y) (f z) < \u03b5)))\n  \u2194\n  \u2203 (\u03bc : \u211d \u2192 \u211d), \u2200 (x : \u211d), (0 : \u211d) \u2264 \u03bc x \u2227 tendsto \u03bc (\ud835\udcdd 0) (\ud835\udcdd 0) \u2227\n  (\u2200 (s t : \u211d) (f : \u211d \u2192 \u211d), f \u2208 F \u2192 |(f s) - (f t)| \u2264 \u03bc (|s - t|)) :=", "src_header": "import .common\n\nopen set real filter function ring_hom topological_space\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology \nnoncomputable theory \n\n", "gpt_formal_statement": " uniform_continuous_iff_has_modulus_of_continuity {\u03b1 : Type*}\n  [metric_space \u03b1] {f : \u03b1 \u2192 \u211d} :\n  uniform_continuous f \u2194 \u2203 (\u03bc : \u211d \u2192 \u211d), (\u2200 (s : \u211d), s > 0 \u2192 \u03bc s > 0) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s + t) \u2264 \u03bc s + \u03bc t) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s * t) \u2264 \u03bc s * \u03bc t) \u2227 (\u2200 (s : \u211d), s > 0 \u2192 \u03bc s < s) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s + t) \u2264 \u03bc s + \u03bc t) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s * t) \u2264 \u03bc s * \u03bc t) \u2227 (\u2200 (s : \u211d), s > 0 \u2192 \u03bc s < s) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s + t) \u2264 \u03bc s + \u03bc t) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s * t) \u2264 \u03bc s * \u03bc t) \u2227 (\u2200 (s : \u211d), s > 0 \u2192 \u03bc s < s) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192 t > 0 \u2192 \u03bc (s + t) \u2264 \u03bc s + \u03bc t) \u2227 (\u2200 (s t : \u211d), s > 0 \u2192", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem metric.uniform_continuous_iff {\u03b1 : Type u} {\u03b2 : Type v}\n\t[pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\tuniform_continuous f \u2194 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2203 (\u03b4 : \u211d) (H : \u03b4 > 0), \u2200 {a b : \u03b1}, has_dist.dist a b < \u03b4 \u2192 has_dist.dist (f a) (f b) < \u03b5)\n\ntheorem add_monoid_hom.uniform_continuous_of_continuous_at_zero {\u03b1 \u03b2 : Type*}\n\t[uniform_space \u03b1] [add_group \u03b1] [uniform_add_group \u03b1] [uniform_space \u03b2]\n\t[add_group \u03b2] [uniform_add_group \u03b2] (f : \u03b1 \u2192+ \u03b2) (hf : continuous_at \u21d1f 0) :\n\tuniform_continuous \u21d1f\n\ntheorem uniform_continuous.continuous {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : uniform_continuous f) :\n\tcontinuous f\n\ntheorem metric.uniform_continuous_on_iff {\u03b1 : Type u} {\u03b2 : Type v}\n\t[pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} :\n\tuniform_continuous_on f s \u2194 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2203 (\u03b4 : \u211d) (H : \u03b4 > 0), \u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b1), y \u2208 s \u2192 has_dist.dist x y < \u03b4 \u2192 has_dist.dist (f x) (f y) < \u03b5)\n\nThe following is the natural language theorem statement: \"A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " uniform_continuous_iff_has_modulus_of_continuity {\u03b1 : Type*}\n  [linear_order \u03b1] [topological_space \u03b1] [metric_space \u03b1]\n  {f : \u03b1 \u2192 \u211d} (hf : continuous f) :\n  uniform_continuous f \u2194 \u2203 (\u03bc : \u211d \u2192 \u211d),\n    (\u2200 (s : \u211d), 0 < s \u2192 0 < \u03bc s) \u2227\n    (\u2200 (s : \u211d), 0 < s \u2192 \u03bc s < 1) \u2227\n    (\u2200 (s : \u211d), \u03bc s = 0 \u2192 s = 0) \u2227\n    (\u2200 (s : \u211d), \u03bc s = 1 \u2192 s \u2260 0) \u2227\n    (\u2200 (s : \u211d), \u03bc s \u2260 0 \u2192 \u2203 (t : \u211d), 0 < t \u2227 t < s \u2227 \u03bc t = 0) \u2227\n    (\u2200 (s t : \u211d), 0 < s \u2192 0 < t \u2192 \u03bc (s + t) \u2264 \u03bc s + \u03bc t) \u2227\n    (\u2200 (s t : \u211d), 0 < s \u2192 0 < t \u2192 \u03bc (s * t) \u2264 \u03bc s * \u03bc t) \u2227\n    (\u2200 (s t : \u211d), 0 < s \u2192 0 < t \u2192 \u03bc (s / t) \u2264 \u03bc s / \u03bc t) \u2227\n    (\u2200 (s t : \u211d), 0 < s \u2192 0 < t \u2192 \u03bc (s - t) \u2264 \u03bc s + \u03bc t) \u2227\n    (\u2200 (s t : \u211d), 0 < s \u2192 0 < t \u2192 \u03bc (s / t) \u2264 \u03bc s / \u03bc t)", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_2_3_2", "nl_statement": "Prove that the products $a b$ and $b a$ are conjugate elements in a group.", "nl_proof": "\\begin{proof}\n\n    We have that $(a^{-1})ab(a^{-1})^{-1} = ba$. \n\n\\end{proof}", "formal_statement": "theorem exercise_2_3_2 {G : Type*} [group G] (a b : G) :\n  \u2203 g : G, b* a = g * a * b * g\u207b\u00b9 :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " conjugate_of_mul_comm {G : Type*} [group G] (a b : G) :\n  conjugate (a * b) (b * a) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem mul_inv_cancel_comm {G : Type*} [comm_group G] (a b : G) :\n\ta * b * a\u207b\u00b9 = b\n\ntheorem mul_inv_cancel_comm_assoc {G : Type*} [comm_group G] (a b : G) :\n\ta * (b * a\u207b\u00b9) = b\n\ntheorem mul_mul_inv_cancel'_right {G : Type*} [comm_group G] (a b : G) :\n\ta * (b * a\u207b\u00b9) = b\n\ntheorem mul_comm {G : Type*} [comm_semigroup G] (a b : G) :\n\ta * b = b * a\n\nThe following is the natural language theorem statement: \"Prove that the products $a b$ and $b a$ are conjugate elements in a group.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " conjugate_of_mul_comm {G : Type*} [group G] (a b : G) :\n  a * b \u2248 b * a ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the products $a b$ and $b a$ are conjugate elements in a group.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_2_8_6", "nl_statement": "Prove that the center of the product of two groups is the product of their centers.", "nl_proof": "\\begin{proof}\n\n    We have that $(g_1, g_2)\\cdot (h_1, h_2) = (h_1, h_2)\\cdot (g_1, g_2)$ if and only if $g_1h_1 = h_1g_1$ and $g_2h_2 = h_2g_2$. \n\n\\end{proof}", "formal_statement": "theorem exercise_2_8_6 {G H : Type*} [group G] [group H] :\n  center (G \u00d7 H) \u2243* (center G) \u00d7 (center H) :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " center_mul_group {G H : Type*} [group G] [group H] :\n  subgroup.center (G \u00d7 H) = subgroup.center G \u00d7 subgroup.center H ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem quotient_group.comap_comap_center {G : Type u} [group G]\n\t{H\u2081 : subgroup G} [H\u2081.normal] {H\u2082 : subgroup (G \u29f8 H\u2081)} [H\u2082.normal] :\n\tsubgroup.comap (quotient_group.mk' H\u2081) (subgroup.comap (quotient_group.mk' H\u2082) (subgroup.center ((G \u29f8 H\u2081) \u29f8 H\u2082))) = subgroup.comap (quotient_group.mk' (subgroup.comap (quotient_group.mk' H\u2081) H\u2082)) (subgroup.center (G \u29f8 subgroup.comap (quotient_group.mk' H\u2081) H\u2082))\n\ntheorem quotient_add_group.comap_comap_center {G : Type u} [add_group G]\n\t{H\u2081 : add_subgroup G} [H\u2081.normal] {H\u2082 : add_subgroup (G \u29f8 H\u2081)} [H\u2082.normal] :\n\tadd_subgroup.comap (quotient_add_group.mk' H\u2081) (add_subgroup.comap (quotient_add_group.mk' H\u2082) (add_subgroup.center ((G \u29f8 H\u2081) \u29f8 H\u2082))) = add_subgroup.comap (quotient_add_group.mk' (add_subgroup.comap (quotient_add_group.mk' H\u2081) H\u2082)) (add_subgroup.center (G \u29f8 add_subgroup.comap (quotient_add_group.mk' H\u2081) H\u2082))\n\ntheorem is_subgroup.mem_center {G : Type*} [group G] {a : G} :\n\ta \u2208 is_subgroup.center G \u2194 \u2200 (g : G), g * a = a * g\n\ntheorem subgroup.mem_center_iff {G : Type*} [group G] {z : G} :\n\tz \u2208 subgroup.center G \u2194 \u2200 (g : G), g * z = z * g\n\nThe following is the natural language theorem statement: \"Prove that the center of the product of two groups is the product of their centers.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " center_mul_eq_mul_center {G H : Type*} [group G] [group H] :\n  center (G * H) = center G * center H ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the center of the product of two groups is the product of their centers.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_3_2_7", "nl_statement": "Prove that every homomorphism of fields is injective.", "nl_proof": "\\begin{proof}\n\n    Suppose $f(a)=f(b)$, then $f(a-b)=0=f(0)$. If $u=(a-b) \\neq 0$, then $f(u) f\\left(u^{-1}\\right)=f(1)=1$, but that means that $0 f\\left(u^{-1}\\right)=1$, which is impossible. Hence $a-b=0$ and $a=b$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_2_7 {F : Type*} [field F] {G : Type*} [field G]\n  (\u03c6 : F \u2192+* G) : injective \u03c6 :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " ring_hom.injective {\u03b1 \u03b2 : Type*} [field \u03b1] [field \u03b2] (f : \u03b1 \u2192+* \u03b2) :\n  function.injective \u21d1f ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem algebra.is_algebraic.alg_hom_bijective {K L : Type*} [field K] [field L]\n\t[algebra K L] (ha : algebra.is_algebraic K L) (f : L \u2192\u2090[K] L) :\n\tfunction.bijective \u21d1f\n\ntheorem ring_hom.coe_field_range {K : Type u} {L : Type v} [field K] [field L]\n\t(f : K \u2192+* L) :\n\t\u2191(f.field_range) = set.range \u21d1f\n\ntheorem ring_hom.injective {\u03b1 \u03b2 : Type*} [division_ring \u03b1] [semiring \u03b2]\n\t[nontrivial \u03b2] (f : \u03b1 \u2192+* \u03b2) :\n\tfunction.injective \u21d1f\n\ntheorem ring_hom.field_range_eq_map {K : Type u} {L : Type v} [field K]\n\t[field L] (f : K \u2192+* L) :\n\tf.field_range = subfield.map f \u22a4\n\nThe following is the natural language theorem statement: \"Prove that every homomorphism of fields is injective.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " injective_of_homomorphism_of_fields {K L : Type*} [field K] [field L]\n  (f : K \u2192+* L) : function.injective f ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that every homomorphism of fields is injective.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_3_7_2", "nl_statement": "Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces.", "nl_proof": "\\begin{proof}\n\n    If $V$ is the set-theoretic union of $n$ proper subspaces $W_i$ ( $1 \\leq i \\leq n$ ), then $|F| \\leq n-1$.\n\nProof. We may suppose no $W_i$ is contained in the union of the other subspaces. Let $u \\in W_i, \\quad u \\notin \\bigcup_{j \\neq i} W_j$ and $v \\notin W_i$.\n\nThen $(v+F u) \\cap W_i=\\varnothing$ and $(v+F u) \\cap W_j(j \\neq i)$ contains at most one vector since otherwise $W_j$ would contain $u$. Hence\n\n$$\n\n|v+F u|=|F| \\leq n-1 .\n\n$$\n\nCorollary: Avoidance lemma for vector spaces.\n\nLet $E$ be a vector space over an infinite field. If a subspace is contained in a finite union of subspaces, it is contained in one of them.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_7_2 {K V : Type*} [field K] [add_comm_group V]\n  [module K V] {\u03b9 : Type*} [fintype \u03b9] (\u03b3 : \u03b9 \u2192 submodule K V) :\n  (\u22c2 (i : \u03b9), (\u03b3 i : set V)) \u2260 \u22a4 :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_finite_union_of_proper_subspaces {k V : Type*} [field k]\n  [add_comm_group V] [vector_space k V] (hk : k.card \u2260 finset.card.fintype) :\n  \u00ac (\u2203 (s : set (submodule k V)), s.finite \u2227 \u2200 (t : submodule k V), t \u2208 s \u2192 t \u2260 \u22a4 \u2227 t \u2260 \u22a5 \u2227 t \u2260 \u22a4) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.exists_finset_card_le_mul {G : Type*} [group G]\n\t(H : subgroup G) [H.finite_index] {S : finset G} (hS : subgroup.closure \u2191S = \u22a4) :\n\t\u2203 (T : finset \u21a5H), T.card \u2264 H.index * S.card \u2227 subgroup.closure \u2191T = \u22a4\n\ntheorem exists_finite_card_le_of_finite_of_linear_independent_of_span\n\t{K : Type*} {V : Type u} [division_ring K] [add_comm_group V] [module K V]\n\t{s t : set V} (ht : t.finite) (hs : linear_independent K (\u03bb (x : \u21a5s), \u2191x))\n\t(hst : s \u2286 \u2191(submodule.span K t)) :\n\t\u2203 (h : s.finite), h.to_finset.card \u2264 ht.to_finset.card\n\ntheorem affine_subspace.nonempty_of_affine_span_eq_top (k V P : Type*) [ring k]\n\t[add_comm_group V] [module k V] [S : add_torsor V P] {s : set P}\n\t(h : affine_span k s = \u22a4) :\n\ts.nonempty\n\ntheorem affine_subspace.eq_univ_of_subsingleton_span_eq_top {k V P : Type*}\n\t[ring k] [add_comm_group V] [module k V] [S : add_torsor V P] {s : set P}\n\t(h\u2081 : s.subsingleton) (h\u2082 : affine_span k s = \u22a4) :\n\ts = set.univ\n\nThe following is the natural language theorem statement: \"Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_finite_union_of_proper_subspaces {V : Type*} [field F] [add_comm_group V]\n  [vector_space F V] (hF : nonempty F) :\n  \u00ac (\u2203 (s : finset (submodule F V)), s.card < \u221e \u2227 \u2200 (U : submodule F V), U \u2208 s \u2192 U \u2260 \u22a4 \u2227\n  \u2200 (U : submodule F V), U \u2260 \u22a4 \u2192 \u2203 (U' : submodule F V), U' \u2208 s \u2227 U \u2264 U') ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_6_4_2", "nl_statement": "Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple.", "nl_proof": "\\begin{proof}\n\n    If $|G|=n=p q$ then the only two Sylow subgroups are of order $p$ and $q$.\n\nFrom Sylow's third theorem we know that $n_p \\mid q$ which means that $n_p=1$ or $n_p=q$.\n\nIf $n_p=1$ then we are done (by a corollary of Sylow's theorem)\n\nIf $n_p=q$ then we have accounted for $q(p-1)=p q-q$ elements of $G$ and so there is only one group of order $q$ and again we are done.\n\n\\end{proof}", "formal_statement": "theorem exercise_6_4_2 {G : Type*} [group G] [fintype G] {p q : \u2115}\n  (hp : prime p) (hq : prime q) (hG : card G = p*q) :\n  is_simple_group G \u2192 false :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_simple_group_of_prime_card_of_prime_card {\u03b1 : Type u} [group \u03b1]\n  [fintype \u03b1] {p q : \u2115} [hp : fact (nat.prime p)] [hq : fact (nat.prime q)]\n  (h : fintype.card \u03b1 = p * q) :\n  \u00ac is_simple_group \u03b1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_p_group.nontrivial_iff_card {p : \u2115} {G : Type*} [group G]\n\t(hG : is_p_group p G) [hp : fact (nat.prime p)] [fintype G] :\n\tnontrivial G \u2194 \u2203 (n : \u2115) (H : n > 0), fintype.card G = p ^ n\n\ntheorem is_simple_group_of_prime_card {\u03b1 : Type u} [group \u03b1] [fintype \u03b1] {p : \u2115}\n\t[hp : fact (nat.prime p)] (h : fintype.card \u03b1 = p) :\n\tis_simple_group \u03b1\n\ntheorem is_simple_add_group_of_prime_card {\u03b1 : Type u} [add_group \u03b1] [fintype \u03b1]\n\t{p : \u2115} [hp : fact (nat.prime p)] (h : fintype.card \u03b1 = p) :\n\tis_simple_add_group \u03b1\n\ntheorem is_p_group.coprime_card_of_ne {G : Type*} [group G] {G\u2082 : Type*}\n\t[group G\u2082] (p\u2081 p\u2082 : \u2115) [hp\u2081 : fact (nat.prime p\u2081)] [hp\u2082 : fact (nat.prime p\u2082)]\n\t(hne : p\u2081 \u2260 p\u2082) (H\u2081 : subgroup G) (H\u2082 : subgroup G\u2082) [fintype \u21a5H\u2081]\n\t[fintype \u21a5H\u2082] (hH\u2081 : is_p_group p\u2081 \u21a5H\u2081) (hH\u2082 : is_p_group p\u2082 \u21a5H\u2082) :\n\t(fintype.card \u21a5H\u2081).coprime (fintype.card \u21a5H\u2082)\n\nThe following is the natural language theorem statement: \"Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_simple_of_card_eq_mul_prime {G : Type*} [group G] [fintype G]\n  {p q : \u2115} (hp : nat.prime p) (hq : nat.prime q) (h : fintype.card G = p * q) :\n  \u00acsimple_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_6_4_12", "nl_statement": "Prove that no group of order 224 is simple.", "nl_proof": "\\begin{proof}\n\n    The following proves there must exist a normal Sylow 2 -subgroup of order 32 ,\n\nSuppose there are $n_2=7$ Sylow 2 -subgroups in $G$. Making $G$ act on the set of these Sylow subgroups by conjugation (Mitt wrote about this but on the set of the other Sylow subgroups, which gives no contradiction), we get a homomorphism $G \\rightarrow S_7$ which must be injective if $G$ is simple (why?).\n\n\n\nBut this cannot be since then we would embed $G$ into $S_7$, which is impossible since $|G| \\nmid 7 !=\\left|S_7\\right|$ (why?)\n\n\\end{proof}", "formal_statement": "theorem exercise_6_4_12 {G : Type*} [group G] [fintype G]\n  (hG : card G = 224) :\n  is_simple_group G \u2192 false :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_simple_of_card_eq_224 {G : Type*} [group G] [fintype G]\n  (hG : fintype.card G = 224) : \u00ac simple_group G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_subgroup.eq_bot_of_card_eq {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_eq {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem add_subgroup.eq_bot_of_card_le {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_le {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\nThe following is the natural language theorem statement: \"Prove that no group of order 224 is simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_simple_of_card_eq_224 {G : Type*} [group G] (hG : card G = 224) :\n  \u00ac simple_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that no group of order 224 is simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_10_1_13", "nl_statement": "An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.", "nl_proof": "\\begin{proof}\n\n    If $x^n=0$, then\n\n$$\n\n(1+x)\\left(\\sum_{k=0}^{n-1}(-1)^k x^k\\right)=1+(-1)^{n-1} x^n=1 .\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_10_1_13 {R : Type*} [ring R] {x : R}\n  (hx : is_nilpotent x) : is_unit (1 + x) :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_unit_of_nilpotent {R : Type*} [comm_ring R] {x : R} (hx : \u2203 (n : \u2115), x ^ n = 0) :\n  is_unit (1 + x) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_unit_of_pow_eq_one {M : Type u} [monoid M] {x : M} {n : \u2115}\n\t(hx : x ^ n = 1) (hn : n \u2260 0) :\n\tis_unit x\n\ntheorem is_unit.mk0 {G\u2080 : Type*} [group_with_zero G\u2080] (x : G\u2080) (hx : x \u2260 0) :\n\tis_unit x\n\ntheorem discrete_valuation_ring.eq_unit_mul_pow_irreducible {R : Type*}\n\t[comm_ring R] [is_domain R] [discrete_valuation_ring R] {x : R} (hx : x \u2260 0)\n\t{\u03d6 : R} (hirr : irreducible \u03d6) :\n\t\u2203 (n : \u2115) (u : R\u02e3), x = \u2191u * \u03d6 ^ n\n\ntheorem is_add_unit_of_nsmul_eq_zero {M : Type u} [add_monoid M] {x : M} {n : \u2115}\n\t(hx : n \u2022 x = 0) (hn : n \u2260 0) :\n\tis_add_unit x\n\nThe following is the natural language theorem statement: \"An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_unit_of_nilpotent {R : Type*} [ring R] (x : R) (hx : \u2203 n : \u2115, x ^ n = 0) :\n  is_unit (1 + x) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_10_6_7", "nl_statement": "Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer.", "nl_proof": "\\begin{proof}\n\n    Let $I$ be some nonzero ideal. Then there exists some $z \\in \\mathbb{Z}[i], z \\neq 0$ such that $z \\in I$. We know that $z=a+b i$, for some $a, b \\in \\mathbb{Z}$. We consider three cases:\n\n1. If $b=0$, then $z=a$, so $z \\in \\mathbb{Z} \\cap I$, and $z \\neq 0$, so the statement of the exercise holds.\n\n2. If $a=0$, then $z=i b$. Since $z \\neq 0$, we conclude that $b \\neq 0$. Since $I$ is an ideal in $\\mathbb{Z}[i]$, and $i \\in \\mathbb{Z}[i]$, we conclude that $i z \\in I$. Furthermore, $i z=-b \\in \\mathbb{Z}$. Thus, $i z$ is a nonzero integer which is in $I$.\n\n3. Let $a \\neq 0$ and $b \\neq 0$. Since $I$ is an ideal and $z \\in I$, we conclude that $z^2 \\in I$; that is,\n\n$$\n\n(a+b i)^2=a^2-b^2+2 a b i \\in I\n\n$$\n\nFurthermore, since $-2 a \\in \\mathbb{Z}[i]$, and $z \\in I$ and $I$ is an ideal, $-2 a z \\in I$; that is,\n\n$$\n\n-2 a z=-2 a(a+b i)=-2 a^2-2 a b i \\in I\n\n$$\n\nSince $I$ is closed under addition,\n\n$$\n\n\\left(a^2-b^2+2 a b i\\right)+\\left(-2 a^2-2 a b i\\right) \\in I \\Longrightarrow-a^2-b^2 \\in I\n\n$$\n\nNotice that $-a^2-b^2 \\neq 0$ since $a^2>0$ and $b^2>0$, so $-a^2-b^2<0$. Furthermore, it is an integer. Thus, we have found a nonzero integer in $I$.\n\n\\end{proof}", "formal_statement": "theorem exercise_10_6_7 {I : ideal gaussian_int}\n  (hI : I \u2260 \u22a5) : \u2203 (z : I), z \u2260 0 \u2227 (z : gaussian_int).im = 0 :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_ne_zero_mem_is_integer {R : Type*} [comm_ring R]\n  {K : Type*} [field K] [algebra R K] [is_fraction_ring R K]\n  {I : fractional_ideal (non_zero_divisors R) K} [nontrivial R] (hI : I \u2260 0) :\n  \u2203 (x : R) (H : x \u2260 0), \u21d1(algebra_map R K) x \u2208 I ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem fractional_ideal.coe_ideal_ne_zero {R : Type*} [comm_ring R] {K : Type*}\n\t[field K] [algebra R K] [is_fraction_ring R K] {I : ideal R} (hI : I \u2260 \u22a5) :\n\t\u2191I \u2260 0\n\ntheorem fractional_ideal.exists_ne_zero_mem_is_integer {R : Type*} [comm_ring R]\n\t{K : Type*} [field K] [algebra R K] [is_fraction_ring R K]\n\t{I : fractional_ideal (non_zero_divisors R) K} [nontrivial R] (hI : I \u2260 0) :\n\t\u2203 (x : R) (H : x \u2260 0), \u21d1(algebra_map R K) x \u2208 I\n\ntheorem ideal.zero_ne_one_of_proper {\u03b1 : Type u} [semiring \u03b1] {I : ideal \u03b1}\n\t(h : I \u2260 \u22a4) :\n\t0 \u2260 1\n\ntheorem fractional_ideal.ne_zero_of_mul_eq_one {R\u2081 : Type*} [comm_ring R\u2081]\n\t{K : Type*} [field K] [algebra R\u2081 K]\n\t(I J : fractional_ideal (non_zero_divisors R\u2081) K) (h : I * J = 1) :\n\tI \u2260 0\n\nThe following is the natural language theorem statement: \"Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_nonzero_int_of_nonzero_ideal {R : Type*} [integral_domain R]\n  [algebra \u2124 R] (I : ideal R) (hI : I \u2260 \u22a5) :\n  \u2203 (z : \u2124), z \u2260 0 \u2227 z \u2208 I ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_10_4_7a", "nl_statement": "Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$.", "nl_proof": "\\begin{proof}\n\n    We have seen that $IJ \\subset I \\cap J$, so it remains to show that $I \\cap J \\subset IJ$.  Since $I+J = (1)$, there are elements $i \\in I$ and $j \\in J$ such that $i+j = 1$.  Let $k \\in I \\cap J$, and multiply $i+j=1$ through by $k$ to get $ki+kj = k$.  Write this more suggestively as\n\n\\[ k = ik+kj. \\]\n\nThe first term is in $IJ$ because $k \\in J$, and the second term is in $IJ$ because $k \\in I$, so $k \\in IJ$ as desired.\n\n\\end{proof}", "formal_statement": "theorem exercise_10_4_7a {R : Type*} [comm_ring R] [no_zero_divisors R]\n  (I J : ideal R) (hIJ : I + J = \u22a4) : I * J = I \u2293 J :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " ideal.mul_eq_inf_of_coprime {R : Type u} [comm_semiring R]\n  {I J : ideal R} (h : I \u2294 J = \u22a4) :\n  I * J = I \u2293 J ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem ideal.mul_eq_inf_of_coprime {R : Type u} [comm_semiring R]\n\t{I J : ideal R} (h : I \u2294 J = \u22a4) :\n\tI * J = I \u2293 J\n\ntheorem ideal.mul_sup_eq_of_coprime_right {R : Type u} [comm_semiring R]\n\t{I J K : ideal R} (h : K \u2294 J = \u22a4) :\n\tI * K \u2294 J = I \u2294 J\n\ntheorem ideal.mul_sup_eq_of_coprime_left {R : Type u} [comm_semiring R]\n\t{I J K : ideal R} (h : I \u2294 J = \u22a4) :\n\tI * K \u2294 J = K \u2294 J\n\ntheorem ideal.sup_mul_eq_of_coprime_right {R : Type u} [comm_semiring R]\n\t{I J K : ideal R} (h : I \u2294 K = \u22a4) :\n\tI \u2294 J * K = I \u2294 J\n\nThe following is the natural language theorem statement: \"Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " ideal.mul_eq_inter_of_sum_eq_univ {R : Type*} [comm_ring R] \n  {I J : ideal R} (h : I + J = \u22a4) : I * J = I \u2229 J ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_11_2_13", "nl_statement": "If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.", "nl_proof": "\\begin{proof}\n\n    Suppose $a|b$ in $\\mathbb{Z}[i]$ and $a,b\\in\\mathbb{Z}$. Then $a(x+yi)=b$ for $x,y\\in\\mathbb{Z}$. Expanding this we get $ax+ayi=b$, and equating imaginary parts gives us $ay=0$, implying $y=0$. \n\n\\end{proof}", "formal_statement": "theorem exercise_11_2_13 (a b : \u2124) :\n  (of_int a : gaussian_int) \u2223 of_int b \u2192 a \u2223 b :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " int.dvd_div_of_mul_dvd {a b c : \u2124} (h : a * b \u2223 c) :\n\tb \u2223 c / a ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.dvd_div_of_mul_dvd {a b c : \u2124} (h : a * b \u2223 c) :\n\tb \u2223 c / a\n\ntheorem nat.dvd_div_of_mul_dvd {a b c : \u2115} (h : a * b \u2223 c) :\n\tb \u2223 c / a\n\ntheorem div_eq_of_eq_mul' {G : Type*} [comm_group G] {a b c : G} (h : a = b * c) :\n\ta / b = c\n\ntheorem div_eq_of_eq_mul'' {G : Type*} [group G] {a b c : G} (h : a = c * b) :\n\ta / b = c\n\nThe following is the natural language theorem statement: \"If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " divides_of_Gauss_int_divides {a b : \u2124} (h : a \u2223\u209a b) : a \u2223 b ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_11_4_6a", "nl_statement": "Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$.", "nl_proof": "\\begin{proof}\n\n    If $x^2+x+1$ were reducible in $\\mathbb{F}_2$, its factors must be linear. But we neither have that $0^2+0+1=$ nor $1^2+1+1=0$, therefore $x^2+x+1$ is irreducible.  \n\n\\end{proof}", "formal_statement": "theorem exercise_11_4_6a {F : Type*} [field F] [fintype F] (hF : card F = 7) :\n  irreducible (X ^ 2 + 1 : polynomial F) :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_of_degree_eq_one_of_monic {R : Type u} [field R]\n  {p : polynomial R} (hp1 : p.degree = 1) (hm : p.monic) :\n  irreducible p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem polynomial.irreducible_of_degree_eq_one {R : Type u} [field R]\n\t{p : polynomial R} (hp1 : p.degree = 1) :\n\tirreducible p\n\ntheorem polynomial.monic.irreducible_of_degree_eq_one {R : Type u} [comm_ring R]\n\t[is_domain R] {p : polynomial R} (hp1 : p.degree = 1) (hm : p.monic) :\n\tirreducible p\n\ntheorem polynomial.of_irreducible_expand {R : Type u} [comm_ring R]\n\t[is_domain R] {p : \u2115} (hp : p \u2260 0) {f : polynomial R}\n\t(hf : irreducible (\u21d1(polynomial.expand R p) f)) :\n\tirreducible f\n\ntheorem polynomial.monic.irreducible_iff_nat_degree' {R : Type u}\n\t[comm_semiring R] [no_zero_divisors R] {p : polynomial R} (hp : p.monic) :\n\tirreducible p \u2194 p \u2260 1 \u2227 \u2200 (f g : polynomial R), f.monic \u2192 g.monic \u2192 f * g = p \u2192 g.nat_degree \u2209 finset.Ioc 0 (p.nat_degree / 2)\n\nThe following is the natural language theorem statement: \"Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_of_degree_two_of_fintype_two {R : Type*} [comm_ring R]\n  [fintype R] (h : fintype.card R = 2) (p : polynomial R) (hp : p.degree = 2) :\n  irreducible p ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_11_4_6c", "nl_statement": "Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$.", "nl_proof": "\\begin{proof}\n\n    If $p(x) = x^3-9$ were reducible, it would have a linear factor, since it either has a linear factor and a quadratic factor or three linear factors. We can then verify by brute force that $p(x)\\neq 0$ for $x \\in \\mathbb{F}_31$. \n\n\\end{proof}", "formal_statement": "theorem exercise_11_4_6c : irreducible (X^3 - 9 : polynomial (zmod 31)) :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_X_sub_C {R : Type u} [comm_ring R] [is_domain R]\n  (r : R) :\n  irreducible (polynomial.X - \u21d1polynomial.C r) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem polynomial.not_irreducible_C {R : Type u} [field R] (x : R) :\n\t\u00acirreducible (\u21d1polynomial.C x)\n\ntheorem polynomial.cyclotomic_three (R : Type*) [ring R] :\n\tpolynomial.cyclotomic 3 R = polynomial.X ^ 2 + polynomial.X + 1\n\ntheorem polynomial.irreducible_X_sub_C {R : Type u} [comm_ring R] [is_domain R]\n\t(r : R) :\n\tirreducible (polynomial.X - \u21d1polynomial.C r)\n\ntheorem polynomial.irreducible_X {R : Type u} [comm_ring R] [is_domain R] :\n\tirreducible polynomial.X\n\nThe following is the natural language theorem statement: \"Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_of_degree_three_of_field_of_prime_order_31 (x : \u2124/31) :\n  irreducible (polynomial.C (x^3 - 9)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_11_13_3", "nl_statement": "Prove that there are infinitely many primes congruent to $-1$ (modulo $4$).", "nl_proof": "\\begin{proof}\n\n    First we show a lemma: if $a \\equiv 3(\\bmod 4)$ then there exists a prime $p$ such that $p \\mid a$ and $p \\equiv 3(\\bmod 4)$.\n\n\n\n    Clearly, all primes dividing $a$ are odd. Suppose all of them would be $\\equiv 1(\\bmod 4)$. Then their product would also be $a \\equiv 1(\\bmod 4)$, which is a contradiction.\n\n\n\nTo prove the main claim, suppose that $p_1, \\ldots, p_n$ would be all such primes. (In particular, we have $p_1=3$.) Consider $a=4 p_2 \\cdots p_n+3$. (Or you can take $a=4 p_2 \\cdots p_n-1$.) Show that $p_i \\nmid a$ for $i=1, \\ldots, n$. (The case $3 \\nmid a$ is solved differently than the other primes - this is the reason for omitting $p_1$ in the definition of $a$.) Then use the above lemma to get a contradiction.\n\n\\end{proof}", "formal_statement": "theorem exercise_11_13_3 (N : \u2115):\n  \u2203 p \u2265 N, nat.prime p \u2227 p + 1 \u2261 0 [MOD 4] :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_infinitely_many_primes_congr_neg_one_mod_four :\n  \u2203 (p : \u2115), nat.prime p \u2227 p % 4 = 3 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem zmod.mod_four_ne_three_of_sq_eq_neg_one {p : \u2115} [fact (nat.prime p)]\n\t{y : zmod p} (hy : y ^ 2 = -1) :\n\tp % 4 \u2260 3\n\ntheorem zmod.mod_four_ne_three_of_sq_eq_neg_sq {p : \u2115} [fact (nat.prime p)]\n\t{x y : zmod p} (hx : x \u2260 0) (hxy : x ^ 2 = -y ^ 2) :\n\tp % 4 \u2260 3\n\ntheorem zmod.exists_sq_eq_neg_one_iff {p : \u2115} [fact (nat.prime p)] :\n\tis_square (-1) \u2194 p % 4 \u2260 3\n\ntheorem char_p.neg_one_ne_one (R : Type u) [ring R] (p : \u2115) [char_p R p]\n\t[fact (2 < p)] :\n\t-1 \u2260 1\n\nThe following is the natural language theorem statement: \"Prove that there are infinitely many primes congruent to $-1$ (modulo $4$).\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_infinitely_many_primes_congr_neg_one_mod_four :\n  \u2203 (p : \u2115), nat.prime p \u2227 p \u2261 -1 [MOD 4] ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that there are infinitely many primes congruent to $-1$ (modulo $4$).\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Artin|exercise_13_6_10", "nl_statement": "Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$.", "nl_proof": "\\begin{proof}\n\n    Since we are working with a finite field with $q$ elements, anyone of them is a root of the following polynomial\n\n$$\n\nx^q-x=0 .\n\n$$\n\nIn particular if we rule out the 0 element, any $a_i \\neq 0$ is a root of\n\n$$\n\nx^{q-1}-1=0 .\n\n$$\n\nThis polynomial splits completely in $\\mathbb{F}_q$ so we find\n\n$$\n\n\\left(x-a_1\\right) \\cdots\\left(x-a_{q-1}\\right)=0\n\n$$\n\nin particular\n\n$$\n\nx^{q-1}-1=\\left(x-a_1\\right) \\cdots\\left(x-a_{q-1}\\right)\n\n$$\n\nThus $a_1 \\cdots a_{q-1}=-1$.\n\n\\end{proof}", "formal_statement": "theorem exercise_13_6_10 {K : Type*} [field K] [fintype K\u02e3] :\n  \u220f (x : K\u02e3), x = -1 :=", "src_header": "import .common \n\nopen function fintype subgroup ideal polynomial submodule zsqrtd char_p\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " prod_nonzero_eq_neg_one {K : Type*} [fintype K] [field K]\n  (hK : \u2200 (x : K), x \u2260 0) :\n  \u220f (x : K), x \u2260 0 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem neg_div_self {K : Type*} [division_ring K] {a : K} (h : a \u2260 0) :\n\t-a / a = -1\n\ntheorem div_neg_self {K : Type*} [division_ring K] {a : K} (h : a \u2260 0) :\n\ta / -a = -1\n\ntheorem fractional_ideal.coe_ideal_ne_zero {R : Type*} [comm_ring R] {K : Type*}\n\t[field K] [algebra R K] [is_fraction_ring R K] {I : ideal R} (hI : I \u2260 \u22a5) :\n\t\u2191I \u2260 0\n\ntheorem ratfunc.num_ne_zero {K : Type u} [hfield : field K] {x : ratfunc K}\n\t(hx : x \u2260 0) :\n\tx.num \u2260 0\n\nThe following is the natural language theorem statement: \"Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " prod_nonzero_eq_neg_one {K : Type*} [field K] [fintype K] [decidable_eq K]\n  (hK : \u00ac(\u2203 (x : K), x \u2260 0 \u2227 x \u2260 1)) :\n  \u220f (x : K), x \u2260 0 \u2192 x = -1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Putnam|exercise_2018_a5", "nl_statement": "Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$.", "nl_proof": "\\begin{proof}\n\n    Call a function $f\\colon \\mathbb{R} \\to \\mathbb{R}$ \\textit{ultraconvex} if $f$ is infinitely differentiable and $f^{(n)}(x) \\geq 0$ for all $n \\geq 0$ and all $x \\in \\mathbb{R}$, where $f^{(0)}(x) = f(x)$;\n\nnote that if $f$ is ultraconvex, then so is $f'$.\n\nDefine the set\n\n\\[\n\nS = \\{ f :\\thinspace \\mathbb{R} \\to \\mathbb{R} \\,|\\,f \\text{ ultraconvex and } f(0)=0\\}.\n\n\\]\n\nFor $f \\in S$, we must have $f(x) = 0$ for all $x < 0$: if $f(x_0) > 0$ for some $x_0 < 0$, then\n\nby the mean value theorem there exists $x \\in (0,x_0)$ for which $f'(x) = \\frac{f(x_0)}{x_0} < 0$.\n\nIn particular, $f'(0) = 0$, so $f' \\in S$ also.\n\n\n\nWe show by induction that for all $n \\geq 0$,\n\n\\[\n\nf(x) \\leq \\frac{f^{(n)}(1)}{n!} x^n \\qquad (f \\in S, x \\in [0,1]).\n\n\\]\n\nWe induct with base case $n=0$, which holds because any $f \\in S$ is nondecreasing. Given the claim for $n=m$,\n\nwe apply the induction hypothesis to $f' \\in S$ to see that\n\n\\[\n\nf'(t) \\leq \\frac{f^{(n+1)}(1)}{n!} t^n \\qquad (t \\in [0,1]),\n\n\\]\n\nthen integrate both sides from $0$ to $x$ to conclude.\n\n\n\nNow for $f \\in S$, we have $0 \\leq f(1) \\leq \\frac{f^{(n)}(1)}{n!}$ for all $n \\geq 0$. \n\nOn the other hand, by Taylor's theorem with remainder,\n\n\\[\n\nf(x) \\geq \\sum_{k=0}^n \\frac{f^{(k)}(1)}{k!}(x-1)^k \\qquad (x \\geq 1).\n\n\\]\n\nApplying this with $x=2$, we obtain $f(2) \\geq \\sum_{k=0}^n \\frac{f^{(k)}(1)}{k!}$ for all $n$;\n\nthis implies that $\\lim_{n\\to\\infty}  \\frac{f^{(n)}(1)}{n!} = 0$.\n\nSince $f(1) \\leq \\frac{f^{(n)}(1)}{n!}$, we must have $f(1) = 0$.\n\n\n\nFor $f \\in S$, we proved earlier that $f(x) = 0$ for all $x\\leq 0$, as well as for $x=1$. Since\n\nthe function $g(x) = f(cx)$ is also ultraconvex for $c>0$, we also have $f(x) = 0$ for all $x>0$;\n\nhence $f$ is identically zero.\n\n\n\nTo sum up, if $f\\colon \\mathbb{R} \\to \\mathbb{R}$ is infinitely differentiable, $f(0)=0$, and $f(1) = 1$,\n\nthen $f$ cannot be ultraconvex. This implies the desired result.\n\n\\end{proof}", "formal_statement": "theorem exercise_2018_a5 (f : \u211d \u2192 \u211d) (hf : cont_diff \u211d \u22a4 f)\n  (hf0 : f 0 = 0) (hf1 : f 1 = 1) (hf2 : \u2200 x, f x \u2265 0) :\n  \u2203 (n : \u2115) (x : \u211d), iterated_deriv n f x = 0 :=", "src_header": "import .common \n\nopen real topological_space filter polynomial\nopen_locale topology big_operators complex_conjugate filter ennreal \n\n", "gpt_formal_statement": " exists_n_x_deriv_lt_zero {f : \u211d \u2192 \u211d} (hf : \u2200 x, f x \u2265 0)\n  (hf0 : f 0 = 0) (hf1 : f 1 = 1) (hf_inf_diff : \u2200 n, \u2203 f', cont_diff_at \u211d n f') :\n  \u2203 (n : \u2115) (x : \u211d), deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (deriv (", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem has_deriv_within_at.liminf_right_slope_le {f : \u211d \u2192 \u211d} {f' x r : \u211d}\n\t(hf : has_deriv_within_at f f' (set.Ici x) x) (hr : f' < r) :\n\t\u2203\u1da0 (z : \u211d) in nhds_within x (set.Ioi x), slope f x z < r\n\ntheorem cont_diff_within_at.norm {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] [normed_space \u211d E] {G : Type*}\n\t[normed_add_comm_group G] [normed_space \u211d G] {f : G \u2192 E} {s : set G} {x : G}\n\t{n : \u2115\u221e} (hf : cont_diff_within_at \u211d n f s x) (h0 : f x \u2260 0) :\n\tcont_diff_within_at \u211d n (\u03bb (y : G), \u2016f y\u2016) s x\n\ntheorem has_deriv_within_at.limsup_slope_le' {f : \u211d \u2192 \u211d} {f' : \u211d} {s : set \u211d}\n\t{x r : \u211d} (hf : has_deriv_within_at f f' s x) (hs : x \u2209 s) (hr : f' < r) :\n\t\u2200\u1da0 (z : \u211d) in nhds_within x s, slope f x z < r\n\ntheorem cont_diff_at.has_strict_deriv_at {n : \u2115\u221e} {\ud835\udd42 : Type*} [is_R_or_C \ud835\udd42]\n\t{F' : Type*} [normed_add_comm_group F'] [normed_space \ud835\udd42 F'] {f : \ud835\udd42 \u2192 F'}\n\t{x : \ud835\udd42} (hf : cont_diff_at \ud835\udd42 n f x) (hn : 1 \u2264 n) :\n\thas_strict_deriv_at f (deriv f x) x\n\nThe following is the natural language theorem statement: \"Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_n_x_of_infinitely_differentiable_nonneg_of_f_0_0_f_1_1 \n  {f : \u211d \u2192 \u211d} (hf : \u2200 n : \u2115, differentiable_at \u211d f n) \n  (hf_nonneg : \u2200 x : \u211d, 0 \u2264 f x) (hf_0_0 : f 0 = 0) (hf_1_1 : f 1 = 1) :\n  \u2203 (n : \u2115) (x : \u211d), (derivative_within_at \u211d f n x (Icc 0 1)).comp_continuous_within_at \n  (Icc 0 1) x < 0 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Putnam|exercise_2018_b4", "nl_statement": "Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic.", "nl_proof": "\\begin{proof}\n\n    We first rule out the case $|a|>1$. In this case, we prove that $|x_{n+1}| \\geq |x_n|$ for all $n$, meaning that we cannot have $x_n = 0$. We proceed by induction; the claim is true for $n=0,1$ by hypothesis. To prove the claim for  $n \\geq 2$, write\n\n\\begin{align*}\n\n|x_{n+1}| &= |2x_nx_{n-1}-x_{n-2}| \\\\\n\n&\\geq 2|x_n||x_{n-1}|-|x_{n-2}| \\\\\n\n&\\geq |x_n|(2|x_{n-1}|-1) \\geq |x_n|,\n\n\\end{align*} \n\nwhere the last step follows from $|x_{n-1}| \\geq |x_{n-2}| \\geq \\cdots \\geq |x_0| = 1$.\n\n\n\nWe may thus assume hereafter that $|a|\\leq 1$. We can then write $a = \\cos b$ for some $b \\in [0,\\pi]$. \n\nLet $\\{F_n\\}$ be the Fibonacci sequence, defined as usual by $F_1=F_2=1$ and $F_{n+1}=F_n+F_{n-1}$. We show by induction that\n\n\\[\n\nx_n = \\cos(F_n b) \\qquad (n \\geq 0).\n\n\\]\n\nIndeed, this is true for $n=0,1,2$; given that it is true for $n \\leq m$, then\n\n\\begin{align*}\n\n2x_mx_{m-1}&=2\\cos(F_mb)\\cos(F_{m-1}b) \\\\\n\n&= \\cos((F_m-F_{m-1})b)+\\cos((F_m+F_{m-1})b) \\\\\n\n&= \\cos(F_{m-2}b)+\\cos(F_{m+1}b)\n\n\\end{align*}\n\nand so \n\n$x_{m+1} = 2x_mx_{m-1}-x_{m-2} = \\cos(F_{m+1}b)$. This completes the induction.\n\n\n\n\n\nSince $x_n = \\cos(F_n b)$, if $x_n=0$ for some $n$ then $F_n b = \\frac{k}{2} \\pi$ for some odd integer $k$. In particular, we can write $b = \\frac{c}{d}(2\\pi)$ where $c = k$ and $d = 4F_n$ are integers.\n\n\n\n\n\nLet $x_n$ denote the pair $(F_n,F_{n+1})$, where each entry in this pair is viewed as an element of $\\mathbb{Z}/d\\mathbb{Z}$. Since there are only finitely many possibilities for $x_n$, there must be some $n_2>n_1$ such that $x_{n_1}=x_{n_2}$. Now $x_n$ uniquely determines both $x_{n+1}$ and $x_{n-1}$, and it follows that the sequence $\\{x_n\\}$ is periodic: for $\\ell = n_2-n_1$, $x_{n+\\ell} = x_n$ for all $n \\geq 0$. In particular, $F_{n+\\ell} \\equiv F_n \\pmod{d}$ for all $n$. But then $\\frac{F_{n+\\ell}c}{d}-\\frac{F_n c}{d}$ is an integer, and so\n\n\\begin{align*}\n\nx_{n+\\ell} &= \\cos\\left(\\frac{F_{n+\\ell}c}{d}(2\\pi)\\right)\\\\\n\n& = \\cos\\left(\\frac{F_n c}{d}(2\\pi)\\right) = x_n\n\n\\end{align*}\n\nfor all $n$. Thus the sequence $\\{x_n\\}$ is periodic, as desired.\n\n\\end{proof}", "formal_statement": "theorem exercise_2018_b4 (a : \u211d) (x : \u2115 \u2192 \u211d) (hx0 : x 0 = a)\n  (hx1 : x 1 = a) \n  (hxn : \u2200 n : \u2115, n \u2265 2 \u2192 x (n+1) = 2*(x n)*(x (n-1)) - x (n-2))\n  (h : \u2203 n, x n = 0) : \n  \u2203 c, function.periodic x c :=", "src_header": "import .common \n\nopen real topological_space filter polynomial\nopen_locale topology big_operators complex_conjugate filter ennreal \n\n", "gpt_formal_statement": " periodic_of_zero_of_nonzero {a : \u211d} (h : a \u2260 0) (h\u2080 : a \u2260 1)\n  (h\u2081 : a \u2260 -1) (h\u2082 : a \u2260 2) (h\u2083 : a \u2260 -2) (h\u2084 : a \u2260 3) (h\u2085 : a \u2260 -3)\n  (h\u2086 : a \u2260 4) (h\u2087 : a \u2260 -4) (h\u2088 : a \u2260 5) (h\u2089 : a \u2260 -5) (h\u2081\u2080 : a \u2260 6)\n  (h\u2081\u2081 : a \u2260 -6) (h\u2081\u2082 : a \u2260 7) (h\u2081\u2083 : a \u2260 -7) (h\u2081\u2084 : a \u2260 8) (h\u2081\u2085 : a \u2260 -8)\n  (h\u2081\u2086 : a \u2260 9) (h\u2081\u2087 : a \u2260 -9) (h\u2081\u2088 : a \u2260 10) (h\u2081\u2089 : a \u2260 -10) (h\u2082\u2080 : a \u2260 11)\n  (h\u2082\u2081 : a \u2260 -11) (h\u2082\u2082 : a \u2260 12) (h\u2082\u2083 : a \u2260 -12) (h\u2082\u2084 : a \u2260 13) (h\u2082\u2085 : a \u2260 -13)\n  (h\u2082\u2086 : a \u2260 14) (h", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.eq_coe_of_zero_le {a : \u2124} (h : 0 \u2264 a) :\n\t\u2203 (n : \u2115), a = \u2191n\n\ntheorem nat.nth_zero_of_zero (p : \u2115 \u2192 Prop) (h : p 0) :\n\tnat.nth p 0 = 0\n\ntheorem nat.nth_zero_of_nth_zero (p : \u2115 \u2192 Prop) (h\u2080 : \u00acp 0) {a b : \u2115}\n\t(hab : a \u2264 b) (ha : nat.nth p a = 0) :\n\tnat.nth p b = 0\n\ntheorem nat.gcd_a_zero_right {s : \u2115} (h : s \u2260 0) :\n\ts.gcd_a 0 = 1\n\nThe following is the natural language theorem statement: \"Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " periodic_of_zero_of_recurrence_sequence {a : \u211d} (h : \u2203 n : \u2115, a ^ n = 0) :\n  \u2203 (p : \u2115), \u2200 (n : \u2115), a ^ n = a ^ (n % p) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Putnam|exercise_2014_a5", "nl_statement": "Let", "nl_proof": "", "formal_statement": "theorem exercise_2014_a5 (P : \u2115 \u2192 polynomial \u2124) \n  (hP : \u2200 n, P n = \u2211 (i : fin n), (n+1) * X ^ n) : \n  \u2200 (j k : \u2115), j \u2260 k \u2192 is_coprime (P j) (P k) :=", "src_header": "import .common \n\nopen real topological_space filter polynomial\nopen_locale topology big_operators complex_conjugate filter ennreal \n\n", "gpt_formal_statement": " exists_of_exists_unique {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop}\n  (h : \u2203! (x : \u03b1), p x) :\n  \u2203 (x : \u03b1), p x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem exists_of_exists_unique {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop}\n\t(h : \u2203! (x : \u03b1), p x) :\n\t\u2203 (x : \u03b1), p x\n\ntheorem exists_of_bex {\u03b1 : Sort u_1} {p q : \u03b1 \u2192 Prop} :\n\t(\u2203 (x : \u03b1) (_x : p x), q x) \u2192 (\u2203 (x : \u03b1), q x)\n\ntheorem exists_unique.exists2 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Sort u_2}\n\t{q : \u03a0 (x : \u03b1), p x \u2192 Prop} (h : \u2203! (x : \u03b1) (hx : p x), q x hx) :\n\t\u2203 (x : \u03b1) (hx : p x), q x hx\n\ntheorem exists_imp_exists {\u03b1 : Sort u} {p q : \u03b1 \u2192 Prop}\n\t(h : \u2200 (a : \u03b1), p a \u2192 q a) (p_1 : \u2203 (a : \u03b1), p a) :\n\t\u2203 (a : \u03b1), q a\n\nThe following is the natural language theorem statement: \"Let\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_of_exists_of_forall_of_forall {\u03b1 : Type*} {p q : \u03b1 \u2192 Prop}\n  (h : \u2203 x, p x \u2227 q x) (h\u2081 : \u2200 x, p x \u2192 r x) (h\u2082 : \u2200 x, q x \u2192 s x) :\n  \u2203 x, r x \u2227 s x ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Putnam|exercise_2001_a5", "nl_statement": "Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$.", "nl_proof": "\\begin{proof}\n\n    Suppose $a^{n+1} - (a+1)^n = 2001$.\n\nNotice that $a^{n+1} + [(a+1)^n - 1]$ is a multiple of $a$; thus\n\n$a$ divides $2002 = 2 \\times 7 \\times 11 \\times 13$.\n\n\n\nSince $2001$ is divisible by 3, we must have $a \\equiv 1 \\pmod{3}$,\n\notherwise one of $a^{n+1}$ and $(a+1)^n$ is a multiple of 3 and the\n\nother is not, so their difference cannot be divisible by 3. Now\n\n$a^{n+1} \\equiv 1 \\pmod{3}$, so we must have $(a+1)^n \\equiv 1\n\n\\pmod{3}$, which forces $n$ to be even, and in particular at least 2.\n\n\n\nIf $a$ is even, then $a^{n+1} - (a+1)^n \\equiv -(a+1)^n \\pmod{4}$.\n\nSince $n$ is even, $-(a+1)^n \\equiv -1 \\pmod{4}$. Since $2001 \\equiv 1\n\n\\pmod{4}$, this is impossible. Thus $a$ is odd, and so must divide\n\n$1001 = 7 \\times 11 \\times 13$. Moreover, $a^{n+1} - (a+1)^n \\equiv a\n\n\\pmod{4}$, so $a \\equiv 1 \\pmod{4}$.\n\n\n\nOf the divisors of $7 \\times 11 \\times 13$, those congruent to 1 mod 3\n\nare precisely those not divisible by 11 (since 7 and 13 are both\n\ncongruent to 1 mod 3). Thus $a$ divides $7 \\times 13$. Now\n\n$a \\equiv 1 \\pmod{4}$ is only possible if $a$ divides $13$.\n\n\n\nWe cannot have $a=1$, since $1 - 2^n \\neq 2001$ for any $n$. Thus\n\nthe only possibility is $a = 13$. One easily checks that $a=13, n=2$ is a\n\nsolution; all that remains is to check that no other $n$ works. In fact,\n\nif $n > 2$, then $13^{n+1} \\equiv 2001 \\equiv 1 \\pmod{8}$.\n\nBut $13^{n+1} \\equiv 13 \\pmod{8}$ since $n$ is even, contradiction.\n\nThus $a=13, n=2$ is the unique solution.\n\n\n\nNote: once one has that $n$ is even, one can use that $2002\n\n=a^{n+1} + 1 - (a+1)^n$ is divisible by $a+1$ to rule out cases.\n\n\\end{proof}", "formal_statement": "theorem exercise_2001_a5 : \n  \u2203! a n : \u2115, a > 0 \u2227 n > 0 \u2227 a^(n+1) - (a+1)^n = 2001 :=", "src_header": "import .common \n\nopen real topological_space filter polynomial\nopen_locale topology big_operators complex_conjugate filter ennreal \n\n", "gpt_formal_statement": " exists_unique_a_n_2001 {a n : \u2115} :\n  a ^ (n + 1) - (a + 1) ^ n = 2001 \u2194 (\u2203 (a n : \u2115), a ^ (n + 1) - (a + 1) ^ n = 2001 \u2227 \u2200 (a' n' : \u2115), a ^ (n + 1) - (a + 1) ^ n = 2001 \u2192 a = a' \u2227 n = n') ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem fin.succ_succ_ne_one {n : \u2115} (a : fin n) :\n\ta.succ.succ \u2260 1\n\ntheorem multiplicity.finite_def {\u03b1 : Type*} [monoid \u03b1] {a b : \u03b1} :\n\tmultiplicity.finite a b \u2194 \u2203 (n : \u2115), \u00aca ^ (n + 1) \u2223 b\n\ntheorem nat.eq_two_pow_or_exists_odd_prime_and_dvd (n : \u2115) :\n\t(\u2203 (k : \u2115), n = 2 ^ k) \u2228 \u2203 (p : \u2115), nat.prime p \u2227 p \u2223 n \u2227 odd p\n\ntheorem pell.xy_succ_succ {a : \u2115} (a1 : 1 < a) (n : \u2115) :\n\tpell.xn a1 (n + 2) + pell.xn a1 n = 2 * a * pell.xn a1 (n + 1) \u2227 pell.yn a1 (n + 2) + pell.yn a1 n = 2 * a * pell.yn a1 (n + 1)\n\nThe following is the natural language theorem statement: \"Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_unique_a_n_of_a_n_plus_one_minus_a_plus_one_n_eq_2001 :\n  \u2203 (a n : \u2115), a ^ (n + 1) - (a + 1) ^ n = 2001 \u2227 \u2200 (a' n' : \u2115), a' ^ (n' + 1) - (a' + 1) ^ n' = 2001 \u2192 a = a' \u2227 n = n' ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Putnam|exercise_1999_b4", "nl_statement": "Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$.", "nl_proof": "\\begin{proof}    \n\n\\setcounter{equation}{0}\n\nWe make repeated use of the following fact: if $f$ is a differentiable function on all of\n\n$\\mathbb{R}$, $\\lim_{x \\to -\\infty} f(x) \\geq 0$, and $f'(x) > 0$ for all $x \\in \\mathbb{R}$, then\n\n$f(x) > 0$ for all $x \\in \\mathbb{R}$. (Proof: if $f(y) < 0$ for some $x$, then $f(x)< f(y)$ for all\n\n$x<y$ since $f'>0$, but then $\\lim_{x \\to -\\infty} f(x) \\leq f(y) < 0$.)\n\n\n\nFrom the inequality $f'''(x) \\leq f(x)$ we obtain\n\n\\[\n\nf'' f'''(x) \\leq f''(x) f(x) < f''(x) f(x) + f'(x)^2\n\n\\]\n\nsince $f'(x)$ is positive. Applying the fact to the difference between the right and left sides,\n\nwe get\n\n\\begin{equation}\n\n\\frac{1}{2} (f''(x))^2 < f(x) f'(x).\n\n\\end{equation}\n\n\n\nOn the other hand, since $f(x)$ and $f'''(x)$ are both positive for all $x$,\n\nwe have\n\n\\[\n\n2f'(x) f''(x) < 2f'(x)f''(x) + 2f(x) f'''(x).\n\n\\]\n\nApplying the fact to the difference between the sides yields\n\n\\begin{equation}\n\nf'(x)^2 \\leq 2f(x) f''(x).\n\n\\end{equation}\n\nCombining (1) and (2), we obtain\n\n\\begin{align*}\n\n\\frac{1}{2} \\left( \\frac{f'(x)^2}{2f(x)} \\right)^2\n\n&< \\frac{1}{2} (f''(x))^2 \\\\\n\n&< f(x) f'(x),\n\n\\end{align*}\n\nor $(f'(x))^3 < 8 f(x)^3$. We conclude $f'(x) < 2f(x)$, as desired.\n\n\\end{proof}", "formal_statement": "theorem exercise_1999_b4 (f : \u211d \u2192 \u211d) (hf: cont_diff \u211d 3 f) \n  (hf1 : \u2200 (n \u2264 3) (x : \u211d), iterated_deriv n f x > 0) \n  (hf2 : \u2200 x : \u211d, iterated_deriv 3 f x \u2264 f x) : \n  \u2200 x : \u211d, deriv f x < 2 * f x :=", "src_header": "import .common \n\nopen real topological_space filter polynomial\nopen_locale topology big_operators complex_conjugate filter ennreal \n\n", "gpt_formal_statement": " deriv_lt_two_mul_self {f : \u211d \u2192 \u211d} (hf : continuous f)\n  (hf' : differentiable \u211d f) (hf'' : differentiable \u211d (deriv f))\n  (hf''' : differentiable \u211d (deriv^[2] f))\n  (hf_pos : \u2200 (x : \u211d), 0 < f x) (hf'_pos : \u2200 (x : \u211d), 0 < deriv f x)\n  (hf''_pos : \u2200 (x : \u211d), 0 < deriv^[2] f x)\n  (hf'''_pos : \u2200 (x : \u211d), 0 < deriv^[3] f x)\n  (hf'''_le : \u2200 (x : \u211d), deriv^[3] f x \u2264 f x) :\n  \u2200 (x : \u211d), deriv f x < 2 * f x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem deriv_sqrt {f : \u211d \u2192 \u211d} {x : \u211d} (hf : differentiable_at \u211d f x)\n\t(hx : f x \u2260 0) :\n\tderiv (\u03bb (x : \u211d), real.sqrt (f x)) x = deriv f x / (2 * real.sqrt (f x))\n\ntheorem strict_convex_on_univ_of_deriv2_pos {f : \u211d \u2192 \u211d} (hf : continuous f)\n\t(hf'' : \u2200 (x : \u211d), 0 < deriv^[2] f x) :\n\tstrict_convex_on \u211d set.univ f\n\ntheorem concave_on_univ_of_deriv2_nonpos {f : \u211d \u2192 \u211d} (hf' : differentiable \u211d f)\n\t(hf'' : differentiable \u211d (deriv f))\n\t(hf''_nonpos : \u2200 (x : \u211d), deriv^[2] f x \u2264 0) :\n\tconcave_on \u211d set.univ f\n\ntheorem strict_concave_on_univ_of_deriv2_neg {f : \u211d \u2192 \u211d} (hf : continuous f)\n\t(hf'' : \u2200 (x : \u211d), deriv^[2] f x < 0) :\n\tstrict_concave_on \u211d set.univ f\n\nThe following is the natural language theorem statement: \"Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " deriv_lt_two_times_of_deriv_three_le_of_deriv_three_pos\n  {f : \u211d \u2192 \u211d} (hf : differentiable \u211d f) (hf' : differentiable \u211d f')\n  (hf'' : differentiable \u211d f'') (hf''' : differentiable \u211d f''')\n  (hf_pos : \u2200 x, 0 < f x) (hf'_pos : \u2200 x, 0 < f' x)\n  (hf''_pos : \u2200 x, 0 < f'' x) (hf'''_pos : \u2200 x, 0 < f''' x)\n  (hf'''_le : \u2200 x, f''' x \u2264 f x) :\n  \u2200 x, f' x < 2 * f x ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Putnam|exercise_1998_b6", "nl_statement": "Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer.", "nl_proof": "\\begin{proof}\n\n    We prove more generally that for any polynomial $P(z)$ with integer\n\ncoefficients which is not a perfect square, there exists a positive\n\ninteger $n$ such that $P(n)$ is not a perfect square. Of course it\n\nsuffices to assume $P(z)$ has no repeated factors, which is to say $P(z)$\n\nand its derivative $P'(z)$ are relatively prime.\n\n\n\nIn particular, if we carry out the Euclidean algorithm on $P(z)$ and $P'(z)$\n\nwithout dividing, we get an integer $D$ (the discriminant of $P$) such that\n\nthe greatest common divisor of $P(n)$ and $P'(n)$ divides $D$ for any $n$.\n\nNow there exist infinitely many primes $p$ such that $p$ divides $P(n)$ for\n\nsome $n$: if there were only finitely many, say, $p_1, \\dots, p_k$, then\n\nfor any $n$ divisible by $m = P(0) p_1 p_2 \\cdots p_k$, we have $P(n)\n\n\\equiv P(0) \\pmod{m}$, that is, $P(n)/P(0)$ is not divisible by $p_1,\n\n\\dots, p_k$, so must be $\\pm 1$, but then $P$ takes some value infinitely\n\nmany times, contradiction. In particular, we can choose some such $p$ not\n\ndividing $D$, and choose $n$ such that $p$ divides $P(n)$. Then $P(n+kp)\n\n\\equiv P(n) + kp P'(n) (\\mathrm{mod}\\,p)$\n\n(write out the Taylor series of the left side);\n\nin particular, since $p$ does not divide $P'(n)$, we can find some $k$\n\nsuch that $P(n+kp)$ is divisible by $p$ but not by $p^2$, and so\n\nis not a perfect square.\n\n\\end{proof}", "formal_statement": "theorem exercise_1998_b6 (a b c : \u2124) : \n  \u2203 n : \u2124, n > 0 \u2227 \u00ac \u2203 m : \u2124, sqrt (n^3 + a*n^2 + b*n + c) = m :=", "src_header": "import .common \n\nopen real topological_space filter polynomial\nopen_locale topology big_operators complex_conjugate filter ennreal \n\n", "gpt_formal_statement": " exists_n_sqrt_not_int {a b c : \u2124} :\n  \u2203 (n : \u2115), \u00ac(\u2203 (x : \u2124), (\u2191n ^ 3 + a * \u2191n ^ 2 + b * \u2191n + c) ^ 2 = x ^ 2) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.not_prime_of_int_mul {a b : \u2124} { : \u2115} (ha : 1 < a.nat_abs)\n\t(hb : 1 < b.nat_abs) (hc : a * b = \u2191c) :\n\t\u00acnat.prime c\n\ntheorem not_fermat_42 {a b c : \u2124} (ha : a \u2260 0) (hb : b \u2260 0) :\n\ta ^ 4 + b ^ 4 \u2260 c ^ 2\n\ntheorem zsqrtd.nonneg_cases {d : \u2115} {a : \u2124\u221a\u2191d} :\n\ta.nonneg \u2192 (\u2203 (x y : \u2115), a = {re := \u2191x, im := \u2191y} \u2228 a = {re := \u2191x, im := -\u2191y} \u2228 a = {re := -\u2191x, im := \u2191y})\n\ntheorem not_fermat_4 {a b c : \u2124} (ha : a \u2260 0) (hb : b \u2260 0) :\n\ta ^ 4 + b ^ 4 \u2260 c ^ 4\n\nThe following is the natural language theorem statement: \"Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_n_sqrt_not_int (a b c : \u2124) :\n  \u2203 (n : \u2115), \u00ac (\u2203 (z : \u2124), z ^ 3 + a * z ^ 2 + b * z + c = n ^ 2) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_1b", "nl_statement": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.", "nl_proof": "\\begin{proof}\n\n    If $r x$ were rational, then $x=\\frac{r x}{r}$ would also be rational.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1b\n(x : \u211d)\n(y : \u211a)\n(h : y \u2260 0)\n: ( irrational x ) -> irrational ( x * y ) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " irrational.rat_mul {x : \u211d} (h : irrational x) {q : \u211a} (hq : q \u2260 0) :\n\tirrational (\u2191q * x) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem irrational.rat_mul {x : \u211d} (h : irrational x) {q : \u211a} (hq : q \u2260 0) :\n\tirrational (\u2191q * x)\n\ntheorem irrational.mul_rat {x : \u211d} (h : irrational x) {q : \u211a} (hq : q \u2260 0) :\n\tirrational (x * \u2191q)\n\ntheorem irrational.rat_div {x : \u211d} (h : irrational x) {q : \u211a} (hq : q \u2260 0) :\n\tirrational (\u2191q / x)\n\ntheorem irrational.mul_nat {x : \u211d} (h : irrational x) {m : \u2115} (hm : m \u2260 0) :\n\tirrational (x * \u2191m)\n\nThe following is the natural language theorem statement: \"If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irrational_of_mul_irrational_of_rational_ne_zero {r x : \u211a}\n  (hr : r \u2260 0) (hx : \u00ac is_rat x) : \u00ac is_rat (r * x) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_4", "nl_statement": "Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.", "nl_proof": "\\begin{proof}\n\nSince $E$ is nonempty, there exists $x \\in E$. Then by definition of lower and upper bounds we have $\\alpha \\leq x \\leq \\beta$, and hence by property $i i$ in the definition of an ordering, we have $\\alpha<\\beta$ unless $\\alpha=x=\\beta$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_4\n(\u03b1 : Type*) [partial_order \u03b1]\n(s : set \u03b1)\n(x y : \u03b1)\n(h\u2080 : set.nonempty s)\n(h\u2081 : x \u2208 lower_bounds s)\n(h\u2082 : y \u2208 upper_bounds s)\n: x \u2264 y :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " le_of_forall_ge_of_dense {\u03b1 : Type u} [linear_order \u03b1]\n  [densely_ordered \u03b1] {a\u2081 a\u2082 : \u03b1} (h : \u2200 (a\u2083 : \u03b1), a\u2083 < a\u2081 \u2192 a\u2083 \u2264 a\u2082) :\n  a\u2081 \u2264 a\u2082 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem le_of_forall_ge_of_dense {\u03b1 : Type u} [linear_order \u03b1]\n\t[densely_ordered \u03b1] {a\u2081 a\u2082 : \u03b1} (h : \u2200 (a\u2083 : \u03b1), a\u2083 < a\u2081 \u2192 a\u2083 \u2264 a\u2082) :\n\ta\u2081 \u2264 a\u2082\n\ntheorem le_of_forall_sub_le {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1}\n\t(h : \u2200 (\u03b5 : \u03b1), \u03b5 > 0 \u2192 b - \u03b5 \u2264 a) :\n\tb \u2264 a\n\ntheorem lt_imp_lt_of_le_imp_le {\u03b1 : Type u} {\u03b2 : Type*} [linear_order \u03b1]\n\t[preorder \u03b2] {a b : \u03b1} {c d : \u03b2} (H : a \u2264 b \u2192 c \u2264 d) (h : d < c) :\n\tb < a\n\ntheorem has_le.le.le_or_le {\u03b1 : Type u} [linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b)\n\t( : \u03b1) :\n\ta \u2264 c \u2228 c \u2264 b\n\nThe following is the natural language theorem statement: \"Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " le_of_lower_bound_of_upper_bound {\u03b1 : Type*} [linear_order \u03b1]\n  {E : set \u03b1} (hE : E.nonempty) (h\u03b1 : \u2200 x \u2208 E, \u03b1 \u2264 x) (h\u03b2 : \u2200 x \u2208 E, x \u2264 \u03b2) :\n  \u03b1 \u2264 \u03b2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_8", "nl_statement": "Prove that no order can be defined in the complex field that turns it into an ordered field.", "nl_proof": "\\begin{proof}\n\n    By Part (a) of Proposition $1.18$, either $i$ or $-i$ must be positive. Hence $-1=i^2=(-i)^2$ must be positive. But then $1=(-1)^2$, must also be positive, and this contradicts Part $(a)$ of Proposition 1.18, since 1 and $-1$ cannot both be positive.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_8 : \u00ac \u2203 (r : \u2102 \u2192 \u2102 \u2192 Prop), is_linear_order \u2102 r :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " no_order_on_complex : \u00ac(\u2203 (r : \u2102 \u2192 \u2102 \u2192 Prop), is_linear_order \u2102 r) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem real.coe_to_nnreal' (r : \u211d) :\n\t\u2191(r.to_nnreal) = linear_order.max r 0\n\ntheorem ennreal.to_real_of_real' {r : \u211d} :\n\t(ennreal.of_real r).to_real = linear_order.max r 0\n\ndef real.linear_order :\n\tlinear_order \u211d\n\ntheorem is_linear_order.swap {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n\t[is_linear_order \u03b1 r] :\n\tis_linear_order \u03b1 (function.swap r)\n\nThe following is the natural language theorem statement: \"Prove that no order can be defined in the complex field that turns it into an ordered field.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " no_order_on_complex : \u00ac \u2203 (r : \u2102 \u2192 \u2102 \u2192 Prop), is_linear_order r ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that no order can be defined in the complex field that turns it into an ordered field.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_12", "nl_statement": "If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$.", "nl_proof": "\\begin{proof}\n\n    We can apply the case $n=2$ and induction on $n$ to get\n\n$$\n\n\\begin{aligned}\n\n\\left|z_1+z_2+\\cdots z_n\\right| &=\\left|\\left(z_1+z_2+\\cdots+z_{n-1}\\right)+z_n\\right| \\\\\n\n& \\leq\\left|z_1+z_2+\\cdots+z_{n-1}\\right|+\\left|z_n\\right| \\\\\n\n& \\leq\\left|z_1\\right|+\\left|z_2\\right|+\\cdots+\\left|z_{n-1}\\right|+\\left|z_n\\right|\n\n\\end{aligned}\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_1_12 (n : \u2115) (f : \u2115 \u2192 \u2102) : \n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " nat_abs_sum_le {\u03b9 : Type*} (s : finset \u03b9) (f : \u03b9 \u2192 \u2124) :\n\t(s.sum (\u03bb (i : \u03b9), f i)).nat_abs \u2264 s.sum (\u03bb (i : \u03b9), (f i).nat_abs) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat_abs_sum_le {\u03b9 : Type*} (s : finset \u03b9) (f : \u03b9 \u2192 \u2124) :\n\t(s.sum (\u03bb (i : \u03b9), f i)).nat_abs \u2264 s.sum (\u03bb (i : \u03b9), (f i).nat_abs)\n\ntheorem finset.le_sum_condensed {M : Type*} [ordered_add_comm_monoid M]\n\t{f : \u2115 \u2192 M} (hf : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m) (n : \u2115) :\n\t(finset.range (2 ^ n)).sum (\u03bb (k : \u2115), f k) \u2264 f 0 + (finset.range n).sum (\u03bb (k : \u2115), 2 ^ k \u2022 f (2 ^ k))\n\ntheorem finset.abs_sum_le_sum_abs {\u03b9 G : Type*}\n\t[linear_ordered_add_comm_group G] (f : \u03b9 \u2192 G) (s : finset \u03b9) :\n\t|s.sum (\u03bb (i : \u03b9), f i)| \u2264 s.sum (\u03bb (i : \u03b9), |f i|)\n\ntheorem finset.le_sum_condensed' {M : Type*} [ordered_add_comm_monoid M]\n\t{f : \u2115 \u2192 M} (hf : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m) (n : \u2115) :\n\t(finset.Ico 1 (2 ^ n)).sum (\u03bb (k : \u2115), f k) \u2264 (finset.range n).sum (\u03bb (k : \u2115), 2 ^ k \u2022 f (2 ^ k))\n\nThe following is the natural language theorem statement: \"If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_14", "nl_statement": "If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.", "nl_proof": "\\begin{proof}\n\n    $|1+z|^2=(1+z)(1+\\bar{z})=1+\\bar{z}+z+z \\bar{z}=2+z+\\bar{z}$. Similarly $|1-z|^2=(1-z)(1-\\bar{z})=1-z-\\bar{z}+z \\bar{z}=2-z-\\bar{z}$. Hence\n\n$$\n\n|1+z|^2+|1-z|^2=4 \\text {. }\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_1_14\n  (z : \u2102) (h : abs z = 1)\n  : (abs (1 + z)) ^ 2 + (abs (1 - z)) ^ 2 = 4 :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " complex.abs_add_eq_of_abs_eq_one {z : \u2102} (h : z.abs = 1) :\n  (1 + z).abs ^ 2 + (1 - z).abs ^ 2 = 4 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.eq_one_or_neg_one_of_mul_eq_one' {z w : \u2124} (h : z * w = 1) :\n\tz = 1 \u2227 w = 1 \u2228 z = -1 \u2227 w = -1\n\ntheorem int.eq_one_or_neg_one_of_mul_eq_one {z w : \u2124} (h : z * w = 1) :\n\tz = 1 \u2228 z = -1\n\ntheorem complex.abs_add_eq {x y : \u2102} (h : x.arg = y.arg) :\n\t\u21d1complex.abs (x + y) = \u21d1complex.abs x + \u21d1complex.abs y\n\ntheorem int.eq_one_or_neg_one_of_mul_eq_neg_one' {z w : \u2124} (h : z * w = -1) :\n\tz = 1 \u2227 w = -1 \u2228 z = -1 \u2227 w = 1\n\nThe following is the natural language theorem statement: \"If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abs_add_abs_sub_abs_eq_two_of_abs_eq_one (z : \u2102) (h : abs z = 1) :\n  abs (1 + z)^2 + abs (1 - z)^2 = 2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_17", "nl_statement": "Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.", "nl_proof": "\\begin{proof}\n\n    The proof is a routine computation, using the relation\n\n$$\n\n|x \\pm y|^2=(x \\pm y) \\cdot(x \\pm y)=|x|^2 \\pm 2 x \\cdot y+|y|^2 .\n\n$$\n\nIf $\\mathrm{x}$ and $\\mathrm{y}$ are the sides of a parallelogram, then $\\mathrm{x}+\\mathrm{y}$ and $\\mathbf{x}-\\mathrm{y}$ are its diagonals. Hence this result says that the sum of the squares on the diagonals of a parallelogram equals the sum of the squares on the sides.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_17\n  (n : \u2115)\n  (x y : euclidean_space \u211d (fin n)) -- R^n\n  : \u2016x + y\u2016^2 + \u2016x - y\u2016^2 = 2*\u2016x\u2016^2 + 2*\u2016y\u2016^2 :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " norm_add_norm_sub_norm_eq_two_norm_add_two_norm {\u03b1 : Type u}\n  [normed_group \u03b1] [normed_space \u211d \u03b1] (x y : \u03b1) :\n  (norm (x + y))^2 + (norm (x - y))^2 = 2 * (norm x)^2 + 2 * (norm y)^2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem geom_sum\u2082_comm {\u03b1 : Type u} [comm_semiring \u03b1] (x y : \u03b1) (n : \u2115) :\n\t(finset.range n).sum (\u03bb (i : \u2115), x ^ i * y ^ (n - 1 - i)) = (finset.range n).sum (\u03bb (i : \u2115), y ^ i * x ^ (n - 1 - i))\n\ntheorem geom_sum\u2082_succ_eq {\u03b1 : Type u} [comm_ring \u03b1] (x y : \u03b1) {n : \u2115} :\n\t(finset.range (n + 1)).sum (\u03bb (i : \u2115), x ^ i * y ^ (n - i)) = x ^ n + y * (finset.range n).sum (\u03bb (i : \u2115), x ^ i * y ^ (n - 1 - i))\n\ntheorem commute.geom_sum\u2082_succ_eq {\u03b1 : Type u} [ring \u03b1] {x y : \u03b1}\n\t(h : commute x y) {n : \u2115} :\n\t(finset.range (n + 1)).sum (\u03bb (i : \u2115), x ^ i * y ^ (n - i)) = x ^ n + y * (finset.range n).sum (\u03bb (i : \u2115), x ^ i * y ^ (n - 1 - i))\n\ntheorem geom_sum\u2082_mul {\u03b1 : Type u} [comm_ring \u03b1] (x y : \u03b1) (n : \u2115) :\n\t(finset.range n).sum (\u03bb (i : \u2115), x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n\n\nThe following is the natural language theorem statement: \"Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_1_18b", "nl_statement": "If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$", "nl_proof": "\\begin{proof}\n\n    Not true when $k=1$, since the product of two nonzero real numbers is nonzero.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_18b\n  : \u00ac \u2200 (x : \u211d), \u2203 (y : \u211d), y \u2260 0 \u2227 x * y = 0 :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " ne_zero_of_mul_right_ne_zero {\u03b1 : Type*} [semiring \u03b1] {x y : \u03b1}\n  (hx : x \u2260 0) (hxy : y \u2260 0) (hxyz : x * y = 0) :\n  false ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem eq_zero_of_ne_zero_of_mul_right_eq_zero {M : Type*} [monoid_with_zero M]\n\t[no_zero_divisors M] {x y : M} (hnx : x \u2260 0) (hxy : y * x = 0) :\n\ty = 0\n\ntheorem eq_zero_of_ne_zero_of_mul_left_eq_zero {M : Type*} [monoid_with_zero M]\n\t[no_zero_divisors M] {x y : M} (hnx : x \u2260 0) (hxy : x * y = 0) :\n\ty = 0\n\ntheorem finprod_eq_zero {\u03b1 M\u2080 : Type*} [comm_monoid_with_zero M\u2080] (f : \u03b1 \u2192 M\u2080)\n\t(x : \u03b1) (hx : f x = 0) (hf : (function.mul_support f).finite) :\n\tfinprod (\u03bb (x : \u03b1), f x) = 0\n\ntheorem norm_one_of_pow_eq_one {\u03b1 : Type*} [normed_division_ring \u03b1] {x : \u03b1}\n\t{k : \u2115+} (h : x ^ \u2191k = 1) :\n\t\u2016x\u2016 = 1\n\nThe following is the natural language theorem statement: \"If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " dot_product_eq_zero_of_eq_zero_of_eq_one {k : \u2115} {x y : fin k \u2192 \u211d}\n  (hx : x = 0) (hy : y \u2260 0) (h : dot_product x y = 0) :\n  k = 1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_2_19a", "nl_statement": "If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.", "nl_proof": "\\begin{proof}\n\n    We are given that $A \\cap B=\\varnothing$. Since $A$ and $B$ are closed, this means $A \\cap \\bar{B}=\\varnothing=\\bar{A} \\cap B$, which says that $A$ and $B$ are separated.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_19a {X : Type*} [metric_space X]\n  (A B : set X) (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\n  separated_nhds A B :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " is_metric_separated_of_disjoint_closed {X : Type*} [emetric_space X]\n  {A B : set X} (hA : is_closed A) (hB : is_closed B) (h : disjoint A B) :\n  is_metric_separated A B ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem disjoint.exists_uniform_thickening {\u03b1 : Type*} [uniform_space \u03b1]\n\t{A B : set \u03b1} (hA : is_compact A) (hB : is_closed B) (h : disjoint A B) :\n\t\u2203 (V : set (\u03b1 \u00d7 \u03b1)) (H : V \u2208 uniformity \u03b1), disjoint (\u22c3 (x : \u03b1) (H : x \u2208 A), uniform_space.ball x V) (\u22c3 (x : \u03b1) (H : x \u2208 B), uniform_space.ball x V)\n\ntheorem is_exposed.is_closed {\ud835\udd5c E : Type*} [normed_linear_ordered_field \ud835\udd5c]\n\t[add_comm_monoid E] [module \ud835\udd5c E] [topological_space E] {A B : set E}\n\t[order_closed_topology \ud835\udd5c] (hAB : is_exposed \ud835\udd5c A B) (hA : is_closed A) :\n\tis_closed B\n\ntheorem metric.closed_ball_disjoint_closed_ball {\u03b1 : Type u}\n\t[pseudo_metric_space \u03b1] {x y : \u03b1} {\u03b4 \u03b5 : \u211d} (h : \u03b4 + \u03b5 < has_dist.dist x y) :\n\tdisjoint (metric.closed_ball x \u03b4) (metric.closed_ball y \u03b5)\n\ntheorem is_metric_separated.disjoint {X : Type*} [emetric_space X] {s t : set X}\n\t(h : is_metric_separated s t) :\n\tdisjoint s t\n\nThe following is the natural language theorem statement: \"If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " separated_of_disjoint_closed {X : Type*} [metric_space X]\n  {A B : set X} (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\n  separated A B ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_2_25", "nl_statement": "Prove that every compact metric space $K$ has a countable base.", "nl_proof": "\\begin{proof}\n\n    $K$ can be covered by a finite union of neighborhoods of radius $1 / n$, and this shows that this implies that $K$ is separable.\n\n\n\nIt is not entirely obvious that a metric space with a countable base is separable. To prove this, let $\\left\\{V_n\\right\\}_{n=1}^{\\infty}$ be a countable base, and let $x_n \\in V_n$. The points $V_n$ must be dense in $X$. For if $G$ is any non-empty open set, then $G$ contains $V_n$ for some $n$, and hence $x_n \\in G$. (Thus for a metric space, having a countable base and being separable are equivalent.)\n\n\\end{proof}", "formal_statement": "theorem exercise_2_25 {K : Type*} [metric_space K] [compact_space K] :\n  \u2203 (B : set (set K)), set.countable B \u2227 is_topological_basis B :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " has_countable_basis_of_compact {\u03b1 : Type u} [metric_space \u03b1]\n  (hK : is_compact K) :\n  has_countable_basis (nhds_set K) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem exists_compact_superset {\u03b1 : Type u} [topological_space \u03b1]\n\t[locally_compact_space \u03b1] {K : set \u03b1} (hK : is_compact K) :\n\t\u2203 (K' : set \u03b1), is_compact K' \u2227 K \u2286 interior K'\n\ntheorem metric.has_basis_nhds_set_cthickening {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1] {K : set \u03b1} (hK : is_compact K) :\n\t(nhds_set K).has_basis (\u03bb (\u03b4 : \u211d), 0 < \u03b4) (\u03bb (\u03b4 : \u211d), metric.cthickening \u03b4 K)\n\ntheorem has_compact_support.intro {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[has_zero \u03b2] {f : \u03b1 \u2192 \u03b2} [t2_space \u03b1] {K : set \u03b1} (hK : is_compact K)\n\t(hfK : \u2200 (x : \u03b1), x \u2209 K \u2192 f x = 0) :\n\thas_compact_support f\n\ntheorem metric.has_basis_nhds_set_thickening {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1] {K : set \u03b1} (hK : is_compact K) :\n\t(nhds_set K).has_basis (\u03bb (\u03b4 : \u211d), 0 < \u03b4) (\u03bb (\u03b4 : \u211d), metric.thickening \u03b4 K)\n\nThe following is the natural language theorem statement: \"Prove that every compact metric space $K$ has a countable base.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " countable_basis_of_compact_space {K : Type*} [metric_space K]\n  (hK : compact_space K) :\n  \u2203 (B : set (set K)), countable B \u2227 is_topological_basis B ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that every compact metric space $K$ has a countable base.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_2_27b", "nl_statement": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$.", "nl_proof": "\\begin{proof}\n\n    If $x \\in W^c$, and $O$ is any neighborhood of $x$, then $x \\in V_n \\subseteq O$ for some n. Since $x \\notin W, V_n \\cap E$ is uncountable. Hence $O$ contains uncountably many points of $E$, and so $x$ is a condensation point of $E$. Thus $x \\in P$, i.e., $W^c \\subseteq P$.\n\nConversely if $x \\in W$, then $x \\in V_n$ for some $V_n$ such that $V_n \\cap E$ is countable. Hence $x$ has a neighborhood (any neighborhood contained in $V_n$ ) containing at most a countable set of points of $E$, and so $x \\notin P$, i.e., $W \\subseteq P^c$. Hence $P=W^c$.\n\nIt is clear that $P$ is closed (since its complement $W$ is open), so that we need only show that $P \\subseteq P^{\\prime}$. Hence suppose $x \\in P$, and $O$ is any neighborhood of $x$. (By definition of $P$ this means $O \\cap E$ is uncountable.) We need to show that there is a point $y \\in P \\cap(O \\backslash\\{x\\})$. If this is not the case, i.e., if every point $y$ in $O \\backslash\\{x\\}$ is in $P^c$, then for each such point $y$ there is a set $V_n$ containing $y$ such that $V_n \\cap E$ is at most countable. That would mean that $y \\in W$, i.e., that $O \\backslash\\{x\\}$ is contained in $W$. It would follow that $O \\cap E \\subseteq\\{x\\} \\cup(W \\cap E)$, and so $O \\cap E$ contains at most a countable set of points, contrary to the hypothesis that $x \\in P$. Hence $O$ contains a point of $P$ different from $x$, and so $P \\subseteq P^{\\prime}$. Thus $P$ is perfect.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_27b (k : \u2115) (E P : set (euclidean_space \u211d (fin k)))\n  (hE : E.nonempty \u2227 \u00ac set.countable E)\n  (hP : P = {x | \u2200 U \u2208 \ud835\udcdd x, (P \u2229 E).nonempty \u2227 \u00ac set.countable (P \u2229 E)}) :\n  set.countable (E \\ P) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " uncountable_of_condensation_points_of_uncountable {\u03b1 : Type u}\n  [pseudo_emetric_space \u03b1] (E : set \u03b1) (hE : E.uncountable) :\n  (E \\ condensation_points E).countable ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem emetric.second_countable_of_almost_dense_set {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1]\n\t(hs : \u2200 (\u03b5 : ennreal), \u03b5 > 0 \u2192 (\u2203 (t : set \u03b1), t.countable \u2227 (\u22c3 (x : \u03b1) (H : x \u2208 t), emetric.closed_ball x \u03b5) = set.univ)) :\n\ttopological_space.second_countable_topology \u03b1\n\ntheorem metric.cthickening_subset_Union_closed_ball_of_lt {\u03b1 : Type*}\n\t[pseudo_metric_space \u03b1] (E : set \u03b1) {\u03b4 \u03b4' : \u211d} (h\u03b4\u2080 : 0 < \u03b4') (h\u03b4\u03b4' : \u03b4 < \u03b4') :\n\tmetric.cthickening \u03b4 E \u2286 \u22c3 (x : \u03b1) (H : x \u2208 E), metric.closed_ball x \u03b4'\n\ntheorem configuration.has_points.line_count_le_point_count {P L : Type*}\n\t[has_mem P L] [configuration.has_points P L] {p : P} {l : L} (h : p \u2209 l)\n\t[hf : finite {p // p \u2208 l}] :\n\tconfiguration.line_count L p \u2264 configuration.point_count P l\n\ntheorem metric.cthickening_mem_nhds_set {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t(E : set \u03b1) {\u03b4 : \u211d} (h\u03b4 : 0 < \u03b4) :\n\tmetric.cthickening \u03b4 E \u2208 nhds_set E\n\nThe following is the natural language theorem statement: \"Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " countable_of_uncountable_subset_of_condensation_points {E : Type*} \n  [uncountable E] [metric_space E] {P : set E} (hP : P = condensation_points E) :\n  countable (E \\ P) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_2_29", "nl_statement": "Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.", "nl_proof": "\\begin{proof}\n\n    Let $O$ be open. For each pair of points $x \\in O, y \\in O$, we define an equivalence relation $x \\sim y$ by saying $x \\sim y$ if and only if $[\\min (x, y), \\max (x, y)] \\subset$ 0 . This is an equivalence relation, since $x \\sim x([x, x] \\subset O$ if $x \\in O)$; if $x \\sim y$, then $y \\sim x$ (since $\\min (x, y)=\\min (y, x)$ and $\\max (x, y)=\\max (y, x))$; and if $x \\sim y$ and $y \\sim z$, then $x \\sim z([\\min (x, z), \\max (x, z)] \\subseteq[\\min (x, y), \\max (x, y)] \\cup$ $[\\min (y, z), \\max (y, z)] \\subseteq O)$. In fact it is easy to prove that\n\n$$\n\n\\min (x, z) \\geq \\min (\\min (x, y), \\min (y, z))\n\n$$\n\nand\n\n$$\n\n\\max (x, z) \\leq \\max (\\max (x, y), \\max (y, z))\n\n$$\n\nIt follows that $O$ can be written as a disjoint union of pairwise disjoint equivalence classes. We claim that each equivalence class is an open interval.\n\n\n\nTo show this, for each $x \\in O$; let $A=\\{z:[z, x] \\subseteq O\\}$ and $B=\\{z:[x, z] \\subseteq$ $O\\}$, and let $a=\\inf A, b=\\sup B$. We claim that $(a, b) \\subset O$. Indeed if $a<z<b$, there exists $c \\in A$ with $c<z$ and $d \\in B$ with $d>z$. Then $z \\in[c, x] \\cup[x, d] \\subseteq O$. We now claim that $(a, b)$ is the equivalence class containing $x$. It is clear that each element of $(a, b)$ is equivalent to $x$ by the way in which $a$ and $b$ were chosen. We need to show that if $z \\notin(a, b)$, then $z$ is not equivalent to $x$. Suppose that $z<a$. If $z$ were equivalent to $x$, then $[z, x]$ would be contained in $O$, and so we would have $z \\in A$. Hence $a$ would not be a lower bound for $A$. Similarly if $z>b$ and $z \\sim x$, then $b$ could not be an upper bound for $B$.\n\n\n\nWe have now established that $O$ is a union of pairwise disjoint open intervals. Such a union must be at most countable, since each open interval contains a rational number not in any other interval.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_29 (U : set \u211d) (hU : is_open U) :\n  \u2203 (f : \u2115 \u2192 set \u211d), (\u2200 n, \u2203 a b : \u211d, f n = {x | a < x \u2227 x < b}) \u2227 (\u2200 n, f n \u2286 U) \u2227\n  (\u2200 n m, n \u2260 m \u2192 f n \u2229 f m = \u2205) \u2227\n  U = \u22c3 n, f n :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " is_open_sUnion_of_pairwise_disjoint_segments {\u03b1 : Type*}\n  [topological_space \u03b1] [t2_space \u03b1] {s : set \u03b1} (hs : is_open s) :\n  \u2203 (U : \u03b1 \u2192 set \u03b1), (\u2200 (x : \u03b1), x \u2208 U x \u2227 is_open (U x)) \u2227 s.pairwise_disjoint U ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem Scott.is_open_sUnion (\u03b1 : Type u) [omega_complete_partial_order \u03b1]\n\t(s : set (set \u03b1)) (hs : \u2200 (t : set \u03b1), t \u2208 s \u2192 Scott.is_open \u03b1 t) :\n\tScott.is_open \u03b1 (\u22c3\u2080 s)\n\ntheorem comp_open_symm_mem_uniformity_sets {\u03b1 : Type*} [uniform_space \u03b1]\n\t{s : set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 uniformity \u03b1) :\n\t\u2203 (t : set (\u03b1 \u00d7 \u03b1)) (H : t \u2208 uniformity \u03b1), is_open t \u2227 symmetric_rel t \u2227 comp_rel t t \u2286 s\n\ntheorem set.finite.t2_separation {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1]\n\t{s : set \u03b1} (hs : s.finite) :\n\t\u2203 (U : \u03b1 \u2192 set \u03b1), (\u2200 (x : \u03b1), x \u2208 U x \u2227 is_open (U x)) \u2227 s.pairwise_disjoint U\n\ntheorem is_open_sInter {\u03b1 : Type u} [topological_space \u03b1] {s : set (set \u03b1)}\n\t(hs : s.finite) :\n\t(\u2200 (t : set \u03b1), t \u2208 s \u2192 is_open t) \u2192 is_open (\u22c2\u2080 s)\n\nThe following is the natural language theorem statement: \"Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_open_union_segments {s : set \u211d} (hs : is_open s) :\n  \u2203 (t : set (set \u211d)), t.finite \u2227 t.pairwise_disjoint \u2227 s = \u22c3\u2080 t ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_3_2a", "nl_statement": "Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$.", "nl_proof": "\\begin{proof}\n\n    Multiplying and dividing by $\\sqrt{n^2+n}+n$ yields\n\n$$\n\n\\sqrt{n^2+n}-n=\\frac{n}{\\sqrt{n^2+n}+n}=\\frac{1}{\\sqrt{1+\\frac{1}{n}}+1} .\n\n$$\n\nIt follows that the limit is $\\frac{1}{2}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_2a\n  : tendsto (\u03bb (n : \u211d), (sqrt (n^2 + n) - n)) at_top (\ud835\udcdd (1/2)) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " tendsto_sqrt_add_self_sub_self :\n\tfilter.tendsto (\u03bb (n : \u2115), nat.sqrt (n ^ 2 + n) - n) filter.at_top (nhds (1 / 2)) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem stirling.tendsto_self_div_two_mul_self_add_one :\n\tfilter.tendsto (\u03bb (n : \u2115), \u2191n / (2 * \u2191n + 1)) filter.at_top (nhds (1 / 2))\n\ntheorem real.pi_lt_sqrt_two_add_series (n : \u2115) :\n\treal.pi < 2 ^ (n + 1) * real.sqrt (2 - real.sqrt_two_add_series 0 n) + 1 / 4 ^ n\n\ntheorem nat.sqrt_le_add (n : \u2115) :\n\tn \u2264 nat.sqrt n * nat.sqrt n + nat.sqrt n + nat.sqrt n\n\ntheorem nat.succ_le_succ_sqrt (n : \u2115) :\n\tn + 1 \u2264 (nat.sqrt n + 1) * (nat.sqrt n + 1)\n\nThe following is the natural language theorem statement: \"Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " lim_sqrt_n_sq_add_n_sub_n_eq_half :\n  tendsto (\u03bb n : \u2115, (n ^ 2 + n) ^ (1 / 2) - n) at_top (\ud835\udcdd (1 / 2)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_3_5", "nl_statement": "For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.", "nl_proof": "\\begin{proof}\n\n    Since the case when $\\limsup _{n \\rightarrow \\infty} a_n=+\\infty$ and $\\limsup _{n \\rightarrow \\infty} b_n=-\\infty$ has been excluded from consideration, we note that the inequality is obvious if $\\limsup _{n \\rightarrow \\infty} a_n=+\\infty$. Hence we shall assume that $\\left\\{a_n\\right\\}$ is bounded above.\n\n\n\nLet $\\left\\{n_k\\right\\}$ be a subsequence of the positive integers such that $\\lim _{k \\rightarrow \\infty}\\left(a_{n_k}+\\right.$ $\\left.b_{n_k}\\right)=\\limsup _{n \\rightarrow \\infty}\\left(a_n+b_n\\right)$. Then choose a subsequence of the positive integers $\\left\\{k_m\\right\\}$ such that\n\n$$\n\n\\lim _{m \\rightarrow \\infty} a_{n_{k_m}}=\\limsup _{k \\rightarrow \\infty} a_{n_k} .\n\n$$\n\nThe subsequence $a_{n_{k_m}}+b_{n_{k_m}}$ still converges to the same limit as $a_{n_k}+b_{n_k}$, i.e., to $\\limsup _{n \\rightarrow \\infty}\\left(a_n+b_n\\right)$. Hence, since $a_{n_k}$ is bounded above (so that $\\limsup _{k \\rightarrow \\infty} a_{n_k}$ is finite), it follows that $b_{n_{k_m}}$ converges to the difference\n\n$$\n\n\\lim _{m \\rightarrow \\infty} b_{n_{k_m}}=\\lim _{m \\rightarrow \\infty}\\left(a_{n_{k_m}}+b_{n_{k_m}}\\right)-\\lim _{m \\rightarrow \\infty} a_{n_{k_m}} .\n\n$$\n\nThus we have proved that there exist subsequences $\\left\\{a_{n_{k_m}}\\right\\}$ and $\\left\\{b_{n_{k_m}}\\right\\}$ which converge to limits $a$ and $b$ respectively such that $a+b=\\limsup _{n \\rightarrow \\infty}\\left(a_n+b_n^*\\right)$. Since $a$ is the limit of a subsequence of $\\left\\{a_n\\right\\}$ and $b$ is the limit of a subsequence of $\\left\\{b_n\\right\\}$, it follows that $a \\leq \\limsup _{n \\rightarrow \\infty} a_n$ and $b \\leq \\limsup _{n \\rightarrow \\infty} b_n$, from which the desired inequality follows.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_5 -- TODO fix\n  (a b : \u2115 \u2192 \u211d)\n  (h : limsup a + limsup b \u2260 0) :\n  limsup (\u03bb n, a n + b n) \u2264 limsup a + limsup b :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " Limsup_add_Limsup {\u03b1 : Type*} [linear_ordered_field \u03b1]\n  {f g : cau_seq \u03b1 has_abs.abs} (hf : f.lim_zero) (hg : g.lim_zero) :\n  (f \u2294 g).lim_zero ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem filter.Limsup_le_Limsup {\u03b1 : Type*} [conditionally_complete_lattice \u03b1]\n\t{f g : filter \u03b1} (hf : filter.is_cobounded has_le.le f . \"is_bounded_default\")\n\t(hg : filter.is_bounded has_le.le g . \"is_bounded_default\")\n\t(h : \u2200 (a : \u03b1), (\u2200\u1da0 (n : \u03b1) in g, n \u2264 a) \u2192 (\u2200\u1da0 (n : \u03b1) in f, n \u2264 a)) :\n\tf.Limsup \u2264 g.Limsup\n\ntheorem cau_seq.sup_lim_zero {\u03b1 : Type*} [linear_ordered_field \u03b1]\n\t{f g : cau_seq \u03b1 has_abs.abs} (hf : f.lim_zero) (hg : g.lim_zero) :\n\t(f \u2294 g).lim_zero\n\ntheorem filter.Liminf_le_Liminf {\u03b1 : Type*} [conditionally_complete_lattice \u03b1]\n\t{f g : filter \u03b1} (hf : filter.is_bounded ge f . \"is_bounded_default\")\n\t(hg : filter.is_cobounded ge g . \"is_bounded_default\")\n\t(h : \u2200 (a : \u03b1), (\u2200\u1da0 (n : \u03b1) in f, a \u2264 n) \u2192 (\u2200\u1da0 (n : \u03b1) in g, a \u2264 n)) :\n\tf.Liminf \u2264 g.Liminf\n\ntheorem ennreal.supr_add_supr {\u03b9 : Sort u_1} {f g : \u03b9 \u2192 ennreal}\n\t(h : \u2200 (i j : \u03b9), \u2203 (k : \u03b9), f i + g j \u2264 f k + g k) :\n\tsupr f + supr g = \u2a06 (a : \u03b9), f a + g a\n\nThe following is the natural language theorem statement: \"For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " limsup_add_le_limsup_add_limsup {\u03b1 : Type*} [linear_order \u03b1]\n  {f g : \u2115 \u2192 \u03b1} (hf : \u2200 n, f n \u2264 f (n + 1)) (hg : \u2200 n, g n \u2264 g (n + 1)) :\n  limsup (\u03bb n, f n + g n) \u2264 limsup f + limsup g ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_3_7", "nl_statement": "Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.", "nl_proof": "\\begin{proof}\n\n    Since $\\left(\\sqrt{a_n}-\\frac{1}{n}\\right)^2 \\geq 0$, it follows that\n\n$$\n\n\\frac{\\sqrt{a_n}}{n} \\leq \\frac{1}{2}\\left(a_n^2+\\frac{1}{n^2}\\right) .\n\n$$\n\nNow $\\Sigma a_n^2$ converges by comparison with $\\Sigma a_n$ (since $\\Sigma a_n$ converges, we have $a_n<1$ for large $n$, and hence $\\left.a_n^2<a_n\\right)$. Since $\\Sigma \\frac{1}{n^2}$ also converges ($p$ series, $p=2$ ), it follows that $\\Sigma \\frac{\\sqrt{a_n}}{n}$ converges.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_7\n  (a : \u2115 \u2192 \u211d)\n  (h : \u2203 y, (tendsto (\u03bb n, (\u2211 i in (finset.range n), a i)) at_top (\ud835\udcdd y))) :\n  \u2203 y, tendsto (\u03bb n, (\u2211 i in (finset.range n), sqrt (a i) / n)) at_top (\ud835\udcdd y) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " summable_of_summable_sqrt {\u03b1 : Type*} [non_unital_non_assoc_semiring \u03b1]\n  [topological_space \u03b1] [topological_semiring \u03b1] {f : \u2115 \u2192 \u03b1} (hf : summable f)\n  (hf0 : \u2200 n, 0 \u2264 f n) :\n  summable (\u03bb n, (f n)^(1/2) / n) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.sqrt_add_eq (n : \u2115) {a : \u2115} (h : a \u2264 n + n) :\n\tnat.sqrt (n * n + a) = n\n\ntheorem summable_mul_right_iff {\u03b1 \u03b2 : Type*} [division_ring \u03b1]\n\t[topological_space \u03b1] [topological_ring \u03b1] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (h : a \u2260 0) :\n\tsummable f \u2194 summable (\u03bb (b : \u03b2), f b * a)\n\ntheorem summable_geometric_two' (a : \u211d) :\n\tsummable (\u03bb (n : \u2115), a / 2 / 2 ^ n)\n\ntheorem summable.mul_right {\u03b1 \u03b2 : Type*} [non_unital_non_assoc_semiring \u03b1]\n\t[topological_space \u03b1] [topological_semiring \u03b1] {f : \u03b2 \u2192 \u03b1} (a : \u03b1)\n\t(hf : summable f) :\n\tsummable (\u03bb (b : \u03b2), f b * a)\n\nThe following is the natural language theorem statement: \"Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " summable_of_summable_sqrt_div_nat {\u03b1 : Type*} [linear_ordered_semiring \u03b1]\n  (a : \u2115 \u2192 \u03b1) (h : summable a) : summable (\u03bb n, sqrt (a n) / n) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_3_13", "nl_statement": "Prove that the Cauchy product of two absolutely convergent series converges absolutely.", "nl_proof": "\\begin{proof}\n\n    Since both the hypothesis and conclusion refer to absolute convergence, we may assume both series consist of nonnegative terms. We let $S_n=\\sum_{k=0}^n a_n, T_n=\\sum_{k=0}^n b_n$, and $U_n=\\sum_{k=0}^n \\sum_{l=0}^k a_l b_{k-l}$. We need to show that $U_n$ remains bounded, given that $S_n$ and $T_n$ are bounded. To do this we make the convention that $a_{-1}=T_{-1}=0$, in order to save ourselves from having to separate off the first and last terms when we sum by parts. We then have\n\n$$\n\n\\begin{aligned}\n\nU_n &=\\sum_{k=0}^n \\sum_{l=0}^k a_l b_{k-l} \\\\\n\n&=\\sum_{k=0}^n \\sum_{l=0}^k a_l\\left(T_{k-l}-T_{k-l-1}\\right) \\\\\n\n&=\\sum_{k=0}^n \\sum_{j=0}^k a_{k-j}\\left(T_j-T_{j-1}\\right) \\\\\n\n&=\\sum_{k=0}^n \\sum_{j=0}^k\\left(a_{k-j}-a_{k-j-1}\\right) T_j \\\\\n\n&=\\sum_{j=0}^n \\sum_{k=j}^n\\left(a_{k-j}-a_{k-j-1}\\right) T_j\n\n&=\\sum_{j=0}^n a_{n-j} T_j \\\\\n\n&\\leq T \\sum_{m=0}^n a_m \\\\\n\n&=T S_n \\\\\n\n&\\leq S T .\n\n\\end{aligned}\n\n$$\n\nThus $U_n$ is bounded, and hence approaches a finite limit.\n\n\n\n\\end{proof}", "formal_statement": "theorem exercise_3_13\n  (a b : \u2115 \u2192 \u211d)\n  (ha : \u2203 y, (tendsto (\u03bb n, (\u2211 i in (finset.range n), |a i|)) at_top (\ud835\udcdd y)))\n  (hb : \u2203 y, (tendsto (\u03bb n, (\u2211 i in (finset.range n), |b i|)) at_top (\ud835\udcdd y))) :\n  \u2203 y, (tendsto (\u03bb n, (\u2211 i in (finset.range n),\n  \u03bb i, (\u2211 j in finset.range (i + 1), a j * b (i - j)))) at_top (\ud835\udcdd y)) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " summable_norm_sum_mul_range_of_summable_norm {\u03b1 : Type*} [normed_ring \u03b1]\n  {f g : \u2115 \u2192 \u03b1} (hf : summable (\u03bb (x : \u2115), \u2016f x\u2016))\n  (hg : summable (\u03bb (x : \u2115), \u2016g x\u2016)) :\n  summable (\u03bb (n : \u2115), \u2016(finset.range (n + 1)).sum (\u03bb (k : \u2115), f k * g (n - k))\u2016) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem cauchy.prod {\u03b1 : Type u} {\u03b2 : Type v} [uniform_space \u03b1]\n\t[uniform_space \u03b2] {f : filter \u03b1} {g : filter \u03b2} (hf : cauchy f) (hg : cauchy g) :\n\tcauchy (f.prod g)\n\ntheorem summable_norm_sum_mul_range_of_summable_norm {\u03b1 : Type*} [normed_ring \u03b1]\n\t{f g : \u2115 \u2192 \u03b1} (hf : summable (\u03bb (x : \u2115), \u2016f x\u2016))\n\t(hg : summable (\u03bb (x : \u2115), \u2016g x\u2016)) :\n\tsummable (\u03bb (n : \u2115), \u2016(finset.range (n + 1)).sum (\u03bb (k : \u2115), f k * g (n - k))\u2016)\n\ntheorem conformal.comp {X Y Z : Type*} [normed_add_comm_group X]\n\t[normed_add_comm_group Y] [normed_add_comm_group Z] [normed_space \u211d X]\n\t[normed_space \u211d Y] [normed_space \u211d Z] {f : X \u2192 Y} {g : Y \u2192 Z}\n\t(hf : conformal f) (hg : conformal g) :\n\tconformal (g \u2218 f)\n\ntheorem ring_hom.finite.comp {A B C : Type*} [comm_ring A] [comm_ring B]\n\t[comm_ring C] {g : B \u2192+* C} {f : A \u2192+* B} (hg : g.finite) (hf : f.finite) :\n\t(g.comp f).finite\n\nThe following is the natural language theorem statement: \"Prove that the Cauchy product of two absolutely convergent series converges absolutely.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abs_converges_of_converges_cauchy_product {R : Type*} [comm_ring R]\n  {f g : \u2115 \u2192 R} (hf : abs_converges f) (hg : abs_converges g) :\n  abs_converges (cauchy_product f g) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the Cauchy product of two absolutely convergent series converges absolutely.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_3_21", "nl_statement": "If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.", "nl_proof": "\\begin{proof}\n\n    Choose $x_n \\in E_n$. (We use the axiom of choice here.) The sequence $\\left\\{x_n\\right\\}$ is a Cauchy sequence, since the diameter of $E_n$ tends to zero as $n$ tends to infinity and $E_n$ contains $E_{n+1}$. Since the metric space $X$ is complete, the sequence $x_n$ converges to a point $x$, which must belong to $E_n$ for all $n$, since $E_n$ is closed and contains $x_m$ for all $m \\geq n$. There cannot be a second point $y$ in all of the $E_n$, since for any point $y \\neq x$ the diameter of $E_n$ is less $\\operatorname{than} d(x, y)$ for large $n$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_21\n  {X : Type*} [metric_space X] [complete_space X]\n  (E : \u2115 \u2192 set X)\n  (hE : \u2200 n, E n \u2283 E (n + 1))\n  (hE' : tendsto (\u03bb n, metric.diam (E n)) at_top (\ud835\udcdd 0)) :\n  \u2203 a, set.Inter E = {a} :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_unique_of_nested_closed_bounded_diam_zero {X : Type*}\n  [metric_space X] {E : \u2115 \u2192 set X} (hE : \u2200 (n : \u2115), is_closed (E n))\n  (hEb : \u2200 (n : \u2115), nonempty (E n)) (hEbnd : \u2200 (n : \u2115), bounded_of_nonempty (E n))\n  (hEn : \u2200 (n : \u2115), E n \u2286 E (n + 1)) (hEd : lim_diam_zero E) :\n  \u2203! (x : X), \u2200 (n : \u2115), x \u2208 E n ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem emetric.exists_real_pos_lt_inf_edist_of_not_mem_closure {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1] {x : \u03b1} {E : set \u03b1} (h : x \u2209 closure E) :\n\t\u2203 (\u03b5 : \u211d), 0 < \u03b5 \u2227 ennreal.of_real \u03b5 < emetric.inf_edist x E\n\ntheorem emetric.exists_forall_closed_ball_subset_aux\u2081 {\u03b9 X : Type*}\n\t[emetric_space X] {K U : \u03b9 \u2192 set X} (hK : \u2200 (i : \u03b9), is_closed (K i))\n\t(hU : \u2200 (i : \u03b9), is_open (U i)) (hKU : \u2200 (i : \u03b9), K i \u2286 U i)\n\t(hfin : locally_finite K) (x : X) :\n\t\u2203 (r : \u211d), \u2200\u1da0 (y : X) in nhds x, r \u2208 set.Ioi 0 \u2229 ennreal.of_real \u207b\u00b9' \u22c2 (i : \u03b9) (hi : y \u2208 K i), {r : ennreal | emetric.closed_ball y r \u2286 U i}\n\ntheorem metric.is_open_singleton_iff {\u03b1 : Type*} [pseudo_metric_space \u03b1] {x : \u03b1} :\n\tis_open {x} \u2194 \u2203 (\u03b5 : \u211d) (H : \u03b5 > 0), \u2200 (y : \u03b1), has_dist.dist y x < \u03b5 \u2192 y = x\n\ntheorem metric.cthickening_singleton {\u03b1 : Type*} [pseudo_metric_space \u03b1] (x : \u03b1)\n\t{\u03b4 : \u211d} (h\u03b4 : 0 \u2264 \u03b4) :\n\tmetric.cthickening \u03b4 {x} = metric.closed_ball x \u03b4\n\nThe following is the natural language theorem statement: \"If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " singleton_of_nested_closed_bounded_diam_zero {X : Type*} [metric_space X]\n  [complete_space X] {E : \u2115 \u2192 set X} (hE : \u2200 n, is_closed (E n))\n  (hE_nonempty : \u2200 n, E n \u2260 \u2205) (hE_bounded : \u2200 n, metric.bounded (E n))\n  (hE_nested : \u2200 n, E n \u2286 E (n + 1))\n  (hE_diam_zero : tendsto (\u03bb n, metric.diameter (E n)) at_top (\ud835\udcdd 0)) :\n  \u2203 x, \u2200 n, x \u2208 E n ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_1a", "nl_statement": "Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous.", "nl_proof": "\\begin{proof}\n\n    $$\n\nf(x)= \\begin{cases}1 & \\text { if } x \\text { is an integer } \\\\ 0 & \\text { if } x \\text { is not an integer. }\\end{cases}\n\n$$\n\n(If $x$ is an integer, then $f(x+h)-f(x-h) \\equiv 0$ for all $h$; while if $x$ is not an integer, $f(x+h)-f(x-h)=0$ for $|h|<\\min (x-[x], 1+[x]-x)$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_1a\n  : \u2203 (f : \u211d \u2192 \u211d), (\u2200 (x : \u211d), tendsto (\u03bb y, f(x + y) - f(x - y)) (\ud835\udcdd 0) (\ud835\udcdd 0)) \u2227 \u00ac continuous f :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " not_continuous_of_tendsto_zero_of_nonneg {f : \u211d \u2192 \u211d}\n  (hf : \u2200 (x : \u211d), tendsto (\u03bb (h : \u211d), f (x + h) - f (x - h)) (nhds 0) (nhds 0))\n  (hfnn : \u2200 (x : \u211d), 0 \u2264 f x) :\n  \u00accontinuous f ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem not_summable_iff_tendsto_nat_at_top_of_nonneg {f : \u2115 \u2192 \u211d}\n\t(hf : \u2200 (n : \u2115), 0 \u2264 f n) :\n\t\u00acsummable f \u2194 filter.tendsto (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (i : \u2115), f i)) filter.at_top filter.at_top\n\ntheorem ennreal.tendsto_cofinite_zero_of_tsum_ne_top {\u03b1 : Type*}\n\t{f : \u03b1 \u2192 ennreal} (hf : \u2211' (x : \u03b1), f x \u2260 \u22a4) :\n\tfilter.tendsto f filter.cofinite (nhds 0)\n\ntheorem ennreal.tendsto_at_top_zero_of_tsum_ne_top {f : \u2115 \u2192 ennreal}\n\t(hf : \u2211' (x : \u2115), f x \u2260 \u22a4) :\n\tfilter.tendsto f filter.at_top (nhds 0)\n\ntheorem summable_iff_not_tendsto_nat_at_top_of_nonneg {f : \u2115 \u2192 \u211d}\n\t(hf : \u2200 (n : \u2115), 0 \u2264 f n) :\n\tsummable f \u2194 \u00acfilter.tendsto (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (i : \u2115), f i)) filter.at_top filter.at_top\n\nThe following is the natural language theorem statement: \"Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_continuous_of_lim_sub_lim_eq_zero {f : \u211d \u2192 \u211d}\n  (hf : \u2200 x : \u211d, tendsto (\u03bb h : \u211d, f (x + h) - f (x - h)) at_top (\ud835\udcdd 0)) :\n  \u00ac continuous f ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_3", "nl_statement": "Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.", "nl_proof": "\\begin{proof}\n\n    $Z(f)=f^{-1}(\\{0\\})$, which is the inverse image of a closed set. Hence $Z(f)$ is closed.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_3\n  {\u03b1 : Type} [metric_space \u03b1]\n  (f : \u03b1 \u2192 \u211d) (h : continuous f) (z : set \u03b1) (g : z = f\u207b\u00b9' {0})\n  : is_closed z :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " is_closed_of_continuous {X : Type*} [metric_space X] {f : X \u2192 \u211d}\n  (hf : continuous f) : is_closed {x : X | f x = 0} ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem analytic_on.eq_on_zero_of_preconnected_of_mem_closure {\ud835\udd5c : Type*}\n\t[nontrivially_normed_field \ud835\udd5c] {E : Type*} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {f : \ud835\udd5c \u2192 E} {z\u2080 : \ud835\udd5c} {U : set \ud835\udd5c} (hf : analytic_on \ud835\udd5c f U)\n\t(hU : is_preconnected U) (h\u2080 : z\u2080 \u2208 U)\n\t(hfz\u2080 : z\u2080 \u2208 closure ({z : \ud835\udd5c | f z = 0} \\ {z\u2080})) :\n\tset.eq_on f 0 U\n\ntheorem zero_at_infty_continuous_map.bounded_range {\u03b1 : Type u} {\u03b2 : Type v}\n\t[topological_space \u03b1] [metric_space \u03b2] [has_zero \u03b2]\n\t(f : zero_at_infty_continuous_map \u03b1 \u03b2) :\n\tmetric.bounded (set.range \u21d1f)\n\ntheorem is_closed_map.closed_range {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : is_closed_map f) :\n\tis_closed (set.range f)\n\ntheorem is_locally_constant.range_finite {X Y : Type*} [topological_space X]\n\t[compact_space X] {f : X \u2192 Y} (hf : is_locally_constant f) :\n\t(set.range f).finite\n\nThe following is the natural language theorem statement: \"Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_closed_of_continuous_of_zero_set {X : Type*} [metric_space X]\n  {f : X \u2192 \u211d} (hf : continuous f) (hfz : \u2200 x, f x = 0 \u2192 x \u2208 set.range f) :\n  is_closed (set.range f) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_4b", "nl_statement": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$.", "nl_proof": "\\begin{proof}\n\n    The function $\\varphi: X \\rightarrow R^1$ given by\n\n$$\n\n\\varphi(p)=d_Y(f(p), g(p))\n\n$$\n\nis continuous, since\n\n$$\n\n\\left|d_Y(f(p), g(p))-d_Y(f(q), g(q))\\right| \\leq d_Y(f(p), f(q))+d_Y(g(p), g(q))\n\n$$\n\n(This inequality follows from the triangle inequality, since\n\n$$\n\nd_Y(f(p), g(p)) \\leq d_Y(f(p), f(q))+d_Y(f(q), g(q))+d_Y(g(q), g(p)),\n\n$$\n\nand the same inequality holds with $p$ and $q$ interchanged. The absolute value $\\left|d_Y(f(p), g(p))-d_Y(f(q), g(q))\\right|$ must be either $d_Y(f(p), g(p))-d_Y(f(q), g(q))$ or $d_Y(f(q), g(q))-d_Y(f(p), g(p))$, and the triangle inequality shows that both of these numbers are at most $d_Y(f(p), f(q))+d_Y(g(p), g(q))$.)\n\nBy the previous problem, the zero set of $\\varphi$ is closed. But by definition\n\n$$\n\nZ(\\varphi)=\\{p: f(p)=g(p)\\} .\n\n$$\n\nHence the set of $p$ for which $f(p)=g(p)$ is closed. Since by hypothesis it is dense, it must be $X$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_4b\n  {\u03b1 : Type} [metric_space \u03b1]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f g : \u03b1 \u2192 \u03b2)\n  (s : set \u03b1)\n  (h\u2081 : continuous f)\n  (h\u2082 : continuous g)\n  (h\u2083 : dense s)\n  (h\u2084 : \u2200 x \u2208 s, f x = g x)\n  : f = g :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " continuous.eq_of_eq_on_dense {X Y : Type*} [metric_space X]\n  [metric_space Y] {f g : X \u2192 Y} (hf : continuous f) (hg : continuous g)\n  (E : set X) (hE : dense E) (h : \u2200 (p : E), f p = g p) :\n  \u2200 (p : X), f p = g p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem measure_theory.measure.eq_of_ae_eq {X Y : Type*} [topological_space X]\n\t{m : measurable_space X} [topological_space Y] [t2_space Y]\n\t{\u03bc : measure_theory.measure X} [\u03bc.is_open_pos_measure] {f g : X \u2192 Y}\n\t(h : f =\u1d50[\u03bc] g) (hf : continuous f) (hg : continuous g) :\n\tf = g\n\ntheorem continuous.ae_eq_iff_eq {X Y : Type*} [topological_space X]\n\t{m : measurable_space X} [topological_space Y] [t2_space Y]\n\t(\u03bc : measure_theory.measure X) [\u03bc.is_open_pos_measure] {f g : X \u2192 Y}\n\t(hf : continuous f) (hg : continuous g) :\n\tf =\u1d50[\u03bc] g \u2194 f = g\n\ntheorem measure_theory.measure.eq_on_of_ae_eq {X Y : Type*}\n\t[topological_space X] {m : measurable_space X} [topological_space Y]\n\t[t2_space Y] {\u03bc : measure_theory.measure X} [\u03bc.is_open_pos_measure] {s : set X}\n\t{f g : X \u2192 Y} (h : f =\u1d50[\u03bc.restrict s] g) (hf : continuous_on f s)\n\t(hg : continuous_on g s) (hU : s \u2286 closure (interior s)) :\n\tset.eq_on f g s\n\ntheorem measure_theory.measure.eq_on_open_of_ae_eq {X Y : Type*}\n\t[topological_space X] {m : measurable_space X} [topological_space Y]\n\t[t2_space Y] {\u03bc : measure_theory.measure X} [\u03bc.is_open_pos_measure] {U : set X}\n\t{f g : X \u2192 Y} (h : f =\u1d50[\u03bc.restrict U] g) (hU : is_open U)\n\t(hf : continuous_on f U) (hg : continuous_on g U) :\n\tset.eq_on f g U\n\nThe following is the natural language theorem statement: \"Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " eq_of_dense_eq {X Y : Type*} [metric_space X] [metric_space Y]\n  (f g : X \u2192 Y) (hf : continuous f) (hg : continuous g) (E : set X)\n  (hE : dense E) (h : \u2200 x \u2208 E, f x = g x) : \u2200 x, f x = g x ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_5b", "nl_statement": "Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.", "nl_proof": "\\begin{proof}\n\n    Let $E:=(0,1)$, and define $f(x):=1 / x$ for all $x \\in E$. If $f$ has a continuous extension $g$ to $\\mathbb{R}$, then $g$ is continuous on $[-1,1]$, and therefore bounded by the intermediate value theorem. However, $f$ is not bounded in any neighborhood of $x=0$, so therefore $g$ is not bounded either, a contradiction.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5b\n  : \u2203 (E : set \u211d) (f : \u211d \u2192 \u211d), (continuous_on f E) \u2227\n  (\u00ac \u2203 (g : \u211d \u2192 \u211d), continuous g \u2227 \u2200 x \u2208 E, f x = g x) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_continuous_function_on_subset_of_R_with_no_continuous_extension\n  {E : set \u211d} (hE : \u2203 (f : E \u2192 \u211d), continuous f) :\n  \u2203 (f : E \u2192 \u211d), continuous f \u2227 \u2200 (g : \u211d \u2192 \u211d), continuous g \u2192 \u2203 (x : \u211d), x \u2208 E \u2227 g x \u2260 f x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem continuous_linear_map.exists_right_inverse_of_surjective {\ud835\udd5c : Type u}\n\t[nontrivially_normed_field \ud835\udd5c] {E : Type v} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {F : Type w} [normed_add_comm_group F] [normed_space \ud835\udd5c F]\n\t[complete_space \ud835\udd5c] [finite_dimensional \ud835\udd5c F] (f : E \u2192L[\ud835\udd5c] F)\n\t(hf : linear_map.range f = \u22a4) :\n\t\u2203 (g : F \u2192L[\ud835\udd5c] E), f.comp g = continuous_linear_map.id \ud835\udd5c F\n\ntheorem is_bounded_linear_map.continuous {\ud835\udd5c : Type*}\n\t[nontrivially_normed_field \ud835\udd5c] {E : Type*} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_add_comm_group F] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} (hf : is_bounded_linear_map \ud835\udd5c f) :\n\tcontinuous f\n\ntheorem is_covering_map.continuous {E X : Type*} [topological_space E]\n\t[topological_space X] {f : E \u2192 X} (hf : is_covering_map f) :\n\tcontinuous f\n\ntheorem continuous.inner {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E]\n\t{\u03b1 : Type*} [topological_space \u03b1] {f g : \u03b1 \u2192 E} (hf : continuous f)\n\t(hg : continuous g) :\n\tcontinuous (\u03bb (t : \u03b1), has_inner.inner (f t) (g t))\n\nThe following is the natural language theorem statement: \"Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_set_and_continuous_function_not_extendable_to_continuous_function\n  (E : set \u211d) (f : E \u2192 \u211d) (hf : continuous f) :\n  \u2203 (g : \u211d \u2192 \u211d), continuous g \u2227 \u2200 (x : \u211d), x \u2208 E \u2192 g x \u2260 f x ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_8a", "nl_statement": "Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$.", "nl_proof": "\\begin{proof}\n\n    Let $a=\\inf E$ and $b=\\sup E$, and let $\\delta>0$ be such that $|f(x)-f(y)|<1$ if $x, y \\in E$ and $|x-y|<\\delta$. Now choose a positive integer $N$ larger than $(b-a) / \\delta$, and consider the $N$ intervals $I_k=\\left[a+\\frac{k-1}{b-a}, a+\\frac{k}{b-a}\\right], k=1,2, \\ldots, N$. For each $k$ such that $I_k \\cap E \\neq \\varnothing$ let $x_k \\in E \\cap I_k$. Then let $M=1+\\max \\left\\{\\left|f\\left(x_k\\right)\\right|\\right\\}$. If $x \\in E$, we have $\\left|x-x_k\\right|<\\delta$ for some $k$, and hence $|f(x)|<M$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_8a\n  (E : set \u211d) (f : \u211d \u2192 \u211d) (hf : uniform_continuous_on f E)\n  (hE : metric.bounded E) : metric.bounded (set.image f E) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " bounded_of_uniform_continuous_on_bounded_set {\u03b1 : Type u} {\u03b2 : Type v}\n  [topological_space \u03b1] [metric_space \u03b2] (f : \u03b1 \u2192 \u03b2) (E : set \u03b1)\n  (hf : uniform_continuous_on f E) (hE : metric.bounded E) :\n  metric.bounded (f '' E) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem cauchy_seq.bounded_range {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{f : \u2115 \u2192 \u03b1} (hf : cauchy_seq f) :\n\tmetric.bounded (set.range f)\n\ntheorem metric.bounded_range_of_cauchy_map_cofinite {\u03b1 : Type u} {\u03b2 : Type v}\n\t[pseudo_metric_space \u03b1] {f : \u03b2 \u2192 \u03b1}\n\t(hf : cauchy (filter.map f filter.cofinite)) :\n\tmetric.bounded (set.range f)\n\ntheorem metric.bounded_range_of_tendsto_cofinite_uniformity {\u03b1 : Type u}\n\t{\u03b2 : Type v} [pseudo_metric_space \u03b1] {f : \u03b2 \u2192 \u03b1}\n\t(hf : filter.tendsto (prod.map f f) (filter.cofinite.prod filter.cofinite) (uniformity \u03b1)) :\n\tmetric.bounded (set.range f)\n\ntheorem bounded_continuous_function.bounded_range {\u03b1 : Type u} {\u03b2 : Type v}\n\t[topological_space \u03b1] [pseudo_metric_space \u03b2]\n\t(f : bounded_continuous_function \u03b1 \u03b2) :\n\tmetric.bounded (set.range \u21d1f)\n\nThe following is the natural language theorem statement: \"Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " bounded_of_uniform_continuous_on_bounded {f : \u211d \u2192 \u211d} \n  (hf : uniform_continuous_on f (set.bounded_of_uniform_continuous_on f)) :\n  metric.bounded (set.range f) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_11a", "nl_statement": "Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$.", "nl_proof": "\\begin{proof}\n\n    Suppose $\\left\\{x_n\\right\\}$ is a Cauchy sequence in $X$. Let $\\varepsilon>0$ be given. Let $\\delta>0$ be such that $d_Y(f(x), f(u))<\\varepsilon$ if $d_X(x, u)<\\delta$. Then choose $N$ so that $d_X\\left(x_n, x_m\\right)<\\delta$ if $n, m>N$. Obviously $d_Y\\left(f\\left(x_n\\right), f\\left(x_m\\right)\\right)<\\varepsilon$ if $m, n>N$, showing that $\\left\\{f\\left(x_n\\right)\\right\\}$ is a Cauchy sequence.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_11a\n  {X : Type*} [metric_space X]\n  {Y : Type*} [metric_space Y]\n  (f : X \u2192 Y) (hf : uniform_continuous f)\n  (x : \u2115 \u2192 X) (hx : cauchy_seq x) :\n  cauchy_seq (\u03bb n, f (x n)) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " uniform_continuous.comp_cauchy_seq {\u03b1 : Type u} {\u03b2 : Type v}\n  [uniform_space \u03b1] {\u03b3 : Type*} [uniform_space \u03b2] [semilattice_sup \u03b3] {f : \u03b1 \u2192 \u03b2}\n  (hf : uniform_continuous f) {u : \u03b3 \u2192 \u03b1} (hu : cauchy_seq u) :\n  cauchy_seq (f \u2218 u) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem uniform_continuous.comp_cauchy_seq {\u03b1 : Type u} {\u03b2 : Type v}\n\t[uniform_space \u03b1] {\u03b3 : Type*} [uniform_space \u03b2] [semilattice_sup \u03b3] {f : \u03b1 \u2192 \u03b2}\n\t(hf : uniform_continuous f) {u : \u03b3 \u2192 \u03b1} (hu : cauchy_seq u) :\n\tcauchy_seq (f \u2218 u)\n\ntheorem uniform_continuous.continuous {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : uniform_continuous f) :\n\tcontinuous f\n\ntheorem is_locally_constant.continuous {X Y : Type*} [topological_space X]\n\t[topological_space Y] {f : X \u2192 Y} (hf : is_locally_constant f) :\n\tcontinuous f\n\ntheorem uniform_inducing.uniform_continuous {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : uniform_inducing f) :\n\tuniform_continuous f\n\nThe following is the natural language theorem statement: \"Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " cauchy_of_uniform_continuous_of_cauchy {X Y : Type*} [metric_space X]\n  [metric_space Y] (f : X \u2192 Y) (hf : uniform_continuous f)\n  {x : \u2115 \u2192 X} (hx : cauchy x) : cauchy (\u03bb n, f (x n)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_15", "nl_statement": "Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.", "nl_proof": "\\begin{proof}\n\n    Suppose $f$ is continuous and not monotonic, say there exist points $a<b<c$ with $f(a)<f(b)$, and $f(c)<f(b)$. Then the maximum value of $f$ on the closed interval $[a, c]$ is assumed at a point $u$ in the open interval $(a, c)$. If there is also a point $v$ in the open interval $(a, c)$ where $f$ assumes its minimum value on $[a, c]$, then $f(a, c)=[f(v), f(u)]$. If no such point $v$ exists, then $f(a, c)=(d, f(u)]$, where $d=\\min (f(a), f(c))$. In either case, the image of $(a, c)$ is not open.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_15 {f : \u211d \u2192 \u211d}\n  (hf : continuous f) (hof : is_open_map f) :\n  monotone f :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " continuous_open_map_of_R1_to_R1_is_monotone {R : Type*}\n  [topological_space R] [division_ring R] [has_continuous_sub R]\n  [has_continuous_add R] [has_continuous_smul R] (f : R \u2192 R)\n  (hf : is_open_map f) (hfc : continuous f) : monotone f ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem monotone_of_deriv_nonneg {f : \u211d \u2192 \u211d} (hf : differentiable \u211d f)\n\t(hf' : \u2200 (x : \u211d), 0 \u2264 deriv f x) :\n\tmonotone f\n\ntheorem omega_complete_partial_order.continuous'.to_monotone {\u03b1 : Type u}\n\t{\u03b2 : Type v} [omega_complete_partial_order \u03b1] [omega_complete_partial_order \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : omega_complete_partial_order.continuous' f) :\n\tmonotone f\n\ntheorem continuous_linear_map.is_open_map_of_ne_zero {R M : Type*}\n\t[topological_space R] [division_ring R] [has_continuous_sub R]\n\t[add_comm_group M] [topological_space M] [has_continuous_add M] [module R M]\n\t[has_continuous_smul R M] (f : M \u2192L[R] R) (hf : f \u2260 0) :\n\tis_open_map \u21d1f\n\ntheorem monotone_int_of_le_succ {\u03b1 : Type u} [preorder \u03b1] {f : \u2124 \u2192 \u03b1}\n\t(hf : \u2200 (n : \u2124), f n \u2264 f (n + 1)) :\n\tmonotone f\n\nThe following is the natural language theorem statement: \"Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " monotone_of_continuous_open_map_real {f : \u211d \u2192 \u211d} (hf : continuous f)\n  (hof : \u2200 x, is_open (set.range f)) : monotone f ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_4_21a", "nl_statement": "Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.", "nl_proof": "\\begin{proof}\n\nFollowing the hint, we observe that $\\rho_F(x)$ must attain its minimum value on $K$, i.e., there is some point $r \\in K$ such that\n\n$$\n\n\\rho_F(r)=\\min _{q \\in K} \\rho_F(q) .\n\n$$\n\nSince $F$ is closed and $r \\notin F$, it follows from Exercise $4.20$ that $\\rho_F(r)>0$. Let $\\delta$ be any positive number smaller than $\\rho_F(r)$. Then for any $p \\in F, q \\in K$, we have\n\n$$\n\nd(p, q) \\geq \\rho_F(q) \\geq \\rho_F(r)>\\delta .\n\n$$\n\nThis proves the positive assertion.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_21a {X : Type*} [metric_space X]\n  (K F : set X) (hK : is_compact K) (hF : is_closed F) (hKF : disjoint K F) :\n  \u2203 (\u03b4 : \u211d), \u03b4 > 0 \u2227 \u2200 (p q : X), p \u2208 K \u2192 q \u2208 F \u2192 dist p q \u2265 \u03b4 :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_thickenings {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n  {s t : set \u03b1} (hst : disjoint s t) (hs : is_compact s) (ht : is_closed t) :\n  \u2203 (\u03b4 : \u211d), 0 < \u03b4 \u2227 disjoint (metric.thickening \u03b4 s) (metric.thickening \u03b4 t) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem disjoint.exists_thickenings {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t{s t : set \u03b1} (hst : disjoint s t) (hs : is_compact s) (ht : is_closed t) :\n\t\u2203 (\u03b4 : \u211d), 0 < \u03b4 \u2227 disjoint (metric.thickening \u03b4 s) (metric.thickening \u03b4 t)\n\ntheorem metric.closed_ball_disjoint_closed_ball {\u03b1 : Type u}\n\t[pseudo_metric_space \u03b1] {x y : \u03b1} {\u03b4 \u03b5 : \u211d} (h : \u03b4 + \u03b5 < has_dist.dist x y) :\n\tdisjoint (metric.closed_ball x \u03b4) (metric.closed_ball y \u03b5)\n\ntheorem emetric.exists_forall_closed_ball_subset_aux\u2081 {\u03b9 X : Type*}\n\t[emetric_space X] {K U : \u03b9 \u2192 set X} (hK : \u2200 (i : \u03b9), is_closed (K i))\n\t(hU : \u2200 (i : \u03b9), is_open (U i)) (hKU : \u2200 (i : \u03b9), K i \u2286 U i)\n\t(hfin : locally_finite K) (x : X) :\n\t\u2203 (r : \u211d), \u2200\u1da0 (y : X) in nhds x, r \u2208 set.Ioi 0 \u2229 ennreal.of_real \u207b\u00b9' \u22c2 (i : \u03b9) (hi : y \u2208 K i), {r : ennreal | emetric.closed_ball y r \u2286 U i}\n\ntheorem disjoint.exists_cthickenings {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t{s t : set \u03b1} (hst : disjoint s t) (hs : is_compact s) (ht : is_closed t) :\n\t\u2203 (\u03b4 : \u211d), 0 < \u03b4 \u2227 disjoint (metric.cthickening \u03b4 s) (metric.cthickening \u03b4 t)\n\nThe following is the natural language theorem statement: \"Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_delta_of_disjoint_compact_closed {X : Type*} [metric_space X]\n  {K F : set X} (hK : compact_space K) (hF : is_closed F) (hKF : disjoint K F) :\n  \u2203 (\u03b4 : \u211d), \u03b4 > 0 \u2227 \u2200 (p q : X), p \u2208 K \u2192 q \u2208 F \u2192 dist p q \u2265 \u03b4 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_5_1", "nl_statement": "Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant.", "nl_proof": "\\begin{proof}\n\n    Dividing by $x-y$, and letting $x \\rightarrow y$, we find that $f^{\\prime}(y)=0$ for all $y$. Hence $f$ is constant.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_1\n  {f : \u211d \u2192 \u211d} (hf : \u2200 x y : \u211d, | (f x - f y) | \u2264 (x - y) ^ 2) :\n  \u2203 c, f = \u03bb x, c :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " is_constant_of_le_of_deriv_le {f : \u211d \u2192 \u211d} (hf : differentiable \u211d f)\n  (h : \u2200 (x y : \u211d), x \u2264 y \u2192 abs (f y - f x) \u2264 (y - x) ^ 2) :\n  is_constant f ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem real.tsum_le_of_sum_range_le {f : \u2115 \u2192 \u211d} { : \u211d}\n\t(hf : \u2200 (n : \u2115), 0 \u2264 f n)\n\t(h : \u2200 (n : \u2115), (finset.range n).sum (\u03bb (i : \u2115), f i) \u2264 c) :\n\t\u2211' (n : \u2115), f n \u2264 c\n\ntheorem summable_of_sum_range_le {f : \u2115 \u2192 \u211d} { : \u211d} (hf : \u2200 (n : \u2115), 0 \u2264 f n)\n\t(h : \u2200 (n : \u2115), (finset.range n).sum (\u03bb (i : \u2115), f i) \u2264 c) :\n\tsummable f\n\ntheorem summable_of_sum_le {\u03b9 : Type*} {f : \u03b9 \u2192 \u211d} { : \u211d} (hf : 0 \u2264 f)\n\t(h : \u2200 (u : finset \u03b9), u.sum (\u03bb (x : \u03b9), f x) \u2264 c) :\n\tsummable f\n\ntheorem image_sub_le_mul_sub_of_deriv_le {f : \u211d \u2192 \u211d} (hf : differentiable \u211d f)\n\t{C : \u211d} (le_hf' : \u2200 (x : \u211d), deriv f x \u2264 C) \u2983x y : \u211d\u2984 (hxy : x \u2264 y) :\n\tf y - f x \u2264 C * (y - x)\n\nThe following is the natural language theorem statement: \"Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " const_of_le_square_sub_square {f : \u211d \u2192 \u211d} (hf : \u2200 x y, abs (f x - f y) \u2264 (x - y)^2) :\n  \u2203 c : \u211d, \u2200 x, f x = c ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_5_3", "nl_statement": "Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough.", "nl_proof": "\\begin{proof}\n\n    If $0<\\varepsilon<\\frac{1}{M}$, we certainly have\n\n$$\n\nf^{\\prime}(x) \\geq 1-\\varepsilon M>0,\n\n$$\n\nand this implies that $f(x)$ is one-to-one, by the preceding problem.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_3 {g : \u211d \u2192 \u211d} (hg : continuous g)\n  (hg' : \u2203 M : \u211d, \u2200 x : \u211d, | deriv g x | \u2264 M) :\n  \u2203 N, \u2200 \u03b5 > 0, \u03b5 < N \u2192 function.injective (\u03bb x : \u211d, x + \u03b5 * g x) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " small_of_injective {\u03b1 : Type v} {\u03b2 : Type w} [small \u03b2] {f : \u03b1 \u2192 \u03b2}\n  (hf : function.injective f) :\n  small \u03b1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem filter.tendsto.zero_mul_is_bounded_under_le {\u03b1 \u03b9 : Type*}\n\t[non_unital_semi_normed_ring \u03b1] {f g : \u03b9 \u2192 \u03b1} {l : filter \u03b9}\n\t(hf : filter.tendsto f l (nhds 0))\n\t(hg : filter.is_bounded_under has_le.le l (has_norm.norm \u2218 g)) :\n\tfilter.tendsto (\u03bb (x : \u03b9), f x * g x) l (nhds 0)\n\ntheorem filter.tendsto.zero_smul_is_bounded_under_le {\u03b1 \u03b9 : Type*}\n\t[normed_field \u03b1] {E : Type*} [seminormed_add_comm_group E] [normed_space \u03b1 E]\n\t{f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 E} {l : filter \u03b9} (hf : filter.tendsto f l (nhds 0))\n\t(hg : filter.is_bounded_under has_le.le l (has_norm.norm \u2218 g)) :\n\tfilter.tendsto (\u03bb (x : \u03b9), f x \u2022 g x) l (nhds 0)\n\ntheorem asymptotics.is_o.tendsto_inv_smul_nhds_zero {\u03b1 E' \ud835\udd5c : Type*4}\n\t[seminormed_add_comm_group E'] [normed_field \ud835\udd5c] [normed_space \ud835\udd5c E']\n\t{f : \u03b1 \u2192 E'} {g : \u03b1 \u2192 \ud835\udd5c} {l : filter \u03b1} (h : f =o[l] g) :\n\tfilter.tendsto (\u03bb (x : \u03b1), (g x)\u207b\u00b9 \u2022 f x) l (nhds 0)\n\ntheorem small_of_injective {\u03b1 : Type v} {\u03b2 : Type w} [small \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.injective f) :\n\tsmall \u03b1\n\nThe following is the natural language theorem statement: \"Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " injective_of_small_epsilon {\u03b1 : Type*} [linear_ordered_field \u03b1]\n  {g : \u03b1 \u2192 \u03b1} (hg : \u2200 x, abs (g x) \u2264 1) (\u03b5 : \u03b1) (h\u03b5 : abs \u03b5 < 1 / 2) :\n  function.injective (\u03bb x, x + \u03b5 * g x) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_5_5", "nl_statement": "Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.", "nl_proof": "\\begin{proof}\n\n    Let $\\varepsilon>0$. Choose $x_0$ such that $\\left|f^{\\prime}(x)\\right|<\\varepsilon$ if $x>x_0$. Then for any $x \\geq x_0$ there exists $x_1 \\in(x, x+1)$ such that\n\n$$\n\nf(x+1)-f(x)=f^{\\prime}\\left(x_1\\right) .\n\n$$\n\nSince $\\left|f^{\\prime}\\left(x_1\\right)\\right|<\\varepsilon$, it follows that $|f(x+1)-f(x)|<\\varepsilon$, as required.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_5\n  {f : \u211d \u2192 \u211d}\n  (hfd : differentiable \u211d f)\n  (hf : tendsto (deriv f) at_top (\ud835\udcdd 0)) :\n  tendsto (\u03bb x, f (x + 1) - f x) at_top at_top :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " tendsto_at_top_add_nonneg_right {\u03b1 \u03b2 : Type*}\n  [ordered_add_comm_monoid \u03b2] {l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2}\n  (hf : filter.tendsto f l filter.at_top) (hg : \u2200 (x : \u03b1), 0 \u2264 g x) :\n  filter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_top ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem summable.tendsto_top_of_pos {\u03b1 : Type*} [linear_ordered_field \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] {f : \u2115 \u2192 \u03b1} (hf : summable f\u207b\u00b9)\n\t(hf' : \u2200 (n : \u2115), 0 < f n) :\n\tfilter.tendsto f filter.at_top filter.at_top\n\ntheorem ennreal.tendsto_sum_nat_add (f : \u2115 \u2192 ennreal) (hf : \u2211' (i : \u2115), f i \u2260 \u22a4) :\n\tfilter.tendsto (\u03bb (i : \u2115), \u2211' (k : \u2115), f (k + i)) filter.at_top (nhds 0)\n\ntheorem filter.tendsto_at_top_add {\u03b1 \u03b2 : Type*} [ordered_add_comm_monoid \u03b2]\n\t{l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : filter.tendsto f l filter.at_top)\n\t(hg : filter.tendsto g l filter.at_top) :\n\tfilter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_top\n\ntheorem filter.tendsto_at_top_add_nonneg_right {\u03b1 \u03b2 : Type*}\n\t[ordered_add_comm_monoid \u03b2] {l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2}\n\t(hf : filter.tendsto f l filter.at_top) (hg : \u2200 (x : \u03b1), 0 \u2264 g x) :\n\tfilter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_top\n\nThe following is the natural language theorem statement: \"Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " tendsto_of_tendsto_sub_of_tendsto_add_one {\u03b1 : Type*} [linear_ordered_field \u03b1]\n  {f : \u2115 \u2192 \u03b1} (hf : tendsto f at_top (\ud835\udcdd 0)) :\n  tendsto (\u03bb x, f (x + 1) - f x) at_top (\ud835\udcdd 0) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_5_7", "nl_statement": "Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$", "nl_proof": "\\begin{proof}\n\n    Since $f(x)=g(x)=0$, we have\n\n$$\n\n\\begin{aligned}\n\n\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)} &=\\lim _{t \\rightarrow x} \\frac{\\frac{f(t)-f(x)}{t-x}}{\\frac{g(t)-g(x)}{t-x}} \\\\\n\n&=\\frac{\\lim _{t \\rightarrow x} \\frac{f(t)-f(x)}{t-x}}{\\lim _{t \\rightarrow x} \\frac{g(t)-g(x)}{t-x}} \\\\\n\n&=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}\n\n\\end{aligned}\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_5_7\n  {f g : \u211d \u2192 \u211d} {x : \u211d}\n  (hf' : differentiable_at \u211d f 0)\n  (hg' : differentiable_at \u211d g 0)\n  (hg'_ne_0 : deriv g 0 \u2260 0)\n  (f0 : f 0 = 0) (g0 : g 0 = 0) :\n  tendsto (\u03bb x, f x / g x) (\ud835\udcdd x) (\ud835\udcdd (deriv f x / deriv g x)) :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " tendsto_div_nhds_zero_of_deriv_eq_zero {\u03b1 \ud835\udd5c : Type*} [normed_field \ud835\udd5c]\n  [topological_space \u03b1] [topological_space \ud835\udd5c] [has_deriv_at \ud835\udd5c \u03b1]\n  {f g : \u03b1 \u2192 \ud835\udd5c} {x : \u03b1} (hf : deriv_at f x = 0) (hg : deriv_at g x = 0)\n  (hgx : g x \u2260 0) :\n  filter.tendsto (\u03bb (t : \u03b1), f t / g t) (nhds x) (nhds 0) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem filter.tendsto.div_at_top {\u03b1 \u03b2 : Type*} [linear_ordered_field \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] [has_continuous_mul \u03b1] {f g : \u03b2 \u2192 \u03b1}\n\t{l : filter \u03b2} {a : \u03b1} (h : filter.tendsto f l (nhds a))\n\t(hg : filter.tendsto g l filter.at_top) :\n\tfilter.tendsto (\u03bb (x : \u03b2), f x / g x) l (nhds 0)\n\ntheorem filter.tendsto.div {\u03b1 G\u2080 : Type*} [group_with_zero G\u2080]\n\t[topological_space G\u2080] [has_continuous_inv\u2080 G\u2080] [has_continuous_mul G\u2080]\n\t{f g : \u03b1 \u2192 G\u2080} {l : filter \u03b1} {a b : G\u2080} (hf : filter.tendsto f l (nhds a))\n\t(hg : filter.tendsto g l (nhds b)) (hy : b \u2260 0) :\n\tfilter.tendsto (f / g) l (nhds (a / b))\n\ntheorem continuous.div {\u03b1 G\u2080 : Type*} [group_with_zero G\u2080]\n\t[topological_space G\u2080] [has_continuous_inv\u2080 G\u2080] [has_continuous_mul G\u2080]\n\t{f g : \u03b1 \u2192 G\u2080} [topological_space \u03b1] (hf : continuous f) (hg : continuous g)\n\t(h\u2080 : \u2200 (x : \u03b1), g x \u2260 0) :\n\tcontinuous (f / g)\n\ntheorem asymptotics.is_o.tendsto_div_nhds_zero {\u03b1 \ud835\udd5c : Type*4} [normed_field \ud835\udd5c]\n\t{l : filter \u03b1} {f g : \u03b1 \u2192 \ud835\udd5c} (h : f =o[l] g) :\n\tfilter.tendsto (\u03bb (x : \u03b1), f x / g x) l (nhds 0)\n\nThe following is the natural language theorem statement: \"Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " lim_div_of_lim_eq_zero_of_lim_ne_zero {\u03b1 : Type*} [linear_ordered_field \u03b1]\n  {f g : \u211d \u2192 \u03b1} (hf : tendsto f at_top (\ud835\udcdd 0)) (hg : tendsto g at_top (\ud835\udcdd 0))\n  (hg' : tendsto (\u03bb x, g' x) at_top (\ud835\udcdd 0))\n  (hg'_ne_0 : \u2200 x, g' x \u2260 0) :\n  tendsto (\u03bb x, f x / g x) at_top (\ud835\udcdd (f' 0 / g' 0)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Rudin|exercise_5_17", "nl_statement": "Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.", "nl_proof": "\\begin{proof}\n\n    Following the hint, we observe that Theorem $5.15$ (Taylor's formula with remainder) implies that\n\n$$\n\n\\begin{aligned}\n\nf(1) &=f(0)+f^{\\prime}(0)+\\frac{1}{2} f^{\\prime \\prime}(0)+\\frac{1}{6} f^{(3)}(s) \\\\\n\nf(-1) &=f(0)-f^{\\prime}(0)+\\frac{1}{2} f^{\\prime \\prime}(0)-\\frac{1}{6} f^{(3)}(t)\n\n\\end{aligned}\n\n$$\n\nfor some $s \\in(0,1), t \\in(-1,0)$. By subtracting the second equation from the first and using the given values of $f(1), f(-1)$, and $f^{\\prime}(0)$, we obtain\n\n$$\n\n1=\\frac{1}{6}\\left(f^{(3)}(s)+f^{(3)}(t)\\right),\n\n$$\n\nwhich is the desired result. Note that we made no use of the hypothesis $f(0)=0$.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_17\n  {f : \u211d \u2192 \u211d}\n  (hf' : differentiable_on \u211d f (set.Icc (-1) 1))\n  (hf'' : differentiable_on \u211d (deriv f) (set.Icc 1 1))\n  (hf''' : differentiable_on \u211d (deriv (deriv f)) (set.Icc 1 1))\n  (hf0 : f (-1) = 0)\n  (hf1 : f 0 = 0)\n  (hf2 : f 1 = 1)\n  (hf3 : deriv f 0 = 0) :\n  \u2203 x, x \u2208 set.Ioo (-1 : \u211d) 1 \u2227 deriv (deriv (deriv f)) x \u2265 3 :=", "src_header": "import .common\n\nopen real complex\nopen topological_space\nopen filter\nopen_locale real \nopen_locale topology\nopen_locale big_operators\nopen_locale complex_conjugate\nopen_locale filter\n\n\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_deriv_lt_slope_aux {x y : \u211d} {f : \u211d \u2192 \u211d}\n  (hf : continuous_on f (set.Icc x y)) (hxy : x < y)\n  (hf'_mono : strict_mono_on (deriv f) (set.Ioo x y))\n  (h : \u2200 (w : \u211d), w \u2208 set.Ioo x y \u2192 deriv f w \u2260 0) :\n  \u2203 (a : \u211d) (H : a \u2208 set.Ioo x y), deriv f a < (f y - f x) / (y - x) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem has_deriv_within_at.liminf_right_slope_le {f : \u211d \u2192 \u211d} {f' x r : \u211d}\n\t(hf : has_deriv_within_at f f' (set.Ici x) x) (hr : f' < r) :\n\t\u2203\u1da0 (z : \u211d) in nhds_within x (set.Ioi x), slope f x z < r\n\ntheorem strict_mono_on.exists_deriv_lt_slope_aux {x y : \u211d} {f : \u211d \u2192 \u211d}\n\t(hf : continuous_on f (set.Icc x y)) (hxy : x < y)\n\t(hf'_mono : strict_mono_on (deriv f) (set.Ioo x y))\n\t(h : \u2200 (w : \u211d), w \u2208 set.Ioo x y \u2192 deriv f w \u2260 0) :\n\t\u2203 (a : \u211d) (H : a \u2208 set.Ioo x y), deriv f a < (f y - f x) / (y - x)\n\ntheorem strict_mono_on.exists_slope_lt_deriv_aux {x y : \u211d} {f : \u211d \u2192 \u211d}\n\t(hf : continuous_on f (set.Icc x y)) (hxy : x < y)\n\t(hf'_mono : strict_mono_on (deriv f) (set.Ioo x y))\n\t(h : \u2200 (w : \u211d), w \u2208 set.Ioo x y \u2192 deriv f w \u2260 0) :\n\t\u2203 (a : \u211d) (H : a \u2208 set.Ioo x y), (f y - f x) / (y - x) < deriv f a\n\ntheorem strict_mono_on.exists_slope_lt_deriv {x y : \u211d} {f : \u211d \u2192 \u211d}\n\t(hf : continuous_on f (set.Icc x y)) (hxy : x < y)\n\t(hf'_mono : strict_mono_on (deriv f) (set.Ioo x y)) :\n\t\u2203 (a : \u211d) (H : a \u2208 set.Ioo x y), (f y - f x) / (y - x) < deriv f a\n\nThe following is the natural language theorem statement: \"Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_x_in_I_of_three_times_differentiable_on_I_and_f_eq_zero_at_boundary\n  {f : \u211d \u2192 \u211d} (hf : three_times_differentiable_on \u211d f I)\n  (hf_boundary : f (-1) = 0 \u2227 f 0 = 0 \u2227 f 1 = 1 \u2227 f' 0 = 0) :\n  \u2203 (x : \u211d), x \u2208 I \u2227 f''' x \u2265 3 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_1_30", "nl_statement": "Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer.", "nl_proof": "\\begin{proof}\n\nLet $2^s$ be the largest power of 2 occuring as a denominator in $H_n$, say $2^s=k \\leqslant n$. Write $H_n=$ $\\frac{1}{2^s}+\\left(1+1 / 2+\\ldots+1 /(k-1)+1 /(k+1)+\\ldots+1 / n\\right.$. The sum in parentheses can be written as $1 / 2^{s-1}$ times sum of fractions with odd denominators, so the denominator of the sum in parentheses will not be divisible by $2^s$, but it must equal $2^s$ by Ex $1.29$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_30 {n : \u2115} : \n  \u00ac \u2203 a : \u2124, \u2211 (i : fin n), (1 : \u211a) / (n+2) = a :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_int_of_sum_one_div_lt_one_div {n : \u2115} (h : 1 < n) :\n  \u00ac (int.of_nat (finset.range n).sum (\u03bb (i : \u2115), 1 / (\u2191i + 1))).is_int ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem norm_sum_neg_one_pow_le (n : \u2115) :\n\t\u2016(finset.range n).sum (\u03bb (i : \u2115), (-1) ^ i)\u2016 \u2264 1\n\ntheorem geom_sum_pos_and_lt_one {\u03b1 : Type u} {n : \u2115} {x : \u03b1}\n\t[strict_ordered_ring \u03b1] (hx : x < 0) (hx' : 0 < x + 1) (hn : 1 < n) :\n\t0 < (finset.range n).sum (\u03bb (i : \u2115), x ^ i) \u2227 (finset.range n).sum (\u03bb (i : \u2115), x ^ i) < 1\n\ntheorem nat.one_div_lt_one_div {\u03b1 : Type*} [linear_ordered_semifield \u03b1]\n\t{n m : \u2115} (h : n < m) :\n\t1 / (\u2191m + 1) < 1 / (\u2191n + 1)\n\ntheorem fin.coe_add_one_of_lt {n : \u2115} {i : fin n.succ} (h : i < fin.last n) :\n\t\u2191(i + 1) = \u2191i + 1\n\nThe following is the natural language theorem statement: \"Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_int_of_sum_inv_nat_lt_one {n : \u2115} (h : \u2211 i in finset.range n, 1 / (i + 1) < 1) :\n  \u00ac (\u2211 i in finset.range n, 1 / (i + 1)) \u2208 \u2124 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_2_4", "nl_statement": "If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even.", "nl_proof": "\\begin{proof}    \n\n\\begin{align*}\n\n\\operatorname{ord}_p\\, n!  &= \\sum_{k\\geq 1} \\left \\lfloor \\frac{n}{p^{k}}\\right \\rfloor \\leq  \\sum_{k\\geq 1}  \\frac{n}{p^{k}} = \\frac{n}{p} \\frac{1}{1 - \\frac{1}{p}} = \\frac{n}{p-1}\n\n\\end{align*}\n\n\n\nThe decomposition of $n!$ in prime factors is\n\n\n\n$n! = p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}$ \n\nwhere $\\alpha_i = \\operatorname{ord}_{p_i}\\, n! \\leq \\frac{n}{p_i-1}$, and $p_i \\leq n, \\ i=1,2,\\cdots,k$.\n\n\n\nThen\n\n\\begin{align*}\n\nn! &\\leq p_1^{\\frac{n}{p_1-1}}p_2^{\\frac{n}{p_2-1}}\\cdots p_k^{\\frac{n}{p_n-1}}\\\\\n\n\\sqrt[n]{n!} &\\leq p_1^{\\frac{1}{p_1-1}}p_2^{\\frac{1}{p_2-1}}\\cdots p_k^{\\frac{1}{p_n-1}}\\\\\n\n&\\leq \\prod_{p\\leq n} p^{\\frac{1}{p-1}}\n\n\\end{align*}\n\n(the values of $p$ in this product describe all prime numbers $p\\leq n$.)\n\n\\end{proof}", "formal_statement": "theorem exercise_2_4 {a : \u2124} (ha : a \u2260 0) \n  (f_a :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " pow_two_add_one_gcd_eq_one_or_two {a : \u2115} (ha : a \u2260 0) {m n : \u2115}\n  (hmn : m < n) :\n  (a ^ (2 ^ n) + 1).gcd (a ^ (2 ^ m) + 1) = 1 \u2228\n  (a ^ (2 ^ n) + 1).gcd (a ^ (2 ^ m) + 1) = 2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.mod_two_add_add_odd_mod_two (m : \u2115) {n : \u2115} (hn : odd n) :\n\tm % 2 + (m + n) % 2 = 1\n\ntheorem nat.coprime.eq_of_mul_eq_zero {m n : \u2115} (h : m.coprime n)\n\t(hmn : m * n = 0) :\n\tm = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0\n\ntheorem pow_mul_pow_sub {M : Type u} [monoid M] (a : M) {m n : \u2115} (h : m \u2264 n) :\n\ta ^ m * a ^ (n - m) = a ^ n\n\ntheorem pow_gcd_eq_one {M : Type*} [monoid M] (x : M) {m n : \u2115} (hm : x ^ m = 1)\n\t(hn : x ^ n = 1) :\n\tx ^ m.gcd n = 1\n\nThe following is the natural language theorem statement: \"If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " gcd_pow_two_add_one_eq_one_or_two (a : \u2124) (h : a \u2260 0) (m n : \u2115) (hmn : m < n) :\n  gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 \u2228 gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_2_27a", "nl_statement": "Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges.", "nl_proof": "\\begin{proof}\n\n    \n\nLet $S \\subset \\mathbb{N}^*$ the set of square free integers.\n\n\n\nLet $N \\in \\mathbb{N}^*$. Every integer $n, \\, 1\\leq n \\leq N$ can be written as $n = a b^2$, where $a,b$ are integers and $a$ is square free. Then $1\\leq a \\leq N$, and $1\\leq b \\leq \\sqrt{N}$, so\n\n$$\\sum_{n\\leq N} \\frac{1}{n} \\leq \\sum_{a \\in S, a\\leq N}\\  \\sum_{1\\leq b \\leq \\sqrt{N}} \\frac{1}{ab^2} \\leq  \\sum_{a \\in S, a\\leq N}\\ \\frac{1}{a} \\, \\sum_{b=1}^\\infty  \\frac{1}{b^2} = \\frac{\\pi^2}{6} \\sum_{a \\in S, a\\leq N}\\ \\frac{1}{a}.$$\n\nSo $$\\sum_{a \\in S, a\\leq N} \\frac{1}{a}  \\geq \\frac{6}{\\pi^2} \\sum_{n\\leq N} \\frac{1}{n}.$$\n\nAs $\\sum_{n=1}^\\infty \\frac{1}{n}$ diverges, $\\lim\\limits_{N \\to \\infty} \\sum\\limits_{a \\in S, a\\leq N} \\frac{1}{a} = +\\infty$, so the family $\\left(\\frac{1}{a}\\right)_{a\\in S}$ of the inverse of square free integers is not summable.\n\n\n\nLet $S_N = \\prod_{p<N}(1+1/p)$ , and $p_1,p_2,\\ldots, p_l\\ (l = l(N))$ all prime integers less than $N$. Then\n\n\\begin{align*}\n\nS_N &= \\left(1+\\frac{1}{p_1}\\right) \\cdots \\left(1+\\frac{1}{p_l}\\right)\\\\\n\n&=\\sum_{(\\varepsilon_1,\\cdots,\\varepsilon_l) \\in \\{0,1\\}^l } \\frac{1}{p_1^{\\varepsilon_1} \\cdots p_l^{\\varepsilon_l}}\n\n\\end{align*}\n\nWe prove this last formula  by induction. This is true for $l=1$ : $\\sum_{\\varepsilon \\in \\{0,1\\}} 1/p_1^\\varepsilon = 1 + 1/p_1$.\n\n\n\nIf it is true for the integer $l$, then \n\n\\begin{align*}\n\n\\left(1+\\frac{1}{p_1}\\right) \\cdots \\left(1+\\frac{1}{p_l}\\right)\\left(1+\\frac{1}{p_{l+1}}\\right) &= \\sum_{(\\varepsilon_1,\\ldots,\\varepsilon_l) \\in \\{0,1\\}^l } \\frac{1}{p_1^{\\varepsilon_1} \\cdots p_l^{\\varepsilon_l}} \\left(1+\\frac{1}{p_{l+1}}\\right)\\\\\n\n&=\\sum_{(\\varepsilon_1,\\ldots,\\varepsilon_l) \\in \\{0,1\\}^l } \\frac{1}{p_1^{\\varepsilon_1} \\cdots p_l^{\\varepsilon_l}} + \\sum_{(\\varepsilon_1,\\ldots,\\varepsilon_l) \\in \\{0,1\\}^l } \\frac{1}{p_1^{\\varepsilon_1} \\cdots p_l^{\\varepsilon_l}p_{l+1}}\\\\\n\n&=\\sum_{(\\varepsilon_1,\\ldots,\\varepsilon_l,\\varepsilon_{l+1}) \\in \\{0,1\\}^{l+1} } \\frac{1}{p_1^{\\varepsilon_1} \\cdots p_l^{\\varepsilon_l}p_{l+1}^{\\varepsilon_{l+1}}} \n\n\\end{align*}\n\nSo it is true for all $l$. \n\n\n\nThus $S_N = \\sum_{n\\in \\Delta} \\frac{1}{n}$, where $\\Delta$ is the set of square free integers whose prime factors are less than $N$.\n\n\n\nAs $\\sum 1/n$, the sum being over square free integers, diverges, $\\lim\\limits_{N\\to \\infty} S_N = + \\infty$ :\n\n$$\\lim_{N \\to \\infty} \\prod_{p<N} \\left(1+\\frac{1}{p}\\right) = +\\infty.$$\n\n $e^x \\geq 1+x, x \\geq \\log (1+x)$ for $x>0$, so\n\n$$\\log S_N = \\sum_{k=1}^{l(N)} \\log\\left(1+\\frac{1}{p_k}\\right) \\leq \\sum_{k=1}^{l(N)} \\frac{1}{p_k}.$$\n\n$\\lim\\limits_{N\\to \\infty} \\log S_N = +\\infty$ and $\\lim\\limits_{N\\to \\infty} l(N) = +\\infty$, so\n\n$$\\lim_{N\\to \\infty} \\sum_{p<N} \\frac{1}{p} = +\\infty.$$\n\n\\end{proof}", "formal_statement": "theorem exercise_2_27a : \n  \u00ac summable (\u03bb i : {p : \u2124 // squarefree p}, (1 : \u211a) / i) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " sum_one_div_square_free_diverges :\n  \u2200 (n : \u2115), \u2203 (m : \u2115), \u2200 (k : \u2115), m \u2264 k \u2192 (\u2203 (p : \u2115), p.prime \u2227 p \u2223 k) \u2192 1 / k < 1 / n ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem bernoulli'_spec (n : \u2115) :\n\t(finset.range n.succ).sum (\u03bb (k : \u2115), \u2191(n.choose (n - k)) / (\u2191n - \u2191k + 1) * bernoulli' k) = 1\n\ntheorem int.alternating_sum_range_choose {n : \u2115} :\n\t(finset.range (n + 1)).sum (\u03bb (m : \u2115), (-1) ^ m * \u2191(n.choose m)) = ite (n = 0) 1 0\n\ntheorem norm_sum_neg_one_pow_le (n : \u2115) :\n\t\u2016(finset.range n).sum (\u03bb (i : \u2115), (-1) ^ i)\u2016 \u2264 1\n\ntheorem bernoulli'_spec' (n : \u2115) :\n\t(finset.nat.antidiagonal n).sum (\u03bb (k : \u2115 \u00d7 \u2115), \u2191((k.fst + k.snd).choose k.snd) / (\u2191(k.snd) + 1) * bernoulli' k.fst) = 1\n\nThe following is the natural language theorem statement: \"Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sum_inv_square_free_diverges :\n  \u2200 (n : \u2115), \u2203 (m : \u2115), \u2211 i in finset.range m, 1 / (i : \u2115) > n ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_3_4", "nl_statement": "Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers.", "nl_proof": "\\begin{proof}    \n\nIf $3x^2+2 = y^2$, then  $\\overline{y}^2 = \\overline{2}$ in $\\mathbb{Z}/3\\mathbb{Z}$.\n\n\n\n\n\nAs $\\{-1,0,1\\}$ is a complete set of residues modulo $3$, the squares in $\\mathbb{Z}/3\\mathbb{Z}$ are $\\overline{0} = \\overline{0}^2$ and  $\\overline{1} = \\overline{1}^2 = (\\overline{-1})^2$, so $\\overline{2}$ is not a square in $\\mathbb{Z}/3\\mathbb{Z}$ : $\\overline{y}^2 = \\overline{2}$ is impossible in $\\mathbb{Z}/3\\mathbb{Z}$.\n\n\n\nThus $3x^2+2 = y^2$ has no solution in integers.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_4 : \u00ac \u2203 x y : \u2124, 3*x^2 + 2 = y^2 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " no_solution_of_3_x_sq_add_2_eq_y_sq :\n  \u2200 (x y : \u2124), 3 * x ^ 2 + 2 \u2260 y ^ 2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem zsqrtd.not_divides_sq {d : \u2115} [dnsq : zsqrtd.nonsquare d] (x y : \u2115) :\n\t(x + 1) * (x + 1) \u2260 d * (y + 1) * (y + 1)\n\ntheorem int.sq_add_sq_of_two_mul_sq_add_sq {m x y : \u2124}\n\t(h : 2 * m = x ^ 2 + y ^ 2) :\n\tm = ((x - y) / 2) ^ 2 + ((x + y) / 2) ^ 2\n\ntheorem zmod.mod_four_ne_three_of_sq_eq_neg_sq {p : \u2115} [fact (nat.prime p)]\n\t{x y : zmod p} (hx : x \u2260 0) (hxy : x ^ 2 = -y ^ 2) :\n\tp % 4 \u2260 3\n\ntheorem ereal.coe_ne_coe_iff {x y : \u211d} :\n\t\u2191x \u2260 \u2191y \u2194 x \u2260 y\n\nThe following is the natural language theorem statement: \"Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " no_solution_of_3_x_square_plus_2_eq_y_square :\n  \u2200 (x y : \u2124), 3 * x ^ 2 + 2 \u2260 y ^ 2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_3_10", "nl_statement": "If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$.", "nl_proof": "\\begin{proof}    \n\nSuppose that $n >1$ is not a prime. Then $n = uv$, where $2 \\leq u \\leq v \\leq n-1$.\n\n\n\n$\\bullet$ If $u \\neq v$, then $n = uv \\mid (n-1)! = 1\\times 2 \\times\\cdots \\times u \\times\\cdots \\times v \\times \\cdots \\times (n-1)$ (even if $u\\wedge v \\neq 1$ !).\n\n\n\n$\\bullet$ If $u=v$, $n = u^2$ is a square.\n\n\n\nIf $u$ is not prime, $u =st,\\ 2\\leq s \\leq t \\leq u-1 \\leq n-1$, and $n = u' v'$, where $u' =s,v' =st^2$ verify  $2 \\leq u' < v' \\leq n-1$. As in the first case, $n = u'v' \\mid (n-1)!$.  \n\n\n\nIf $u = p$ is a prime, then $n =p^2$.\n\n\n\nIn the case $p = 2$, $n = 4$ and $n=4  \\nmid (n-1)! = 6$. In the other case $p >2$, and $(n-1)! = (p^2 - 1)!$ contains the factors $p < 2p < p^2$, so $p^2 \\mid (p^2-1)!, n \\mid (n-1)!$.\n\n\n\nConclusion : if $n$ is not a prime, $(n - 1)! \\equiv 0 \\pmod n$, except when $n=4$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_10 {n : \u2115} (hn0 : \u00ac n.prime) (hn1 : n \u2260 4) : \n  factorial (n-1) \u2261 0 [MOD n] :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " nat.factorial_equiv_zero_of_not_prime {n : \u2115} (h : \u00acnat.prime n)\n  (h4 : n \u2260 4) :\n  (n - 1).factorial % n = 0 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.prime_of_fac_equiv_neg_one {n : \u2115} (h : \u2191((n - 1).factorial) = -1)\n\t(h1 : n \u2260 1) :\n\tnat.prime n\n\ntheorem nat.prime_iff_fac_equiv_neg_one {n : \u2115} (h : n \u2260 1) :\n\tnat.prime n \u2194 \u2191((n - 1).factorial) = -1\n\ntheorem nat.eq_prime_pow_of_unique_prime_dvd {n p : \u2115} (hpos : n \u2260 0)\n\t(h : \u2200 {d : \u2115}, nat.prime d \u2192 d \u2223 n \u2192 d = p) :\n\tn = p ^ n.factors.length\n\ntheorem nat.factorization_eq_zero_of_not_dvd {n p : \u2115} (h : \u00acp \u2223 n) :\n\t\u21d1(n.factorization) p = 0\n\nThe following is the natural language theorem statement: \"If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " fact_mod_of_not_prime {n : \u2115} (h : \u00ac nat.prime n) :\n  (n - 1)! % n = 0 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_4_4", "nl_statement": "Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$.", "nl_proof": "\\begin{proof}\n\n    Suppose that $a$ is a primitive root modulo $p$. As $p-1$ is even, $(-a)^{p-1}=a^{p-1} \\equiv 1$ $(\\bmod p)$\n\nIf $(-a)^n \\equiv 1(\\bmod p)$, with $n \\in \\mathbb{N}$, then $a^n \\equiv(-1)^n(\\bmod p)$.\n\nTherefore $a^{2 n} \\equiv 1(\\bmod p)$. As $a$ is a primitive root modulo $p, p-1|2 n, 2 t| n$, so $n$ is even.\n\n\n\nHence $a^n \\equiv 1(\\bmod p)$, and $p-1 \\mid n$. So the least $n \\in \\mathbb{N}^*$ such that $(-a)^n \\equiv 1$ $(\\bmod p)$ is $p-1:$ the order of $-a$ modulo $p$ is $p-1,-a$ is a primitive root modulo $p$. Conversely, if $-a$ is a primitive root modulo $p$, we apply the previous result at $-a$ to to obtain that $-(-a)=a$ is a primitive root.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_4 {p t: \u2115} (hp0 : p.prime) (hp1 : p = 4*t + 1) \n  (a : zmod p) : \n  is_primitive_root a p \u2194 is_primitive_root (-a) p :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_primitive_root.neg_iff {R : Type*} [comm_ring R] (p : \u2115)\n  [nontrivial R] [h : char_p R p] (hp : p \u2260 2) (a : R)\n  (hpa : is_primitive_root a p) :\n  is_primitive_root (-a) p \u2194 is_primitive_root a p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_primitive_root.neg_one {R : Type*} [comm_ring R] (p : \u2115)\n\t[nontrivial R] [h : char_p R p] (hp : p \u2260 2) :\n\tis_primitive_root (-1) 2\n\ntheorem nat.totient_eq_iff_prime {p : \u2115} (hp : 0 < p) :\n\tp.totient = p - 1 \u2194 nat.prime p\n\ntheorem nat.prime.dvd_iff_eq {p a : \u2115} (hp : nat.prime p) (a1 : a \u2260 1) :\n\ta \u2223 p \u2194 p = a\n\ntheorem nat.prime.pow_eq_iff {p a k : \u2115} (hp : nat.prime p) :\n\ta ^ k = p \u2194 a = p \u2227 k = 1\n\nThe following is the natural language theorem statement: \"Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_primitive_root_iff_neg_is_primitive_root {p : \u2115} (hp : nat.prime p)\n  (h : p % 4 = 1) (a : \u2115) (ha : nat.coprime a p) :\n  nat.is_primitive_root a p \u2194 nat.is_primitive_root (-a) p ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_4_6", "nl_statement": "If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$.", "nl_proof": "\\begin{proof}\n\n \\newcommand{\\legendre}[2]{\\genfrac{(}{)}{}{}{#1}{#2}}\n\nWrite $p = 2^k + 1$, with $k = 2^n$.\n\n\n\nWe suppose that $n>0$, so $k\\geq 2, p \\geq 5$. As $p$ is prime, $3^{p-1} \\equiv 1 \\pmod p$. \n\n\n\nIn other words, $3^{2^k} \\equiv 1 \\pmod p$ : the order of $3$ is a divisor of $2^k$, a power of $2$.\n\n\n\n$3$ has order $2^k$ modulo $p$ iff $3^{2^{k-1}} \\not \\equiv 1 \\pmod p$. As $\\left (3^{2^{k-1}} \\right)^2 \\equiv 1 \\pmod p$, where $p$ is prime, this is equivalent to $3^{2^{k-1}}  \\equiv -1 \\pmod p$, which remains to prove.\n\n\n\n$3^{2^{k-1}} = 3^{(p-1)/2} \\equiv \\legendre{3}{p} \\pmod p$.\n\n\n\nAs the result is true for $p=5$, we can suppose $n\\geq 2$.\n\nFrom the law of quadratic reciprocity :\n\n$$\\legendre{3}{p} \\legendre{p}{3} = (-1)^{(p-1)/2} = (-1)^{2^{k-1}} = 1.$$\n\nSo $\\legendre{3}{p} = \\legendre{p}{3}$\n\n \n\n\\begin{align*}\n\np = 2^{2^n}+1 &\\equiv (-1)^{2^n} + 1 \\pmod 3\\\\\n\n&\\equiv 2 \\equiv -1 \\pmod 3,\n\n\\end{align*}\n\nso $\\legendre{3}{p} = \\legendre {p}{3} = -1$, that is to say\n\n$$3^{2^{k-1}}  \\equiv -1 \\pmod p.$$\n\nThe order of $3$ modulo $p = 2^{2^n} + 1$ is $p-1 = 2^{2^n}$ : $3$ is a primitive root modulo $p$.\n\n\n\n(On the other hand, if $3$ is of order $p-1$ modulo $p$, then $p$ is prime, so\n\n$$ F_n = 2^{2^n} + 1 \\ \\mathrm{is}\\ \\mathrm{prime}\\ \\iff 3^{(F_n-1)/2} = 3^{2^{2^n - 1}} \\equiv -1 \\pmod {F_n}.)$$\n\n\\end{proof}", "formal_statement": "theorem exercise_4_6 {p n : \u2115} (hp : p.prime) (hpn : p = 2^n + 1) : \n  is_primitive_root 3 p :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " fermat_prime.primitive_root_three (p : \u2115) (hp : fermat_prime p) :\n  primitive_root 3 p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem gaussian_int.prime_of_nat_prime_of_mod_four_eq_three (p : \u2115)\n\t[hp : fact (nat.prime p)] (hp3 : p % 4 = 3) :\n\tprime \u2191p\n\ntheorem nat.prime.five_le_of_ne_two_of_ne_three {p : \u2115} (hp : nat.prime p)\n\t(h_two : p \u2260 2) (h_three : p \u2260 3) :\n\t5 \u2264 p\n\ntheorem nat.prime.is_prime_pow {p : \u2115} (hp : nat.prime p) :\n\tis_prime_pow p\n\ntheorem nat.totient_prime {p : \u2115} (hp : nat.prime p) :\n\tp.totient = p - 1\n\nThe following is the natural language theorem statement: \"If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " fermat_prime_of_primitive_root_3 (p : \u2115) (hp : nat.prime p) \n  (h : p = 2 ^ nat.find_prime p + 1) :\n  nat.primitive_root 3 p ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_4_11", "nl_statement": "Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.", "nl_proof": "\\begin{proof}    \n\nLet $S_k = 1^k+2^k+\\cdots+(p-1)^k$.\n\n\n\nLet $g$ a primitive root modulo $p$ : $\\overline{g}$ a generator of $\\mathbb{F}_p^*$.\n\n\n\nAs $(\\overline{1},\\overline{g},\\overline{g}^{2}, \\ldots, \\overline{g}^{p-2}) $ is a permutation of $ (\\overline{1},\\overline{2}, \\ldots,\\overline{p-1})$,\n\n\\begin{align*}\n\n\\overline{S_k} &= \\overline{1}^k + \\overline{2}^k+\\cdots+ \\overline{p-1}^k\\\\\n\n&= \\sum_{i=0}^{p-2} \\overline{g}^{ki} =\n\n\\left\\{\n\n\\begin{array}{ccc}\n\n\\overline{ p-1} = -\\overline{1} &  \\mathrm{if} &  p-1 \\mid k  \\\\\n\n \\frac{ \\overline{g}^{(p-1)k} -1}{ \\overline{g}^k -1} = \\overline{0}&  \\mathrm{if}  &   p-1 \\nmid k\n\n\\end{array}\n\n\\right.\n\n\\end{align*}\n\nsince $p-1 \\mid k \\iff \\overline{g}^k = \\overline{1}$.\n\n\n\nConclusion :\n\n\\begin{align*}\n\n1^k+2^k+\\cdots+(p-1)^k&\\equiv 0 \\pmod p\\ \\mathrm{if} \\ p-1 \\nmid k\\\\\n\n1^k+2^k+\\cdots+(p-1)^k&\\equiv -1 \\pmod p\\ \\mathrm{if} \\ p-1 \\mid k\\\\\n\n\\end{align*}\n\n\\end{proof}", "formal_statement": "theorem exercise_4_11 {p : \u2115} (hp : p.prime) (k s: \u2115) \n  (s :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " sum_pow_congr_zero_of_not_dvd_of_prime {p k : \u2115} (hp : nat.prime p)\n  (hk : \u00acp - 1 \u2223 k) :\n  (finset.range (p - 1)).sum (\u03bb (x : \u2115), x ^ k) \u2261 0 [MOD p] ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.not_pos_pow_dvd {p k : \u2115} (hp : 1 < p) (hk : 1 < k) :\n\t\u00acp ^ k \u2223 p\n\ntheorem nat.arithmetic_function.card_distinct_factors_apply_prime_pow {p k : \u2115}\n\t(hp : nat.prime p) (hk : k \u2260 0) :\n\t\u21d1nat.arithmetic_function.card_distinct_factors (p ^ k) = 1\n\ntheorem nat.sum_divisors_prime_pow {\u03b1 : Type*} [add_comm_monoid \u03b1] {k p : \u2115}\n\t{f : \u2115 \u2192 \u03b1} (h : nat.prime p) :\n\t(p ^ k).divisors.sum (\u03bb (x : \u2115), f x) = (finset.range (k + 1)).sum (\u03bb (x : \u2115), f (p ^ x))\n\ntheorem nat.totient_mul_of_prime_of_not_dvd {p n : \u2115} (hp : nat.prime p)\n\t(h : \u00acp \u2223 n) :\n\t(p * n).totient = (p - 1) * n.totient\n\nThe following is the natural language theorem statement: \"Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sum_pow_mod_p_of_p_sub_one_not_dvd_k {p k : \u2115} (hp : nat.prime p) \n  (hk : \u00acp - 1 \u2223 k) :\n  (\u2211 i in finset.range (p - 1), i ^ k) % p = 0 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_5_28", "nl_statement": "Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$.", "nl_proof": "\\begin{proof}    \n\nIf  $p\\equiv 1\\ [4]$ and if there exists $x \\in \\mathbb{Z}$ such that $x^4 \\equiv 2\\ [p]$, then\n\n$$2^{\\frac{p-1}{4} }\\equiv  x^{p-1} \\equiv 1 \\ [p].$$ \n\n\n\nFrom Ex. 5.27, where $p = a^2 +b^2, a$ odd,  we know that $$f^{\\frac{ab}{2}} \\equiv 2^{\\frac{p-1}{4} } \\equiv 1 \\ [p].$$\n\n\n\nSince $f^2 \\equiv -1\\ [p]$, the order of $f$ modulo $p$ is 4, thus $4 \\mid \\frac{ab}{2}$, so $8\\mid ab$.\n\n\n\nAs $a$ is odd, $8 | b$, then $p = A^2 + 64 B^2$ (with $A = a, B = b/8$).\n\n\n\n\\bigskip\n\n\n\nConversely, if $p=A^2+64 B^2$, then $p\\equiv A^2 \\equiv 1 \\ [4]$.\n\n\n\nLet $a=A,b=8B$. Then $$2^{\\frac{p-1}{4} } \\equiv f^{\\frac{ab}{2}} \\equiv f^{4AB} \\equiv (-1)^{2AB} \\equiv 1 \\ [p].$$\n\n\n\nAs $2^{\\frac{p-1}{4} } \\equiv 1 \\ [p]$, $x^4 \\equiv 2 \\ [p]$ has a solution in $\\mathbb{Z}$ (Prop. 4.2.1) : $2$ is a biquadratic residue modulo $p$.\n\n\n\nConclusion : \n\n\n\n$$\\exists A \\in \\mathbb{Z}, \\exists B \\in \\mathbb{Z}\\,, p = A^2+64 B^2 \\iff( p\\equiv 1 \\ [4] \\ \\mathrm{and} \\ \\exists x \\in \\mathbb{Z}, \\, x^4 \\equiv 2 \\ [p]).$$\n\n\\end{proof}", "formal_statement": "theorem exercise_5_28 {p : \u2115} (hp : p.prime) (hp1 : p \u2261 1 [MOD 4]): \n  \u2203 x, x^4 \u2261 2 [MOD p] \u2194 \u2203 A B, p = A^2 + 64*B^2 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_sq_eq_two_iff_of_eq_one_mod_four {p : \u2115} [fact (nat.prime p)]\n  (hp : p % 4 = 1) :\n  is_square 2 \u2194 \u2203 (a b : \u2115), p = a ^ 2 + 64 * b ^ 2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem zmod.exists_sq_eq_two_iff {p : \u2115} [fact (nat.prime p)] (hp : p \u2260 2) :\n\tis_square 2 \u2194 p % 8 = 1 \u2228 p % 8 = 7\n\ntheorem zmod.exists_sq_eq_neg_two_iff {p : \u2115} [fact (nat.prime p)] (hp : p \u2260 2) :\n\tis_square (-2) \u2194 p % 8 = 1 \u2228 p % 8 = 3\n\ntheorem exists_add_order_of_eq_prime_pow_iff {G : Type u} {x : G} [add_monoid G]\n\t{p : \u2115} [hp : fact (nat.prime p)] :\n\t(\u2203 (k : \u2115), add_order_of x = p ^ k) \u2194 \u2203 (m : \u2115), p ^ m \u2022 x = 0\n\ntheorem nat.prime.eq_two_or_odd {p : \u2115} (hp : nat.prime p) :\n\tp = 2 \u2228 p % 2 = 1\n\nThe following is the natural language theorem statement: \"Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_solution_of_x_4_equiv_2_of_p_equiv_1_mod_4_iff_p_eq_A_2_add_64_B_2\n  (p : \u2115) (hp : nat.prime p) (h : p % 4 = 1) :\n  \u2203 (x : \u2115), x ^ 4 \u2261 2 [MOD p] \u2194\n  \u2203 (A B : \u2115), p = A ^ 2 + 64 * B ^ 2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Ireland-Rosen|exercise_12_12", "nl_statement": "Show that $\\sin (\\pi / 12)$ is an algebraic number.", "nl_proof": "\\begin{proof}\n\n$$\n\n\\begin{aligned}\n\n    \\sin \\pi/12=\\sin \\left(\\pi/4-\\pi/6\\right) & =\\sin \\pi/4 \\cos \\pi/6-\\cos \\pi/4 \\sin \\pi/6 \\\\\n\n& =\\frac{\\sqrt{3}}{2 \\sqrt{2}}-\\frac{1}{2 \\sqrt{2}} \\\\\n\n& =\\frac{\\sqrt{3}-1}{2 \\sqrt{2}}\n\n\\end{aligned}\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_12_12 : is_algebraic \u211a (sin (real.pi/12)) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen zsqrtd gaussian_int char_p nat.arithmetic_function \n\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " real.sin_pi_div_twelve :\n\treal.sin (real.pi / 12) = real.sqrt (3 + 2 * real.sqrt 2) / 2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem complex.sin_pi_div_two :\n\tcomplex.sin (\u2191real.pi / 2) = 1\n\ntheorem real.sin_pi_div_sixteen :\n\treal.sin (real.pi / 16) = real.sqrt (2 - real.sqrt (2 + real.sqrt 2)) / 2\n\ntheorem real.sin_pi_div_two :\n\treal.sin (real.pi / 2) = 1\n\ntheorem real.sin_pi_div_four :\n\treal.sin (real.pi / 4) = real.sqrt 2 / 2\n\nThe following is the natural language theorem statement: \"Show that $\\sin (\\pi / 12)$ is an algebraic number.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " algebraic_sin_pi_div_12 : algebraic \u2102 (sin (\u03c0 / 12)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $\\sin (\\pi / 12)$ is an algebraic number.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_1_2", "nl_statement": "Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).", "nl_proof": "\\begin{proof}\n\n$$\n\n\\left(\\frac{-1+\\sqrt{3} i}{2}\\right)^2=\\frac{-1-\\sqrt{3} i}{2},\n\n$$\n\nhence\n\n$$\n\n\\left(\\frac{-1+\\sqrt{3} i}{2}\\right)^3=\\frac{-1-\\sqrt{3} i}{2} \\cdot \\frac{-1+\\sqrt{3} i}{2}=1\n\n$$\n\nThis means $\\frac{-1+\\sqrt{3} i}{2}$ is a cube root of 1.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_2 :\n  (\u27e8-1/2, real.sqrt 3 / 2\u27e9 : \u2102) ^ 3 = -1 :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " cube_root_of_one :\n\t((-1 : \u2102) + complex.sqrt 3 * complex.I) / 2 = 1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem real.sqrt_one :\n\treal.sqrt 1 = 1\n\ntheorem complex.sin_pi_div_two :\n\tcomplex.sin (\u2191real.pi / 2) = 1\n\ntheorem complex.exp_two_pi_mul_I :\n\tcomplex.exp (2 * \u2191real.pi * complex.I) = 1\n\ntheorem complex.norm_sq_I :\n\t\u21d1complex.norm_sq complex.I = 1\n\nThe following is the natural language theorem statement: \"Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " cube_root_of_1_of_sqrt_3_i :\n  (complex.I * \u221a3 / 2) ^ 3 = 1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_1_4", "nl_statement": "Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.", "nl_proof": "\\begin{proof}\n\n    If $a=0$, then we immediately have our result. So suppose $a \\neq 0$. Then, because $a$ is some nonzero real or complex number, it has a multiplicative inverse $\\frac{1}{a}$. Now suppose that $v$ is some vector such that\n\n$$\n\na v=0\n\n$$\n\nMultiply by $\\frac{1}{a}$ on both sides of this equation to get\n\n$$\n\n\\begin{aligned}\n\n\\frac{1}{a}(a v) & =\\frac{1}{a} 0 & & \\\\\n\n\\frac{1}{a}(a v) & =0 & & \\\\\n\n\\left(\\frac{1}{a} \\cdot a\\right) v & =0 & & \\text { (associativity) } \\\\\n\n1 v & =0 & & \\text { (definition of } 1/a) \\\\\n\nv & =0 & & \\text { (multiplicative identity) }\n\n\\end{aligned}\n\n$$\n\nHence either $a=0$ or, if $a \\neq 0$, then $v=0$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_4 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (v : V) (a : F): a \u2022 v = 0 \u2194 a = 0 \u2228 v = 0 :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " smul_eq_zero_iff_eq {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [add_monoid \u03b2]\n  [distrib_mul_action \u03b1 \u03b2] (a : \u03b1) {x : \u03b2} :\n  a \u2022 x = 0 \u2194 a = 0 \u2228 x = 0 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem module.eval_apply_eq_zero_iff (K : Type*) {V : Type*} [field K]\n\t[add_comm_group V] [module K V] (v : V) :\n\t\u21d1(module.dual.eval K V) v = 0 \u2194 v = 0\n\ntheorem module.forall_dual_apply_eq_zero_iff (K : Type*) {V : Type*} [field K]\n\t[add_comm_group V] [module K V] (v : V) :\n\t(\u2200 (\u03c6 : module.dual K V), \u21d1\u03c6 v = 0) \u2194 v = 0\n\ntheorem smul_eq_zero_iff_eq {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [add_monoid \u03b2]\n\t[distrib_mul_action \u03b1 \u03b2] (a : \u03b1) {x : \u03b2} :\n\ta \u2022 x = 0 \u2194 x = 0\n\ntheorem div_eq_zero_iff {G\u2080 : Type*} [group_with_zero G\u2080] {a b : G\u2080} :\n\ta / b = 0 \u2194 a = 0 \u2228 b = 0\n\nThe following is the natural language theorem statement: \"Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " mul_zero_iff_zero_or_zero {K V : Type*} [field K] [add_comm_group V] \n  [vector_space K V] (a : K) (v : V) :\n  a \u2022 v = 0 \u2194 a = 0 \u2228 v = 0 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_1_7", "nl_statement": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.", "nl_proof": "\\begin{proof}\n\n$$\n\nU=\\left\\{(x, y) \\in \\mathbf{R}^2:|x|=|y|\\right\\}\n\n$$\n\nFor $(x, y) \\in U$ and $\\lambda \\in \\mathbb{R}$, it follows $\\lambda(x, y)=$ $(\\lambda x, \\lambda y)$, so $|\\lambda x|=|\\lambda||x|=|\\lambda||y|=|\\lambda y|$. Therefore, $\\lambda(x, y) \\in U$.\n\n\n\nOn the other hand, consider $a=(1,-1), b=$ $(1,1) \\in U$. Then, $a+b=(1,-1)+(1,1)=$ $(2,0) \\notin U$. So, $U$ is not a subspace of $\\mathbb{R}^2$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_7 : \u2203 U : set (\u211d \u00d7 \u211d),\n  (U \u2260 \u2205) \u2227\n  (\u2200 (c : \u211d) (u : \u211d \u00d7 \u211d), u \u2208 U \u2192 c \u2022 u \u2208 U) \u2227\n  (\u2200 U' : submodule \u211d (\u211d \u00d7 \u211d), U \u2260 \u2191U') :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " not_subspace_of_closed_under_scalar_multiplication\n  {R : Type*} [comm_ring R] [add_comm_group R] [topological_space R]\n  [topological_add_group R] [module R R] (U : set R)\n  (hU : \u2200 (r : R) (x : R), x \u2208 U \u2192 r \u2022 x \u2208 U) (hU0 : \u2205 \u2260 U) :\n  \u00ac is_submodule U ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem open_add_subgroup.neg_mem {G : Type*} [add_group G]\n\t[topological_space G] (U : open_add_subgroup G) {g : G} (h : g \u2208 U) :\n\t-g \u2208 U\n\ntheorem subgroup.is_open_of_open_subgroup {G : Type*} [group G]\n\t[topological_space G] [has_continuous_mul G] (H : subgroup G)\n\t{U : open_subgroup G} (h : U.to_subgroup \u2264 H) :\n\tis_open \u2191H\n\ntheorem submodule.is_open_mono {R M : Type*} [comm_ring R] [add_comm_group M]\n\t[topological_space M] [topological_add_group M] [module R M]\n\t{U P : submodule R M} (h : U \u2264 P) (hU : is_open \u2191U) :\n\tis_open \u2191P\n\ntheorem open_subgroup.inv_mem {G : Type*} [group G] [topological_space G]\n\t(U : open_subgroup G) {g : G} (h : g \u2208 U) :\n\tg\u207b\u00b9 \u2208 U\n\nThe following is the natural language theorem statement: \"Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_subspace_of_closed_under_scalar_mul {U : Type*} [add_comm_group U]\n  [vector_space \u211d U] (hU : \u2200 (x : \u211d) (u : U), u \u2208 U \u2192 x \u2022 u \u2208 U)\n  (hU_ne : U \u2260 (0 : U)) : \u00ac is_subspace U ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_1_9", "nl_statement": "Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.", "nl_proof": "\\begin{proof}\n\n    To prove this one way, suppose for purposes of contradiction that for $U_1$ and $U_2$, which are subspaces of $V$, that $U_1 \\cup U_2$ is a subspace and neither is completely contained within the other. In other words, $U_1 \\nsubseteq U_2$ and $U_2 \\nsubseteq U_1$. We will show that you can pick a vector $v \\in U_1$ and a vector $u \\in U_2$ such that $v+u \\notin U_1 \\cup U_2$, proving that if $U_1 \\cup U_2$ is a subspace, one must be completely contained inside the other.\n\n\n\nIf $U_1 \\nsubseteq U_2$, we can pick a $v \\in U_1$ such that $v \\notin U_2$. Since $v$ is in the subspace $U_1$, then $(-v)$ must also be, by definition. Similarly, if $U_2 \\nsubseteq U_1$, then we can pick a $u \\in U_2$ such that $u \\notin U_1$. Since $u$ is in the subspace $U_2$, then $(-u)$ must also be, by definition.\n\n\n\nIf $v+u \\in U_1 \\cup U_2$, then $v+u$ must be in $U_1$ or $U_2$. But, $v+u \\in U_1 \\Rightarrow v+u+(-v) \\in U_1 \\Rightarrow u \\in U_1$\n\nSimilarly,\n\n$$\n\nv+u \\in U_2 \\Rightarrow v+u+(-u) \\in U_2 \\Rightarrow v \\in U_2\n\n$$\n\nThis is clearly a contradiction, as each element was defined to not be in these subspaces. Thus our initial assumption must have been wrong, and $U_1 \\subseteq U_2$ or $U_2 \\subseteq U_1$\n\nTo prove the other way, Let $U_1 \\subseteq U_2$ (WLOG). $U_1 \\subseteq U_2 \\Rightarrow U_1 \\cup U_2=U_2$. Since $U_2$ is a subspace, $U_1 \\cup U_2$ is as well. QED.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_9 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (U W : submodule F V):\n  \u2203 U' : submodule F V, (U'.carrier = \u2191U \u2229 \u2191W \u2194 (U \u2264 W \u2228 W \u2264 U)) :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " subspace.union_iff {V : Type*} [add_comm_group V] [vector_space \u2102 V]\n  {U\u2081 U\u2082 : subspace V} :\n  subspace.subtype (U\u2081.val \u222a U\u2082.val) \u2194 U\u2081 \u2264 U\u2082 \u2228 U\u2082 \u2264 U\u2081 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem open_add_subgroup.coe_subset {G : Type*} [add_group G]\n\t[topological_space G] {U V : open_add_subgroup G} :\n\t\u2191U \u2286 \u2191V \u2194 U \u2264 V\n\ntheorem open_add_subgroup.coe_inf {G : Type*} [add_group G]\n\t[topological_space G] {U V : open_add_subgroup G} :\n\t\u2191(U \u2293 V) = \u2191U \u2229 \u2191V\n\ntheorem open_subgroup.coe_inf {G : Type*} [group G] [topological_space G]\n\t{U V : open_subgroup G} :\n\t\u2191(U \u2293 V) = \u2191U \u2229 \u2191V\n\ntheorem open_add_subgroup.ext_iff {G : Type*} [add_group G]\n\t[topological_space G] {U V : open_add_subgroup G} :\n\tU = V \u2194 \u2200 (x : G), x \u2208 U \u2194 x \u2208 V\n\nThe following is the natural language theorem statement: \"Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " union_subspace_iff_subset {K V : Type*} [field K] [add_comm_group V] \n  [vector_space K V] {U\u2081 U\u2082 : subspace V} :\n  U\u2081 \u2294 U\u2082 = \u22a4 \u2194 U\u2081 \u2286 U\u2082 \u2228 U\u2082 \u2286 U\u2081 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_3_8", "nl_statement": "Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$.", "nl_proof": "\\begin{proof}\n\n    The point here is to note that every subspace of a vector space has a complementary subspace.\n\nIn this example, $U$ will precisely turn out to be the complementary subspace of null $T$. That is, $V=U \\oplus \\operatorname{null} T$\n\nHow should we characterize $U$ ? This can be achieved by extending a basis $B_1=\\left\\{v_1, v_2, \\ldots, v_m\\right\\}$ of null $T$ to a basis of $V$. Let $B_2=\\left\\{u_1, u_2, \\ldots, u_n\\right\\}$ be such that $B=B_1 \\cup B_2$ is a basis of $V$.\n\n\n\nDefine $U=\\operatorname{span}\\left(B_2\\right)$. Now, since $B_1$ and $B_2$ are complementary subsets of the basis $B$ of $V$, their spans will turn out to be complementary subspaces of $V$. Let's prove that $V=U \\oplus$ null $T$.\n\n\n\nLet $v \\in V$. Then, $v$ can be expressed as a linear combination of the vectors in $B$.\n\nLet $v=a_1 u_1+\\cdots+a_n u_n+c_1 v_1+\\cdots+c_m v_m$. However, since $\\left\\{u_1, u_2, \\ldots, u_n\\right\\}$ is a basis of $U, a_1 u_1+$ $\\cdots+a_n u_n=u \\in U$ and since $\\left\\{v_1, v_2, \\ldots, v_m\\right\\}$ is a basis of null $T, c_1 v_1+\\cdots+c_m v_m=w \\in$ null $T$.\n\nHence, $v=u+w \\in U+\\operatorname{null} T$. This shows that\n\n$$\n\nV=U+\\operatorname{null} T\n\n$$\n\nNow, let $v \\in U \\cap \\operatorname{null} T$.\n\nSince $v \\in U, u$ can be expressed as a linear combination of basis vectors of $U$. Let\n\n$$\n\nv=a_1 u_1+\\cdots+a_n u_n\n\n$$\n\nSimilarly, since $v \\in \\operatorname{null} T$, it can also be expressed as a tinear combination of the basis vectors of null $T$. Let\n\n$$\n\nv=c_1 v_1+\\cdots+c_m v_m\n\n$$\n\nThe left hand sides of the above two equations are equal. Therefore, we can equate the right hand sides.\n\n$$\n\n\\begin{aligned}\n\n& a_1 u_1+\\cdots+a_n u_n=v=c_1 v_1+\\cdots+c_m v_m \\\\\n\n& a_1 u_1+\\cdots+a_n u_n-c_1 v_1-\\cdots-c_m v_m=0\n\n\\end{aligned}\n\n$$\n\nWe have found a linear combination of $u_i^{\\prime}$ 's and $v_i$ 's which is equal to zero. However, they are basis vectors of $V$. Hence, all the multipliers $c_i$ 's and $a_i$ 's must be zero implying that $v=0$.\n\nTherefore, if $v \\in U \\cap$ null $T$, then $v=0$. this means that\n\n$$\n\nU \\cap \\operatorname{null} T=\\{0\\}\n\n$$\n\nThe above shows that $U$ satisfies the first of the required conditions.\n\nNow let $w \\in$ range $T$. Then, there exists $v \\in V$ such that $T v=w$. This allows us to write $v=u+w$ where $u \\in U$ and $w \\in$ null $T$. This implies\n\n$$\n\n\\begin{aligned}\n\nw & =T v \\\\\n\n& =T(u+w) \\\\\n\n& =T u+T w \\\\\n\n& =T u+0 \\quad \\quad(\\text { since } w \\in \\operatorname{null} T) \\\\\n\n& =T u\n\n\\end{aligned}\n\n$$\n\nThis shows that if $w \\in$ range $T$ then $w=T u$ for some $u \\in U$. Therefore, range $T \\subseteq\\{T u \\mid u \\in U\\}$.\n\nSince $U$ is a subspace of $V$, it follows that $T u \\in$ range $T$ for all $u \\in U$. Thus, $\\{T u \\mid u \\in U\\} \\subseteq$ range $T$.\n\nTherefore, range $T=\\{T u \\mid u \\in U\\}$.\n\nThis shows that $U$ satisfies the second required condition as well.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_8 {F V W : Type*}  [add_comm_group V]\n  [add_comm_group W] [field F] [module F V] [module F W]\n  (L : V \u2192\u2097[F] W) :\n  \u2203 U : submodule F V, U \u2293 L.ker = \u22a5 \u2227\n  linear_map.range L = range (dom_restrict L U):=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " exists_subspace_of_range_eq_image {K : Type u} {V : Type v} [field K]\n  [add_comm_group V] [module K V] [finite_dimensional K V] {W : Type w}\n  [add_comm_group W] [module K W] (T : V \u2192\u2097[K] W) :\n  \u2203 (U : submodule K V), U.comap T = \u22a5 \u2227 T.range = T '' U ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subspace.dual_equiv_dual_def {K : Type u} {V : Type v} [field K]\n\t[add_comm_group V] [module K V] (W : subspace K V) :\n\tW.dual_equiv_dual.to_linear_map = W.dual_lift.range_restrict\n\ntheorem subspace.finrank_add_finrank_dual_annihilator_comap_eq {K : Type u}\n\t{V : Type v} [field K] [add_comm_group V] [module K V] [finite_dimensional K V]\n\t(W : subspace K (module.dual K V)) :\n\tfinite_dimensional.finrank K \u21a5W + finite_dimensional.finrank K \u21a5(submodule.dual_annihilator_comap W) = finite_dimensional.finrank K V\n\ntheorem subspace.dual_annihilator_comap_top {K : Type u} {V : Type v} [field K]\n\t[add_comm_group V] [module K V] (W : subspace K V) :\n\t\u22a4.dual_annihilator_comap = \u22a5\n\ntheorem continuous_linear_map.range_eq_map_coprod_subtypeL_equiv_of_is_compl\n\t{\ud835\udd5c : Type*} [nontrivially_normed_field \ud835\udd5c] {E : Type*} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_add_comm_group F] [normed_space \ud835\udd5c F]\n\t[complete_space F] [complete_space E] (f : E \u2192L[\ud835\udd5c] F) {G : submodule \ud835\udd5c F}\n\t(h : is_compl (linear_map.range f) G) [complete_space \u21a5G]\n\t(hker : linear_map.ker f = \u22a5) :\n\tlinear_map.range f = submodule.map \u2191(f.coprod_subtypeL_equiv_of_is_compl h hker) (\u22a4.prod \u22a5)\n\nThe following is the natural language theorem statement: \"Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_subspace_of_range_eq_range_of_null_eq_zero {V W : Type*} \n  [add_comm_group V] [add_comm_group W] [vector_space \u211d V] [vector_space \u211d W] \n  [finite_dimensional \u211d V] {T : V \u2192\u2097[\u211d] W} :\n  \u2203 (U : submodule \u211d V), U.comap T.to_fun = \u22a5 \u2227 range T = U.map T.to_fun ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_5_1", "nl_statement": "Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.", "nl_proof": "\\begin{proof}\n\n    First off, assume that $U_1, \\ldots, U_m$ are subspaces of $V$ invariant under $T$. Now, consider a vector $u \\in$ $U_1+\\ldots+U_m$. There does exist $u_1 \\in U_1, \\ldots, u_m \\in U_m$ such that $u=u_1+\\ldots+u_m$.\n\n\n\nOnce you apply $T$ towards both sides of the previous equation, we would then get $T u=T u_1+\\ldots+$ $T u_m$.\n\n\n\nSince each $U_j$ is invariant under $T$, then we would have $T u_1 \\in U_1+\\ldots+T u_m$. This would then make the equation shows that $T u \\in U_1+\\ldots+T u_m$, which does imply that $U_1+. .+U_m$ is invariant under $T$\n\n\\end{proof}", "formal_statement": "theorem exercise_5_1 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {L : V \u2192\u2097[F] V} {n : \u2115} (U : fin n \u2192 submodule F V)\n  (hU : \u2200 i : fin n, map L (U i) = U i) :\n  map L (\u2211 i : fin n, U i : submodule F V) =\n  (\u2211 i : fin n, U i : submodule F V) :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " submodule.sum_mem_supr {R M : Type*} [semiring R] [add_comm_monoid M]\n  [module R M] {\u03b9 : Type*} [fintype \u03b9] {f : \u03b9 \u2192 M} {p : \u03b9 \u2192 submodule R M}\n  (h : \u2200 (i : \u03b9), f i \u2208 p i) :\n  finset.univ.sum (\u03bb (i : \u03b9), f i) \u2208 \u2a06 (i : \u03b9), p i ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_independent.to_subtype_range' {R M : Type*} [ring R]\n\t[add_comm_group M] [module R M] {\u03b9 : Type*} {f : \u03b9 \u2192 M}\n\t(hf : linear_independent R f) {t : set M} (ht : set.range f = t) :\n\tlinear_independent R coe\n\ntheorem summable.comp_injective {\u03b1 \u03b2 \u03b3 : Type*} [add_comm_group \u03b1]\n\t[uniform_space \u03b1] [uniform_add_group \u03b1] {f : \u03b2 \u2192 \u03b1} [complete_space \u03b1]\n\t{i : \u03b3 \u2192 \u03b2} (hf : summable f) (hi : function.injective i) :\n\tsummable (f \u2218 i)\n\ntheorem submodule.sum_mem_supr {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {\u03b9 : Type*} [fintype \u03b9] {f : \u03b9 \u2192 M} {p : \u03b9 \u2192 submodule R M}\n\t(h : \u2200 (i : \u03b9), f i \u2208 p i) :\n\tfinset.univ.sum (\u03bb (i : \u03b9), f i) \u2208 \u2a06 (i : \u03b9), p i\n\ntheorem linear_independent_subtype_range {R M : Type*} [semiring R]\n\t[add_comm_monoid M] [module R M] {\u03b9 : Type*} {f : \u03b9 \u2192 M}\n\t(hf : function.injective f) :\n\tlinear_independent R coe \u2194 linear_independent R f\n\nThe following is the natural language theorem statement: \"Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " invariant_of_sum_invariant {V : Type*} [add_comm_group V] \n  [module \u2102 V] {T : V \u2192\u2097[\u2102] V} {U : Type*} [fintype U] {f : U \u2192 submodule \u2102 V} \n  (hf : \u2200 (i : U), T.range \u2286 f i) :\n  T.range \u2286 \u2a06 (i : U), f i ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_5_11", "nl_statement": "Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.", "nl_proof": "\\begin{proof}\n\n    To start, let $\\lambda \\in F$ be an eigenvalue of $S T$. Now, we would want $\\lambda$ to be an eigenvalue of $T S$. Since $\\lambda$, by itself, is an eigenvalue of $S T$, then there has to be a nonzero vector $v \\in V$ such that $(S T) v=\\lambda v$.\n\nNow, With a given reference that $(S T) v=\\lambda v$, you will then have the following: $(T S)(T v)=$ $T(S T v)=T(\\lambda v)=\\lambda T v$\n\nIf $T v \\neq 0$, then the listed equation above shows that $\\lambda$ is an eigenvalue of $T S$.\n\nIf $T v=0$, then $\\lambda=0$, since $S(T v)=\\lambda T v$. This also means that $T$ isn't invertible, which would imply that $T S$ isn't invertible, which can also be implied that $\\lambda$, which equals 0 , is an eigenvalue of $T S$.\n\nStep 3\n\n3 of 3\n\nNow, regardless of whether $T v=0$ or not, we would have shown that $\\lambda$ is an eigenvalue of $T S$. Since $\\lambda$ (was) an arbitrary eigenvalue of $S T$, we have shown that every single eigenvalue of $S T$ is an eigenvalue of $T S$. When you do reverse the roles of both $S$ and $T$, then we can conclude that that every single eigenvalue of $T S$ is also an eigenvalue of $S T$. Therefore, both $S T$ and $T S$ have the exact same eigenvalues.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_11 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (S T : End F V) :\n  (S * T).eigenvalues = (T * S).eigenvalues  :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " linear_map.is_symmetric.has_eigenvalue_eigenvalues_of_comm {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [dec_\ud835\udd5c : decidable_eq \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t{S T : E \u2192\u2097[\ud835\udd5c] E} (hS : S.is_symmetric) (hT : T.is_symmetric)\n\t(hST : S.comm T) [finite_dimensional \ud835\udd5c E] {n : \u2115}\n\t(hn : finite_dimensional.finrank \ud835\udd5c E = n) (i : fin n) :\n\tmodule.End.has_eigenvalue (S.mul T) \u2191(hS.eigenvalues hn i) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_map.is_symmetric.has_eigenvalue_eigenvalues {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [dec_\ud835\udd5c : decidable_eq \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t{T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) [finite_dimensional \ud835\udd5c E] {n : \u2115}\n\t(hn : finite_dimensional.finrank \ud835\udd5c E = n) (i : fin n) :\n\tmodule.End.has_eigenvalue T \u2191(hT.eigenvalues hn i)\n\ntheorem linear_map.is_symmetric.apply_eigenvector_basis {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [dec_\ud835\udd5c : decidable_eq \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t{T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) [finite_dimensional \ud835\udd5c E] {n : \u2115}\n\t(hn : finite_dimensional.finrank \ud835\udd5c E = n) (i : fin n) :\n\t\u21d1T (\u21d1(hT.eigenvector_basis hn) i) = \u2191(hT.eigenvalues hn i) \u2022 \u21d1(hT.eigenvector_basis hn) i\n\ntheorem inner_product_apply_eigenvector {\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*}\n\t[inner_product_space \ud835\udd5c E] {\u03bc : \ud835\udd5c} {v : E} {T : E \u2192\u2097[\ud835\udd5c] E}\n\t(h : v \u2208 module.End.eigenspace T \u03bc) :\n\thas_inner.inner v (\u21d1T v) = \u03bc * \u2191\u2016v\u2016 ^ 2\n\ntheorem linear_map.is_symmetric.has_eigenvector_eigenvector_basis {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [dec_\ud835\udd5c : decidable_eq \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t{T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) [finite_dimensional \ud835\udd5c E] {n : \u2115}\n\t(hn : finite_dimensional.finrank \ud835\udd5c E = n) (i : fin n) :\n\tmodule.End.has_eigenvector T \u2191(hT.eigenvalues hn i) (\u21d1(hT.eigenvector_basis hn) i)\n\nThe following is the natural language theorem statement: \"Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " eigenvalues_of_mul_eq_mul_eigenvalues {V : Type*} [finite_dimensional V]\n  [add_comm_group V] [vector_space \u2102 V] {S T : V \u2192\u2097[\u2102] V} :\n  eigenvalues (S * T) = eigenvalues (T * S) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_5_13", "nl_statement": "Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.", "nl_proof": "\\begin{proof}\n\n    First off, let $T$ isn't a scalar multiple of the identity operator. So, there does exists that $v \\in V$ such that $u$ isn't an eigenvector of $T$. Therefore, $(u, T u)$ is linearly independent.\n\n\n\nNext, you should extend $(u, T u)$ to a basis of $\\left(u, T u, v_1, \\ldots, v_n\\right)$ of $V$. So, let $U=\\operatorname{span}\\left(u, v_1, \\ldots, v_n\\right)$. Then, $U$ is a subspace of $V$ and $\\operatorname{dim} U=\\operatorname{dim} V-1$. However, $U$ isn't invariant under $T$ since both $u \\in U$ and $T u \\in U$. This given contradiction to our hypothesis about $T$ actually shows us that our guess that $T$ is not a scalar multiple of the identity must have been false.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_13 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] [finite_dimensional F V] {T : End F V}\n  (hS : \u2200 U : submodule F V, finrank F U = finrank F V - 1 \u2192\n  map T U = U) : \u2203 c : F, T = c \u2022 id :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " linear_map.is_scalar_multiple_of_id_of_invariant_subspace_of_dim_dim_sub_one\n  {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V]\n  [finite_dimensional K V] (T : V \u2192\u2097[K] V)\n  (hT : \u2200 (U : submodule K V), (U.dim = V.dim - 1) \u2192 T.range \u2286 U) :\n  \u2203 (c : K), T = c \u2022 1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_map.ker_to_span_singleton (K V : Type*) [field K]\n\t[add_comm_group V] [module K V] {x : V} (h : x \u2260 0) :\n\tlinear_map.ker (linear_map.to_span_singleton K V x) = \u22a5\n\ntheorem linear_map.is_symmetric.restrict_scalars {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) :\n\t(linear_map.restrict_scalars \u211d T).is_symmetric\n\ntheorem linear_map.is_symmetric.subsingleton_of_no_eigenvalue_finite_dimensional\n\t{\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t[finite_dimensional \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric)\n\t(hT' : \u2200 (\u03bc : \ud835\udd5c), module.End.eigenspace T \u03bc = \u22a5) :\n\tsubsingleton E\n\ntheorem linear_equiv.of_injective_endo_right_inv {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]\n\t(f : V \u2192\u2097[K] V) (h_inj : function.injective \u21d1f) :\n\tf * \u2191((linear_equiv.of_injective_endo f h_inj).symm) = 1\n\nThe following is the natural language theorem statement: \"Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " linear_map.is_scalar_of_dim_sub_one_invariant {K V : Type*} \n  [field K] [add_comm_group V] [vector_space K V] [finite_dimensional K V] \n  (T : V \u2192\u2097[K] V) (hT : \u2200 (U : submodule K V), U.dim = V.dim - 1 \u2192 T.range \u2286 U) :\n  \u2203 (c : K), T = c \u2022 linear_map.id ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_5_24", "nl_statement": "Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.", "nl_proof": "\\begin{proof}\n\n    First off, let us assume that $U$ is a subspace of $V$ that is invariant under $T$. Therefore, $\\left.T\\right|_U \\in \\mathcal{L}(U)$. If $\\operatorname{dim}$ $U$ were odd, then $\\left.T\\right|_U$ would have an eigenvalue $\\lambda \\in \\mathbb{R}$, so there would exist a nonzero vector $u \\in U$ such that\n\n$$\n\n\\left.T\\right|_U u=\\lambda u .\n\n$$\n\nSo, this would imply that $T_u=\\lambda u$, which would imply that $\\lambda$ is an eigenvalue of $T$. But $T$ has no eigenvalues, so $\\operatorname{dim} U$ must be even.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_24 {V : Type*} [add_comm_group V]\n  [module \u211d V] [finite_dimensional \u211d V] {T : End \u211d V}\n  (hT : \u2200 c : \u211d, eigenspace T c = \u22a5) {U : submodule \u211d V}\n  (hU : map T U = U) : even (finrank U) :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " linear_map.is_symmetric.subsingleton_of_no_eigenvalue_finite_dimensional\n  {\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n  [finite_dimensional \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric)\n  (hT' : \u2200 (\u03bc : \ud835\udd5c), module.End.eigenspace T \u03bc = \u22a5) :\n  subsingleton E ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_map.is_symmetric.subsingleton_of_no_eigenvalue_finite_dimensional\n\t{\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t[finite_dimensional \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric)\n\t(hT' : \u2200 (\u03bc : \ud835\udd5c), module.End.eigenspace T \u03bc = \u22a5) :\n\tsubsingleton E\n\ntheorem linear_map.is_symmetric.has_eigenvalue_eigenvalues {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [dec_\ud835\udd5c : decidable_eq \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t{T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) [finite_dimensional \ud835\udd5c E] {n : \u2115}\n\t(hn : finite_dimensional.finrank \ud835\udd5c E = n) (i : fin n) :\n\tmodule.End.has_eigenvalue T \u2191(hT.eigenvalues hn i)\n\ntheorem linear_map.is_symmetric.has_eigenvector_eigenvector_basis {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [dec_\ud835\udd5c : decidable_eq \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t{T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) [finite_dimensional \ud835\udd5c E] {n : \u2115}\n\t(hn : finite_dimensional.finrank \ud835\udd5c E = n) (i : fin n) :\n\tmodule.End.has_eigenvector T \u2191(hT.eigenvalues hn i) (\u21d1(hT.eigenvector_basis hn) i)\n\ntheorem linear_map.is_symmetric.orthogonal_supr_eigenspaces_eq_bot' {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E}\n\t(hT : T.is_symmetric) [finite_dimensional \ud835\udd5c E] :\n\t(\u2a06 (\u03bc : module.End.eigenvalues T), module.End.eigenspace T \u2191\u03bc)\u15ee = \u22a5\n\nThe following is the natural language theorem statement: \"Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " even_dim_of_no_eigenvalues {V : Type*} [add_comm_group V] \n  [vector_space \u211d V] [finite_dimensional \u211d V] {T : V \u2192\u2097[\u211d] V} \n  (hT : \u2200 (v : V), v \u2260 0 \u2192 T v \u2260 v) :\n  \u2200 (U : submodule \u211d V), U.is_invariant T \u2192 U.dim_eq 0 \u2228 U.dim_eq 2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_6_3", "nl_statement": "Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.", "nl_proof": "\\begin{proof}\n\n    Let $a_1, a_2, \\ldots, a_n, b_1, b_2, \\ldots, b_n \\in R$.\n\nWe have that\n\n$$\n\n\\left(\\sum_{j=1}^n a_j b_j\\right)^2\n\n$$\n\nis equal to the\n\n$$\n\n\\left(\\sum_{j=1}^n a_j b_j \\frac{\\sqrt{j}}{\\sqrt{j}}\\right)^2=\\left(\\sum_{j=1}^n\\left(\\sqrt{j} a_j\\right)\\left(b_j \\frac{1}{\\sqrt{j}}\\right)\\right)^2\n\n$$\n\nThis can be observed as an inner product, and using the Cauchy-Schwarz Inequality, we get\n\n$$\n\n\\begin{aligned}\n\n&\\left(\\sum_{j=1}^n a_j b_j\\right)^2=\\left(\\sum_{j=1}^n\\left(\\sqrt{j} a_j\\right)\\left(b_j \\frac{1}{\\sqrt{j}}\\right)\\right)^2 \\\\\n\n&=\\left\\langle\\left(a, \\sqrt{2} a_2, \\ldots, \\sqrt{n} a_n\\right),\\left(b_1, \\frac{b_2}{\\sqrt{2}}, \\ldots, \\frac{b_n}{\\sqrt{n}}\\right)\\right\\rangle \\\\\n\n& \\leq\\left\\|\\left(a, \\sqrt{2} a_2, \\ldots, \\sqrt{n} a_n\\right)\\right\\|^2\\left\\|\\left(b_1, \\frac{b_2}{\\sqrt{2}}, \\ldots, \\frac{b_n}{\\sqrt{n}}\\right)\\right\\|^2 \\\\\n\n&=\\left(\\sum_{j=1}^n j a_j^2\\right)\\left(\\sum_{j=1}^n \\frac{b_j^2}{j}\\right) \\\\\n\n& \\text { Hence, }\\left(\\sum_{j=1}^n a_j b_j\\right)^2=\\left(\\sum_{j=1}^n j a_j^2\\right)\\left(\\sum_{j=1}^n \\frac{b_j^2}{j}\\right) .\n\n\\end{aligned}\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_6_3 {n : \u2115} (a b : fin n \u2192 \u211d) :\n  (\u2211 i, a i * b i) ^ 2 \u2264 (\u2211 i : fin n, i * a i ^ 2) * (\u2211 i, b i ^ 2 / i) :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " sum_mul_le_sum_mul_sum_mul_inv {n : \u2115} {R : Type*} [comm_ring R]\n  (a b : fin n \u2192 R) :\n  (finset.univ.sum (\u03bb (i : fin n), a i * b i)) ^ 2 \u2264\n  (finset.univ.sum (\u03bb (i : fin n), i.val * a i ^ 2)) *\n  (finset.univ.sum (\u03bb (i : fin n), b i ^ 2 / i.val)) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.pred_mul_geom_sum_le (a b n : \u2115) :\n\t(b - 1) * (finset.range n.succ).sum (\u03bb (i : \u2115), a / b ^ i) \u2264 a * b - a / b ^ n\n\ntheorem nat.geom_sum_le {b : \u2115} (hb : 2 \u2264 b) (a n : \u2115) :\n\t(finset.range n).sum (\u03bb (i : \u2115), a / b ^ i) \u2264 a * b / (b - 1)\n\ntheorem fin.sum_pow_mul_eq_add_pow {n : \u2115} {R : Type*} [comm_semiring R]\n\t(a b : R) :\n\tfinset.univ.sum (\u03bb (s : finset (fin n)), a ^ s.card * b ^ (n - s.card)) = (a + b) ^ n\n\ntheorem nat.geom_sum_Ico_le {b : \u2115} (hb : 2 \u2264 b) (a n : \u2115) :\n\t(finset.Ico 1 n).sum (\u03bb (i : \u2115), a / b ^ i) \u2264 a / (b - 1)\n\nThe following is the natural language theorem statement: \"Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sum_mul_le_sum_mul_sum_inv_mul (n : \u2115) (a b : fin n \u2192 \u211d) :\n  (\u2211 i in finset.range n, a i * b i) ^ 2 \u2264\n    (\u2211 i in finset.range n, i * a i ^ 2) * (\u2211 i in finset.range n, b i ^ 2 / i) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_6_13", "nl_statement": "Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.", "nl_proof": "\\begin{proof}\n\nIf $v \\in \\operatorname{span}\\left(e_1, \\ldots, e_m\\right)$, it means that\n\n$$\n\nv=\\alpha_1 e_1+\\ldots+\\alpha_m e_m .\n\n$$\n\nfor some scalars $\\alpha_i$. We know that $\\alpha_k=\\left\\langle v, e_k\\right\\rangle, \\forall k \\in\\{1, \\ldots, m\\}$. Therefore,\n\n$$\n\n\\begin{aligned}\n\n\\|v\\|^2 & =\\langle v, v\\rangle \\\\\n\n& =\\left\\langle\\alpha_1 e_1+\\ldots+\\alpha_m e_m, \\alpha_1 e_1+\\ldots+\\alpha_m e_m\\right\\rangle \\\\\n\n& =\\left|\\alpha_1\\right|^2\\left\\langle e_1, e_1\\right\\rangle+\\ldots+\\left|\\alpha_m\\right|^2\\left\\langle e_m, e_m\\right\\rangle \\\\\n\n& =\\left|\\alpha_1\\right|^2+\\ldots+\\left|\\alpha_m\\right|^2 \\\\\n\n& =\\left|\\left\\langle v, e_1\\right\\rangle\\right|^2+\\ldots+\\left|\\left\\langle v, e_m\\right\\rangle\\right|^2 .\n\n\\end{aligned}\n\n$$\n\n$\\Rightarrow$ Assume that $v \\notin \\operatorname{span}\\left(e_1, \\ldots, e_m\\right)$. Then, we must have\n\n$$\n\nv=v_{m+1}+\\frac{\\left\\langle v, v_0\\right\\rangle}{\\left\\|v_0\\right\\|^2} v_0,\n\n$$\n\nwhere $v_0=\\alpha_1 e_1+\\ldots+\\alpha_m e_m, \\alpha_k=\\left\\langle v, e_k\\right\\rangle, \\forall k \\in\\{1, \\ldots, m\\}$, and $v_{m+1}=v-$ $\\frac{\\left\\langle v, v_0\\right\\rangle}{\\left\\|v_0\\right\\|^2} v_0 \\neq 0$.\n\n\n\nWe have $\\left\\langle v_0, v_{m+1}\\right\\rangle=0$ (from which we get $\\left\\langle v, v_0\\right\\rangle=\\left\\langle v_0, v_0\\right\\rangle$ and $\\left\\langle v, v_{m+1}\\right\\rangle=$ $\\left.\\left\\langle v_{m+1}, v_{m+1}\\right\\rangle\\right)$. Now,\n\n$$\n\n\\begin{aligned}\n\n\\|v\\|^2 & =\\langle v, v\\rangle \\\\\n\n& =\\left\\langle v, v_{m+1}+\\frac{\\left\\langle v, v_0\\right\\rangle}{\\left\\|v_0\\right\\|^2} v_0\\right\\rangle \\\\\n\n& =\\left\\langle v, v_{m+1}\\right\\rangle+\\left\\langle v, \\frac{\\left\\langle v, v_0\\right\\rangle}{\\left\\|v_0\\right\\|^2} v_0\\right\\rangle \\\\\n\n& =\\left\\langle v_{m+1}, v_{m+1}\\right\\rangle+\\frac{\\left\\langle v_0, v_0\\right\\rangle}{\\left\\|v_0\\right\\|^2}\\left\\langle v_0, v_0\\right\\rangle \\\\\n\n& =\\left\\|v_{m+1}\\right\\|^2+\\left\\|v_0\\right\\|^2 \\\\\n\n& >\\left\\|v_0\\right\\|^2 \\\\\n\n& =\\left|\\alpha_1\\right|^2+\\ldots+\\left|\\alpha_m\\right|^2 \\\\\n\n& =\\left|\\left\\langle v, e_1\\right\\rangle\\right|^2+\\ldots+\\left|\\left\\langle v, e_m\\right\\rangle\\right|^2 .\n\n\\end{aligned}\n\n$$\n\nBy contrapositive, if $\\left\\|v_1\\right\\|^2=\\left|\\left\\langle v, e_1\\right\\rangle\\right|^2+\\ldots+\\left|\\left\\langle v, e_m\\right\\rangle\\right|^2$, then $v \\in \\operatorname{span}\\left(e_1, \\ldots, e_m\\right)$.\n\n\\end{proof}", "formal_statement": "theorem exercise_6_13 {V : Type*} [inner_product_space \u2102 V] {n : \u2115}\n  {e : fin n \u2192 V} (he : orthonormal \u2102 e) (v : V) :\n  \u2225v\u2225^2 = \u2211 i : fin n, \u2225\u27eav, e i\u27eb_\u2102\u2225^2 \u2194 v \u2208 span \u2102 (e '' univ) :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " orthonormal.norm_eq_sum_of_squares_iff_in_span {\ud835\udd5c E : Type*}\n  [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E] {\u03b9 : Type*} {v : basis \u03b9 \ud835\udd5c E}\n  (hv : orthonormal \ud835\udd5c \u21d1v) (i : \u03b9) (x : E) :\n  \u2225x\u2225 = \u2211 i, \u2225(\u21d1v i) \u2022 x\u2225 ^ 2 \u2194 x \u2208 submodule.span \ud835\udd5c (set.range v) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem orthonormal_basis.span_apply {\u03b9' \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*}\n\t[inner_product_space \ud835\udd5c E] {v' : \u03b9' \u2192 E} (h : orthonormal \ud835\udd5c v') (s : finset \u03b9')\n\t(i : \u21a5s) :\n\t\u2191(\u21d1(orthonormal_basis.span h s) i) = v' \u2191i\n\ntheorem orthonormal_basis.coe_mk {\u03b9 \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*}\n\t[inner_product_space \ud835\udd5c E] [fintype \u03b9] {v : \u03b9 \u2192 E} (hon : orthonormal \ud835\udd5c v)\n\t(hsp : \u22a4 \u2264 submodule.span \ud835\udd5c (set.range v)) :\n\t\u21d1(orthonormal_basis.mk hon hsp) = v\n\ndef orthonormal_basis.span {\u03b9' \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*}\n\t[inner_product_space \ud835\udd5c E] {v' : \u03b9' \u2192 E} (h : orthonormal \ud835\udd5c v') (s : finset \u03b9') :\n\torthonormal_basis \u21a5s \ud835\udd5c \u21a5(submodule.span \ud835\udd5c \u2191(finset.image v' s))\n\ntheorem orthonormal.equiv_to_linear_equiv {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] {\u03b9 \u03b9' E' : Type*} [inner_product_space \ud835\udd5c E']\n\t{v : basis \u03b9 \ud835\udd5c E} (hv : orthonormal \ud835\udd5c \u21d1v) {v' : basis \u03b9' \ud835\udd5c E'}\n\t(hv' : orthonormal \ud835\udd5c \u21d1v') (e : \u03b9 \u2243 \u03b9') :\n\t(hv.equiv hv' e).to_linear_equiv = v.equiv v' e\n\nThe following is the natural language theorem statement: \"Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " norm_eq_sum_of_squares_of_orthonormal_basis_iff_mem_span\n  {K : Type*} [field K] [inner_product_space K \u211d]\n  {n : \u2115} (e : fin n \u2192 K) (h : is_orthonormal_basis K e)\n  (v : K) :\n  \u2225v\u2225^2 = \u2211 i in finset.range n, (v \u2022 e i)^2 \u2194 v \u2208 span K (e '' finset.range n) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_7_5", "nl_statement": "Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$.", "nl_proof": "\\begin{proof}\n\n    First off, suppose that $\\operatorname{dim} V \\geq 2$. Next let $\\left(e_1, \\ldots, e_n\\right)$ be an orthonormal basis of $V$. Now, define $S, T \\in L(V)$ by both $S\\left(a_1 e_1+\\ldots+a_n e_n\\right)=a_2 e_1-a_1 e_2$ and $T\\left(a_1 e_1+\\ldots+\\right.$ $\\left.a_n e_n\\right)=a_2 e_1+a_1 e_2$. So, just by now doing a simple calculation verifies that $S^*\\left(a_1 e_1+\\right.$ $\\left.\\ldots+a_n e_n\\right)=-a_2 e_1+a_1 e_2$\n\n\n\nNow, based on this formula, another calculation would show that $S S^*=S^* S$. Another simple calculation would that that $T$ is self-adjoint. Therefore, both $S$ and $T$ are normal. However, $S+T$ is given by the formula of $(S+T)\\left(a_1 e_1+\\ldots+a_n e_n\\right)=2 a_2 e_1$. In this case, a simple calculator verifies that $(S+T)^*\\left(a_1 e_1+\\ldots+a_n e_n\\right)=2 a_1 e_2$.\n\n\n\nTherefore, there is a final simple calculation that shows that $(S+T)(S+T)^* \\neq(S+$ $T)^*(S+T)$. So, in other words, $S+T$ isn't normal. Thereofre, the set of normal operators on $V$ isn't closed under addition and hence isn't a subspace of $L(V)$.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_5 {V : Type*} [inner_product_space \u2102 V] \n  [finite_dimensional \u2102 V] (hV : finrank V \u2265 2) :\n  \u2200 U : submodule \u2102 (End \u2102 V), U.carrier \u2260\n  {T | T * T.adjoint = T.adjoint * T} :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " not_submodule_of_dim_ge_two {K : Type u} {V : Type v}\n  [division_ring K] [add_comm_group V] [module K V] (h : 2 \u2264 module.rank K V) :\n  \u00ac submodule K (normal_ops K V) (linear_map K V V) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem finite_dimensional_of_dim_eq_one {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V] (h : module.rank K V = 1) :\n\tfinite_dimensional K V\n\ntheorem finite_dimensional_of_dim_eq_zero {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V] (h : module.rank K V = 0) :\n\tfinite_dimensional K V\n\ntheorem finite_dimensional.finite_dimensional_of_finrank {K : Type u}\n\t{V : Type v} [division_ring K] [add_comm_group V] [module K V]\n\t(h : 0 < finite_dimensional.finrank K V) :\n\tfinite_dimensional K V\n\ntheorem finite_dimensional.nontrivial_of_finrank_pos {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V]\n\t(h : 0 < finite_dimensional.finrank K V) :\n\tnontrivial V\n\nThe following is the natural language theorem statement: \"Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_subspace_of_dim_ge_two {V : Type*} [field K] [add_comm_group V] \n  [vector_space K V] [finite_dimensional K V] (h : 2 \u2264 finite_dimensional.finrank K V) :\n  \u00ac submodule K (normal_ops K V) (linear_map.module K V) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_7_9", "nl_statement": "Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real.", "nl_proof": "\\begin{proof}\n\n    First off, suppose $V$ is a complex inner product space and $T \\in L(V)$ is normal. If $T$ is self-adjoint, then all its eigenvalues are real. So, conversely, let all of the eigenvalues of $T$ be real. By the complex spectral theorem, there's an orthonormal basis $\\left(e_1, \\ldots, e_n\\right)$ of $V$ consisting of eigenvectors of $T$. Thus, there exists real numbers $\\lambda_1, \\ldots, \\lambda_n$ such that $T e_j=\\lambda_j e_j$ for $j=$ $1, \\ldots, n$.\n\nThe matrix of $T$ with respect to the basis of $\\left(e_1, \\ldots, e_n\\right)$ is the diagonal matrix with $\\lambda_1, \\ldots, \\lambda_n$ on the diagonal. So, the matrix equals its conjugate transpose. Therefore, $T=T^*$. In other words, $T$ s self-adjoint.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_9 {V : Type*} [inner_product_space \u2102 V]\n  [finite_dimensional \u2102 V] (T : End \u2102 V)\n  (hT : T * T.adjoint = T.adjoint * T) :\n  is_self_adjoint T \u2194 \u2200 e : T.eigenvalues, (e : \u2102).im = 0 :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " is_self_adjoint_iff_eigenvalues_real {\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c]\n  {E : Type*} [inner_product_space \ud835\udd5c E] [complete_space E] {T : E \u2192L[\ud835\udd5c] E}\n  (hT : is_normal T) : is_self_adjoint T \u2194 \u2200 (\u03bc : module.End.eigenvalues T),\n  is_real \u03bc ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem continuous_linear_map.is_positive.is_self_adjoint {\ud835\udd5c E : Type*}\n\t[is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E] [complete_space E] {T : E \u2192L[\ud835\udd5c] E}\n\t(hT : T.is_positive) :\n\tis_self_adjoint T\n\ntheorem linear_map.is_symmetric.coe_to_self_adjoint {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] [complete_space E] {T : E \u2192\u2097[\ud835\udd5c] E}\n\t(hT : T.is_symmetric) :\n\t\u2191(hT.to_self_adjoint) = T\n\ntheorem linear_map.is_symmetric.orthogonal_family_eigenspaces' {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E}\n\t(hT : T.is_symmetric) :\n\torthogonal_family \ud835\udd5c (\u03bb (\u03bc : module.End.eigenvalues T), (module.End.eigenspace T \u2191\u03bc).subtype\u2097\u1d62)\n\ntheorem is_self_adjoint.eq_smul_self_of_is_local_extr_on {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E] [complete_space E]\n\t{T : E \u2192L[\ud835\udd5c] E} (hT : is_self_adjoint T) {x\u2080 : E}\n\t(hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 \u2016x\u2080\u2016) x\u2080) :\n\t\u21d1T x\u2080 = \u2191((\u03bb (x : E), T.re_apply_inner_self x / \u2016x\u2016 ^ 2) x\u2080) \u2022 x\u2080\n\nThe following is the natural language theorem statement: \"Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " self_adjoint_of_normal_of_eigenvalues_real {V : Type*} [inner_product_space \u2102 V]\n  [normed_group V] [normed_space \u2102 V] {T : V \u2192\u2097[\u2102] V} (hT : T.is_normal)\n  (hT_eigenvalues : \u2200 (\u03bb : \u2102), is_eigenvalue T \u03bb \u2192 \u03bb.is_real) :\n  T.is_self_adjoint ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Axler|exercise_7_11", "nl_statement": "Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)", "nl_proof": "\\begin{proof}\n\n    Let $V$ be a complex inner product space.\n\nIt is known that an operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if\n\n$$\n\nS^2=T\n\n$$\n\nNow, suppose that $T$ is a normal operator on $V$.\n\nBy the Complex Spectral Theorem, there is $e_1, \\ldots, e_n$ an orthonormal basis of $V$ consisting of eigenvalues of $T$ and let $\\lambda_1, \\ldots, \\lambda_n$ denote their corresponding eigenvalues.\n\nDefine $S$ by\n\n$$\n\nS e_j=\\sqrt{\\lambda_j} e_j,\n\n$$\n\nfor each $j=1, \\ldots, n$.\n\nObviously, $S^2 e_j=\\lambda_j e_j=T e_j$.\n\nHence, $S^2=T$ so there exist a square root of $T$.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_11 {V : Type*} [inner_product_space \u2102 V]\n  [finite_dimensional \u2102 V] {T : End \u2102 V} (hT : T*T.adjoint = T.adjoint*T) :\n  \u2203 (S : End \u2102 V), S ^ 2 = T :=", "src_header": "import .common \n\nopen set fintype complex polynomial submodule linear_map finite_dimensional\nopen module module.End inner_product_space\n\nopen_locale big_operators\n\n", "gpt_formal_statement": " exists_sqrt_of_normal {\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*}\n  [inner_product_space \ud835\udd5c E] [complete_space E] {T : E \u2192L[\ud835\udd5c] E}\n  (hT : T.is_normal) : \u2203 (S : E \u2192L[\ud835\udd5c] E), S.is_normal \u2227 S ^ 2 = T ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_self_adjoint.eq_smul_self_of_is_local_extr_on {\ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E] [complete_space E]\n\t{T : E \u2192L[\ud835\udd5c] E} (hT : is_self_adjoint T) {x\u2080 : E}\n\t(hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 \u2016x\u2080\u2016) x\u2080) :\n\t\u21d1T x\u2080 = \u2191((\u03bb (x : E), T.re_apply_inner_self x / \u2016x\u2016 ^ 2) x\u2080) \u2022 x\u2080\n\ntheorem linear_map.is_symmetric.restrict_scalars {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric) :\n\t(linear_map.restrict_scalars \u211d T).is_symmetric\n\ntheorem is_self_adjoint.eq_smul_self_of_is_local_extr_on_real {F : Type*}\n\t[inner_product_space \u211d F] [complete_space F] {T : F \u2192L[\u211d] F}\n\t(hT : is_self_adjoint T) {x\u2080 : F}\n\t(hextr : is_local_extr_on T.re_apply_inner_self (metric.sphere 0 \u2016x\u2080\u2016) x\u2080) :\n\t\u21d1T x\u2080 = (\u03bb (x : F), T.re_apply_inner_self x / \u2016x\u2016 ^ 2) x\u2080 \u2022 x\u2080\n\ntheorem linear_map.is_symmetric.subsingleton_of_no_eigenvalue_finite_dimensional\n\t{\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {E : Type*} [inner_product_space \ud835\udd5c E]\n\t[finite_dimensional \ud835\udd5c E] {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.is_symmetric)\n\t(hT' : \u2200 (\u03bc : \ud835\udd5c), module.End.eigenspace T \u03bc = \u22a5) :\n\tsubsingleton E\n\nThe following is the natural language theorem statement: \"Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_sqrt_of_normal {V : Type*} [inner_product_space \u2102 V] \n  [normed_group V] [normed_space \u2102 V] {T : V \u2192\u2097[\u2102] V} (hT : T.is_normal) :\n  \u2203 (S : V \u2192\u2097[\u2102] V), S.is_normal \u2227 S ^ 2 = T ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_2a", "nl_statement": "Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative.", "nl_proof": "\\begin{proof}\n\n    Not commutative since\n\n$$\n\n1 \\star(-1)=1-(-1)=2\n\n$$\n\n$$\n\n(-1) \\star 1=-1-1=-2 .\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_2a : \u2203 a b : \u2124, a - b \u2260 b - a :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_commute_of_add_commute_neg_neg {G : Type*} [subtraction_monoid G]\n  {a b : G} (h : add_commute a b) : \u00accommute a b ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem commute.neg_left {R : Type x} [has_mul R] [has_distrib_neg R] {a b : R} :\n\tcommute a b \u2192 commute (-a) b\n\ntheorem add_commute.neg_neg {G : Type*} [subtraction_monoid G] {a b : G} :\n\tadd_commute a b \u2192 add_commute (-a) (-b)\n\ntheorem commute.neg_right {R : Type x} [has_mul R] [has_distrib_neg R] {a b : R} :\n\tcommute a b \u2192 commute a (-b)\n\ntheorem add_commute.neg_left {G : Type*} [add_group G] {a b : G} :\n\tadd_commute a b \u2192 add_commute (-a) b\n\nThe following is the natural language theorem statement: \"Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_comm_star : \u00accommutative (\u03bb a b : \u2124, a - b) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_4", "nl_statement": "Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative.", "nl_proof": "\\begin{proof}\n\n    We have\n\n$$\n\n\\begin{aligned}\n\n(\\bar{a} \\cdot \\bar{b}) \\cdot \\bar{c} &=\\overline{a \\cdot b} \\cdot \\bar{c} \\\\\n\n&=\\overline{(a \\cdot b) \\cdot c} \\\\\n\n&=\\overline{a \\cdot(b \\cdot c)} \\\\\n\n&=\\bar{a} \\cdot \\overline{b \\cdot c} \\\\\n\n&=\\bar{a} \\cdot(\\bar{b} \\cdot \\bar{c})\n\n\\end{aligned}\n\n$$\n\nsince integer multiplication is associative.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_4 (n : \u2115) : \n  \u2200 (a b c : \u2115), (a * b) * c \u2261 a * (b * c) [ZMOD n] :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " nat.mul_mod_assoc (a b c : \u2115) :\n\t(a * b) % c = (a % c) * (b % c) % c ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.mul_mod (a b n : \u2115) :\n\ta * b % n = a % n * (b % n) % n\n\ntheorem nat.mul_add_mod (a b c : \u2115) :\n\t(a * b + c) % b = c % b\n\ntheorem nat.mod_mul_left_mod (a b c : \u2115) :\n\ta % (b * c) % c = a % c\n\ntheorem int.mul_mod (a b n : \u2124) :\n\ta * b % n = a % n * (b % n) % n\n\nThe following is the natural language theorem statement: \"Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " mul_assoc_mod (n : \u2115) (a b c : \u2124) :\n  (a % n) * (b % n) * (c % n) = (a * b * c) % n ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_15", "nl_statement": "Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$.", "nl_proof": "\\begin{proof}\n\n    For $n=1$, note that for all $a_1 \\in G$ we have $a_1^{-1}=a_1^{-1}$.\n\nNow for $n \\geq 2$ we proceed by induction on $n$. For the base case, note that for all $a_1, a_2 \\in G$ we have\n\n$$\n\n\\left(a_1 \\cdot a_2\\right)^{-1}=a_2^{-1} \\cdot a_1^{-1}\n\n$$\n\nsince\n\n$$\n\na_1 \\cdot a_2 \\cdot a_2^{-1} a_1^{-1}=1 .\n\n$$\n\nFor the inductive step, suppose that for some $n \\geq 2$, for all $a_i \\in G$ we have\n\n$$\n\n\\left(a_1 \\cdot \\ldots \\cdot a_n\\right)^{-1}=a_n^{-1} \\cdot \\ldots \\cdot a_1^{-1} .\n\n$$\n\nThen given some $a_{n+1} \\in G$, we have\n\n$$\n\n\\begin{aligned}\n\n\\left(a_1 \\cdot \\ldots \\cdot a_n \\cdot a_{n+1}\\right)^{-1} &=\\left(\\left(a_1 \\cdot \\ldots \\cdot a_n\\right) \\cdot a_{n+1}\\right)^{-1} \\\\\n\n&=a_{n+1}^{-1} \\cdot\\left(a_1 \\cdot \\ldots \\cdot a_n\\right)^{-1} \\\\\n\n&=a_{n+1}^{-1} \\cdot a_n^{-1} \\cdot \\ldots \\cdot a_1^{-1},\n\n\\end{aligned}\n\n$$\n\nusing associativity and the base case where necessary.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_15 {G : Type*} [group G] (as : list G) :\n  as.prod\u207b\u00b9 = (as.reverse.map (\u03bb x, x\u207b\u00b9)).prod :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " finprod_inv_distrib {G : Type*} {\u03b1 : Sort u_4} [division_comm_monoid G]\n  (f : \u03b1 \u2192 G) :\n  finprod (\u03bb (x : \u03b1), (f x)\u207b\u00b9) = (finprod (\u03bb (x : \u03b1), f x))\u207b\u00b9 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem fin.partial_prod_left_inv {n : \u2115} {G : Type*} [group G]\n\t(f : fin (n + 1) \u2192 G) :\n\tf 0 \u2022 fin.partial_prod (\u03bb (i : fin n), (f \u2191i)\u207b\u00b9 * f i.succ) = f\n\ntheorem fin.partial_prod_right_inv {n : \u2115} {G : Type*} [group G] (g : G)\n\t(f : fin n \u2192 G) (i : fin n) :\n\t((g \u2022 fin.partial_prod f) \u2191i)\u207b\u00b9 * (g \u2022 fin.partial_prod f) i.succ = f i\n\ntheorem pow_inv_comm {G : Type w} [group G] (a : G) (m n : \u2115) :\n\ta\u207b\u00b9 ^ m * a ^ n = a ^ n * a\u207b\u00b9 ^ m\n\ntheorem finprod_inv_distrib {G : Type*} {\u03b1 : Sort u_4} [division_comm_monoid G]\n\t(f : \u03b1 \u2192 G) :\n\tfinprod (\u03bb (x : \u03b1), (f x)\u207b\u00b9) = (finprod (\u03bb (x : \u03b1), f x))\u207b\u00b9\n\nThe following is the natural language theorem statement: \"Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " inv_prod_eq_prod_inv {G : Type*} [group G] {n : \u2115} (a : fin n \u2192 G) :\n  (\u220f i in finset.range n, a i)\u207b\u00b9 = \u220f i in finset.range n, (a i)\u207b\u00b9 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_17", "nl_statement": "Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$.", "nl_proof": "\\begin{proof}\n\n    We have $x \\cdot x^{n-1}=x^n=1$, so by the uniqueness of inverses $x^{-1}=x^{n-1}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_17 {G : Type*} [group G] {x : G} {n : \u2115}\n  (hxn: order_of x = n) :\n  x\u207b\u00b9 = x ^ (n-1) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " inv_eq_pow_sub_one_of_order_eq {G : Type u} [monoid G] (x : G) (n : \u2115)\n  (hx : x ^ n = 1) (hn : n \u2260 0) :\n  x\u207b\u00b9 = x ^ (n - 1) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem pow_order_of_eq_one {G : Type u} [monoid G] (x : G) :\n\tx ^ order_of x = 1\n\ntheorem order_of_eq_of_pow_and_pow_div_prime {G : Type u} {x : G} {n : \u2115}\n\t[monoid G] (hn : 0 < n) (hx : x ^ n = 1)\n\t(hd : \u2200 (p : \u2115), nat.prime p \u2192 p \u2223 n \u2192 x ^ (n / p) \u2260 1) :\n\torder_of x = n\n\ntheorem exists_npow_eq_one_of_zpow_eq_one {G : Type*} [group G] {n : \u2124}\n\t(hn : n \u2260 0) {x : G} (h : x ^ n = 1) :\n\t\u2203 (n : \u2115), 0 < n \u2227 x ^ n = 1\n\ntheorem units.coe_inv_of_pow_eq_one {M : Type u} [monoid M] (x : M) (n : \u2115)\n\t(hx : x ^ n = 1) (hn : n \u2260 0) :\n\t\u2191(units.of_pow_eq_one x n hx hn)\u207b\u00b9 = x ^ (n - 1)\n\nThe following is the natural language theorem statement: \"Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " inv_eq_pow_sub_one_of_order_eq_nat {G : Type*} [group G] (x : G)\n  (hx : \u2203 n : \u2115, x ^ n = 1) : x\u207b\u00b9 = x ^ (nat.find hx - 1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_20", "nl_statement": "For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order.", "nl_proof": "\\begin{proof}\n\n    Recall that the order of a group element is either a positive integer or infinity.\n\nSuppose $|x|$ is infinite and that $\\left|x^{-1}\\right|=n$ for some $n$. Then\n\n$$\n\nx^n=x^{(-1) \\cdot n \\cdot(-1)}=\\left(\\left(x^{-1}\\right)^n\\right)^{-1}=1^{-1}=1,\n\n$$\n\na contradiction. So if $|x|$ is infinite, $\\left|x^{-1}\\right|$ must also be infinite. Likewise, if $\\left|x^{-1}\\right|$ is infinite, then $\\left|\\left(x^{-1}\\right)^{-1}\\right|=|x|$ is also infinite.\n\nSuppose now that $|x|=n$ and $\\left|x^{-1}\\right|=m$ are both finite. Then we have\n\n$$\n\n\\left(x^{-1}\\right)^n=\\left(x^n\\right)^{-1}=1^{-1}=1,\n\n$$\n\nso that $m \\leq n$. Likewise, $n \\leq m$. Hence $m=n$ and $x$ and $x^{-1}$ have the same order.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_20 {G : Type*} [group G] {x : G} :\n  order_of x = order_of x\u207b\u00b9 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " order_of_inv {G : Type u} [group G] (x : G) :\n\torder_of x\u207b\u00b9 = order_of x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem order_of_inv {G : Type u} [group G] (x : G) :\n\torder_of x\u207b\u00b9 = order_of x\n\ntheorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} :\n\tis_of_fin_order x\u207b\u00b9 \u2194 is_of_fin_order x\n\ntheorem order_of_neg {G : Type u} [add_group G] (x : G) :\n\tadd_order_of (-x) = add_order_of x\n\ntheorem pow_order_of_eq_one {G : Type u} [monoid G] (x : G) :\n\tx ^ order_of x = 1\n\nThe following is the natural language theorem statement: \"For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " order_of_inv_eq_order_of_element {G : Type*} [group G] (x : G) :\n  order x = order x\u207b\u00b9 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_22b", "nl_statement": "Deduce that $|a b|=|b a|$ for all $a, b \\in G$.", "nl_proof": "\\begin{proof}\n\n    Let $a$ and $b$ be arbitrary group elements. Letting $x=a b$ and $g=a$, we see that\n\n$$\n\n|a b|=\\left|a^{-1} a b a\\right|=|b a| .\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_22b {G: Type*} [group G] (a b : G) : \n  order_of (a * b) = order_of (b * a) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " norm_mul_comm {\u03b1 : Type*} [normed_division_ring \u03b1] (a b : \u03b1) :\n\t\u2016a * b\u2016 = \u2016b * a\u2016 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem norm_mul {\u03b1 : Type*} [normed_division_ring \u03b1] (a b : \u03b1) :\n\t\u2016a * b\u2016 = \u2016a\u2016 * \u2016b\u2016\n\ntheorem mul_comm {G : Type*} [comm_semigroup G] (a b : G) :\n\ta * b = b * a\n\ntheorem mul_mul_inv_cancel'_right {G : Type*} [comm_group G] (a b : G) :\n\ta * (b * a\u207b\u00b9) = b\n\ntheorem mul_inv_cancel_comm_assoc {G : Type*} [comm_group G] (a b : G) :\n\ta * (b * a\u207b\u00b9) = b\n\nThe following is the natural language theorem statement: \"Deduce that $|a b|=|b a|$ for all $a, b \\in G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " norm_mul_eq_norm_mul_of_comm_group {G : Type*} [comm_group G] \n  [normed_group G] (a b : G) :\n  \u2225a * b\u2225 = \u2225b * a\u2225 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Deduce that $|a b|=|b a|$ for all $a, b \\in G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_1_29", "nl_statement": "Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian.", "nl_proof": "\\begin{proof}\n\n    $(\\Rightarrow)$ Suppose $a_1, a_2 \\in A$ and $b_1, b_2 \\in B$. Then\n\n$$\n\n\\left(a_1 a_2, b_1 b_2\\right)=\\left(a_1, b_1\\right) \\cdot\\left(a_2, b_2\\right)=\\left(a_2, b_2\\right) \\cdot\\left(a_1, b_1\\right)=\\left(a_2 a_1, b_2 b_1\\right) .\n\n$$\n\nSince two pairs are equal precisely when their corresponding entries are equal, we have $a_1 a_2=a_2 a_1$ and $b_1 b_2=b_2 b_1$. Hence $A$ and $B$ are abelian.\n\n$(\\Leftarrow)$ Suppose $\\left(a_1, b_1\\right),\\left(a_2, b_2\\right) \\in A \\times B$. Then we have\n\n$$\n\n\\left(a_1, b_1\\right) \\cdot\\left(a_2, b_2\\right)=\\left(a_1 a_2, b_1 b_2\\right)=\\left(a_2 a_1, b_2 b_1\\right)=\\left(a_2, b_2\\right) \\cdot\\left(a_1, b_1\\right) .\n\n$$\n\nHence $A \\times B$ is abelian.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_1_29 {A B : Type*} [group A] [group B] :\n  \u2200 x y : A \u00d7 B, x*y = y*x \u2194 (\u2200 x y : A, x*y = y*x) \u2227 \n  (\u2200 x y : B, x*y = y*x) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " abelian_group_prod_iff_abelian_group_left_right {A B : Type*}\n  [abelian_group A] [abelian_group B] :\n  abelian_group (A \u00d7 B) \u2194 abelian_group A \u2227 abelian_group B ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef category_theory.functor_prod_functor_equiv_counit_iso (A : Type u\u2081)\n\t[category_theory.category A] (B : Type u\u2082) [category_theory.category B]\n\t(C : Type u\u2083) [category_theory.category C] :\n\tcategory_theory.functor_prod_to_prod_functor A B C \u22d9 category_theory.prod_functor_to_functor_prod A B C \u2245 \ud835\udfed (A \u2964 B \u00d7 C)\n\ndef category_theory.functor_prod_functor_equiv (A : Type u\u2081)\n\t[category_theory.category A] (B : Type u\u2082) [category_theory.category B]\n\t(C : Type u\u2083) [category_theory.category C] :\n\t(A \u2964 B) \u00d7 (A \u2964 C) \u224c A \u2964 B \u00d7 C\n\ndef fundamental_groupoid_functor.prod_iso (A B : Top) :\n\tcategory_theory.Groupoid.of (\u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj A) \u00d7 \u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj B)) \u2245 fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (\u21a5A \u00d7 \u21a5B))\n\ndef category_theory.functor_prod_functor_equiv_unit_iso (A : Type u\u2081)\n\t[category_theory.category A] (B : Type u\u2082) [category_theory.category B]\n\t(C : Type u\u2083) [category_theory.category C] :\n\t\ud835\udfed ((A \u2964 B) \u00d7 (A \u2964 C)) \u2245 category_theory.prod_functor_to_functor_prod A B C \u22d9 category_theory.functor_prod_to_prod_functor A B C\n\nThe following is the natural language theorem statement: \"Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " abelian_of_prod_abelian {A B : Type*} [group A] [group B] :\n  abelian (A \u00d7 B) \u2194 abelian A \u2227 abelian B ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_3_8", "nl_statement": "Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group", "nl_proof": "\\begin{proof}\n\n    Recall that the codomain of an injective function must be at least as large (in cardinality) as the domain of the function. With that in mind, define the function\n\n$$\n\n\\begin{gathered}\n\nf: \\mathbb{N} \\rightarrow S_{\\mathbb{N}} \\\\\n\nf(n)=(1 n)\n\n\\end{gathered}\n\n$$\n\nwhere $(1 n)$ is the cycle decomposition of an element of $S_{\\mathbb{N}}$ (specifically it's the function given by $g(1)=n, g(2)=2, g(3)=3, \\ldots)$. The function $f$ maps every natural number to a distinct one of these functions. Hence $f$ is injective. Hence $\\infty=|\\mathbb{N}| \\leq\\left|S_{\\mathbb{N}}\\right|$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_3_8 : infinite (equiv.perm \u2115) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " infinite_of_not_fintype_perm {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1]\n  (h : fintype (equiv.perm \u03b1) \u2192 false) :\n  infinite (equiv.perm \u03b1) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef fintype_perm {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] :\n\tfintype (equiv.perm \u03b1)\n\ntheorem fintype.card_perm {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] :\n\tfintype.card (equiv.perm \u03b1) = (fintype.card \u03b1).factorial\n\ntheorem infinite.of_not_fintype {\u03b1 : Type*} (h : fintype \u03b1 \u2192 false) :\n\tinfinite \u03b1\n\ntheorem equiv.perm.subtype_perm_of_fintype_apply {\u03b1 : Type u} (f : equiv.perm \u03b1)\n\t{p : \u03b1 \u2192 Prop} [fintype {x // p x}] (h : \u2200 (x : \u03b1), p x \u2192 p (\u21d1f x))\n\t(x : {x // p x}) :\n\t\u21d1(f.subtype_perm_of_fintype h) x = \u27e8\u21d1f \u2191x, _\u27e9\n\nThe following is the natural language theorem statement: \"Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " infinite_of_fintype_perm_Omega {\u03a9 : Type*} [fintype \u03a9] :\n  infinite (perm \u03a9) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_6_11", "nl_statement": "Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$.", "nl_proof": "\\begin{proof}\n\n    We know from set theory that the mapping $\\varphi: A \\times B \\rightarrow B \\times A$ given by $\\varphi((a, b))=(b, a)$ is a bijection with inverse $\\psi: B \\times A \\rightarrow A \\times B$ given by $\\psi((b, a))=(a, b)$. Also $\\varphi$ is a homomorphism, as we show below.\n\nLet $a_1, a_2 \\in A$ and $b_1, b_2 \\in B$. Then\n\n$$\n\n\\begin{aligned}\n\n\\varphi\\left(\\left(a_1, b_1\\right) \\cdot\\left(a_2, b_2\\right)\\right) &=\\varphi\\left(\\left(a_1 a_2, b_1 b_2\\right)\\right) \\\\\n\n&=\\left(b_1 b_2, a_1 a_2\\right) \\\\\n\n&=\\left(b_1, a_1\\right) \\cdot\\left(b_2, a_2\\right) \\\\\n\n&=\\varphi\\left(\\left(a_1, b_1\\right)\\right) \\cdot \\varphi\\left(\\left(a_2, b_2\\right)\\right)\n\n\\end{aligned}\n\n$$\n\nHence $A \\times B \\cong B \\times A$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_6_11 {A B : Type*} [group A] [group B] : \n  A \u00d7 B \u2243* B \u00d7 A :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " prod_iso_comm (A B : Top) :\n\t(fundamental_groupoid_functor.prod_iso A B).hom = (fundamental_groupoid_functor.prod_iso B A).hom ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef fundamental_groupoid_functor.prod_iso (A B : Top) :\n\tcategory_theory.Groupoid.of (\u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj A) \u00d7 \u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj B)) \u2245 fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (\u21a5A \u00d7 \u21a5B))\n\ntheorem fundamental_groupoid_functor.prod_iso_inv (A B : Top) :\n\t(fundamental_groupoid_functor.prod_iso A B).inv = (fundamental_groupoid_functor.proj_left A B).prod' (fundamental_groupoid_functor.proj_right A B)\n\ntheorem fundamental_groupoid_functor.prod_iso_hom (A B : Top) :\n\t(fundamental_groupoid_functor.prod_iso A B).hom = fundamental_groupoid_functor.prod_to_prod_Top A B\n\ndef fundamental_groupoid_functor.prod_to_prod_Top (A B : Top) :\n\t\u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj A) \u00d7 \u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj B) \u2964 \u21a5(fundamental_groupoid.fundamental_groupoid_functor.obj (Top.of (\u21a5A \u00d7 \u21a5B)))\n\nThe following is the natural language theorem statement: \"Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_group_isomorphism_prod_comm {A B : Type*} [group A] [group B] :\n  is_group_isomorphism (prod.comm : A \u00d7 B \u2192 B \u00d7 A) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_1_6_23", "nl_statement": "Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian.", "nl_proof": "\\begin{proof}\n\n    Solution: We define a mapping $f: G \\rightarrow G$ by $f(x)=x^{-1} \\sigma(x)$.\n\nClaim: $f$ is injective.\n\nProof of claim: Suppose $f(x)=f(y)$. Then $y^{-1} \\sigma(y)=x^{-1} \\sigma(x)$, so that $x y^{-1}=\\sigma(x) \\sigma\\left(y^{-1}\\right)$, and $x y^{-1}=\\sigma\\left(x y^{-1}\\right)$. Then we have $x y^{-1}=1$, hence $x=y$. So $f$ is injective.\n\n\n\nSince $G$ is finite and $f$ is injective, $f$ is also surjective. Then every $z \\in G$ is of the form $x^{-1} \\sigma(x)$ for some $x$. Now let $z \\in G$ with $z=x^{-1} \\sigma(x)$. We have\n\n$$\n\n\\sigma(z)=\\sigma\\left(x^{-1} \\sigma(x)\\right)=\\sigma(x)^{-1} x=\\left(x^{-1} \\sigma(x)\\right)^{-1}=z^{-1} .\n\n$$\n\nThus $\\sigma$ is in fact the inversion mapping, and we assumed that $\\sigma$ is a homomorphism. By a previous example, then, $G$ is abelian.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_6_23 {G : Type*} \n  [group G] (\u03c3 : mul_aut G) (hs : \u2200 g : G, \u03c3 g = 1 \u2192 g = 1) \n  (hs2 : \u2200 g : G, \u03c3 (\u03c3 g) = g) :\n  \u2200 x y : G, x*y = y*x :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_abelian_of_finite_group_with_automorphism_sigma_sigma_squared_is_id\n  {G : Type*} [fintype G] [group G] (sigma : G \u2192 G)\n  (hsigma : \u2200 (g : G), sigma g = g \u2194 g = 1)\n  (hsigma_squared : \u2200 (g : G), sigma (sigma g) = g) :\n  is_abelian G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef subgroup.comm_group_topological_closure {G : Type w} [topological_space G]\n\t[group G] [topological_group G] [t2_space G] (s : subgroup G)\n\t(hs : \u2200 (x y : \u21a5s), x * y = y * x) :\n\tcomm_group \u21a5(s.topological_closure)\n\ntheorem is_normal_subgroup_of_comm_group {G : Type*} [comm_group G] {s : set G}\n\t(hs : is_subgroup s) :\n\tis_normal_subgroup s\n\ntheorem is_group_hom.preimage {G H : Type*} [group G] [group H] {f : G \u2192 H}\n\t(hf : is_group_hom f) {s : set H} (hs : is_subgroup s) :\n\tis_subgroup (f \u207b\u00b9' s)\n\ntheorem is_normal_add_subgroup_of_add_comm_group {G : Type*} [add_comm_group G]\n\t{s : set G} (hs : is_add_subgroup s) :\n\tis_normal_add_subgroup s\n\nThe following is the natural language theorem statement: \"Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " comm_group_of_automorphism_of_order_two_is_id {G : Type*} [group G] \n  [fintype G] (s : G \u2192* G) (hs : \u2200 (g : G), s g = g \u2194 g = 1) \n  (hs2 : s \u2218 s = function.id) :\n  comm_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_2_1_13", "nl_statement": "Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$.", "nl_proof": "\\begin{proof}\n\n    Solution: First, suppose there does not exist a nonzero element in $H$. Then $H=0$.\n\nNow suppose there does exist a nonzero element $a \\in H$; without loss of generality, say $a=p / q$ in lowest terms for some integers $p$ and $q$ - that is, $\\operatorname{gcd}(p, q)=1$. Now $q \\cdot \\frac{p}{q}=p \\in H$, and since $q / p \\in H$, we have $p \\cdot \\frac{q}{p} \\in H$. There exist integers $x, y$ such that $q x+p y=1$; note that $q x \\in H$ and $p y \\in H$, so that $1 \\in H$. Thus $n \\in H$ for all $n \\in \\mathbb{Z}$. Moreover, if $n \\neq 0,1 / n \\in H$. Then $m / n \\in H$ for all integers $m, n$ with $n \\neq 0$; hence $H=\\mathbb{Q}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_1_13 (H : add_subgroup \u211a) {x : \u211a} \n  (hH : x \u2208 H \u2192 (1 / x) \u2208 H):\n  H = \u22a5 \u2228 H = \u22a4 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " eq_zero_or_eq_univ_of_one_div_mem {G : Type*} [add_group G]\n  (H : add_subgroup G) (h : \u2200 (x : G), x \u2260 0 \u2192 1 / x \u2208 H) :\n  H = \u22a5 \u2228 H = univ ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem eq_zero_of_one_div_eq_zero {G\u2080 : Type*} [group_with_zero G\u2080] {a : G\u2080}\n\t(h : 1 / a = 0) :\n\ta = 0\n\ntheorem fintype.sum_eq_zero {\u03b1 M : Type*} [fintype \u03b1] [add_comm_monoid M]\n\t(f : \u03b1 \u2192 M) (h : \u2200 (a : \u03b1), f a = 0) :\n\tfinset.univ.sum (\u03bb (a : \u03b1), f a) = 0\n\ntheorem units.mk0_one {G\u2080 : Type*} [group_with_zero G\u2080]\n\t(h : 1 \u2260 0 := one_ne_zero) :\n\tunits.mk0 1 h = 1\n\ntheorem add_subgroup.eq_bot_of_card_eq {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\nThe following is the natural language theorem statement: \"Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " eq_zero_or_eq_univ_of_inv_mem {H : Type*} [add_group H] [decidable_eq H]\n  [fintype H] (h : \u2200 x : H, x \u2260 0 \u2192 1 / x \u2208 H) :\n  H = (0 : H) \u2228 H = univ ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_2_4_16a", "nl_statement": "A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$.", "nl_proof": "\\begin{proof}\n\nIf $H$ is maximal, then we are done. If $H$ is not maximal, then there is a subgroup $K_1$ of $G$ such that $H<K_1<G$. If $K_1$ is maximal, we are done. But if $K_1$ is not maximal, there is a subgroup $K_2$ with $H<K_1<K_2<G$. If $K_2$ is maximal, we are done, and if not, keep repeating the procedure. Since $G$ is finite, this process must eventually come to an end, so that $K_n$ is maximal for some positive integer $n$. Then $K_n$ is a maximal subgroup containing $H$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_4_16a {G : Type*} [group G] {H : subgroup G}  \n  (hH : H \u2260 \u22a4) : \n  \u2203 M : subgroup G, M \u2260 \u22a4 \u2227\n  \u2200 K : subgroup G, M \u2264 K \u2192 K = M \u2228 K = \u22a4 \u2227 \n  H \u2264 M :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_maximal_subgroup_of_proper_subgroup {G : Type*} [group G]\n  (H : subgroup G) (hH : H \u2260 \u22a4) :\n  \u2203 (M : subgroup G), M.is_maximal_of_proper_subgroup H ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.eq_top_of_le_card {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] [fintype G] (h : fintype.card G \u2264 fintype.card \u21a5H) :\n\tH = \u22a4\n\ntheorem subgroup.eq_top_of_card_eq {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] [fintype G] (h : fintype.card \u21a5H = fintype.card G) :\n\tH = \u22a4\n\ntheorem add_subgroup.eq_top_of_le_card {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] [fintype G]\n\t(h : fintype.card G \u2264 fintype.card \u21a5H) :\n\tH = \u22a4\n\ntheorem subgroup.exists_finset_card_le_mul {G : Type*} [group G]\n\t(H : subgroup G) [H.finite_index] {S : finset G} (hS : subgroup.closure \u2191S = \u22a4) :\n\t\u2203 (T : finset \u21a5H), T.card \u2264 H.index * S.card \u2227 subgroup.closure \u2191T = \u22a4\n\nThe following is the natural language theorem statement: \"A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_maximal_subgroup_of_proper_subgroup {G : Type*} [group G] \n  [fintype G] {H : subgroup G} (hH : H \u2260 \u22a4) :\n  \u2203 (M : subgroup G), M.is_maximal \u2227 H \u2264 M ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_2_4_16c", "nl_statement": "Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$.", "nl_proof": "\\begin{proof}\n\n    Suppose $H$ is a maximal subgroup of $G$. Then $H$ is cyclic, and we may write $H=\\left\\langle x^k\\right\\rangle$ for some integer $k$, with $k>1$. Let $d=(n, k)$. Since $H$ is a proper subgroup, we know by Proposition 6 that $d>1$. Choose a prime factor $p$ of $d$. If $k=p=d$ then $k \\mid n$ as required.\n\n\n\nIf, however, $k$ is not prime, then consider the subgroup $K=\\left\\langle x^p\\right\\rangle$. Since $p$ is a proper divisor of $k$, it follows that $H<K$. But $H$ is maximal, so we must have $K=G$. Again by Proposition 6 , we must then have $(p, n)=1$. However, $p$ divides $d$ which divides $n$, so $p \\mid n$ and $(p, n)=p>1$, a contradiction. Therefore $k=p$ and the left-to-right implication holds.\n\nNow, for the converse, suppose $H=\\left\\langle x^p\\right\\rangle$ for $p$ a prime dividing $n$. If $H$ is not maximal then the first part of this exercise shows that there is a maximal subgroup $K$ containing $H$. Then $K=\\left\\langle x^q\\right\\rangle$. So $x^p \\in\\left\\langle x^q\\right\\rangle$, which implies $q \\mid p$. But the only divisors of $p$ are 1 and $p$. If $q=1$ then $K=G$ and $K$ cannot be a proper subgroup, and if $q=p$ then $H=K$ and $H$ cannot be a proper subgroup of $K$. This contradiction shows that $H$ is maximal.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_4_16c {n : \u2115} (H : add_subgroup (zmod n)) : \n  \u2203 p : \u2115, nat.prime p \u2227 H = add_subgroup.closure {p} \u2194 \n  H \u2260 \u22a4 \u2227 \u2200 K : add_subgroup (zmod n), H \u2264 K \u2192 K = H \u2228 K = \u22a4 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " maximal_iff_order_of_eq_prime_pow {G : Type u} {x : G} [monoid G]\n  {p : \u2115} [hp : fact (nat.prime p)] (hg : x ^ p = 1) (hg1 : x \u2260 1) :\n  maximal (subgroup.closure (\u03bb (i : \u2115), x ^ i)) \u2194 order_of x = p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem order_of_eq_prime {G : Type u} {x : G} [monoid G] {p : \u2115}\n\t[hp : fact (nat.prime p)] (hg : x ^ p = 1) (hg1 : x \u2260 1) :\n\torder_of x = p\n\ntheorem order_of_eq_prime_pow {G : Type u} {x : G} {n : \u2115} [monoid G] {p : \u2115}\n\t[hp : fact (nat.prime p)] (hnot : \u00acx ^ p ^ n = 1) (hfin : x ^ p ^ (n + 1) = 1) :\n\torder_of x = p ^ (n + 1)\n\ntheorem exists_order_of_eq_prime_pow_iff {G : Type u} {x : G} [monoid G] {p : \u2115}\n\t[hp : fact (nat.prime p)] :\n\t(\u2203 (k : \u2115), order_of x = p ^ k) \u2194 \u2203 (m : \u2115), x ^ p ^ m = 1\n\ntheorem nat.prime.exists_order_of_eq_pow_factorization_exponent (G : Type u)\n\t[monoid G] {p : \u2115} (hp : nat.prime p) :\n\t\u2203 (g : G), order_of g = p ^ \u21d1((monoid.exponent G).factorization) p\n\nThe following is the natural language theorem statement: \"Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " maximal_of_cyclic_of_prime_div_order {G : Type*} [group G] \n  (x : G) (hx : x \u2260 1) (hx_ord : \u2203 n : \u2115, x ^ n = 1) \n  (H : subgroup G) (hH : H.is_maximal) :\n  \u2203 (p : \u2115) (hp : nat.prime p), p \u2223 (x.order hx_ord) \u2227 H = \u27e8x ^ p\u27e9 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_3_1_22a", "nl_statement": "Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$.", "nl_proof": "\\begin{proof}\n\n    Suppose $H$ and $K$ are normal subgroups of $G$. We already know that $H \\cap K$ is a subgroup of $G$, so we need to show that it is normal. Choose any $g \\in G$ and any $x \\in H \\cap K$. Since $x \\in H$ and $H \\unlhd G$, we know $g x g^{-1} \\in H$. Likewise, since $x \\in K$ and $K \\unlhd G$, we have $g x g^{-1} \\in K$. Therefore $g x g^{-1} \\in H \\cap K$. This shows that $g(H \\cap K) g^{-1} \\subseteq H \\cap K$, and this is true for all $g \\in G$. By Theorem 6 (5) (which we will prove in Exercise 3.1.25), this is enough to show that $H \\cap K \\unlhd G$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_1_22a (G : Type*) [group G] (H K : subgroup G) \n  [subgroup.normal H] [subgroup.normal K] :\n  subgroup.normal (H \u2293 K) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " subgroup.normal_inf_normal {G : Type*} [group G] (H K : subgroup G)\n  [hH : H.normal] [hK : K.normal] :\n  (H \u2293 K).normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.normal.subgroup_of {G : Type*} [group G] {H : subgroup G}\n\t(hH : H.normal) (K : subgroup G) :\n\t(H.subgroup_of K).normal\n\ndef subgroup.normal_inf_normal {G : Type*} [group G] (H K : subgroup G)\n\t[hH : H.normal] [hK : K.normal] :\n\t(H \u2293 K).normal\n\ntheorem subgroup.le_normalizer_of_normal {G : Type*} [group G]\n\t{H K : subgroup G} [hK : (H.subgroup_of K).normal] (HK : H \u2264 K) :\n\tK \u2264 H.normalizer\n\ndef subgroup.sup_normal {G : Type*} [group G] (H K : subgroup G) [hH : H.normal]\n\t[hK : K.normal] :\n\t(H \u2294 K).normal\n\nThe following is the natural language theorem statement: \"Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " normal_inter_normal_is_normal {G : Type*} [group G] {H K : subgroup G}\n  (hH : H.normal) (hK : K.normal) : (H \u2229 K).normal ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_3_2_8", "nl_statement": "Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$.", "nl_proof": "\\begin{proof}\n\n    Solution: Let $|H|=p$ and $|K|=q$. We saw in a previous exercise that $H \\cap K$ is a subgroup of both $H$ and $K$; by Lagrange's Theorem, then, $|H \\cap K|$ divides $p$ and $q$. Since $\\operatorname{gcd}(p, q)=1$, then, $|H \\cap K|=1$. Thus $H \\cap K=1$.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_2_8 {G : Type*} [group G] (H K : subgroup G)\n  [fintype H] [fintype K] \n  (hHK : nat.coprime (fintype.card H) (fintype.card K)) : \n  H \u2293 K = \u22a5 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " subgroup.eq_one_of_coprime {G : Type*} [group G] {H K : subgroup G}\n  [fintype G] [fintype \u21a5H] [fintype \u21a5K] (h1 : fintype.card \u21a5H.finite)\n  (h2 : fintype.card \u21a5K.finite) (h3 : (fintype.card \u21a5H).coprime (fintype.card \u21a5K)) :\n  H \u2229 K = 1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.is_complement'_of_coprime {G : Type*} [group G]\n\t{H K : subgroup G} [fintype G] [fintype \u21a5H] [fintype \u21a5K]\n\t(h1 : fintype.card \u21a5H * fintype.card \u21a5K = fintype.card G)\n\t(h2 : (fintype.card \u21a5H).coprime (fintype.card \u21a5K)) :\n\tH.is_complement' K\n\ntheorem subgroup.is_complement'_of_card_mul_and_disjoint {G : Type*} [group G]\n\t{H K : subgroup G} [fintype G] [fintype \u21a5H] [fintype \u21a5K]\n\t(h1 : fintype.card \u21a5H * fintype.card \u21a5K = fintype.card G) (h2 : disjoint H K) :\n\tH.is_complement' K\n\ntheorem subgroup.is_complement'.card_mul {G : Type*} [group G]\n\t{H K : subgroup G} [fintype G] [fintype \u21a5H] [fintype \u21a5K]\n\t(h : H.is_complement' K) :\n\tfintype.card \u21a5H * fintype.card \u21a5K = fintype.card G\n\ntheorem subgroup.eq_one_of_smul_eq_one {G : Type*} [group G] {H : subgroup G}\n\t[H.is_commutative] [H.finite_index] [H.normal]\n\t(hH : (nat.card \u21a5H).coprime H.index) (\u03b1 : H.quotient_diff) (h : \u21a5H) :\n\th \u2022 \u03b1 = \u03b1 \u2192 h = 1\n\nThe following is the natural language theorem statement: \"Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " finite_subgroup_intersection_eq_one_of_rel_prime_card {G : Type*} \n  [group G] {H K : subgroup G} [fintype H] [fintype K] \n  (hH : H.card.prime_factors.pairwise_coprime) \n  (hK : K.card.prime_factors.pairwise_coprime) :\n  H \u2229 K = 1 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_3_2_16", "nl_statement": "Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$.", "nl_proof": "\\begin{proof}\n\n    Solution: If $p$ is prime, then $\\varphi(p)=p-1$ (where $\\varphi$ denotes the Euler totient). Thus\n\n$$\n\n\\mid\\left((\\mathbb{Z} /(p))^{\\times} \\mid=p-1 .\\right.\n\n$$\n\nSo for all $a \\in(\\mathbb{Z} /(p))^{\\times}$, we have $|a|$ divides $p-1$. Hence\n\n$$\n\na=1 \\cdot a=a^{p-1} a=a^p \\quad(\\bmod p) .\n\n$$\n\n\\end{proof}", "formal_statement": "theorem exercise_3_2_16 (p : \u2115) (hp : nat.prime p) (a : \u2115) :\n  nat.coprime a p \u2192 a ^ p \u2261 a [ZMOD p] :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " fermat_little_theorem {p a : \u2115} (hp : nat.prime p) (a1 : a \u2260 1) :\n  a ^ p \u2261 a [ZMOD p] ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.modeq.pow_card_sub_one_eq_one {p : \u2115} (hp : nat.prime p) {n : \u2124}\n\t(hpn : is_coprime n \u2191p) :\n\tn ^ (p - 1) \u2261 1 [ZMOD \u2191p]\n\ntheorem nat.prime.pow_eq_iff {p a k : \u2115} (hp : nat.prime p) :\n\ta ^ k = p \u2194 a = p \u2227 k = 1\n\ntheorem nat.prime.dvd_iff_eq {p a : \u2115} (hp : nat.prime p) (a1 : a \u2260 1) :\n\ta \u2223 p \u2194 p = a\n\ntheorem nat.totient_eq_iff_prime {p : \u2115} (hp : 0 < p) :\n\tp.totient = p - 1 \u2194 nat.prime p\n\nThe following is the natural language theorem statement: \"Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " fermat_little_theorem (p : \u2115) (hp : nat.prime p) (a : \u2115) :\n  nat.coprime a p \u2192 a ^ p \u2261 a [MOD p] ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_3_3_3", "nl_statement": "Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$.", "nl_proof": "\\begin{proof}\n\n    Solution: Suppose $K \\backslash N \\neq \\emptyset$; say $k \\in K \\backslash N$. Now $G / N \\cong \\mathbb{Z} /(p)$ is cyclic, and moreover is generated by any nonidentity- in particular by $\\bar{k}$\n\n\n\nNow $K N \\leq G$ since $N$ is normal. Let $g \\in G$. We have $g N=k^a N$ for some integer a. In particular, $g=k^a n$ for some $n \\in N$, hence $g \\in K N$. We have $[K: K \\cap N]=p$ by the Second Isomorphism Theorem.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_3_3 {p : primes} {G : Type*} [group G] \n  {H : subgroup G} [hH : H.normal] (hH1 : H.index = p) : \n  \u2200 K : subgroup G, K \u2264 H \u2228 H \u2294 K = \u22a4 \u2228 (K \u2293 H).relindex K = p :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_p_group.to_sup_of_normal_left' {p : \u2115} {G : Type*} [group G]\n  {H K : subgroup G} (hH : is_p_group p H) (hK : is_p_group p K)\n  (hHK : K \u2264 H.normalizer) :\n  is_p_group p (H \u2294 K) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_p_group.to_sup_of_normal_left' {p : \u2115} {G : Type*} [group G]\n\t{H K : subgroup G} (hH : is_p_group p \u21a5H) (hK : is_p_group p \u21a5K)\n\t(hHK : K \u2264 H.normalizer) :\n\tis_p_group p \u21a5(H \u2294 K)\n\ntheorem is_p_group.to_sup_of_normal_right' {p : \u2115} {G : Type*} [group G]\n\t{H K : subgroup G} (hH : is_p_group p \u21a5H) (hK : is_p_group p \u21a5K)\n\t(hHK : H \u2264 K.normalizer) :\n\tis_p_group p \u21a5(H \u2294 K)\n\ntheorem subgroup.le_normalizer_of_normal {G : Type*} [group G]\n\t{H K : subgroup G} [hK : (H.subgroup_of K).normal] (HK : H \u2264 K) :\n\tK \u2264 H.normalizer\n\ntheorem subgroup.normal_subgroup_of_iff {G : Type*} [group G] {H K : subgroup G}\n\t(hHK : H \u2264 K) :\n\t(H.subgroup_of K).normal \u2194 \u2200 (h k : G), h \u2208 H \u2192 k \u2208 K \u2192 k * h * k\u207b\u00b9 \u2208 H\n\nThe following is the natural language theorem statement: \"Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " prime_index_of_normal_subgroup_of_prime_index_of_subgroup {G : Type*} \n  [group G] {H K : subgroup G} (hH : H.normal) (hK : K \u2264 G) \n  (h : card (G \u29f8 H) = nat.prime p) (hp : nat.prime p) :\n  K \u2264 H \u2228 (G = H * K \u2227 card (K \u29f8 K \u2229 H) = p) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_3_4_4", "nl_statement": "Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be a finite abelian group. We use induction on $|G|$. Certainly the result holds for the trivial group. And if $|G|=p$ for some prime $p$, then the positive divisors of $|G|$ are 1 and $p$ and the result is again trivial.\n\n\n\nNow assume that the statement is true for all groups of order strictly smaller than $|G|$, and let $n$ be a positive divisor of $|G|$ with $n>1$. First, if $n$ is prime then Cauchy's Theorem allows us to find an element $x \\in G$ having order $n$. Then $\\langle x\\rangle$ is the desired subgroup. On the other hand, if $n$ is not prime, then $n$ has a prime divisor $p$, so that $n=k p$ for some integer $k$. Cauchy's Theorem allows us to find an element $x$ having order $p$. Set $N=\\langle x\\rangle$. By Lagrange's Theorem,\n\n$$\n\n|G / N|=\\frac{|G|}{|N|}<|G| .\n\n$$\n\nNow, by the inductive hypothesis, the group $G / N$ must have a subgroup of order $k$. And by the Lattice Isomorphism Theorem, this subgroup has the form $H / N$ for some subgroup $H$ of $G$. Then $|H|=k|N|=k p=n$, so that $H$ has order $n$. This completes the inductive step.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_4_4 {G : Type*} [comm_group G] [fintype G] {n : \u2115}\n    (hn : n \u2223 (fintype.card G)) :\n    \u2203 (H : subgroup G) (H_fin : fintype H), @card H H_fin = n  :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_subgroup_card_dvd_of_fintype_abelian {G : Type*} [group G]\n  [fintype G] [fintype.abelian G] (n : \u2115) (hdvd : n \u2223 fintype.card G) :\n  \u2203 (H : subgroup G), fintype.card \u21a5H = n ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_subgroup.card_dvd_of_surjective {G H : Type*} [add_group G]\n\t[add_group H] [fintype G] [fintype H] (f : G \u2192+ H)\n\t(hf : function.surjective \u21d1f) :\n\tfintype.card H \u2223 fintype.card G\n\ntheorem is_p_group.of_card {p : \u2115} {G : Type*} [group G] [fintype G] {n : \u2115}\n\t(hG : fintype.card G = p ^ n) :\n\tis_p_group p G\n\ntheorem subgroup.card_dvd_of_surjective {G H : Type*} [group G] [group H]\n\t[fintype G] [fintype H] (f : G \u2192* H) (hf : function.surjective \u21d1f) :\n\tfintype.card H \u2223 fintype.card G\n\ntheorem sylow.exists_subgroup_card_pow_succ {G : Type u} [group G] [fintype G]\n\t{p n : \u2115} [hp : fact (nat.prime p)] (hdvd : p ^ (n + 1) \u2223 fintype.card G)\n\t{H : subgroup G} (hH : fintype.card \u21a5H = p ^ n) :\n\t\u2203 (K : subgroup G), fintype.card \u21a5K = p ^ (n + 1) \u2227 H \u2264 K\n\nThe following is the natural language theorem statement: \"Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_subgroup_of_order_dvd_card_of_fintype_abelian_group {G : Type*} \n  [group G] [fintype G] [abelian_group G] (n : \u2115) (h : n \u2223 fintype.card G) :\n  \u2203 (H : subgroup G), fintype.card H = n ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_3_4_5b", "nl_statement": "Prove that quotient groups of a solvable group are solvable.", "nl_proof": "\\begin{proof}\n\n    Next, note that\n\n$$\n\nH_i=G_i \\cap H=\\left(G_i \\cap G_{i+1}\\right) \\cap H=G_i \\cap H_{i+1} .\n\n$$\n\nBy the Second Isomorphism Theorem, we then have\n\n$$\n\nH_{i+1} / H_i=H_{i+1} /\\left(H_{i+1} \\cap G_i\\right) \\cong H_{i+1} G_i / G_i \\leq G_{i+1} / G_i .\n\n$$\n\nSince $H_{i+1} / H_i$ is isomorphic to a subgroup of the abelian group $G_{i+1} / G_i$, it follows that $H_{i+1} / H_i$ is also abelian. This completes the proof that $H$ is solvable.\n\nNext, let $N \\unlhd G$. For each $i$, define\n\n$$\n\nN_i=G_i N, \\quad 0 \\leq i \\leq n .\n\n$$\n\nNow let $g \\in N_{i+1}$, where $g=g_0 n_0$ with $g_0 \\in G_{i+1}$ and $n_0 \\in N$. Also let $x \\in N_i$, where $x=g_1 n_1$ with $g_1 \\in G_i$ and $n_1 \\in N$. Then\n\n$$\n\ng x g^{-1}=g_0 n_0 g_1 n_1 n_0^{-1} g_0^{-1} .\n\n$$\n\nNow, since $N$ is normal in $G, N g=g N$, so $n_0 g_1=g_1 n_2$ for some $n_2 \\in N$. Then\n\n$$\n\ng x g^{-1}=g_0 g_1\\left(n_2 n_1 n_0^{-1}\\right) g_0^{-1}=g_0 g_1 n_3 g_0^{-1}\n\n$$\n\nfor some $n_3 \\in N$. Then $n_3 g_0^{-1}=g_0^{-1} n_4$ for some $n_4 \\in N$. And $g_0 g_1 g_0^{-1} \\in G_i$ since $G_i \\unlhd G_{i+1}$, so\n\n$$\n\ng x g^{-1}=g_0 g_1 g_0^{-1} n_4 \\in N_i .\n\n$$\n\nThis shows that $N_i \\unlhd N_{i+1}$. So by the Lattice Isomorphism Theorem, we have $N_{i+1} / N \\unlhd N_i / N$. This shows that\n\n$$\n\n1=N_0 / N \\unlhd N_1 / N \\unlhd N_2 / N \\unlhd \\cdots \\unlhd N_n / N=G / N .\n\n$$\n\nMoreover, the Third Isomorphism Theorem says that\n\n$$\n\n\\left(N_{i+1} / N\\right) /\\left(N_i / N\\right) \\cong N_{i+1} / N_i,\n\n$$\n\nso the proof will be complete if we can show that $N_{i+1} / N_i$ is abelian.\n\nLet $x, y \\in N_{i+1} / N_i$. Then\n\n$$\n\nx=\\left(g_0 n_0\\right) N_i \\quad \\text { and } \\quad y=\\left(g_1 n_1\\right) N_i\n\n$$\n\nfor some $g_0, g_1 \\in G_{i+1}$ and $n_0, n_1 \\in N$. We have\n\n$$\n\n\\begin{aligned}\n\nx y x^{-1} y^{-1} & =\\left(g_0 n_0\\right)\\left(g_1 n_1\\right)\\left(g_0 n_0\\right)^{-1}\\left(g_1 n_1\\right)^{-1} N_i \\\\\n\n& =g_0 n_0 g_1 n_1 n_0^{-1} g_0^{-1} n_1^{-1} g_1^{-1} N_i .\n\n\\end{aligned}\n\n$$\n\nSince $N \\unlhd G, g N=N g$ for any $g \\in G$, so we can find $n_2 \\in N$ such that\n\n$$\n\nx y x^{-1} y^{-1}=g_0 g_1 g_0^{-1} g^{-1} n_2 N_i .\n\n$$\n\nNow $N_i=G_i N=N G_i$ since $N \\unlhd G$ (see Proposition 14 and its corollary). Therefore\n\n$$\n\nn_2 N_i=n_2 N G_i=N G_i=G_i N\n\n$$\n\nand we get\n\n$$\n\nx y x^{-1} y^{-1}=g_0 g_1 g_0^{-1} g^{-1} G_i N=G_i N .\n\n$$\n\nSo $x y x^{-1} y^{-1}=1 N_i$ or $x y=y x$. This completes the proof that $G / N$ is solvable.\n\n\\end{proof}", "formal_statement": "theorem exercise_3_4_5b {G : Type*} [group G] [is_solvable G] \n  (H : subgroup G) [subgroup.normal H] : \n  is_solvable (G \u29f8 H) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " solvable_quotient_of_solvable {G : Type*} [group G] (H : subgroup G)\n  [H.normal] [h : is_solvable G] :\n  is_solvable (G \u29f8 H) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef solvable_quotient_of_solvable {G : Type*} [group G] (H : subgroup G)\n\t[H.normal] [h : is_solvable G] :\n\tis_solvable (G \u29f8 H)\n\ntheorem quotient_group.quotient_quotient_equiv_quotient_aux_coe {G : Type u}\n\t[group G] (N : subgroup G) [nN : N.normal] (M : subgroup G) [nM : M.normal]\n\t(h : N \u2264 M) (x : G \u29f8 N) :\n\t\u21d1(quotient_group.quotient_quotient_equiv_quotient_aux N M h) \u2191x = \u21d1(quotient_group.map N M (monoid_hom.id G) h) x\n\ndef quotient_group.quotient_quotient_equiv_quotient {G : Type u} [group G]\n\t(N : subgroup G) [nN : N.normal] (M : subgroup G) [nM : M.normal] (h : N \u2264 M) :\n\t(G \u29f8 N) \u29f8 subgroup.map (quotient_group.mk' N) M \u2243* G \u29f8 M\n\ntheorem quotient_group.quotient_mul_equiv_of_eq_mk {G : Type u} [group G]\n\t{M N : subgroup G} [M.normal] [N.normal] (h : M = N) (x : G) :\n\t\u21d1(quotient_group.quotient_mul_equiv_of_eq h) (quotient_group.mk x) = quotient_group.mk x\n\nThe following is the natural language theorem statement: \"Prove that quotient groups of a solvable group are solvable.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " solvable_quotient_of_solvable {G : Type*} [group G] [solvable G] \n  {N : subgroup G} (hN : N.normal) : solvable (G / N) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that quotient groups of a solvable group are solvable.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_2_8", "nl_statement": "Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$.", "nl_proof": "\\begin{proof}\n\n    Solution: $G$ acts on the cosets $G / H$ by left multiplication. Let $\\lambda: G \\rightarrow S_{G / H}$ be the permutation representation induced by this action, and let $K$ be the kernel of the representation.\n\nNow $K$ is normal in $G$, and $K \\leq \\operatorname{stab}_G(H)=H$. By the First Isomorphism Theorem, we have an injective group homomorphism $\\bar{\\lambda}: G / K \\rightarrow S_{G / H}$. Since $\\left|S_{G / H}\\right|=n !$, we have $[G: K] \\leq n !$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_2_8 {G : Type*} [group G] {H : subgroup G} \n  {n : \u2115} (hn : n > 0) (hH : H.index = n) : \n  \u2203 K \u2264 H, K.normal \u2227 K.index \u2264 n.factorial :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_normal_le_finset_card_le_fact {G : Type*} [group G]\n  {H : subgroup G} [H.finite_index] :\n  \u2203 (K : subgroup G) [K.normal], K \u2264 H \u2227 (nat.card \u21a5K).finite \u2227\n  (nat.card \u21a5K).fact \u2264 H.index ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.exists_finset_card_le_mul {G : Type*} [group G]\n\t(H : subgroup G) [H.finite_index] {S : finset G} (hS : subgroup.closure \u2191S = \u22a4) :\n\t\u2203 (T : finset \u21a5H), T.card \u2264 H.index * S.card \u2227 subgroup.closure \u2191T = \u22a4\n\ntheorem subgroup.finite_index_of_le {G : Type*} [group G] {H K : subgroup G}\n\t[H.finite_index] (h : H \u2264 K) :\n\tK.finite_index\n\ntheorem subgroup.exists_smul_eq {G : Type*} [group G] {H : subgroup G}\n\t[H.is_commutative] [H.finite_index] [H.normal]\n\t(hH : (nat.card \u21a5H).coprime H.index) (\u03b1 \u03b2 : H.quotient_diff) :\n\t\u2203 (h : \u21a5H), h \u2022 \u03b1 = \u03b2\n\ntheorem add_subgroup.finite_index_of_le {G : Type*} [add_group G]\n\t{H K : add_subgroup G} [H.finite_index] (h : H \u2264 K) :\n\tK.finite_index\n\nThe following is the natural language theorem statement: \"Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_normal_subgroup_of_finite_index_le_fact {G : Type*} [group G]\n  {H : subgroup G} (hH : fintype (G / H)) :\n  \u2203 (K : subgroup G), K \u2264 H \u2227 fintype (G / K) \u2227 card (G / K) \u2264 fact (card (G / H)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_2_9a", "nl_statement": "Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$.", "nl_proof": "\\begin{proof}\n\n    Solution: Let $G$ be a group of order $p^k$ and $H \\leq G$ a subgroup with $[G: H]=p$. Now $G$ acts on the conjugates $g H g^{-1}$ by conjugation, since\n\n$$\n\ng_1 g_2 \\cdot H=\\left(g_1 g_2\\right) H\\left(g_1 g_2\\right)^{-1}=g_1\\left(g_2 H g_2^{-1}\\right) g_1^{-1}=g_1 \\cdot\\left(g_2 \\cdot H\\right)\n\n$$\n\nand $1 \\cdot H=1 H 1=H$. Moreover, under this action we have $H \\leq \\operatorname{stab}(H)$. By Exercise 3.2.11, we have\n\n$$\n\n[G: \\operatorname{stab}(H)][\\operatorname{stab}(H): H]=[G: H]=p,\n\n$$\n\na prime.\n\nIf $[G: \\operatorname{stab}(H)]=p$, then $[\\operatorname{stab}(H): H]=1$ and we have $H=\\operatorname{stab}(H)$; moreover, $H$ has exactly $p$ conjugates in $G$. Let $\\varphi: G \\rightarrow S_p$ be the permutation representation induced by the action of $G$ on the conjugates of $H$, and let $K$ be the kernel of this representation. Now $K \\leq \\operatorname{stab}(H)=H$. By the first isomorphism theorem, the induced map $\\bar{\\varphi}: G / K \\rightarrow S_p$ is injective, so that $|G / K|$ divides $p$ !. Note, however, that $|G / K|$ is a power of $p$ and that the only powers of $p$ that divide $p$ ! are 1 and $p$. So $[G: K]$ is 1 or $p$. If $[G: K]=1$, then $G=K$ so that $g H g^{-1}=H$ for all $g \\in G$; then $\\operatorname{stab}(H)=G$ and we have $[G: \\operatorname{stab}(H)]=1$, a contradiction. Now suppose $[G: K]=p$. Again by Exercise $3.2$.11 we have $[G: K]=[G: H][H: K]$, so that $[H: K]=1$, hence $H=K$. Again, this implies that $H$ is normal so that $g H g^{-1}=H$ for all $g \\in G$, and we have $[G: \\operatorname{stab}(H)]=1$, a contradiction. Thus $[G: \\operatorname{stab}(H)] \\neq p$\n\nIf $[G: \\operatorname{stab}(H)]=1$, then $G=\\operatorname{stab}(H)$. That is, $g H g^{-1}=H$ for all $g \\in G$; thus $H \\leq G$ is normal.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_2_9a {G : Type*} [fintype G] [group G] {p \u03b1 : \u2115} \n  (hp : p.prime) (ha : \u03b1 > 0) (hG : card G = p ^ \u03b1) : \n  \u2200 H : subgroup G, H.index = p \u2192 H.normal :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " normal_of_index_p {G : Type u} [group G] {p : \u2115}\n  [fact (nat.prime p)] (hG : \u2203 (n : \u2115), G.card = p ^ n) (H : subgroup G)\n  [H.finite_index] (hH : H.index = p) : H.normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem sylow.normal_of_normalizer_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G)\n\t(hn : \u2191P.normalizer.normal) :\n\t\u2191P.normal\n\ntheorem is_p_group.index {p : \u2115} {G : Type*} [group G] (hG : is_p_group p G)\n\t[hp : fact (nat.prime p)] (H : subgroup G) [H.finite_index] :\n\t\u2203 (n : \u2115), H.index = p ^ n\n\ntheorem sylow.normal_of_all_max_subgroups_normal {G : Type u} [group G]\n\t[finite G] (hnc : \u2200 (H : subgroup G), is_coatom H \u2192 H.normal) {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) :\n\t\u2191P.normal\n\ntheorem sylow.characteristic_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\t\u2191P.characteristic\n\nThe following is the natural language theorem statement: \"Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " normal_of_prime_power_order_of_index_prime {G : Type*} [group G] \n  [fintype G] {p : \u2115} [hp : fact (nat.prime p)] {\u03b1 : \u2115} (hG : fintype.card G = p ^ \u03b1) \n  {H : subgroup G} (hH : H.card = p ^ (\u03b1 - 1)) :\n  H.normal ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_4_2", "nl_statement": "Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be an abelian group of order $p q$. We need to prove that if $p$ and $q$ are distinct primes than $G$ is cyclic. By Cauchy's theorem there are $a, b \\in G$ with $a$ of order $p$ and $b$ of order $q$. Since $(|a|,|b|)=1$ and $a b=b a$ then $|a b|=|a| \\cdot|b|=p q$. Therefore $a b$ is an element of order $p q$, the order of $G$, which means $G$ is cyclic.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_4_2 {G : Type*} [fintype G] [group G] \n  {p q : nat.primes} (hpq : p \u2260 q) (hG : card G = p*q) : \n  is_cyclic G :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_cyclic_of_prime_card {\u03b1 : Type u} [group \u03b1] [fintype \u03b1] {p : \u2115}\n  [hp : fact (nat.prime p)] (h : fintype.card \u03b1 = p) :\n  is_cyclic \u03b1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_cyclic_of_prime_card {\u03b1 : Type u} [group \u03b1] [fintype \u03b1] {p : \u2115}\n\t[hp : fact (nat.prime p)] (h : fintype.card \u03b1 = p) :\n\tis_cyclic \u03b1\n\ntheorem is_p_group.cyclic_center_quotient_of_card_eq_prime_sq {p : \u2115}\n\t{G : Type*} [group G] [fintype G] [fact (nat.prime p)]\n\t(hG : fintype.card G = p ^ 2) :\n\tis_cyclic (G \u29f8 subgroup.center G)\n\ntheorem is_p_group.coprime_card_of_ne {G : Type*} [group G] {G\u2082 : Type*}\n\t[group G\u2082] (p\u2081 p\u2082 : \u2115) [hp\u2081 : fact (nat.prime p\u2081)] [hp\u2082 : fact (nat.prime p\u2082)]\n\t(hne : p\u2081 \u2260 p\u2082) (H\u2081 : subgroup G) (H\u2082 : subgroup G\u2082) [fintype \u21a5H\u2081]\n\t[fintype \u21a5H\u2082] (hH\u2081 : is_p_group p\u2081 \u21a5H\u2081) (hH\u2082 : is_p_group p\u2082 \u21a5H\u2082) :\n\t(fintype.card \u21a5H\u2081).coprime (fintype.card \u21a5H\u2082)\n\ntheorem is_p_group.is_nilpotent {G : Type*} [hG : group G] [finite G] {p : \u2115}\n\t[hp : fact (nat.prime p)] (h : is_p_group p G) :\n\tgroup.is_nilpotent G\n\nThe following is the natural language theorem statement: \"Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_cyclic_of_abelian_of_order_pq {G : Type*} [group G] [fintype G]\n  {p q : \u2115} (hp : nat.prime p) (hq : nat.prime q) (hpq : p \u2260 q)\n  (hG : fintype.card G = p * q) (hG_abelian : abelian_group G) :\n  is_cyclic G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_4_6b", "nl_statement": "Prove that there exists a normal subgroup that is not characteristic.", "nl_proof": "\\begin{proof}\n\n    We have to produce a group $G$ and a subgroup $H$ such that $H$ is normal in $G$, but not characterestic. Consider the Klein's four group $G=\\{ e, a, b, a b\\}$. This is an abelian group with each element having order 2. Consider $H=\\{ e, a\\}$. $H$ is normal in $G$. Define $\\sigma: G \\rightarrow G$ as $\\sigma(a)=b, \\sigma(b)=a, \\sigma(a b)=a b$. Clearly $\\sigma$ does not fix $H$. So, $H$ is not characterestic.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_4_6b {G : Type*} [group G] : \n  \u2203 H : subgroup G, H.characteristic \u2227 \u00ac H.normal :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_normal_not_characteristic {G : Type*} [group G] :\n\t\u2203 (H : subgroup G), H.normal \u2227 \u00acH.characteristic ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef subgroup.normal_of_characteristic {G : Type*} [group G] (H : subgroup G)\n\t[h : H.characteristic] :\n\tH.normal\n\ndef conj_act.normal_of_characteristic_of_normal {G : Type*} [group G]\n\t{H : subgroup G} [hH : H.normal] {K : subgroup \u21a5H} [h : K.characteristic] :\n\t(subgroup.map H.subtype K).normal\n\ntheorem subgroup.normal.subgroup_of {G : Type*} [group G] {H : subgroup G}\n\t(hH : H.normal) (K : subgroup G) :\n\t(H.subgroup_of K).normal\n\ndef subgroup.commutator_normal {G : Type*} [group G] (H\u2081 H\u2082 : subgroup G)\n\t[h\u2081 : H\u2081.normal] [h\u2082 : H\u2082.normal] :\n\t\u2045H\u2081, H\u2082\u2046.normal\n\nThe following is the natural language theorem statement: \"Prove that there exists a normal subgroup that is not characteristic.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_normal_not_char {G : Type*} [group G] :\n  \u2203 (H : subgroup G), H.normal \u2227 \u00acH.char ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that there exists a normal subgroup that is not characteristic.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_4_8a", "nl_statement": "Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$.", "nl_proof": "\\begin{proof}\n\nWe prove that $H$ is invariant under every inner automorphism of $G$. Consider a inner automorphism $\\phi_g$ of $G$. Now, $\\left.\\phi_g\\right|_K$ is a automorphism of $K$ because $K$ is normal in $G$. But $H$ is a characterestic subgroup of $K$, so $\\left.\\phi_g\\right|_K(H) \\subset H$, so in general $\\phi_g(H) \\subset H$. Hence $H$ is characteretstic in $G$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_4_8a {G : Type*} [group G] (H K : subgroup G)  \n  (hHK : H \u2264 K) [hHK1 : (H.subgroup_of K).normal] [hK : K.normal] : \n  H.normal :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " subgroup.normal_of_characteristic_of_normal {G : Type*} [group G]\n  {H : subgroup G} [hH : H.normal] {K : subgroup G} [hK : K.characteristic]\n  (HK : H \u2264 K) : H.normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subgroup.normal.subgroup_of {G : Type*} [group G] {H : subgroup G}\n\t(hH : H.normal) (K : subgroup G) :\n\t(H.subgroup_of K).normal\n\ntheorem subgroup.le_normalizer_of_normal {G : Type*} [group G]\n\t{H K : subgroup G} [hK : (H.subgroup_of K).normal] (HK : H \u2264 K) :\n\tK \u2264 H.normalizer\n\ntheorem add_subgroup.le_normalizer_of_normal {G : Type*} [add_group G]\n\t{H K : add_subgroup G} [hK : (H.add_subgroup_of K).normal] (HK : H \u2264 K) :\n\tK \u2264 H.normalizer\n\ndef conj_act.normal_of_characteristic_of_normal {G : Type*} [group G]\n\t{H : subgroup G} [hH : H.normal] {K : subgroup \u21a5H} [h : K.characteristic] :\n\t(subgroup.map H.subtype K).normal\n\nThe following is the natural language theorem statement: \"Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " normal_of_characteristic_normal {G : Type*} [group G] {H K : subgroup G}\n  (hH : H \u2264 K) (hK : K \u2264 G) (hK_normal : normal K G)\n  (hH_char : characteristic K H) : normal H G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_13", "nl_statement": "Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.", "nl_proof": "\\begin{proof}    \n\nSince $|G|=56=2^{3}.7$, $G$ has $2-$Sylow subgroup of order $8$, as well as $7-$Sylow subgroup of order $7$. Now, we count the number of such subgroups. Let $n_{7}$ be the number of  $7-$Sylow subgroup and $n_{2}$ be the number of  $2-$Sylow subgroup. Now $n_{7}=1+7k$ where $1+7k|8$. The choices for $k$ are $0$ or $1$. If $k=0$, there is only one $7-$Sylow subgroup and hence normal. So, assume now, that there are $8$ $7-$Sylow subgroup(for $k=1$). Now we look at $2-$ Sylow subgroups. $n_{2}=1+2k| 7$. So choice for $k$ are $0$ and $3$. If $k=0$, there is only one $2-$Sylow subgroup and hence normal. So, assume now, that there are $7$ $2-$Sylow subgroup (for $k=3$). Now we claim that simultaneously, there cannot be $8$ $7-$Sylow subgroup and $7$ $2-$Sylow subgroup. So, either $7-$Sylow subgroup is normal being unique, or  the $2-$Sylow subgroup is normal. Now, to prove the claim, we observe that there are 48 elements of order $7$. Let $H_{1}$ and $H_{2}$ be two distinct  $2-$Sylow subgroup. Now $|H_{1}|=8$. So we already get $48+8=56$ distinct elements in the group. Now $H_{2}$ being distinct from $H_{1}$, has at least one element which is not in $H_{1}$. This adds one more element in the group, at the least. Now already we have number of elements in the group exceeding the number of element in $G$. This gives a contradiction and proves the claim.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_13 {G : Type*} [group G] [fintype G]\n  (hG : card G = 56) :\n  \u2203 (p : \u2115) (P : sylow p G), P.normal :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_normal_sylow_of_card_56 {G : Type*} [group G] [fintype G]\n  (hG : fintype.card G = 56) :\n  \u2203 (p : \u2115) (h : nat.prime p) (P : sylow p G), \u2191P.normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem sylow.characteristic_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\t\u2191P.characteristic\n\ntheorem sylow.smul_eq_of_normal {p : \u2115} {G : Type*} [group G] {g : G}\n\t{P : sylow p G} [h : \u2191P.normal] :\n\tg \u2022 P = P\n\ntheorem card_sylow_eq_card_quotient_normalizer {p : \u2115} {G : Type*} [group G]\n\t[fact (nat.prime p)] [fintype (sylow p G)] (P : sylow p G) :\n\tfintype.card (sylow p G) = fintype.card (G \u29f8 \u2191P.normalizer)\n\ntheorem sylow.card_normalizer_modeq_card {G : Type u} [group G] [fintype G]\n\t{p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G}\n\t(hH : fintype.card \u21a5H = p ^ n) :\n\tfintype.card \u21a5(H.normalizer) \u2261 fintype.card G [MOD p ^ (n + 1)]\n\nThe following is the natural language theorem statement: \"Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_normal_sylow_of_card_eq_56 {G : Type*} [group G] [fintype G]\n  (hG : card G = 56) :\n  \u2203 (p : \u2115) (hp : nat.prime p) (H : sylow p G), H.normal ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_15", "nl_statement": "Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.", "nl_proof": "\\begin{proof}\n\n    Since $|G|=351=3^{2}.13$, $G$ has $3-$Sylow subgroup of order $9$, as well as $13-$Sylow subgroup of order $13$. Now, we count the number of such subgroups. Let $n_{13}$ be the number of $13-$Sylow subgroup and $n_{3}$ be the number of  $3-$Sylow subgroup. Now $n_{13}=1+13k$ where $1+13k|9$. The choices for $k$ is $0$. Hence, there is a unique $13-$Sylow subgroup and hence is normal.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_15 {G : Type*} [group G] [fintype G] \n  (hG : card G = 351) : \n  \u2203 (p : \u2115) (P : sylow p G), P.normal :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " sylow.normal_of_order_351 {G : Type u} [group G] [finite G]\n  (hG : G.card = 351) :\n  \u2203 (p : \u2115) (h : nat.prime p) (P : sylow p G), \u2191P.normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem sylow.characteristic_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\t\u2191P.characteristic\n\ntheorem sylow.normal_of_normalizer_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G)\n\t(hn : \u2191P.normalizer.normal) :\n\t\u2191P.normal\n\ntheorem sylow.subsingleton_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\tsubsingleton (sylow p G)\n\ntheorem sylow.normal_of_all_max_subgroups_normal {G : Type u} [group G]\n\t[finite G] (hnc : \u2200 (H : subgroup G), is_coatom H \u2192 H.normal) {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) :\n\t\u2191P.normal\n\nThe following is the natural language theorem statement: \"Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_normal_sylow_of_order_351 {G : Type*} [group G] [fintype G]\n  (hG : fintype.card G = 351) :\n  \u2203 (p : \u2115) (hp : nat.prime p) (P : sylow p G), P.normal ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_17", "nl_statement": "Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup.", "nl_proof": "\\begin{proof}    \n\nSince $|G|=105=3.5.7$, $G$ has $3-$Sylow subgroup of order $3$, as well as $5-$Sylow subgroup of order $5$ and, $7-$Sylow subgroup of order 7. Now, we count the number of such subgroups. Let $n_{3}$ be the number of $3-$Sylow subgroup, $n_{5}$ be the number of  $5-$Sylow subgroup, and $n_{7}$ be the number of $7-$Sylow subgroup. Now $n_{7}=1+7k$ where $1+7k|15$. The choices for $k$ are $0$ or $1$. If $k=0$, there is only one $7-$Sylow subgroup and hence normal. So, assume now, that there are $15$ $7-$Sylow subgroup(for $k=1$). Now we look at $5-$ Sylow subgroups. $n_{5}=1+5k| 21$. So choice for $k$ are $0$ and $4$. If $k=0$, there is only one $5-$Sylow subgroup and hence normal. So, assume now, that there are $24$ $5-$Sylow subgroup (for $k=4$). Now we claim that simultaneously, there cannot be $15$ $7-$Sylow subgroup and $24$ $5-$Sylow subgroup. So, either $7-$Sylow subgroup is normal being unique, or  the $5-$Sylow subgroup is normal. Now, to prove the claim, we observe that there are 90 elements of order $7$. Also, see that there are $24\\times 4=96$ number of elements of order 5. So we get $90+94=184$ number of elements which exceeds the order of the group. This gives a contradiction and proves the claim. So, now we have proved that there is either a normal $5-$Sylow subgroup or a normal $7-$Sylow subgroup.\n\n    Now we prove that indeed both $5-$ Sylow subgroup and 7 -Sylow subgroup are normal. Assume that 7 -Sylow subgroup is normal. So, there is a unique 7 -Sylow subgroup, say $H$. Now assume that there are 245 -Sylow subgroups. So, we get again $24 \\times 4=96$ elements of order 5 . From $H$ we get 7 elements which gives us total of $96+7=103$ elements. Now consider the number of 3 -Sylow subgroups. $n_3=1+3 k \\mid 35$. Then the possibilities for $k$ are 0 and 2 . But we can rule out $k=2$ because having 73 -Sylow subgroup, will mean we have 14 elements of order 3 . So we get $103+14=117$ elements in total which exceeds the order of the group. So we have now that there is a unique 3 -Sylow subgroup and hence normal. Call that subgroup $K$. Now take any one 5 -Sylow subgroup, call it $L$. Now observe $L K$ is a subgroup of $G$ with order 15 . We know that a group of order 15 is cyclic by an example in Page-143 of the book. So, there is an element of order 15. Actually we have $\\phi(15)=8$ number of elements of order 15. But then again we already had 103 elements and then we actually get at least $103+8=111$ elements which exceeds the order of the group. So, there can't be 24 5-Sylow subgroups, and hence there is a unique 5-Sylow subgroup, and hence normal.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_17 {G : Type*} [fintype G] [group G] \n  (hG : card G = 105) : \n  nonempty(sylow 5 G) \u2227 nonempty(sylow 7 G) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " exists_normal_sylow_of_card_eq_mul_prime_prime {G : Type*} [group G]\n  (hG : fintype.card G = 105) :\n  \u2203 (P : sylow 5 G) (Q : sylow 7 G), P.normal \u2227 Q.normal ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_p_group.inf_normalizer_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) (Q : sylow p G) :\n\tP \u2293 \u2191Q.normalizer = P \u2293 \u2191Q\n\ntheorem card_sylow_eq_card_quotient_normalizer {p : \u2115} {G : Type*} [group G]\n\t[fact (nat.prime p)] [fintype (sylow p G)] (P : sylow p G) :\n\tfintype.card (sylow p G) = fintype.card (G \u29f8 \u2191P.normalizer)\n\ntheorem sylow.normalizer_normalizer {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) :\n\t\u2191P.normalizer.normalizer = \u2191P.normalizer\n\ntheorem sylow.smul_eq_of_normal {p : \u2115} {G : Type*} [group G] {g : G}\n\t{P : sylow p G} [h : \u2191P.normal] :\n\tg \u2022 P = P\n\nThe following is the natural language theorem statement: \"Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_normal_sylow_of_card_105 {G : Type*} [group G] [fintype G]\n  (hG : fintype.card G = 105) :\n  \u2203 (P : sylow 5 G) (Q : sylow 7 G), P.normalizer = Q.normalizer ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_19", "nl_statement": "Prove that if $|G|=6545$ then $G$ is not simple.", "nl_proof": "\\begin{proof}    \n\nSince $|G|=132=2^{2}.3.11$, $G$ has $2-$Sylow subgroup of order $4$, as well as $11-$Sylow subgroup of order $11$, and $3-$Sylow subgroup of order $3$. Now, we count the number of such subgroups. Let $n_{11}$ be the number of  $11-$Sylow subgroup and $n_{3}$ be the number of  $3-$Sylow subgroup. Now $n_{11}=1+11k$ where $1+11k|12$. The choices for $k$ are $0$ or $1$. If $k=0$, there is only one $11-$Sylow subgroup and hence normal. So, assume now, that there are $12$ $11-$Sylow subgroup(for $k=1$). Now we look at $3-$ Sylow subgroups. $n_{3}=1+3k| 44$. So choice for $k$ are $0$, $1$, and $7$. If $k=0$, there is only one $3-$Sylow subgroup and hence normal. So, assume now, that there are $4$ $2-$Sylow subgroup (for $k=3$). Now we claim that simultaneously, there cannot be $12$ $11-$Sylow subgroup and $4$ $3-$Sylow subgroups provided there is more than one $2-$Sylow subgroups. So, either $2-$Sylow subgroup is normal or if not, then, either $11-$Sylow subgroup is normal being unique, or  the $3-$Sylow subgroup is normal(We don't consider the possibility of $22$ $3-$Sylow subgroup because of obvious reason). Now, to prove the claim, we observe that there are $120$ elements of order $11$. Also there are $8$ elements of order $3$. So we already get $120+8+1=129$ distinct elements in the group. Let us count the number of $2-$Sylow subgroups in $G$. $n_{2}=1+2k|33$. The possibilities for $k$ are $0$, $1$, $5$, $16$. Now, assume there is more than one $2-$Sylow subgroups. Let $H_{1}$ and $H_{2}$ be two distinct  $2-$Sylow subgroup. Now $|H_{1}|=4$. So we already get $129+3=132$ distinct elements in the group. Now $H_{2}$ being distinct from $H_{1}$, has at least one element which is not in $H_{1}$. This adds one more element in the group, at the least. Now already we have number of elements in the group exceeding the number of element in $G$. This gives a contradiction and proves the claim.\n\nHence $G$ is not simple.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_19 {G : Type*} [fintype G] [group G] \n  (hG : card G = 6545) : \u00ac is_simple_group G :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_simple_of_card_eq {G : Type*} [group G] [fintype G]\n  (h : fintype.card G = 6545) : \u00ac simple_group G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_subgroup.eq_bot_of_card_eq {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_eq {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem add_subgroup.eq_bot_of_card_le {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_le {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\nThe following is the natural language theorem statement: \"Prove that if $|G|=6545$ then $G$ is not simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_simple_of_card_eq_6545 {G : Type*} [group G] [fintype G] \n  (hG : fintype.card G = 6545) : \u00acsimple_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $|G|=6545$ then $G$ is not simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_21", "nl_statement": "Prove that if $|G|=2907$ then $G$ is not simple.", "nl_proof": "\\begin{proof}    \n\nSince $|G|=2907=3^{2}.17.19$, $G$ has $19-$Sylow subgroup of order $19$. Now, we count the number of such subgroups. Let $n_{19}$ be the number of $19-$Sylow subgroup. Now $n_{19}=1+19k$ where $1+19k|3^{2}.17$. The choices for $k$ is $0$. Hence, there is a unique $19-$Sylow subgroup and hence is normal. so $G$ is not simple.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_21 {G : Type*} [fintype G] [group G]\n  (hG : card G = 2907) : \u00ac is_simple_group G :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_simple_of_card_eq {G : Type*} [group G] [fintype G]\n  (h : fintype.card G = 2907) : \u00ac simple_group G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_subgroup.eq_bot_of_card_eq {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem add_subgroup.eq_bot_of_card_le {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_eq {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_le {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\nThe following is the natural language theorem statement: \"Prove that if $|G|=2907$ then $G$ is not simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_simple_of_card_eq_2907 {G : Type*} [group G] [fintype G] \n  (hG : fintype.card G = 2907) : \u00acsimple_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $|G|=2907$ then $G$ is not simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_23", "nl_statement": "Prove that if $|G|=462$ then $G$ is not simple.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be a group of order $462=11 \\cdot 42$. Note that 11 is a prime not dividing 42 . Let $P \\in$ $S y l_{11}(G)$. [We know $P$ exists since $S y l_{11}(G) \\neq \\emptyset$]. Note that $|P|=11^1=11$ by definition. \n\n\n\nThe number of Sylow 11-subgroups of $G$ is of the form $1+k \\cdot 11$, i.e., $n_{11} \\equiv 1$ (mod 11) and $n_{11}$ divides 42 . The only such number that divides 42 and equals 1 (mod 11) is 1 so $n_{11}=1$. Hence $P$ is the unique Sylow 11-subgroup.\n\n\n\nSince $P$ is the unique Sylow Il-subgroup, this implies that $P$ is normal in $G$.\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_23 {G : Type*} [fintype G] [group G]\n  (hG : card G = 462) : \u00ac is_simple_group G :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " not_simple_of_card_eq {G : Type*} [group G] [fintype G]\n  (h : fintype.card G = 462) : \u00ac simple_group G ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem add_subgroup.eq_bot_of_card_eq {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem add_subgroup.eq_bot_of_card_le {G : Type*} [add_group G]\n\t(H : add_subgroup G) [fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_eq {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H = 1) :\n\tH = \u22a5\n\ntheorem subgroup.eq_bot_of_card_le {G : Type*} [group G] (H : subgroup G)\n\t[fintype \u21a5H] (h : fintype.card \u21a5H \u2264 1) :\n\tH = \u22a5\n\nThe following is the natural language theorem statement: \"Prove that if $|G|=462$ then $G$ is not simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_simple_of_card_eq_462 {G : Type*} [group G] [fintype G] \n  (hG : fintype.card G = 462) : \u00ac simple_group G ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $|G|=462$ then $G$ is not simple.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_4_5_33", "nl_statement": "Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$.", "nl_proof": "\\begin{proof}\n\n    Let $G$ be a group and $P$ is a normal $p$-Sylow subgroup of $G .|G|=p^a . m$ where $p \\nmid m$. Then $|P|=p^a$. Let $H$ be a subgroup of $G$. Now if $|H|=k$ such that $p \\nmid k$. Then $P \\cap H=\\{e\\}$. There is nothing to prove in this case. Let $|H|=p^b . n$, where $b \\leq a$, and $p \\nmid n$. Now consider $P H$ which is a subgroup of $G$, as $P$ is normal. Now $|P H|=\\frac{|P||H|}{|P \\cap H|}=\\frac{p^{a+b} \\cdot n}{|P \\cap H|}$. Now since $P H \\leq G$, so $|P H|=p^a$.l, as $P \\leq P H$. This forces $|P \\cap H|=p^b$. So by order consideration we have $P \\cap H$ is a sylow $-p$ subgroup of $H$. Now we know $P$ is unique $p$ - Sylow subgroup. Suppose $H$ has a sylow-p subgroup distinct from $P \\cap H$, call it $H_1$. Now $H_1$ is a p-subgroup of $G$. So, $H_1$ is contained in some Sylow-p subgroup of $G$, call it $P_1$. Clearly $P_1$ is distinct from $P$, which is a contradiction. So $P \\cap H$ is the only $p$-Sylow subgroup of $H$, and hence normal in $H$\n\n\\end{proof}", "formal_statement": "theorem exercise_4_5_33 {G : Type*} [group G] [fintype G] {p : \u2115} \n  (P : sylow p G) [hP : P.normal] (H : subgroup G) [fintype H] : \n  \u2200 R : sylow p H, R.to_subgroup = (H \u2293 P.to_subgroup).subgroup_of H \u2227\n  nonempty (sylow p H) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " sylow.subsingleton_of_normal {G : Type u} [group G] {p : \u2115}\n  [fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n  subsingleton (sylow p G) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem sylow.subsingleton_of_normal {G : Type u} [group G] {p : \u2115}\n\t[fact (nat.prime p)] [finite (sylow p G)] (P : sylow p G) (h : \u2191P.normal) :\n\tsubsingleton (sylow p G)\n\ntheorem is_p_group.inf_normalizer_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) (Q : sylow p G) :\n\tP \u2293 \u2191Q.normalizer = P \u2293 \u2191Q\n\ntheorem is_p_group.to_sup_of_normal_left' {p : \u2115} {G : Type*} [group G]\n\t{H K : subgroup G} (hH : is_p_group p \u21a5H) (hK : is_p_group p \u21a5K)\n\t(hHK : K \u2264 H.normalizer) :\n\tis_p_group p \u21a5(H \u2294 K)\n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _\n\nThe following is the natural language theorem statement: \"Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " unique_sylow_of_normal_sylow_inter_subgroup {G : Type*} [group G]\n  {p : \u2115} [hp : fact (nat.prime p)] {P : subgroup G} (hP : is_p_group p P)\n  (hP_normal : P \u2264 normalizer G P) {H : subgroup G} :\n  is_p_group p (P \u2229 H) \u2227 \u2200 (Q : subgroup G), is_p_group p Q \u2192 Q \u2264 P \u2229 H ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_7_1_2", "nl_statement": "Prove that if $u$ is a unit in $R$ then so is $-u$.", "nl_proof": "\\begin{proof}\n\n    Solution: Since $u$ is a unit, we have $u v=v u=1$ for some $v \\in R$. Thus, we have\n\n$$\n\n(-v)(-u)=v u=1\n\n$$\n\nand\n\n$$\n\n(-u)(-v)=u v=1 .\n\n$$\n\nThus $-u$ is a unit.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_1_2 {R : Type*} [ring R] {u : R}\n  (hu : is_unit u) : is_unit (-u) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " units.neg_is_unit {R : Type*} [ring R] (u : units R) :\n  units (-u) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem module.ray.units_smul_of_neg {R : Type*} [strict_ordered_comm_ring R]\n\t{M : Type*} [add_comm_group M] [module R M] (u : R\u02e3) (hu : \u2191u < 0)\n\t(v : module.ray R M) :\n\tu \u2022 v = -v\n\ntheorem units.neg_smul {R M : Type*} [ring R] [add_comm_group M] [module R M]\n\t(u : R\u02e3) (x : M) :\n\t-u \u2022 x = -(u \u2022 x)\n\ntheorem add_units.neg_unique {\u03b1 : Type u} [add_monoid \u03b1] {u\u2081 u\u2082 : add_units \u03b1}\n\t(h : \u2191u\u2081 = \u2191u\u2082) :\n\t\u2191-u\u2081 = \u2191-u\u2082\n\ntheorem add_units.coe_neg {M : Type*} [subtraction_monoid M] (u : add_units M) :\n\t\u2191-u = -\u2191u\n\nThe following is the natural language theorem statement: \"Prove that if $u$ is a unit in $R$ then so is $-u$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_unit_neg_of_is_unit {R : Type*} [comm_ring R] (u : R) (hu : is_unit u) :\n  is_unit (-u) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $u$ is a unit in $R$ then so is $-u$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_7_1_12", "nl_statement": "Prove that any subring of a field which contains the identity is an integral domain.", "nl_proof": "\\begin{proof}\n\n    Solution: Let $R \\subseteq F$ be a subring of a field. (We need not yet assume that $1 \\in R$ ). Suppose $x, y \\in R$ with $x y=0$. Since $x, y \\in F$ and the zero element in $R$ is the same as that in $F$, either $x=0$ or $y=0$. Thus $R$ has no zero divisors. If $R$ also contains 1 , then $R$ is an integral domain.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_1_12 {F : Type*} [field F] {K : subring F}\n  (hK : (1 : F) \u2208 K) : is_domain K :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_domain_of_is_subring_of_field {R S : Type*} [comm_ring R]\n  [comm_ring S] [is_field S] (hRS : is_subring R S) : is_domain R ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem ring.dimension_le_one.integral_closure (R A : Type*) [comm_ring R]\n\t[comm_ring A] [nontrivial R] [is_domain A] [algebra R A]\n\t(h : ring.dimension_le_one R) :\n\tring.dimension_le_one \u21a5(integral_closure R A)\n\ntheorem is_field_of_is_integral_of_is_field' {R S : Type*} [comm_ring R]\n\t[comm_ring S] [is_domain S] [algebra R S] (H : algebra.is_integral R S)\n\t(hR : is_field R) :\n\tis_field S\n\ntheorem ring_hom.finite.to_is_integral {R S : Type*} [comm_ring R] [comm_ring S]\n\t{f : R \u2192+* S} (h : f.finite) :\n\tf.is_integral\n\ntheorem algebra.is_integral.is_field_iff_is_field {R S : Type*} [comm_ring R]\n\t[nontrivial R] [comm_ring S] [is_domain S] [algebra R S]\n\t(H : algebra.is_integral R S) (hRS : function.injective \u21d1(algebra_map R S)) :\n\tis_field R \u2194 is_field S\n\nThe following is the natural language theorem statement: \"Prove that any subring of a field which contains the identity is an integral domain.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " integral_domain_of_subring_of_field {R : Type*} [field R] {S : Type*} \n  [ring S] [subring R S] (h : (1 : S) \u2260 0) : integral_domain S ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that any subring of a field which contains the identity is an integral domain.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_7_2_2", "nl_statement": "Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$.", "nl_proof": "\\begin{proof}\n\n    Solution: If $b p(x)=0$ for some nonzero $b \\in R$, then it is clear that $p(x)$ is a zero divisor.\n\nNow suppose $p(x)$ is a zero divisor; that is, for some $q(x)=\\sum_{i=0}^m b_i x^i$, we have $p(x) q(x)=0$. We may choose $q(x)$ to have minimal degree among the nonzero polynomials with this property.\n\nWe will now show by induction that $a_i q(x)=0$ for all $0 \\leq i \\leq n$.\n\nFor the base case, note that\n\n$$\n\np(x) q(x)=\\sum_{k=0}^{n+m}\\left(\\sum_{i+j=k} a_i b_j\\right) x^k=0 .\n\n$$\n\nThe coefficient of $x^{n+m}$ in this product is $a_n b_m$ on one hand, and 0 on the other. Thus $a_n b_m=0$. Now $a_n q(x) p(x)=0$, and the coefficient of $x^m$ in $q$ is $a_n b_m=0$. Thus the degree of $a_n q(x)$ is strictly less than that of $q(x)$; since $q(x)$ has minimal degree among the nonzero polynomials which multiply $p(x)$ to 0 , in fact $a_n q(x)=0$. More specifically, $a_n b_i=0$ for all $0 \\leq i \\leq m$.\n\nFor the inductive step, suppose that for some $0 \\leq t<n$, we have $a_r q(x)=0$ for all $t<r \\leq n$. Now\n\n$$\n\np(x) q(x)=\\sum_{k=0}^{n+m}\\left(\\sum_{i+j=k} a_i b_j\\right) x^k=0 .\n\n$$\n\nOn one hand, the coefficient of $x^{m+t}$ is $\\sum_{i+j=m+t} a_i b_j$, and on the other hand, it is 0 . Thus\n\n$$\n\n\\sum_{i+j=m+t} a_i b_j=0 .\n\n$$\n\nBy the induction hypothesis, if $i \\geq t$, then $a_i b_j=0$. Thus all terms such that $i \\geq t$ are zero. If $i<t$, then we must have $j>m$, a contradiction. Thus we have $a_t b_m=0$. As in the base case,\n\n$$\n\na_t q(x) p(x)=0\n\n$$\n\nand $a_t q(x)$ has degree strictly less than that of $q(x)$, so that by minimality, $a_t q(x)=0$.\n\nBy induction, $a_i q(x)=0$ for all $0 \\leq i \\leq n$. In particular, $a_i b_m=0$. Thus $b_m p(x)=0$.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_2_2 {R : Type*} [ring R] (p : polynomial R) :\n  p \u2223 0 \u2194 \u2203 b : R, b \u2260 0 \u2227 b \u2022 p = 0 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " polynomial.is_zero_divisor_iff {R : Type u} [semiring R]\n  [no_zero_divisors R] {p : polynomial R} :\n  is_zero_divisor p \u2194 \u2203 (b : R), b \u2260 0 \u2227 b * p = 0 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem mv_polynomial.ne_zero_iff {R : Type u} {\u03c3 : Type*} [comm_semiring R]\n\t{p : mv_polynomial \u03c3 R} :\n\tp \u2260 0 \u2194 \u2203 (d : \u03c3 \u2192\u2080 \u2115), mv_polynomial.coeff d p \u2260 0\n\ntheorem polynomial.zero_le_degree_iff {R : Type u} [semiring R]\n\t{p : polynomial R} :\n\t0 \u2264 p.degree \u2194 p \u2260 0\n\ntheorem polynomial.trailing_coeff_nonzero_iff_nonzero {R : Type u} [semiring R]\n\t{p : polynomial R} :\n\tp.trailing_coeff \u2260 0 \u2194 p \u2260 0\n\ntheorem polynomial.is_unit_iff {R : Type u} [semiring R] [no_zero_divisors R]\n\t{p : polynomial R} :\n\tis_unit p \u2194 \u2203 (r : R), is_unit r \u2227 \u21d1polynomial.C r = p\n\nThe following is the natural language theorem statement: \"Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_zero_divisor_iff_exists_nonzero_mul_eq_zero {R : Type*} [comm_ring R]\n  {p : polynomial R} :\n  p.is_zero_divisor \u2194 \u2203 (b : R), b \u2260 0 \u2227 b * p = 0 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_7_3_16", "nl_statement": "Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$.", "nl_proof": "\\begin{proof}\n\n    Suppose $r \\in \\varphi[Z(R)]$. Then $r=\\varphi(z)$ for some $z \\in Z(R)$. Now let $x \\in S$. Since $\\varphi$ is surjective, we have $x=\\varphi y$ for some $y \\in R$. Now\n\n$$\n\nx r=\\varphi(y) \\varphi(z)=\\varphi(y z)=\\varphi(z y)=\\varphi(z) \\varphi(y)=r x .\n\n$$\n\nThus $r \\in Z(S)$.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_3_16 {R S : Type*} [ring R] [ring S] \n  {\u03c6 : R \u2192+* S} (hf : surjective \u03c6) : \n  \u03c6 '' (center R) \u2282 center S :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " ring_hom.center_image_subset_center {R : Type u} {S : Type v}\n  [ring R] [ring S] (f : R \u2192+* S) (hf : function.surjective f) :\n  f '' (set.center R) \u2286 set.center S ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem subring.coe_center (R : Type u) [ring R] :\n\t\u2191(subring.center R) = set.center R\n\ntheorem ring_hom.is_subring_image {R : Type u} {S : Type v} [ring R] [ring S]\n\t(f : R \u2192+* S) {s : set R} (hs : is_subring s) :\n\tis_subring (\u21d1f '' s)\n\ntheorem set.image_subset_image_iff {\u03b1 \u03b2 : Type*} {s t : set \u03b1} {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.injective f) :\n\tf '' s \u2286 f '' t \u2194 s \u2286 t\n\ntheorem subring.center_to_subsemiring (R : Type u) [ring R] :\n\t(subring.center R).to_subsemiring = subsemiring.center R\n\nThe following is the natural language theorem statement: \"Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " center_image_subset_center {R S : Type*} [ring R] [ring S]\n  (f : R \u2192+* S) (hf : function.surjective f) :\n  f '' (center R) \u2286 center S ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_7_4_27", "nl_statement": "Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$.", "nl_proof": "\\begin{proof}\n\n    $\\mathfrak{N}(R)$ is an ideal of $R$. Thus for all $b \\in R,-a b$ is nilpotent. Hence $1-a b$ is a unit in $R$.\n\n\\end{proof}", "formal_statement": "theorem exercise_7_4_27 {R : Type*} [comm_ring R] (hR : (0 : R) \u2260 1) \n  {a : R} (ha : is_nilpotent a) (b : R) : \n  is_unit (1-a*b) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_unit_one_sub_self_of_mem_nonunits {R : Type u}\n  [comm_ring R] [local_ring R] (a : R) (h : a \u2208 nonunits R) :\n  is_unit (1 - a) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem local_ring.is_unit_of_mem_nonunits_one_sub_self {R : Type u}\n\t[comm_ring R] [local_ring R] (a : R) (h : 1 - a \u2208 nonunits R) :\n\tis_unit a\n\ntheorem local_ring.is_unit_one_sub_self_of_mem_nonunits {R : Type u}\n\t[comm_ring R] [local_ring R] (a : R) (h : a \u2208 nonunits R) :\n\tis_unit (1 - a)\n\ntheorem principal_ideal_ring.ne_zero_of_mem_factors {R : Type v} [comm_ring R]\n\t[is_domain R] [is_principal_ideal_ring R] {a b : R} (ha : a \u2260 0)\n\t(hb : b \u2208 principal_ideal_ring.factors a) :\n\tb \u2260 0\n\ntheorem unique_factorization_monoid.no_factors_of_no_prime_factors {R : Type*}\n\t[cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b : R}\n\t(ha : a \u2260 0) (h : \u2200 {d : R}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acprime d) {d : R} :\n\td \u2223 a \u2192 d \u2223 b \u2192 is_unit d\n\nThe following is the natural language theorem statement: \"Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_unit_of_nilpotent_of_comm_ring {R : Type*} [comm_ring R] \n  (hR : \u2203 (a : R), a \u2260 0 \u2227 a \u2260 1) (a : R) (ha : a \u2260 0) (hna : a.is_nilpotent) \n  (b : R) : is_unit (1 - a * b) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_8_2_4", "nl_statement": "Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.", "nl_proof": "\\begin{proof}\n\n    Let $I \\leq R$ be a nonzero ideal and let $I / \\sim$ be the set of equivalence classes of elements of $I$ with regards to the relation of being associates. We can equip $I / \\sim$ with a partial order with $[x] \\leq[y]$ if $y \\mid x$. Condition (ii) implies all chains in $I / \\sim$ have an upper bound, so By Zorn's lemma $I / \\sim$ contains a maximal element, i.e. $I$ contains a class of associated elements which are minimal with respect to divisibility.\n\n\n\nNow let $a, b \\in I$ be two elements such that $[a]$ and $[b]$ are minimal with respect to divisibility. By condition (i) $a$ and $b$ have a greatest common divisor $d$ which can be expressed as $d=$ $a x+b y$ for some $x, y \\in R$. In particular, $d \\in I$. Since $a$ and $b$ are minimal with respect to divisibility, we have that $[a]=[b]=[d]$. Therefore $I$ has at least one element $a$ that is minimal with regard to divisibility and all such elements are associate, and we have $I=\\langle a\\rangle$ and so $I$ is principal. We conclude $R$ is a principal ideal domain.\n\n\\end{proof}", "formal_statement": "theorem exercise_8_2_4 {R : Type*} [ring R][no_zero_divisors R] \n  [cancel_comm_monoid_with_zero R] [gcd_monoid R]\n  (h1 : \u2200 a b : R, a \u2260 0 \u2192 b \u2260 0 \u2192 \u2203 r s : R, gcd a b = r*a + s*b)\n  (h2 : \u2200 a : \u2115 \u2192 R, (\u2200 i j : \u2115, i < j \u2192 a i \u2223 a j) \u2192 \n  \u2203 N : \u2115, \u2200 n \u2265 N, \u2203 u : R, is_unit u \u2227 a n = u * a N) : \n  is_principal_ideal_ring R :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " is_principal_ideal_ring_of_gcd_dvd_iff_exists_and_right_div_gcd_ne_zero\n  {R : Type*} [integral_domain R] (h : \u2200 (a b : R), a \u2260 0 \u2192 b \u2260 0 \u2192\n    \u2203 (r s : R), gcd_monoid.gcd a b = r * a + s * b)\n  (h' : \u2200 (a : \u2115 \u2192 R), (\u2200 (i : \u2115), a (i + 1) \u2223 a i) \u2192 \u2203 (N : \u2115),\n    \u2200 (n : \u2115), n \u2265 N \u2192 a n = units.mk0 (a N)) :\n  is_principal_ideal_ring R ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.div_mod_unique {a b r q : \u2124} (h : 0 < b) :\n\ta / b = q \u2227 a % b = r \u2194 r + b * q = a \u2227 0 \u2264 r \u2227 r < b\n\ntheorem gcd_dvd_iff_exists {R : Type u} [comm_ring R] [is_domain R]\n\t[is_principal_ideal_ring R] [gcd_monoid R] (a b : R) {z : R} :\n\tgcd_monoid.gcd a b \u2223 z \u2194 \u2203 (x y : R), z = a * x + b * y\n\ntheorem int.gcd_div_gcd_div_gcd {i j : \u2124} (H : 0 < i.gcd j) :\n\t(i / \u2191(i.gcd j)).gcd (j / \u2191(i.gcd j)) = 1\n\ntheorem right_div_gcd_ne_zero {R : Type*} [euclidean_domain R] [gcd_monoid R]\n\t{p q : R} (hq : q \u2260 0) :\n\tq / gcd_monoid.gcd p q \u2260 0\n\nThe following is the natural language theorem statement: \"Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " PID_of_gcd_exists_and_divides_of_finite_type {R : Type*} \n  [integral_domain R] (hgcd : \u2200 a b : R, a \u2260 0 \u2228 b \u2260 0 \u2192 \u2203 r s : R, gcd a b = r * a + s * b) \n  (hdiv : \u2200 (a : \u2115 \u2192 R) (h : \u2200 i, a (i + 1) \u2223 a i), \u2203 N : \u2115, \u2200 n \u2265 N, a n = a N * (a n / a N)) :\n  PID R ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_8_3_5a", "nl_statement": "Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$.", "nl_proof": "\\begin{proof}\n\n    Suppose $a=a_1+a_2 \\sqrt{-n}, b=b_1+b_2 \\sqrt{-n} \\in R$ are such that $2=a b$, then $N(a) N(b)=4$. Without loss of generality we can assume $N(a) \\leq N(b)$, so $N(a)=1$ or $N(a)=2$. Suppose $N(a)=2$, then $a_1^2+n a_2^2=2$ and since $n>3$ we have $a_2=0$, which implies $a_1^2=2$, a contradiction. So $N(a)=1$ and $a$ is a unit. Therefore 2 is irreducible in $R$.\n\n\n\nSuppose now $\\sqrt{-n}=a b$, then $N(a) N(b)=n$ and we can assume $N(a)<$ $N(b)$ since $n$ is square free. Suppose $N(a)>1$, then $a_1^2+n a_2^2>1$ and $a_1^2+n a_2^2 \\mid n$, so $a_2=0$, and therefore $a_1^2 \\mid n$. Since $n$ is squarefree, $a_1=\\pm 1$, a contradiction. Therefore $N(a)=1$ and so $a$ is a unit and $\\sqrt{-n}$ is irreducible.\n\n\n\nSuppose $1+\\sqrt{-n}=a b$, then $N(a) N(b)=n+1$ and we can assume $N(a) \\leq N(b)$. Suppose $N(a)>1$, then $a_1^2+n a_2^2>1$ and $a_1^2+n a_2^2 \\mid n+1$. If $\\left|a_2\\right| \\geq 2$, then since $n>3$ we have a contradiction since $N(a)$ is too large. If $\\left|a_2\\right|=1$, then $a_1^2+n$ divides $1+n$ and so $a_1=\\pm 1$, and in either case $N(a)=n+1$ which contradicts $N(a) \\leq N(b)$. If $a_2=0$ then $a_1^2\\left(b_1^2+n b_2^2\\right)=\\left(a_1 b_1\\right)^2+n\\left(a_1 b_2\\right)^2=n+1$. If $\\left|a_1 b_2\\right| \\geq 2$ we have a contradiction. If $\\left|a_1 b_2\\right|=1$ then $a_1=\\pm 1$ which contradicts $N(a)>1$. If $\\left|a_1 b_2\\right|=0$, then $b_2=0$ and so $a_1 b_1=\\sqrt{-n}$, a contradiction. Therefore $N(a)=1$ and so $a$ is a unit and $1+\\sqrt{-n}$ is irreducible.\n\n\\end{proof}", "formal_statement": "theorem exercise_8_3_5a {n : \u2124} (hn0 : n > 3) (hn1 : squarefree n) : \n  irreducible (2 :zsqrtd $ -n) \u2227 \n  irreducible (\u27e80, 1\u27e9 : zsqrtd $ -n) \u2227 \n  irreducible (1 + \u27e80, 1\u27e9 : zsqrtd $ -n) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_of_squarefree_int_greater_than_three {n : \u2115}\n  (hn : n > 3) (hns : squarefree n) :\n  irreducible (2 : \u2124[sqrt (-n)]) \u2227 irreducible (sqrt (-n)) \u2227\n  irreducible (1 + sqrt (-n)) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem nat.squarefree_of_factorization_le_one {n : \u2115} (hn : n \u2260 0)\n\t(hn' : \u2200 (p : \u2115), \u21d1(n.factorization) p \u2264 1) :\n\tsquarefree n\n\ntheorem nat.sq_mul_squarefree_of_pos {n : \u2115} (hn : 0 < n) :\n\t\u2203 (a b : \u2115), 0 < a \u2227 0 < b \u2227 b ^ 2 * a = n \u2227 squarefree a\n\ntheorem nat.two_mul_odd_div_two {n : \u2115} (hn : n % 2 = 1) :\n\t2 * (n / 2) = n - 1\n\ntheorem is_primitive_root.arg {n : \u2115} {\u03b6 : \u2102} (h : is_primitive_root \u03b6 n)\n\t(hn : n \u2260 0) :\n\t\u2203 (i : \u2124), \u03b6.arg = \u2191i / \u2191n * (2 * real.pi) \u2227 is_coprime i \u2191n \u2227 i.nat_abs < n\n\nThe following is the natural language theorem statement: \"Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_of_sqrt_neg_n_of_sqrt_neg_n_add_one_of_two {n : \u2115} \n  (hn : n > 3) (h : nat.prime 2) (h_sqrt_neg_n : \u2203 (x : \u2124), x ^ 2 = -n) :\n  irreducible (2 : \u2124[sqrt (-n)]) \u2227 irreducible (sqrt (-n)) \u2227 \n  irreducible (1 + sqrt (-n)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_8_3_6b", "nl_statement": "Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.", "nl_proof": "\\begin{proof}\n\n    The division algorithm gives us that every element of $\\mathbb{Z}[i] /\\langle q\\rangle$ is represented by an element $a+b i$ such that $0 \\leq a, b<q$. Each such choice is distinct since if $a_1+b_1 i+\\langle q\\rangle=a_2+b_2 i+\\langle q\\rangle$, then $\\left(a_1-a_2\\right)+\\left(b_1-b_2\\right) i$ is divisible by $q$, so $a_1 \\equiv a_2 \\bmod q$ and $b_1 \\equiv b_2 \\bmod q$. So $\\mathbb{Z}[i] /\\langle q\\rangle$ has order $q^2$.\n\n\n\nSince $q \\equiv 3 \\bmod 4, q$ is irreducible, hence prime in $\\mathbb{Z}[i]$. Therefore $\\langle q\\rangle$ is a prime ideal in $\\mathbb{Z}[i]$, and so $\\mathbb{Z}[i] /\\langle q\\rangle$ is an integral domain. So $\\mathbb{Z}[i] /\\langle q\\rangle$ is a field.\n\n\\end{proof}", "formal_statement": "theorem exercise_8_3_6b {q : \u2115} (hq0 : q.prime) \n  (hq1 : q \u2261 3 [ZMOD 4]) {R : Type*} [ring R]\n  (hR : R = (gaussian_int \u29f8 ideal.span ({q} : set gaussian_int))) : \n  is_field R \u2227 \u2203 finR : fintype R, @card R finR = q^2 :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " zmod.exists_sq_eq_prime_iff_of_mod_four_eq_three {p q : \u2115}\n  [fact (nat.prime p)] [fact (nat.prime q)] (hp3 : p % 4 = 3) (hq3 : q % 4 = 3)\n  (hpq : p \u2260 q) :\n  is_square \u2191q \u2194 \u00acis_square \u2191p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem zmod.exists_sq_eq_prime_iff_of_mod_four_eq_three {p q : \u2115}\n\t[fact (nat.prime p)] [fact (nat.prime q)] (hp3 : p % 4 = 3) (hq3 : q % 4 = 3)\n\t(hpq : p \u2260 q) :\n\tis_square \u2191q \u2194 \u00acis_square \u2191p\n\ntheorem polynomial.ker_mod_by_monic_hom {R : Type u} [comm_ring R]\n\t{q : polynomial R} (hq : q.monic) :\n\tlinear_map.ker q.mod_by_monic_hom = submodule.restrict_scalars R (ideal.span {q})\n\ntheorem ideal.span_singleton_prime {\u03b1 : Type u} [comm_semiring \u03b1] {p : \u03b1}\n\t(hp : p \u2260 0) :\n\t(ideal.span {p}).is_prime \u2194 prime p\n\ntheorem zmod.exists_sq_eq_prime_iff_of_mod_four_eq_one {p q : \u2115}\n\t[fact (nat.prime p)] [fact (nat.prime q)] (hp1 : p % 4 = 1) (hq1 : q \u2260 2) :\n\tis_square \u2191q \u2194 is_square \u2191p\n\nThe following is the natural language theorem statement: \"Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " quotient_ring_is_field_of_prime_equiv_3_mod_4 {q : \u2124} (hq : nat.prime q)\n  (hq\u2081 : q % 4 = 3) :\n  is_field (quotient_ring \u2124 (ideal.span {q})) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_9_1_10", "nl_statement": "Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals.", "nl_proof": "\\begin{proof}\n\n    Let $R=\\mathbb{Z}\\left[x_1, x_2, \\ldots, x_n\\right]$ and consider the ideal $K=\\left(x_{2 k+1} x_{2 k+2} \\mid k \\in \\mathbb{Z}_{+}\\right)$in $R$.\n\nConsider the family of subsets $X=\\left\\{\\left\\{x_{2 k+1}, x_{2 k+2}\\right\\} \\mid k \\in \\mathbb{Z}_{+}\\right\\}$, and $Y$ the set of choice function on $X$, ie the set of functions $\\lambda: \\mathbb{Z}_{+} \\rightarrow \\cup_{\\mathbb{Z}_{+}}\\left\\{x_{2 k+1}, x_{2 k+2}\\right\\}$ with $\\lambda(a) \\in$ $\\left\\{x_{2 a+1}, x_{2 a+2}\\right\\}$\n\nFor each $\\lambda \\in Y$ we have the ideal $I_\\lambda=(\\lambda(0), \\lambda(1), \\ldots)$.\n\nAll these ideals are distinct, ie for $\\lambda \\neq \\lambda^{\\prime}$ we have $I_\\lambda \\neq I_{\\lambda^{\\prime}}$.\n\nWe also have that by construction $K \\subset I_\\lambda$ for all $\\lambda \\in Y$.\n\nBy the Third Isomorphism Treorem\n\n$$\n\n(R / K) /\\left(I_\\lambda / K\\right) \\cong R / I_\\lambda\n\n$$\n\nNote also that $R / I_\\lambda$ is isomorphic to the polynomial ring over $R$ with indeterminates the $x_i$ not in the image of $\\lambda$, and since there is a countably infinite number of them we can conclude $R / I_\\lambda \\cong R$, an integral domain. Therefore $I_\\lambda / K$ is a prime ideal of $R / K$\n\n\n\nWe prove now that $I_\\lambda / K$ is a minimal prime ideal. Let $J / K \\subseteq I_\\lambda / K$ be a prime ideal. For each pair $\\left(x_{2 k+1}, x_{2 k+2}\\right)$ we have that $x_{2 k+1} x_{2 k+2} \\in K$ so $x_{2 k+1} x_{2 k+2} \\bmod K \\in J / K$ so $J$ must contain one of the elements in $\\left\\{x_{2 k+1}, x_{2 k+2}\\right\\}$. But since $J / K \\subseteq I_\\lambda / K$ it must be $\\lambda(k)$ for all $k \\in \\mathbb{Z}_{+}$. Therefore $J / K=I_\\lambda / K$\n\n\\end{proof}", "formal_statement": "theorem exercise_9_1_10 {f : \u2115 \u2192 mv_polynomial \u2115 \u2124} \n  (hf : f = \u03bb i, X i * X (i+1)): \n  infinite (minimal_primes (mv_polynomial \u2115 \u2124 \u29f8 ideal.span (range f))) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " minimal_primes_of_infinite_ring_of_infinite_ideal {R : Type*}\n  [comm_ring R] (I : ideal R) (hI : I.is_infinite) :\n  \u2203 (p : ideal R), p.is_prime \u2227 p.is_minimal \u2227 p.is_infinite ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem ideal.Inf_minimal_primes {R : Type*} [comm_ring R] {I : ideal R} :\n\thas_Inf.Inf I.minimal_primes = I.radical\n\ntheorem ideal.minimal_primes_eq_comap {R : Type*} [comm_ring R] {I : ideal R} :\n\tI.minimal_primes = ideal.comap (ideal.quotient.mk I) '' minimal_primes (R \u29f8 I)\n\ntheorem ideal.radical_minimal_primes {R : Type*} [comm_ring R] {I : ideal R} :\n\tI.radical.minimal_primes = I.minimal_primes\n\ntheorem ideal.fst_comp_quotient_inf_equiv_quotient_prod {R : Type u}\n\t[comm_ring R] (I J : ideal R) (coprime : I \u2294 J = \u22a4) :\n\t(ring_hom.fst (R \u29f8 I) (R \u29f8 J)).comp \u2191(I.quotient_inf_equiv_quotient_prod J coprime) = ideal.quotient.factor (I \u2293 J) I inf_le_left\n\nThe following is the natural language theorem statement: \"Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_infinitely_many_minimal_prime_ideals_of_quotient_ring \n  (R : Type*) [comm_ring R] :\n  \u2203 (I : ideal R), I.is_prime \u2227 I.is_minimal \u2227 \u2200 (J : ideal R), J.is_prime \u2192 J.is_minimal \u2192 J = I ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_9_4_2a", "nl_statement": "Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.", "nl_proof": "\\begin{proof}\n\n$$\n\nx^4-4 x^3+6\n\n$$\n\nThe polynomial is irreducible by Eisenstiens Criterion since the prime $2$ doesnt divide the leading coefficient 2 divide coefficients of the low order term $-4,0,0$ but 6 is not divided by the square of 2.\n\n\\end{proof}", "formal_statement": "theorem exercise_9_4_2a : irreducible (X^4 - 4*X^3 + 6 : polynomial \u2124) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_of_coprime {p : polynomial \u2124} (hp : p.is_unit_trinomial)\n  (h : \u2200 (q : polynomial \u2124), q \u2223 p \u2192 q \u2223 p.mirror \u2192 is_unit q) :\n  irreducible p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem polynomial.irreducible_of_degree_eq_one {R : Type u} [field R]\n\t{p : polynomial R} (hp1 : p.degree = 1) :\n\tirreducible p\n\ntheorem polynomial.monic.irreducible_of_degree_eq_one {R : Type u} [comm_ring R]\n\t[is_domain R] {p : polynomial R} (hp1 : p.degree = 1) (hm : p.monic) :\n\tirreducible p\n\ntheorem polynomial.monic.irreducible_iff_nat_degree {R : Type u}\n\t[comm_semiring R] [no_zero_divisors R] {p : polynomial R} (hp : p.monic) :\n\tirreducible p \u2194 p \u2260 1 \u2227 \u2200 (f g : polynomial R), f.monic \u2192 g.monic \u2192 f * g = p \u2192 f.nat_degree = 0 \u2228 g.nat_degree = 0\n\ntheorem polynomial.is_unit_trinomial.irreducible_of_coprime {p : polynomial \u2124}\n\t(hp : p.is_unit_trinomial)\n\t(h : \u2200 (q : polynomial \u2124), q \u2223 p \u2192 q \u2223 p.mirror \u2192 is_unit q) :\n\tirreducible p\n\nThe following is the natural language theorem statement: \"Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_of_polynomial_of_degree_four_of_coeff_four_of_coeff_six\n  (p : polynomial \u2124) (hp : p.degree = 4) (hp\u2081 : p.coeff 4 = 1) (hp\u2082 : p.coeff 6 = -4) :\n  irreducible p ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_9_4_2c", "nl_statement": "Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$.", "nl_proof": "\\begin{proof}\n\n$$\n\np(x)=x^4+6 x^3+4 x^2+2 x+1\n\n$$\n\nWe calculate $p(x-1)$\n\n$$\n\n\\begin{aligned}\n\n(x-1)^4 & =x^4-4 x^3+6 x^2-4 x+1 \\\\\n\n6(x-1)^3 & =6 x^3-18 x^2+18 x-6 \\\\\n\n4(x-1)^2 & =4 x^2-8 x+4 \\\\\n\n2(x-1) & =2 x-2 \\\\\n\n1 & =1\n\n\\end{aligned}\n\n$$\n\n$$\n\n\\begin{aligned}\n\n& p(x-1)=(x-1)^4+6(x-1)^3+4(x-1)^2+2(x-1)+1=x^4+2 x^3-8 x^2+ \\\\\n\n& 8 x-2 \\\\\n\n& q(x)=x^4+2 x^3-8 x^2+8 x-2\n\n\\end{aligned}\n\n$$\n\n$q(x)$ is irreducible by Eisenstiens Criterion since the prime $\\$ 2 \\$$ divides the lower coefficient but $\\$ 2^{\\wedge} 2 \\$$ doesnt divide constant $-2$. Any factorization of $p(x)$ would provide a factor of $p(x)(x-1)$\n\nSince:\n\n$$\n\n\\begin{aligned}\n\n& p(x)=a(x) b(x) \\\\\n\n& q(x)=p(x)(x-1)=a(x-1) b(x-1)\n\n\\end{aligned}\n\n$$\n\nWe get a contradiction with the irreducibility of $p(x-1)$, so $p(x)$ is irreducible in $Z[x]$\n\n\\end{proof}", "formal_statement": "theorem exercise_9_4_2c : irreducible \n  (X^4 + 4*X^3 + 6*X^2 + 2*X + 1 : polynomial \u2124) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_of_degree_four_polynomial (x : \u2124) :\n  irreducible (x ^ 4 + 4 * x ^ 3 + 6 * x ^ 2 + 2 * x + 1) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem polynomial.not_irreducible_C {R : Type u} [field R] (x : R) :\n\t\u00acirreducible (\u21d1polynomial.C x)\n\ntheorem polynomial.degree_eq_one_of_irreducible_of_root {R : Type u}\n\t[comm_ring R] [is_domain R] {p : polynomial R} (hi : irreducible p) {x : R}\n\t(hx : p.is_root x) :\n\tp.degree = 1\n\ntheorem polynomial.nat_degree_X_add_C {R : Type u} [nontrivial R] [semiring R]\n\t(x : R) :\n\t(polynomial.X + \u21d1polynomial.C x).nat_degree = 1\n\ntheorem polynomial.cyclotomic_three (R : Type*) [ring R] :\n\tpolynomial.cyclotomic 3 R = polynomial.X ^ 2 + polynomial.X + 1\n\nThe following is the natural language theorem statement: \"Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_polynomial_of_degree_four (x : polynomial \u2124) :\n  irreducible (x^4 + 4*x^3 + 6*x^2 + 2*x + 1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_9_4_9", "nl_statement": "Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D.", "nl_proof": "\\begin{proof}\n\n$Z[\\sqrt{2}]$ is an Euclidean domain, and so a unique factorization domain.\n\nWe have to prove $p(x)=x^2-\\sqrt{2}$ irreducible.\n\nSuppose to the contrary.\n\nif $p(x)$ is reducible then it must have root.\n\nLet $a+b \\sqrt{2}$ be a root of $x^2-\\sqrt{2}$.\n\nNow we have\n\n$$\n\na^2+2 b^2+2 a b \\sqrt{2}=\\sqrt{2}\n\n$$\n\nBy comparing the coefficients we get $2 a b=1$ for some pair of integers $a$ and $b$, a contradiction.\n\nSo $p(x)$ is irredicible over $Z[\\sqrt{2}]$.\n\n\\end{proof}", "formal_statement": "theorem exercise_9_4_9 : \n  irreducible (X^2 - C sqrtd : polynomial (zsqrtd 2)) :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " irreducible_of_squarefree_of_irreducible {R : Type*} [comm_ring R]\n  [is_domain R] [unique_factorization_domain R] {x : R} (hx : x \u2260 0)\n  {\u03d6 : R} (hirr : irreducible \u03d6) :\n  squarefree (x ^ 2 - \u03d6) \u2192 irreducible (x ^ 2 - \u03d6) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem inv_of_two_smul_add_inv_of_two_smul (R : Type*) {M : Type*} [semiring R]\n\t[add_comm_monoid M] [module R M] [invertible 2] (x : M) :\n\t\u215f 2 \u2022 x + \u215f 2 \u2022 x = x\n\ntheorem irreducible.squarefree {R : Type*} [comm_monoid R] {x : R}\n\t(h : irreducible x) :\n\tsquarefree x\n\ntheorem abs_sq {R : Type*} [linear_ordered_ring R] (x : R) :\n\t|x ^ 2| = x ^ 2\n\ntheorem discrete_valuation_ring.eq_unit_mul_pow_irreducible {R : Type*}\n\t[comm_ring R] [is_domain R] [discrete_valuation_ring R] {x : R} (hx : x \u2260 0)\n\t{\u03d6 : R} (hirr : irreducible \u03d6) :\n\t\u2203 (n : \u2115) (u : R\u02e3), x = \u2191u * \u03d6 ^ n\n\nThe following is the natural language theorem statement: \"Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " irreducible_of_polynomial_of_sqrt_two {R : Type*} [comm_ring R]\n  [is_ufd R] (x : R) :\n  irreducible (x^2 - 2) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Dummit-Foote|exercise_11_1_13", "nl_statement": "Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$.", "nl_proof": "\\begin{proof}    \n\nSince $B$ is a basis of $V$, every element of $V$ can be written uniquely as a finite linear combination of elements of $B$. Let $X$ be the set of all such finite linear combinations. Then $X$ has the same cardinality as $V$, since the map from $X$ to $V$ that takes each linear combination to the corresponding element of $V$ is a bijection.\n\n\n\nWe will show that $X$ has the same cardinality as $B$. Since $B$ is countable and $X$ is a union of countable sets, it suffices to show that each set $X_n$, consisting of all finite linear combinations of $n$ elements of $B$, is countable.\n\n\n\nLet $P_n(X)$ be the set of all subsets of $X$ with cardinality $n$. Then we have $X_n \\subseteq P_n(B)$. Since $B$ is countable, we have $\\mathrm{card}(P_n(B)) \\leq \\mathrm{card}(B^n) = \\mathrm{card}(B)$, where $B^n$ is the Cartesian product of $n$ copies of $B$.\n\n\n\nThus, we have $\\mathrm{card}(X_n) \\leq \\mathrm{card}(P_n(B)) \\leq \\mathrm{card}(B)$, so $X_n$ is countable. It follows that $X$ is countable, and hence has the same cardinality as $B$.\n\n\n\nTherefore, we have shown that the cardinality of $V$ is equal to the cardinality of $B$. Since $F$ is countable, it follows that the cardinality of $V$ is countable as well.\n\n\n\nNow let $Q$ be a countable field, and let $R$ be a vector space over $Q$. Let $n$ be a positive integer. Then any basis of $R^n$ over $Q$ has the same cardinality as $R^n$, which is countable. Since $R$ is a direct sum of $n$ copies of $R^n$, it follows that any basis of $R$ over $Q$ has the same cardinality as $R$. Hence, the cardinality of $R$ is countable.\n\n\n\nFinally, since $R$ is a countable vector space and $Q$ is a countable field, it follows that $R$ and $Q^{\\oplus \\mathrm{card}(R)}$ are isomorphic as additive abelian groups. Therefore, we have $R \\cong_Q Q^{\\oplus \\mathrm{card}(R)}$, and in particular $R \\cong_Q R^n$ for any positive integer $n$.\n\n\\end{proof}", "formal_statement": "theorem exercise_11_1_13 {\u03b9 : Type*} [fintype \u03b9] : \n  (\u03b9 \u2192 \u211d) \u2243\u2097[\u211a] \u211d :=", "src_header": "import .common \n\nopen set function nat int fintype real polynomial mv_polynomial\nopen subgroup ideal submodule zsqrtd gaussian_int char_p mul_aut matrix\n\nopen_locale pointwise\nopen_locale big_operators\nnoncomputable theory\n\n", "gpt_formal_statement": " vector_space_equiv_of_dim_eq_one {K : Type u} {V : Type v} [field K]\n  [add_comm_group V] [module K V] (h : module.rank K V = 1) :\n  V \u2243\u2097[K] K ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem finrank_euclidean_space_fin {\ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] {n : \u2115} :\n\tfinite_dimensional.finrank \ud835\udd5c (euclidean_space \ud835\udd5c (fin n)) = n\n\ndef equiv.vector_equiv_fin (\u03b1 : Type*) (n : \u2115) :\n\tvector \u03b1 n \u2243 (fin n \u2192 \u03b1)\n\ndef fin_dim_vectorspace_equiv {K : Type u} {V : Type v} [field K]\n\t[add_comm_group V] [module K V] (n : \u2115) (hn : module.rank K V = \u2191n) :\n\tV \u2243\u2097[K] fin n \u2192 K\n\ndef euclidean_space (\ud835\udd5c : Type*) [is_R_or_C \ud835\udd5c] (n : Type*) [fintype n] :\n\tType (max u_2 u_1)\n\nThe following is the natural language theorem statement: \"Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " Q_vector_space_equiv_R_of_nat (n : \u2115) :\n  vector_space \u211a (euclidean_space \u211d (fin n)) \u2243\u2097[\u211a] euclidean_space \u211d (fin 1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_1_13b", "nl_statement": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant.", "nl_proof": "\\begin{proof}\n\nLet $f(z)=f(x, y)=u(x, y)+i v(x, y)$, where $z=x+i y$.\n\nSince $\\operatorname{Im}(f)=$ constant,\n\n$$\n\n\\frac{\\partial v}{\\partial x}=0, \\frac{\\partial v}{\\partial y}=0 .\n\n$$\n\nBy the Cauchy-Riemann equations,\n\n$$\n\n\\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y}=0 .\n\n$$\n\nThus in $\\Omega$,\n\n$$\n\nf^{\\prime}(z)=\\frac{\\partial f}{\\partial x}=\\frac{\\partial u}{\\partial x}+i \\frac{\\partial v}{\\partial x}=0+0=0 .\n\n$$\n\nThus $f$ is constant.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_13b {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (a b : \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (hc : \u2203 (c : \u211d), \u2200 z \u2208 \u03a9, (f z).im = c) :\n  f a = f b :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " holomorphic_constant_of_constant_im {f : \u2102 \u2192 \u2102} (hf : holomorphic f)\n  (h : \u2200 (z : \u2102), f z = f 0) :\n  \u2200 (z : \u2102), f z = 0 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_isometry.im_apply_eq_im {f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102} (h : \u21d1f 1 = 1) (z : \u2102) :\n\tz + \u21d1(star_ring_end \u2102) z = \u21d1f z + \u21d1(star_ring_end \u2102) (\u21d1f z)\n\ntheorem linear_isometry.im_apply_eq_im_or_neg_of_re_apply_eq_re {f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102}\n\t(h\u2082 : \u2200 (z : \u2102), (\u21d1f z).re = z.re) (z : \u2102) :\n\t(\u21d1f z).im = z.im \u2228 (\u21d1f z).im = -z.im\n\ntheorem algebraic_independent_image {R A : Type*} [comm_ring R] [comm_ring A]\n\t[algebra R A] {\u03b9 : Type*} {s : set \u03b9} {f : \u03b9 \u2192 A} (hf : set.inj_on f s) :\n\talgebraic_independent R (\u03bb (x : \u21a5s), f \u2191x) \u2194 algebraic_independent R (\u03bb (x : \u21a5(f '' s)), \u2191x)\n\ntheorem set.inj_on.mem_image_iff {\u03b1 : Type u} {\u03b2 : Type v} {s s\u2081 : set \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} {x : \u03b1} (hf : set.inj_on f s) (hs : s\u2081 \u2286 s) (hx : x \u2208 s) :\n\tf x \u2208 f '' s\u2081 \u2194 x \u2208 s\u2081\n\nThe following is the natural language theorem statement: \"Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " holomorphic_of_const_Im {f : \u2102 \u2192 \u2102} {s : set \u2102} (hf : holomorphic f s)\n  (hIm : \u2200 z \u2208 s, \u2200 w \u2208 s, f z.im = f w.im) :\n  \u2200 z \u2208 s, \u2200 w \u2208 s, f z = f w ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_1_19a", "nl_statement": "Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle.", "nl_proof": "\\begin{proof}\n\n    For $z \\in S:=\\{z \\in \\mathbb{C}:|z|=1\\}$ it also holds $z^n \\in S$ for all $n \\in \\mathbb{N}$ (since in this case $\\left.\\left|z^n\\right|=|z|^n=1^n=1\\right)$\n\nThus, the sequence $\\left(a_n\\right)_{n \\in \\mathbb{N}}$ with $a_n=n z^n$ does not converge to zero which is necessary for the corresponding sum $\\sum_{n \\in \\mathbb{N}} a_n$ to be convergent. Hence this sum does not converge.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_19a (z : \u2102) (hz : abs z = 1) (s : \u2115 \u2192 \u2102)\n    (h : s = (\u03bb n, \u2211 i in (finset.range n), i * z ^ i)) :\n    \u00ac \u2203 y, tendsto s at_top (\ud835\udcdd y) :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " does_not_converge_on_unit_circle (z : \u2102) (hz : complex.abs z = 1) :\n  \u00acconverges_to_fun (\u03bb (n : \u2115), n * z ^ n) z ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem circle.of_conj_div_self_coe (z : \u2102) (hz : z \u2260 0) :\n\t\u2191(circle.of_conj_div_self z hz) = \u21d1(star_ring_end \u2102) z / z\n\ntheorem complex.eq_coe_norm_of_nonneg {z : \u2102} (hz : 0 \u2264 z) :\n\tz = \u2191\u2016z\u2016\n\ntheorem complex.unit_disc.coe_mk (z : \u2102) (hz : \u21d1complex.abs z < 1) :\n\t\u2191(complex.unit_disc.mk z hz) = z\n\ntheorem int.nat_abs_ne_zero_of_ne_zero {z : \u2124} (hz : z \u2260 0) :\n\tz.nat_abs \u2260 0\n\nThe following is the natural language theorem statement: \"Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_converges_on_unit_circle (z : \u2102) (hz : abs z = 1) :\n  \u00acconverges_on \u2102 (\u03bb n, n * z ^ n) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_1_19c", "nl_statement": "Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$.", "nl_proof": "\\begin{proof}\n\n    If $z=1$ then $\\sum z^n / n=\\sum 1 / n$ is divergent (harmonic series). If $|z|=1$ and $z \\neq 1$, write $z=e^{2 \\pi i t}$ with $t \\in(0,1)$ and apply Dirichlet's test: if $\\left\\{a_n\\right\\}$ is a sequence of real numbers and $\\left\\{b_n\\right\\}$ a sequence of complex numbers satisfying\n\n- $a_{n+1} \\leq a_n$\n\n- $\\lim _{n \\rightarrow \\infty} a_n=0$\n\n- $\\left|\\sum_{n=1}^N b_n\\right| \\leq M$ for every positive integer $N$ and some $M>0$,\n\nthen $\\sum a_n b_n$ converges. Let $a_n=1 / n$, so $a_n$ satisfies $a_{n+1} \\leq a_n$ and $\\lim _{n \\rightarrow \\infty} a_n=0$. Let $b_n=e^{2 \\pi i n t}$, then\n\n$$\n\n\\left|\\sum_{n=1}^N b_n\\right|=\\left|\\sum_{n=1}^N e^{2 \\pi i n t}\\right|=\\left|\\frac{e^{2 \\pi i t}-e^{2 \\pi i(N+1) t}}{1-e^{2 \\pi i t}}\\right| \\leq \\frac{2}{\\left|1-e^{2 \\pi i t}\\right|}=M \\text { for all } N\n\n$$\n\nThus $\\sum a_n b_n=\\sum z^n / n$ converges for every point in the unit circle except $z=1$.\n\n\\end{proof}", "formal_statement": "theorem exercise_1_19c (z : \u2102) (hz : abs z = 1) (hz2 : z \u2260 1) (s : \u2115 \u2192 \u2102)\n    (h : s = (\u03bb n, \u2211 i in (finset.range n), i * z / i)) :\n    \u2203 z, tendsto s at_top (\ud835\udcdd z) :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " complex.is_cau_abs_exp (z : \u2102) :\n\tis_cau_seq has_abs.abs (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (m : \u2115), \u21d1complex.abs (z ^ m / \u2191(m.factorial)))) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem complex.eq_coe_norm_of_nonneg {z : \u2102} (hz : 0 \u2264 z) :\n\tz = \u2191\u2016z\u2016\n\ntheorem int.nat_abs_ne_zero_of_ne_zero {z : \u2124} (hz : z \u2260 0) :\n\tz.nat_abs \u2260 0\n\ntheorem int.nat_abs_sign_of_nonzero {z : \u2124} (hz : z \u2260 0) :\n\tz.sign.nat_abs = 1\n\ntheorem complex.is_cau_abs_exp (z : \u2102) :\n\tis_cau_seq has_abs.abs (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (m : \u2115), \u21d1complex.abs (z ^ m / \u2191(m.factorial))))\n\nThe following is the natural language theorem statement: \"Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " converges_at_of_abs_lt_one_of_ne_one {z : \u2102} (hz : abs z < 1) (hz1 : z \u2260 1) :\n  is_cau_seq (\u03bb n, z ^ n / n) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_2_2", "nl_statement": "Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$.", "nl_proof": "\\begin{proof}\n\n    We have $\\int_0^{\\infty} \\frac{\\sin x}{x} d x=\\frac{1}{2 * i} \\int_0^{\\infty} \\frac{e^{i * x}-e^{-i * x}}{x} d x=\\frac{1}{2 * i}\\left(\\int_0^{\\infty} \\frac{e^{i * x}-1}{x} d x-\\int_0^{\\infty} \\frac{e^{-i * x}-1}{x} d x=\\right.$ $\\frac{1}{2 * i} \\int_{-\\infty}^{\\infty} \\frac{e^{i * x}-1}{x} d x$. Now integrate along the big and small semicircles $C_0$ and $C_1$ shown below. For $C_0$ : we have that $\\int_{C_0} \\frac{1}{x} d x=\\pi * i$ and $\\left|\\int_{C_0} \\frac{e^{i * x}}{x} d x\\right| \\leq$ $2 *\\left|\\int_{C_{00}} \\frac{e^{i * x}}{x} d x\\right|+\\left|\\int_{C_{01}} \\frac{e^{i * x}}{x} d x\\right|$ where $C_{00}$ and $C_{01}$ are shown below $\\left(C_{01}\\right.$ contains the part of $C_0$ that has points with imaginary parts more than $a$ and $C_{00}$ is one of the other 2 components). We have $\\left|\\int_{C_{00}} \\frac{e^{i * x}}{x} d x\\right| \\leq$ $\\sup _{x \\in C_{00}}\\left(e^{i * x}\\right) / R * \\int_{C_{00}}|d x| \\leq e^{-a} * \\pi$ and $\\left|\\int_{C_{01}} \\frac{e^{i * x}}{x} d x\\right| \\leq\\left|\\int_{C_{01}} \\frac{1}{x} d x\\right| \\leq$ $\\frac{1}{R} * C * a$ for some constant $C$ (the constant $C$ exists because the length of the curve approaches $a$ as $a / R \\rightarrow 0)$. Thus, the integral of $e^{i * x} / x$ over $C_0$ is bounded by $A * e^{-a}+B * a / R$ for some constants $A$ and $B$. Pick $R$ large and $a=\\sqrt{R}$ and note that the above tends to 0 . About the integral over $C_1$ : We have $e^{i * x}-1=1+O(x)$ for $x \\rightarrow 0$ (this is again from $\\sin (x) / x \\rightarrow 1$ ),\n\n4\n\nso $\\left|\\int_{C_1} \\frac{e^{i * x}-1}{x} d x\\right| \\leq O(1) *\\left|\\int_{C_1} d x\\right| \\rightarrow 0$ as $x \\rightarrow 0$. Thus, we only care about the integral over $C_{00}$ which is $-\\pi * i$. Using Cauchy's theorem we get that our integral equals $\\frac{1}{2 * i}(-(\\pi * i))=\\pi / 2$.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_2 :\n  tendsto (\u03bb y, \u222b x in 0..y, real.sin x / x) at_top (\ud835\udcdd (real.pi / 2)) :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " integral_sin_x_div_x_eq_pi_div_two :\n  \u222b (0 : \u211d) \u221e (\u03bb x, sin x / x) = real.pi / 2 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem complex.sin_pi_div_two :\n\tcomplex.sin (\u2191real.pi / 2) = 1\n\ntheorem real.sin_pi_div_two :\n\treal.sin (real.pi / 2) = 1\n\ntheorem real.sin_pi_div_eight :\n\treal.sin (real.pi / 8) = real.sqrt (2 - real.sqrt 2) / 2\n\ntheorem real.sin_pi_div_four :\n\treal.sin (real.pi / 4) = real.sqrt 2 / 2\n\nThe following is the natural language theorem statement: \"Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " integral_sin_x_div_x_eq_pi_div_two :\n  \u222b\u207b a in 0, \u221e, sin a / a = \u03c0 / 2 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_2_13", "nl_statement": "Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.", "nl_proof": "\\begin{proof}\n\nSay that at least one of the coefficients of the Taylor series vanishes is the same as saying that for every $a \\in \\mathbb{C}$ there is $m \\in \\mathbb{N}$ such that $f^{(m)}(a)=0$.\n\nConsider $A_n:=\\left\\{z \\in \\mathbb{C}: f^{(n)}(z)=0\\right\\}$ for each $n \\in \\mathbb{N}$. Note that:\n\n$f$ is polynomial iff $A_n$ is not countable for some $n \\in \\mathbb{N}$.\n\nIndeed, if $f$ is polynomial of degree $n$, then $f^{(n+1)}(z)=0$ for all $z \\in \\mathbb{C}$, then $A_{n+1}=\\mathbb{C}$, so, $A_{n+1}$ is not countable. Conversely, if there is $n \\in \\mathbb{C}$ such that $A_n$ is not countable, then $A_n$ has a limit point, then by Identity principle we have $f^{(n)}(z)=0$ for all $z \\in \\mathbb{C}$, so, $f$ is a polynomial of degree at most $n-1$.\n\n\n\nTherefore, tt suffices to show that there is $n \\in \\mathbb{N}$ such that $A_n$ is not countable. Indeed, consider $\\bigcup_{n \\in \\mathbb{N}} A_n$, by hypothesis for each $a \\in \\mathbb{C}$ there is $m \\in \\mathbb{N}$ such that $f^{(m)}(a)=0$, then $\\mathbb{C} \\subseteq \\bigcup_{n \\in \\mathbb{N}} A_n$. Therefore, $\\bigcup_{n \\in \\mathbb{N}} A_n$ is not countable, then there is $n \\in \\mathbb{N}$ such that $A_n$ is not countable.\n\n\\end{proof}", "formal_statement": "theorem exercise_2_13 {f : \u2102 \u2192 \u2102}\n    (hf : \u2200 z\u2080 : \u2102, \u2203 (s : set \u2102) (c : \u2115 \u2192 \u2102), is_open s \u2227 z\u2080 \u2208 s \u2227\n      \u2200 z \u2208 s, tendsto (\u03bb n, \u2211 i in finset.range n, (c i) * (z - z\u2080)^i) at_top (\ud835\udcdd (f z\u2080))\n      \u2227 \u2203 i, c i = 0) :\n    \u2203 (c : \u2115 \u2192 \u2102) (n : \u2115), f = \u03bb z, \u2211 i in finset.range n, (c i) * z ^ n :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " analytic_on.eq_on_zero_of_preconnected_of_mem_closure {\ud835\udd5c : Type*}\n\t[nontrivially_normed_field \ud835\udd5c] {E : Type*} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {f : \ud835\udd5c \u2192 E} {z\u2080 : \ud835\udd5c} {U : set \ud835\udd5c} (hf : analytic_on \ud835\udd5c f U)\n\t(hU : is_preconnected U) (h\u2080 : z\u2080 \u2208 U)\n\t(hfz\u2080 : z\u2080 \u2208 closure ({z : \ud835\udd5c | f z = 0} \\ {z\u2080})) :\n\tset.eq_on f 0 U ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_map.minpoly_coeff_zero_of_injective {R : Type u} {M : Type v}\n\t[comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M]\n\t[module.finite R M] {f : M \u2192\u2097[R] M} (hf : function.injective \u21d1f) :\n\t(minpoly R f).coeff 0 \u2260 0\n\ntheorem analytic_at.frequently_zero_iff_eventually_zero {\ud835\udd5c : Type*}\n\t[nontrivially_normed_field \ud835\udd5c] {E : Type*} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {f : \ud835\udd5c \u2192 E} {w : \ud835\udd5c} (hf : analytic_at \ud835\udd5c f w) :\n\t(\u2203\u1da0 (z : \ud835\udd5c) in nhds_within w {w}\u1d9c, f z = 0) \u2194 \u2200\u1da0 (z : \ud835\udd5c) in nhds w, f z = 0\n\ntheorem analytic_on.eq_on_zero_of_preconnected_of_mem_closure {\ud835\udd5c : Type*}\n\t[nontrivially_normed_field \ud835\udd5c] {E : Type*} [normed_add_comm_group E]\n\t[normed_space \ud835\udd5c E] {f : \ud835\udd5c \u2192 E} {z\u2080 : \ud835\udd5c} {U : set \ud835\udd5c} (hf : analytic_on \ud835\udd5c f U)\n\t(hU : is_preconnected U) (h\u2080 : z\u2080 \u2208 U)\n\t(hfz\u2080 : z\u2080 \u2208 closure ({z : \ud835\udd5c | f z = 0} \\ {z\u2080})) :\n\tset.eq_on f 0 U\n\ntheorem polynomial.nat_degree_eq_zero_of_derivative_eq_zero {R : Type u}\n\t[semiring R] [no_zero_smul_divisors \u2115 R] {f : polynomial R}\n\t(h : \u21d1polynomial.derivative f = 0) :\n\tf.nat_degree = 0\n\nThe following is the natural language theorem statement: \"Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_polynomial_of_analytic_of_coeff_zero {f : \u2102 \u2192 \u2102} (hf : analytic f)\n  (h : \u2200 z\u2080 : \u2102, \u2203 n : \u2115, f.taylor_series z\u2080 n = 0) :\n  is_polynomial f ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_3_4", "nl_statement": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$.", "nl_proof": "\\begin{proof}\n\n$$\n\nx /\\left(x^2+a^2\\right)=x / 2 i a(1 /(x-i a)-1 /(x+i a))=1 / 2 i a(i a /(x-i a)+i a /(x+\n\n$$\n\n$i a))=(1 /(x-i a)+1 /(x+i a)) / 2$. So we care about $\\sin (x)(1 /(x-i a)+$ $1 /(x+i a)) / 2$. Its residue at $x=i a$ is $\\sin (i a) / 2=\\left(e^{-a}-e^a\\right) / 4 i$.?\n\n\\end{proof}", "formal_statement": "theorem exercise_3_4 (a : \u211d) (ha : 0 < a) :\n    tendsto (\u03bb y, \u222b x in -y..y, x * real.sin x / (x ^ 2 + a ^ 2))\n    at_top (\ud835\udcdd (real.pi * (real.exp (-a)))) :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " integral_sin_div_of_pos {a : \u211d} (ha : 0 < a) :\n  \u222b (x : \u211d) in -\u221e..\u221e, x * sin x / (x ^ 2 + a ^ 2) = \u03c0 * exp (-a) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem integral_inv_of_pos {a b : \u211d} (ha : 0 < a) (hb : 0 < b) :\n\t\u222b (x : \u211d) in a..b, x\u207b\u00b9 = real.log (b / a)\n\ntheorem integral_inv_of_neg {a b : \u211d} (ha : a < 0) (hb : b < 0) :\n\t\u222b (x : \u211d) in a..b, x\u207b\u00b9 = real.log (b / a)\n\ntheorem integral_one_div_of_neg {a b : \u211d} (ha : a < 0) (hb : b < 0) :\n\t\u222b (x : \u211d) in a..b, 1 / x = real.log (b / a)\n\ntheorem integral_one_div_of_pos {a b : \u211d} (ha : 0 < a) (hb : 0 < b) :\n\t\u222b (x : \u211d) in a..b, 1 / x = real.log (b / a)\n\nThe following is the natural language theorem statement: \"Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " integral_sin_over_square_plus_a_square_eq_pi_exp_neg_a (a : \u211d) (ha : 0 < a) :\n  \u222b\u207b\u221e \u221e (\u03bb x, x * sin x / (x ^ 2 + a ^ 2)) = \u03c0 * exp (-a) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_3_14", "nl_statement": "Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$.", "nl_proof": "\\begin{proof}\n\nLook at $f(1 / z)$. If it has an essential singularity at 0 , then pick any $z_0 \\neq 0$. Now we know that the range of $f$ is dense as $z \\rightarrow 0$. We also know that the image of $f$ in some small ball around $z_0$ contains a ball around $f\\left(z_0\\right)$. But this means that the image of $f$ around this ball intersects the image of $f$ in any arbitrarily small ball around 0 (because of the denseness). Thus, $f$ cannot be injective. So the singularity at 0 is not essential, so $f(1 / z)$ is some polynomial of $1 / z$, so $f$ is some polynomial of $z$. If its degree is more than 1 it is not injective (fundamental theorem of algebra), so the degree of $f$ is 1 .\n\n\\end{proof}", "formal_statement": "theorem exercise_3_14 {f : \u2102 \u2192 \u2102} (hf : differentiable \u2102 f)\n    (hf_inj : function.injective f) :\n    \u2203 (a b : \u2102), f = (\u03bb z, a * z + b) \u2227 a \u2260 0 :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " entire_injective_iff_linear {f : \u2102 \u2192 \u2102} (hf : entire f) (hfi : function.injective f) :\n  \u2203 (a b : \u2102), a \u2260 0 \u2227 f = \u03bb z, a * z + b ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem linear_map.minpoly_coeff_zero_of_injective {R : Type u} {M : Type v}\n\t[comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M]\n\t[module.finite R M] {f : M \u2192\u2097[R] M} (hf : function.injective \u21d1f) :\n\t(minpoly R f).coeff 0 \u2260 0\n\ntheorem function.injective.ne_iff' {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.injective f) {x y : \u03b1} {z : \u03b2} (h : f y = z) :\n\tf x \u2260 z \u2194 x \u2260 y\n\ntheorem continuous_linear_map.exists_ne_zero {R\u2081 R\u2082 : Type*} [semiring R\u2081]\n\t[semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {M\u2081 : Type*} [topological_space M\u2081]\n\t[add_comm_monoid M\u2081] {M\u2082 : Type*} [topological_space M\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2081 M\u2081] [module R\u2082 M\u2082] {f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (hf : f \u2260 0) :\n\t\u2203 (x : M\u2081), \u21d1f x \u2260 0\n\ntheorem function.injective.ne_iff {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.injective f) {x y : \u03b1} :\n\tf x \u2260 f y \u2194 x \u2260 y\n\nThe following is the natural language theorem statement: \"Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " entire_injective_iff_linear {f : \u2102 \u2192 \u2102} (hf : entire f) (hfi : function.injective f) :\n  \u2203 (a b : \u2102), a \u2260 0 \u2227 f = \u03bb z, a * z + b ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Shakarchi|exercise_5_1", "nl_statement": "Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$.", "nl_proof": "\\begin{proof}\n\n    Fix $\\mathrm{N}$ and let $D(0, R)$ contains the first $\\mathrm{N}$ zeroes of f. Let $S_N=\\sum_{k=1}^N\\left(1-\\left|z_k\\right|\\right)=$ $\\sum_{k=1}^N \\int_{\\left|z_k\\right|}^1 1 d r$. Let $\\eta_k$ be the characteristic function of the interval $\\left.\\| z_k \\mid, 1\\right]$. We have $S_N=\\sum_{k=1}^N \\int_0^1 \\eta(r) d r=\\int_0^1\\left(\\sum_{k=1}^N \\eta_k(r)\\right) d r \\leq \\int_0^1 n(r) d r$, where $n(r)$ is the number of zeroes of $f$ at the disk $D(0, r)$. For $r \\leq 1$ we have $n(r) \\leq \\frac{n(r)}{r}$. This means that $S_N \\leq \\int_0^1 n(r) \\frac{d r}{r}$. If $f(0)=0$ then we have $f(z)=z^m g(z)$ for some integer $\\mathrm{m}$ and some holomorphic $g$ with $g(0) \\neq 0$. The other zeroes of $\\mathrm{f}$ are precisely the zeroes of $g$. Thus we have reduced the problem to $f(0) \\neq 0$. By the Corollary of the Jensen's equality we get $S_N \\leq \\int_0^1 n(r) \\frac{d r}{r}=\\frac{1}{2 \\pi} \\int_0^{2 \\pi} \\log \\left|f\\left(R e^{i \\pi}\\right)\\right| d \\phi-\\log |f(0)|<M$ since $f$ is bounded. The partial sums of the series are boundend and therefore the series converges.\n\n\\end{proof}", "formal_statement": "theorem exercise_5_1 (f : \u2102 \u2192 \u2102) (hf : differentiable_on \u2102 f (ball 0 1))\n  (hb : bounded (set.range f)) (h0 : f \u2260 0) (zeros : \u2115 \u2192 \u2102) (hz : \u2200 n, f (zeros n) = 0)\n  (hzz : set.range zeros = {z | f z = 0 \u2227 z \u2208 (ball (0 : \u2102) 1)}) :\n  \u2203 (z : \u2102), tendsto (\u03bb n, (\u2211 i in finset.range n, (1 - zeros i))) at_top (\ud835\udcdd z) :=", "src_header": "import .common \n\nopen complex filter function interval_integral metric\n\nopen_locale big_operators\nopen_locale filter\nopen_locale topology\n\n", "gpt_formal_statement": " holomorphic_bounded_not_identically_zero_sum_of_zeros_lt_one_finite\n  {f : \u2102 \u2192 \u2102} (hf : holomorphic f) (hf0 : f \u2260 0) (hf1 : \u2200 z, f z = 0 \u2192 abs z < 1)\n  (hf2 : \u2200 z, abs z < 1 \u2192 f z \u2260 0) (hf3 : \u2200 z, abs z < 1 \u2192 abs (f z) \u2264 1) :\n  \u2211' (z : \u2102), 1 - abs z < \u22a4 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem ennreal.tendsto_cofinite_zero_of_tsum_ne_top {\u03b1 : Type*}\n\t{f : \u03b1 \u2192 ennreal} (hf : \u2211' (x : \u03b1), f x \u2260 \u22a4) :\n\tfilter.tendsto f filter.cofinite (nhds 0)\n\ntheorem ennreal.tendsto_sum_nat_add (f : \u2115 \u2192 ennreal) (hf : \u2211' (i : \u2115), f i \u2260 \u22a4) :\n\tfilter.tendsto (\u03bb (i : \u2115), \u2211' (k : \u2115), f (k + i)) filter.at_top (nhds 0)\n\ntheorem ennreal.tsum_add_one_eq_top {f : \u2115 \u2192 ennreal} (hf : \u2211' (n : \u2115), f n = \u22a4)\n\t(hf0 : f 0 \u2260 \u22a4) :\n\t\u2211' (n : \u2115), f (n + 1) = \u22a4\n\ntheorem real.infi_of_not_bdd_below {\u03b1 : Sort u_1} {f : \u03b1 \u2192 \u211d}\n\t(hf : \u00acbdd_below (set.range f)) :\n\t(\u2a05 (i : \u03b1), f i) = 0\n\nThe following is the natural language theorem statement: \"Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " sum_of_one_minus_abs_of_zeros_of_holomorphic_bounded_not_identically_zero\n  {f : \u2102 \u2192 \u2102} (hf : holomorphic f) (hf_bd : metric.bounded (set.range f))\n  (hf_nz : \u00ac f = function.const \u2102 0) (hf_z : \u2200 z, f z = 0 \u2192 abs z < 1) :\n  \u2211 z in set.range f, 1 - abs z < \u22a4 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_13_3b", "nl_statement": "Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$.", "nl_proof": "\\begin{proof}\n\n    Let $X=\\mathbb{R}, U_1=(-\\infty, 0)$ and $U_2=(0, \\infty)$. Then $U_1$ and $U_2$ are in $\\mathcal{T}_{\\infty}$ but $U_1 \\cup U_2=\\mathbb{R} \\backslash\\{0\\}$ is not.\n\n\\end{proof}", "formal_statement": "theorem exercise_13_3b : \u00ac \u2200 X : Type, \u2200s : set (set X),\n  (\u2200 t : set X, t \u2208 s \u2192 (set.infinite t\u1d9c \u2228 t = \u2205 \u2228 t = \u22a4)) \u2192 \n  (set.infinite (\u22c3\u2080 s)\u1d9c \u2228 (\u22c3\u2080 s) = \u2205 \u2228 (\u22c3\u2080 s) = \u22a4) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " topological_space.opens.not_nonempty_iff_eq_bot {\u03b1 : Type*}\n  [topological_space \u03b1] (U : topological_space.opens \u03b1) :\n  \u00ac\u2191U.nonempty \u2194 U = \u22a5 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem topological_space.opens.not_nonempty_iff_eq_bot {\u03b1 : Type*}\n\t[topological_space \u03b1] (U : topological_space.opens \u03b1) :\n\t\u00ac\u2191U.nonempty \u2194 U = \u22a5\n\ntheorem alexandroff.not_specializes_infty_coe {X : Type*} [topological_space X]\n\t{x : X} :\n\t\u00acalexandroff.infty \u2933 \u2191x\n\ntheorem alexandroff.not_inseparable_infty_coe {X : Type*} [topological_space X]\n\t{x : X} :\n\t\u00acinseparable alexandroff.infty \u2191x\n\ntheorem topological_space.opens.inclusion_map_eq_top {X : Top}\n\t(U : topological_space.opens \u21a5X) :\n\t(topological_space.opens.map U.inclusion).obj U = \u22a4\n\nThe following is the natural language theorem statement: \"Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_topology_of_infinite_or_empty_or_all_of_X (X : Type*) :\n  \u00ac topological_space (\u22c3 (U : set X), {U | X - U \u2208 {\u2205, univ, {x | x.infinite}}}) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_13_4a2", "nl_statement": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$.", "nl_proof": "\\begin{proof}\n\n    On the other hand, the union $\\bigcup_\\alpha \\mathcal{T}_\\alpha$ is in general not a topology on $X$. For instance, let $X=\\{a, b, c\\}$. Then $\\mathcal{T}_1=\\{\\emptyset, X,\\{a\\}\\}$ and $\\mathcal{T}_2=\\{\\emptyset, X,\\{b\\}\\}$ are topologies on $X$ but $\\mathcal{T}_1 \\cup \\mathcal{T}_2=$ $\\{\\emptyset, X,\\{a\\},\\{b\\}\\}$ is not.\n\n\\end{proof}", "formal_statement": "theorem exercise_13_4a2 :\n  \u2203 (X I : Type*) (T : I \u2192 set (set X)),\n  (\u2200 i, is_topology X (T i)) \u2227 \u00ac  is_topology X (\u22c2 i : I, T i) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " not_topology_of_Union {\u03b1 : Type u} {\u03b9 : Sort w}\n  [topological_space \u03b1] {f : \u03b9 \u2192 set (set \u03b1)} (h : \u2200 (i : \u03b9), is_topology (f i)) :\n  \u00ac is_topology (\u22c3 (i : \u03b9), f i) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_open_Union {\u03b1 : Type u} {\u03b9 : Sort w} [topological_space \u03b1]\n\t{f : \u03b9 \u2192 set \u03b1} (h : \u2200 (i : \u03b9), is_open (f i)) :\n\tis_open (\u22c3 (i : \u03b9), f i)\n\ntheorem is_open_bUnion {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t{s : set \u03b2} {f : \u03b2 \u2192 set \u03b1} (h : \u2200 (i : \u03b2), i \u2208 s \u2192 is_open (f i)) :\n\tis_open (\u22c3 (i : \u03b2) (H : i \u2208 s), f i)\n\ntheorem topological_space.is_topological_basis.open_iff_eq_sUnion {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {B : set (set \u03b1)}\n\t(hB : topological_space.is_topological_basis B) {u : set \u03b1} :\n\tis_open u \u2194 \u2203 (S : set (set \u03b1)) (H : S \u2286 B), u = \u22c3\u2080 S\n\ntheorem is_clopen_Union {\u03b1 : Type u} [topological_space \u03b1] {\u03b2 : Type*}\n\t[finite \u03b2] {s : \u03b2 \u2192 set \u03b1} (h : \u2200 (i : \u03b2), is_clopen (s i)) :\n\tis_clopen (\u22c3 (i : \u03b2), s i)\n\nThe following is the natural language theorem statement: \"If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_topology_of_union_topologies {X : Type*} {\u03b1 : Type*} \n  (T : \u03b1 \u2192 set (set X)) (hT\u2081 : \u2200 (\u03b1 : Type*), \u2200 (T : \u03b1 \u2192 set (set X)), \n  \u2200 (U : set X), U \u2208 T \u03b1 \u2192 is_open U) (hT\u2082 : \u2200 (\u03b1 : Type*), \u2200 (T : \u03b1 \u2192 set (set X)), \n  \u2200 (U : set X), U \u2208 T \u03b1 \u2192 is_open U) (hT\u2083 : \u2200 (\u03b1 : Type*), \u2200 (T : \u03b1 \u2192 set (set X)), \n  \u2200 (U : set X), U \u2208 T \u03b1 \u2192 is_open U) :\n  \u00ac is_topology (\u22c3 (\u03b1 : Type*), T \u03b1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_13_4b2", "nl_statement": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$.", "nl_proof": "\\begin{proof}\n\n    Now we prove that there exists a unique largest topology contained in all $\\mathcal{T}_\\alpha$. Uniqueness of such topology is clear. Consider $\\mathcal{T}=\\bigcap_\\alpha \\mathcal{T}_\\alpha$. We already know that $\\mathcal{T}$ is a topology by, and clearly $\\mathcal{T} \\subset \\mathcal{T}_\\alpha$ for all $\\alpha$. If $\\mathcal{O}$ is another topology contained in all $\\mathcal{T}_\\alpha$, it must be contained in their intersection, so $\\mathcal{O} \\subset \\mathcal{T}$. I follows that $\\mathcal{T}$ is the unique largest topology contained in all $\\mathcal{T}_\\alpha$.\n\n\\end{proof}", "formal_statement": "theorem exercise_13_4b2 (X I : Type*) (T : I \u2192 set (set X)) (h : \u2200 i, is_topology X (T i)) :\n  \u2203! T', is_topology X T' \u2227 (\u2200 i, T' \u2286 T i) \u2227\n  \u2200 T'', is_topology X T'' \u2192 (\u2200 i, T'' \u2286 T i) \u2192 T' \u2286 T'' :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " unique_topological_space_of_topologies {\u03b1 : Type u}\n  {X : Type u} {T : \u03b1 \u2192 topological_space X} :\n  unique (\u03bb (t : topological_space X), \u2200 (a : \u03b1), T a \u2264 t) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef subsingleton.unique_topological_space {\u03b1 : Type u} [subsingleton \u03b1] :\n\tunique (topological_space \u03b1)\n\ndef Top.topological_space (X : Top) :\n\ttopological_space \u21a5X\n\ntheorem to_topological_space_top {\u03b1 : Type*} :\n\tuniform_space.to_topological_space = \u22a4\n\ntheorem group_topology.to_topological_space_top {\u03b1 : Type u} [group \u03b1] :\n\t\u22a4.to_topological_space = \u22a4\n\nThe following is the natural language theorem statement: \"Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " unique_largest_topology_of_topologies {X : Type*} \n  (T : Type*) [\u2200 \u03b1, topological_space (T \u03b1)] :\n  topological_space X ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_13_5b", "nl_statement": "Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.", "nl_proof": "\\begin{proof}\n\n    If we now considered $\\mathcal{A}$ as a subbasis, then the elements of $\\mathcal{T}$ are union of finite intersections of elements of $\\mathcal{A}$. The inclusion $\\mathcal{O} \\subset \\mathcal{T}$ is again clear and $\\mathcal{T} \\subset \\mathcal{O}$ holds since every union of finite intersections of elements of $\\mathcal{A}$ belongs to $\\mathcal{O}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_13_5b {X : Type*}\n  [t : topological_space X] (A : set (set X)) (hA : t = generate_from A) :\n  generate_from A = generate_from (sInter {T | is_topology X T \u2227 A \u2286 T}) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " topological_space.is_topological_basis.topology_eq_inter_topologies\n  {\u03b1 : Type u} [t : topological_space \u03b1] {B : set (set \u03b1)}\n  (hB : topological_space.is_topological_basis B) :\n  t = \u22c2 (t' : topological_space \u03b1), t'.is_topological_basis B ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef submodules_ring_basis.topology {\u03b9 R A : Type*} [comm_ring R] [comm_ring A]\n\t[algebra R A] {B : \u03b9 \u2192 submodule R A} [nonempty \u03b9]\n\t(hB : submodules_ring_basis B) :\n\ttopological_space A\n\ntheorem topological_space.is_topological_basis.open_eq_sUnion {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {B : set (set \u03b1)}\n\t(hB : topological_space.is_topological_basis B) {u : set \u03b1} (ou : is_open u) :\n\t\u2203 (S : set (set \u03b1)) (H : S \u2286 B), u = \u22c3\u2080 S\n\ntheorem topological_space.is_topological_basis.open_eq_Union {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {B : set (set \u03b1)}\n\t(hB : topological_space.is_topological_basis B) {u : set \u03b1} (ou : is_open u) :\n\t\u2203 (\u03b2 : Type u) (f : \u03b2 \u2192 set \u03b1), (u = \u22c3 (i : \u03b2), f i) \u2227 \u2200 (i : \u03b2), f i \u2208 B\n\ntheorem path_connected_subset_basis {X : Type*} [topological_space X] {x : X}\n\t[loc_path_connected_space X] {U : set X} (h : is_open U) (hx : x \u2208 U) :\n\t(nhds x).has_basis (\u03bb (s : set X), s \u2208 nhds x \u2227 is_path_connected s \u2227 s \u2286 U) id\n\nThe following is the natural language theorem statement: \"Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " topology_generated_eq_inter_topologies_containing_subbasis \n  {X : Type*} {A : set (set X)} (hA : is_subbasis A) :\n  topology.generated A = \u22c2 (T : set (set X)) (hT : is_topology T) \n  (hT_A : A \u2286 T) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_13_8a", "nl_statement": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$.", "nl_proof": "\\begin{proof}\n\n    Exercise 13.8. (a) First note that $\\mathcal{B}$ is a basis for a topology on $\\mathbb{R}$. This follows from the fact that the union of its elements is all of $\\mathbb{R}$ and the intersection of two elements of $\\mathcal{B}$ is either empty or another element of $\\mathcal{B}$. Let $\\mathcal{T}$ be the standard topology on $\\mathbb{R}$. Clearly the topology generated by $\\mathcal{B}$ is coarser than $\\mathcal{T}$. Let $U \\in \\mathcal{T}$ and $x \\in U$. Then $U$ contains an open interval with centre $x$. Since the rationals are dense in $\\mathbb{R}$ with the standard topology, there exists $q \\in \\mathbb{Q}$ such that $x \\in(x-q, x+q) \\subset U$. This proves that $\\mathcal{T}$ is coarser than the topology generated by $\\mathcal{B}$. We conclude that $\\mathcal{B}$ generates the standard topology on $\\mathbb{R}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_13_8a :\n  topological_space.is_topological_basis {S : set \u211d | \u2203 a b : \u211a, a < b \u2227 S = Ioo a b} :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_topological_basis_Ioo_rat :\n  topological_space.is_topological_basis (\u22c3 (a b : \u211a) (h : a < b), {set.Ioo \u2191a \u2191b}) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem real.is_topological_basis_Ioo_rat :\n\ttopological_space.is_topological_basis (\u22c3 (a b : \u211a) (h : a < b), {set.Ioo \u2191a \u2191b})\n\ntheorem ctop.realizer.is_basis {\u03b1 : Type*} [T : topological_space \u03b1]\n\t(F : ctop.realizer \u03b1) :\n\ttopological_space.is_topological_basis (set.range F.F.f)\n\ntheorem ctop.to_topsp_is_topological_basis {\u03b1 \u03c3 : Type*} (F : ctop \u03b1 \u03c3) :\n\ttopological_space.is_topological_basis (set.range F.f)\n\ntheorem ennreal.nhds_top_basis :\n\t(nhds \u22a4).has_basis (\u03bb (a : ennreal), a < \u22a4) (\u03bb (a : ennreal), set.Ioi a)\n\nThe following is the natural language theorem statement: \"Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_topological_basis_of_rational_intervals :\n  is_topological_basis (set.range (\u03bb (p : \u211a \u00d7 \u211a), {a | p.1 < a \u2227 a < p.2})) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_16_1", "nl_statement": "Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$.", "nl_proof": "\\begin{proof}\n\n    Exercise 16.1. Let $\\mathcal{T}$ be the topology $A$ inherits as a subspace of $Y$, and $\\mathcal{O}$ be the topology it inherits as a subspace of $X$. A (standard) basis element for $\\mathcal{T}$ has the form $U \\cap A$ where $U$ is open in $Y$, so is of the form $(Y \\cap V) \\cap A=V \\cap A$ where $V$ is open in $X$. Therefore every basis element for $\\mathcal{T}$ is also a basis element for $\\mathcal{O}$. Conversely, a (standard) basis element for $\\mathcal{O}$ have the form $W \\cap A=W \\cap Y \\cap A$ where $W$ is open in $X$. Since $W \\cap Y$ is open in $Y$, this is a basis element for $\\mathcal{T}$, so every basis element for $\\mathcal{O}$ is a basis element for $\\mathcal{T}$. It follows that $\\mathcal{T}=\\mathcal{O}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_16_1 {X : Type*} [topological_space X]\n  (Y : set X)\n  (A : set Y) :\n  \u2200 U : set A, is_open U \u2194 is_open (subtype.val '' U) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " subspace.topology_eq_of_subset {X : Type*} [topological_space X]\n  {Y : set X} (hY : is_open Y) {A : set Y} (hA : is_open A) :\n  subtype.topology A = subtype.topology (subset.val '' A) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem homeomorph.symm_to_homotopy_equiv {X : Type u} {Y : Type v}\n\t[topological_space X] [topological_space Y] (h : X \u2243\u209c Y) :\n\th.symm.to_homotopy_equiv = h.to_homotopy_equiv.symm\n\ntheorem homeomorph.coe_to_homotopy_equiv {X : Type u} {Y : Type v}\n\t[topological_space X] [topological_space Y] (h : X \u2243\u209c Y) :\n\t\u21d1(h.to_homotopy_equiv) = \u21d1h\n\ntheorem homeomorph.trans_to_homotopy_equiv {X : Type u} {Y : Type v}\n\t{Z : Type w} [topological_space X] [topological_space Y] [topological_space Z]\n\t(h\u2080 : X \u2243\u209c Y) (h\u2081 : Y \u2243\u209c Z) :\n\t(h\u2080.trans h\u2081).to_homotopy_equiv = h\u2080.to_homotopy_equiv.trans h\u2081.to_homotopy_equiv\n\ntheorem open_subgroup.ext {G : Type*} [group G] [topological_space G]\n\t{U V : open_subgroup G} (h : \u2200 (x : G), x \u2208 U \u2194 x \u2208 V) :\n\tU = V\n\nThe following is the natural language theorem statement: \"Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " subspace_topology_eq_subspace_topology {X Y : Type*} [topological_space X]\n  [topological_space Y] (hY : subspace Y X) (A : set Y) :\n  subspace.topology A = subspace.topology (hY.subtype A) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_16_6", "nl_statement": "Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$.", "nl_proof": "\\begin{proof}\n\n    We know that $\\mathcal{B}=\\{(a,b)|a<b, a \\text{ and } b \\text rational\\}$ is a basis for $\\mathcal{R}$, therefore the set we are concerned with in the above question is a basis for $\\mathcal{R}^2$. \n\n\\end{proof}", "formal_statement": "theorem exercise_16_6\n  (S : set (set (\u211d \u00d7 \u211d)))\n  (hS : \u2200 s, s \u2208 S \u2192 \u2203 a b c d, (rational a \u2227 rational b \u2227 rational c \u2227 rational d\n  \u2227 s = {x | \u2203 x\u2081 x\u2082, x = (x\u2081, x\u2082) \u2227 a < x\u2081 \u2227 x\u2081 < b \u2227 c < x\u2082 \u2227 x\u2082 < d})) :\n  is_topological_basis S :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_basis_of_topology_prod_Ioo_Ioo_rat {\u03b1 \u03b2 : Type*}\n  [topological_space \u03b1] [topological_space \u03b2]\n  (h\u03b1 : is_basis_of_topology (\u03bb (a b : \u03b1), {a .. b}) (\u03bb (a b : \u03b1), is_open_Ioo a b))\n  (h\u03b2 : is_basis_of_topology (\u03bb (a b : \u03b2), {a .. b}) (\u03bb (a b : \u03b2), is_open_Ioo a b)) :\n  is_basis_of_topology (\u03bb (a b : \u03b1 \u00d7 \u03b2), {a .. b}) (\u03bb (a b : \u03b1 \u00d7 \u03b2), is_open_Ioo a b) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem int.sub_lt_sub_of_le_of_lt {a b c d : \u2124} (hab : a \u2264 b) (hcd : c < d) :\n\ta - d < b - c\n\ntheorem int.sub_lt_sub {a b c d : \u2124} (hab : a < b) (hcd : c < d) :\n\ta - d < b - c\n\ntheorem int.sub_lt_sub_of_lt_of_le {a b c d : \u2124} (hab : a < b) (hcd : c \u2264 d) :\n\ta - d < b - c\n\ntheorem int.sub_le_sub {a b c d : \u2124} (hab : a \u2264 b) (hcd : c \u2264 d) :\n\ta - d \u2264 b - c\n\nThe following is the natural language theorem statement: \"Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_topological_basis_of_rational_intervals (a b c d : \u211a) \n  (hab : a < b) (hcd : c < d) :\n  is_topological_basis (Icc a b) (Icc c d) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_18_8a", "nl_statement": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.", "nl_proof": "\\begin{proof}\n\n    We prove that $U=\\{x \\mid g(x)<f(x)\\}$ is open in $X$. Let $a \\in U$, so that $g(a)<f(a)$. If there is an element $c$ between $g(a)$ and $f(a)$, then $a \\in g^{-1}((-\\infty, c)) \\cap f^{-1}((c,+\\infty))$. If there are no elements between $g(a)$ and $f(a)$, then $a \\in g^{-1}\\left((-\\infty, f(a)) \\cap f^{-1}((g(a),+\\infty))\\right.$. Note that all these preimages are open since $f$ and $g$ are continuous. Thus $U=V \\cup W$, where\n\n$$\n\nV=\\bigcup_{c \\in X} g^{-1}((-\\infty, c)) \\cap f^{-1}((c,+\\infty)) \\quad \\text { and } \\quad W=\\bigcup_{\\substack{g(a)<f(a) \\\\(g(a), f(a))=\\emptyset}} g^{-1}\\left((-\\infty, f(a)) \\cap f^{-1}((g(a),+\\infty))\\right.\n\n$$\n\nare open in $X$. So $U$ is open in $X$ and therefore $X \\backslash U=\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.\n\n\\end{proof}", "formal_statement": "theorem exercise_18_8a {X Y : Type*} [topological_space X] [topological_space Y]\n  [linear_order Y] [order_topology Y] {f g : X \u2192 Y}\n  (hf : continuous f) (hg : continuous g) :\n  is_closed {x | f x \u2264 g x} :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_closed_le {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n  [preorder \u03b1] [t : order_closed_topology \u03b1] [topological_space \u03b2] {f g : \u03b2 \u2192 \u03b1}\n  (hf : continuous f) (hg : continuous g) :\n  is_closed {b : \u03b2 | f b \u2264 g b} ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_closed_le {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[preorder \u03b1] [t : order_closed_topology \u03b1] [topological_space \u03b2] {f g : \u03b2 \u2192 \u03b1}\n\t(hf : continuous f) (hg : continuous g) :\n\tis_closed {b : \u03b2 | f b \u2264 g b}\n\ntheorem is_closed.is_closed_le {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[preorder \u03b1] [t : order_closed_topology \u03b1] [topological_space \u03b2] {f g : \u03b2 \u2192 \u03b1}\n\t{s : set \u03b2} (hs : is_closed s) (hf : continuous_on f s)\n\t(hg : continuous_on g s) :\n\tis_closed {x \u2208 s | f x \u2264 g x}\n\ntheorem is_open_lt {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[linear_order \u03b1] [order_closed_topology \u03b1] [topological_space \u03b2] {f g : \u03b2 \u2192 \u03b1}\n\t(hf : continuous f) (hg : continuous g) :\n\tis_open {b : \u03b2 | f b < g b}\n\ntheorem is_closed_eq {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] [t2_space \u03b1] {f g : \u03b2 \u2192 \u03b1} (hf : continuous f)\n\t(hg : continuous g) :\n\tis_closed {x : \u03b2 | f x = g x}\n\nThe following is the natural language theorem statement: \"Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " is_closed_of_continuous_le {X Y : Type*} [topological_space X]\n  [topological_space Y] [order_topology Y] (f g : X \u2192 Y) (hf : continuous f)\n  (hg : continuous g) :\n  is_closed {x | f x \u2264 g x} ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_18_13", "nl_statement": "Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$.", "nl_proof": "\\begin{proof}\n\n    Let $h, g: \\bar{A} \\rightarrow Y$ be continuous extensions of $f$. Suppose that there is a point $x \\in \\bar{A}$ such that $h(x) \\neq g(x)$. Since $h=g$ on $A$, we must have $x \\in A^{\\prime}$. Since $Y$ is Hausdorff, there is a neighbourhood $U$ of $h(x)$ and a neighbourhood $V$ of $g(x)$ such that $U \\cap V=\\emptyset$. Since $h$ and $g$ are continuous, $h^{-1}(U) \\cap g^{-1}(V)$ is a neighbourhood of $x$. Since $x \\in A^{\\prime}$, there is a point $y \\in h^{-1}(U) \\cap g^{-1}(V) \\cap A$ different from $x$. But $h=g$ on $A$, so $g^{-1}(V) \\cap A=h^{-1}(V) \\cap A$ and hence $y \\in h^{-1}(U) \\cap h^{-1}(V)=h^{-1}(U \\cap V)=\\emptyset$, a contradiction. It follows that $h=g$ on $\\bar{A}$.\n\n\\end{proof}", "formal_statement": "theorem exercise_18_13\n  {X : Type*} [topological_space X] {Y : Type*} [topological_space Y]\n  [t2_space Y] {A : set X} {f : A \u2192 Y} (hf : continuous f)\n  (g : closure A \u2192 Y)\n  (g_con : continuous g) :\n  \u2200 (g' : closure A \u2192 Y), continuous g' \u2192  (\u2200 (x : closure A), g x = g' x) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " continuous_on.extend_unique {X Y : Type*} [topological_space X]\n  [topological_space Y] [t2_space Y] {f : X \u2192 Y} {A : set X}\n  (hf : continuous_on f A) (h : \u2203 (g : X \u2192 Y), continuous g \u2227 \u2200 (x : X), x \u2208 A \u2192 g x = f x) :\n  \u2203! (g : X \u2192 Y), continuous g \u2227 \u2200 (x : X), x \u2208 A \u2192 g x = f x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem uniform_space.completion.ext {\u03b1 : Type*} [uniform_space \u03b1] {Y : Type*}\n\t[topological_space Y] [t2_space Y] {f g : uniform_space.completion \u03b1 \u2192 Y}\n\t(hf : continuous f) (hg : continuous g) (h : \u2200 (a : \u03b1), f \u2191a = g \u2191a) :\n\tf = g\n\ntheorem uniform_space.completion.ext' {\u03b1 : Type*} [uniform_space \u03b1] {Y : Type*}\n\t[topological_space Y] [t2_space Y] {f g : uniform_space.completion \u03b1 \u2192 Y}\n\t(hf : continuous f) (hg : continuous g) (h : \u2200 (a : \u03b1), f \u2191a = g \u2191a)\n\t(a : uniform_space.completion \u03b1) :\n\tf a = g a\n\ntheorem continuous_monoid_hom.ext {A B : Type*} [monoid A] [monoid B]\n\t[topological_space A] [topological_space B] {f g : continuous_monoid_hom A B}\n\t(h : \u2200 (x : A), \u21d1f x = \u21d1g x) :\n\tf = g\n\ntheorem extend_from_extends {X Y : Type*} [topological_space X]\n\t[topological_space Y] [t2_space Y] {f : X \u2192 Y} {A : set X}\n\t(hf : continuous_on f A) (x : X) (H : x \u2208 A) :\n\textend_from A f x = f x\n\nThe following is the natural language theorem statement: \"Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " unique_extension_of_continuous_of_hausdorff {X Y : Type*} \n  [topological_space X] [topological_space Y] (hY : hausdorff Y) \n  (A : set X) (f : A \u2192 Y) (hf : continuous f) (g : closure A \u2192 Y) \n  (hg : continuous g) (hgf : \u2200 x \u2208 A, g x = f x) :\n  g = f \u2218 subtype.val ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_20_2", "nl_statement": "Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.", "nl_proof": "\\begin{proof}\n\n    The dictionary order topology on $\\mathbb{R} \\times \\mathbb{R}$ is the same as the product topology $\\mathbb{R}_d \\times \\mathbb{R}$, where $\\mathbb{R}_d$ denotes $\\mathbb{R}$ with the discrete topology. We know that $\\mathbb{R}_d$ and $\\mathbb{R}$ are metrisable. Thus, it suffices to show that the product of two metrisable spaces is metrisable.\n\nSo let $X$ and $Y$ be metrisable spaces, with metrics $d$ and $d^{\\prime}$ respectively. On $X \\times Y$, define\n\n$$\n\n\\rho(x \\times y, w \\times z)=\\max \\left\\{d(x, w), d^{\\prime}(y, z)\\right\\} .\n\n$$\n\nThen $\\rho$ is a metric on $X \\times Y$; it remains to prove that it induces the product topology on $X \\times Y$. If $B_d\\left(x, r_1\\right) \\times B_d\\left(y, r_2\\right)$ is a basis element for the product space $X \\times Y$, and $r=\\min \\left\\{r_1, r_2\\right\\}$, then $x \\times y \\in B_\\rho(x \\times y, r) \\subset B_d\\left(x, r_1\\right) \\times B_d\\left(y, r_2\\right)$, so the product topology is coarser than the $\\rho$-topology. Conversely, if $B_\\rho(x \\times y, \\delta)$ is a basis element for the $\\rho$-topology, then $x \\times y \\in B_d(x, \\delta) \\times B_{d^{\\prime}}(y, \\delta) \\subset$ $B_\\rho(x \\times y, \\delta)$, so the product topology is finer than the $\\rho$-topology. It follows that both topologies are equal, so the product space $X \\times Y$ is metrisable.\n\n\\end{proof}", "formal_statement": "theorem exercise_20_2\n  [topological_space (\u211d \u00d7\u2097 \u211d)] [order_topology (\u211d \u00d7\u2097 \u211d)]\n  : metrizable_space (\u211d \u00d7\u2097 \u211d) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " metrizable_space_prod_real_real_dictionary_order :\n  topological_space.metrizable_space (\u211d \u00d7 \u211d) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef topological_space.metrizable_space_prod {X Y : Type*} [topological_space X]\n\t[topological_space Y] [topological_space.metrizable_space X]\n\t[topological_space.metrizable_space Y] :\n\ttopological_space.metrizable_space (X \u00d7 Y)\n\ndef topological_space.pseudo_metrizable_space_prod {X Y : Type*}\n\t[topological_space X] [topological_space Y]\n\t[topological_space.pseudo_metrizable_space X]\n\t[topological_space.pseudo_metrizable_space Y] :\n\ttopological_space.pseudo_metrizable_space (X \u00d7 Y)\n\ndef prod.topological_space {\u03b1 : Type u} {\u03b2 : Type v} [t\u2081 : topological_space \u03b1]\n\t[t\u2082 : topological_space \u03b2] :\n\ttopological_space (\u03b1 \u00d7 \u03b2)\n\ntheorem prod_eq_generate_from {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] :\n\tprod.topological_space = topological_space.generate_from {g : set (\u03b1 \u00d7 \u03b2) | \u2203 (s : set \u03b1) (t : set \u03b2), is_open s \u2227 is_open t \u2227 g = s \u00d7\u02e2 t}\n\nThe following is the natural language theorem statement: \"Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " metrizable_of_prod_dict_order_topology {\u03b1 \u03b2 : Type*} \n  [topological_space \u03b1] [topological_space \u03b2] :\n  metrizable_space (prod_dict_order_topology \u03b1 \u03b2) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_21_6b", "nl_statement": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly.", "nl_proof": "\\begin{proof}\n\n    The sequence $\\left(f_n\\right)_n$ does not converge uniformly, since given $0<\\varepsilon<1$ and $N \\in \\mathbb{Z}_{+}$, for $x=\\varepsilon^{1 / N}$ we have $d\\left(f_N(x), f(x)\\right)=\\varepsilon$. We can also apply Theorem 21.6: the convergence is not uniform since $f$ is not continuous.\n\n\\end{proof}", "formal_statement": "theorem exercise_21_6b\n  (f : \u2115 \u2192 I \u2192 \u211d )\n  (h : \u2200 x n, f n x = x ^ n) :\n  \u00ac \u2203 f\u2080, tendsto_uniformly f f\u2080 at_top :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " not_uniform_limit_of_pow_const {\u03b1 : Type*} [uniform_space \u03b1] [group \u03b1]\n  [uniform_group \u03b1] (n : \u2115) :\n  \u00ac uniform_limit (\u03bb (x : \u03b1), x ^ n) (\u03bb (x : \u03b1), 0) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem irrational.of_pow {x : \u211d} (n : \u2115) :\n\tirrational (x ^ n) \u2192 irrational x\n\ntheorem int.neg_one_pow_ne_zero {n : \u2115} :\n\t(-1) ^ n \u2260 0\n\ntheorem zero_pow_le_one {R : Type*} [ordered_semiring R] (n : \u2115) :\n\t0 ^ n \u2264 1\n\ntheorem uniform_continuous_pow_const {\u03b1 : Type*} [uniform_space \u03b1] [group \u03b1]\n\t[uniform_group \u03b1] (n : \u2115) :\n\tuniform_continuous (\u03bb (x : \u03b1), x ^ n)\n\nThe following is the natural language theorem statement: \"Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_uniform_limit_of_pow_n_of_x_in_Ioo_zero_one (n : \u2115) :\n  \u00ac uniform_limit (\u03bb n : \u2115, (\u03bb x : \u211d, x ^ n)) (\u03bb n : \u2115, (\u03bb x : \u211d, x ^ (n + 1)))\n    (\u03bb x : \u211d, x ^ n) (Ioo 0 1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_22_2a", "nl_statement": "Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.", "nl_proof": "\\begin{proof}\n\nLet $1_Y: Y \\rightarrow Y$ be the identity map in $Y$. If $U$ is a subset of $Y$ and $p^{-1}(U)$ is open in $X$, then $f^{-1}\\left(p^{-1}(U)\\right)=1_Y^{-1}(U)=U$ is open in $Y$ by continuity of $f$. Thus $p$ is a quotient map.\n\n\\end{proof}", "formal_statement": "theorem exercise_22_2a {X Y : Type*} [topological_space X]\n  [topological_space Y] (p : X \u2192 Y) (h : continuous p) :\n  quotient_map p \u2194 \u2203 (f : Y \u2192 X), continuous f \u2227 p \u2218 f = id :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " quotient_map_of_continuous_right_inverse {X Y : Type*}\n  [topological_space X] [topological_space Y] (p : X \u2192 Y) (f : Y \u2192 X)\n  (hf : continuous f) (h : p \u2218 f = id) : quotient_map p ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem quotient_map.of_quotient_map_compose {\u03b1 \u03b2 \u03b3 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] [topological_space \u03b3] {g : \u03b2 \u2192 \u03b3}\n\t{f : \u03b1 \u2192 \u03b2} (hf : continuous f) (hg : continuous g)\n\t(hgf : quotient_map (g \u2218 f)) :\n\tquotient_map g\n\ntheorem continuous.quotient_map' {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] {s : setoid \u03b1} {t : setoid \u03b2} {f : \u03b1 \u2192 \u03b2}\n\t(hf : continuous f) (H : (setoid.r \u21d2 setoid.r) f f) :\n\tcontinuous (quotient.map' f H)\n\ntheorem discrete_quotient.map_comp {X : Type*} [topological_space X] {Y : Type*}\n\t[topological_space Y] {f : Y \u2192 X} {cont : continuous f}\n\t{A : discrete_quotient Y} {B : discrete_quotient X} {Z : Type*}\n\t[topological_space Z] {g : Z \u2192 Y} {cont' : continuous g}\n\t{C : discrete_quotient Z} (h1 : discrete_quotient.le_comap cont' C A)\n\t(h2 : discrete_quotient.le_comap cont A B) :\n\tdiscrete_quotient.map _ = discrete_quotient.map h2 \u2218 discrete_quotient.map h1\n\ntheorem discrete_quotient.map_of_le_apply {X : Type*} [topological_space X]\n\t{Y : Type*} [topological_space Y] {f : Y \u2192 X} {cont : continuous f}\n\t{A : discrete_quotient Y} {B : discrete_quotient X} {C : discrete_quotient Y}\n\t(cond : discrete_quotient.le_comap cont A B) (h : C \u2264 A) ( : \u21a5C) :\n\tdiscrete_quotient.map _ c = discrete_quotient.map cond (discrete_quotient.of_le h c)\n\nThe following is the natural language theorem statement: \"Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " quotient_of_continuous_map_of_continuous_map_comp_id {X Y : Type*}\n  [topological_space X] [topological_space Y] (p : X \u2192 Y) (hpc : continuous p)\n  (f : Y \u2192 X) (hfc : continuous f) (h : p \u2218 f = id) :\n  quotient_map p ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_22_5", "nl_statement": "Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map.", "nl_proof": "\\begin{proof}\n\nLet $U$ be open in $A$. Since $A$ is open in $X, U$ is open in $X$ as well, so $p(U)$ is open in $Y$. Since $q(U)=p(U)=p(U) \\cap p(A)$, the set $q(U)$ is open in $p(A)$. Thus $q$ is an open map.\n\n\\end{proof}", "formal_statement": "theorem exercise_22_5 {X Y : Type*} [topological_space X]\n  [topological_space Y] (p : X \u2192 Y) (hp : is_open_map p)\n  (A : set X) (hA : is_open A) : is_open_map (p \u2218 subtype.val : A \u2192 Y) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_open_of_is_open_map {X Y : Top} (p : X \u27f6 Y) (h : is_open_map p)\n  {A : set \u21a5X} (hA : is_open A) : is_open_map (p.restrict A) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem topological_space.opens.map_obj {X Y : Top} (f : X \u27f6 Y) (U : set \u21a5Y)\n\t(p : is_open U) :\n\t(topological_space.opens.map f).obj \u27e8U, p\u27e9 = \u27e8\u21d1f \u207b\u00b9' U, _\u27e9\n\ntheorem topological_space.opens.map_eq {X Y : Top} (f g : X \u27f6 Y) (h : f = g) :\n\ttopological_space.opens.map f = topological_space.opens.map g\n\ntheorem topological_space.opens.map_comp_obj' {X Y Z : Top} (f : X \u27f6 Y)\n\t(g : Y \u27f6 Z) (U : set \u21a5Z) (p : is_open U) :\n\t(topological_space.opens.map (f \u226b g)).obj \u27e8U, p\u27e9 = (topological_space.opens.map f).obj ((topological_space.opens.map g).obj \u27e8U, p\u27e9)\n\ntheorem topological_space.opens.to_Top_map (X : Top)\n\t{U V : topological_space.opens \u21a5X} {f : U \u27f6 V} {x : \u21a5X} {h : x \u2208 U.val} :\n\t\u21d1((topological_space.opens.to_Top X).map f) \u27e8x, h\u27e9 = \u27e8x, _\u27e9\n\nThe following is the natural language theorem statement: \"Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " open_map_of_open_map_of_open_subset {X Y : Type*} [topological_space X]\n  [topological_space Y] (p : X \u2192 Y) (h : open_map p) (A : set X) (hA : is_open A) :\n  open_map (p.restrict A) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_23_3", "nl_statement": "Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected.", "nl_proof": "\\begin{proof}\n\n    For each $\\alpha$ we have $A \\cap A_\\alpha \\neq \\emptyset$, so each $A \\cup A_\\alpha$ is connected by Theorem 23.3. In turn $\\left\\{A \\cup A_\\alpha\\right\\}_\\alpha$ is a collection of connected spaces that have a point in common (namely any point in $A)$, so $\\bigcup_\\alpha\\left(A \\cup A_\\alpha\\right)=A \\cup\\left(\\bigcup_\\alpha A_\\alpha\\right)$ is connected. \n\n\\end{proof}", "formal_statement": "theorem exercise_23_3 {X : Type*} [topological_space X]\n  [topological_space X] {A : \u2115 \u2192 set X}\n  (hAn : \u2200 n, is_connected (A n))\n  (A\u2080 : set X)\n  (hA : is_connected A\u2080)\n  (h : \u2200 n, A\u2080 \u2229 A n \u2260 \u2205) :\n  is_connected (A\u2080 \u222a (\u22c3 n, A n)) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_connected.union_of_connected_intersection {\u03b1 : Type u}\n  [topological_space \u03b1] {s : set \u03b1} {t : \u03b1 \u2192 set \u03b1}\n  (h : \u2200 (a : \u03b1), s \u2229 t a \u2260 \u2205) (hs : is_connected s)\n  (ht : \u2200 (a : \u03b1), is_connected (t a)) :\n  is_connected (s \u222a (\u22c3 (a : \u03b1), t a)) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_preconnected_Union {\u03b1 : Type u} [topological_space \u03b1] {\u03b9 : Sort u_1}\n\t{s : \u03b9 \u2192 set \u03b1} (h\u2081 : (\u22c2 (i : \u03b9), s i).nonempty)\n\t(h\u2082 : \u2200 (i : \u03b9), is_preconnected (s i)) :\n\tis_preconnected (\u22c3 (i : \u03b9), s i)\n\ntheorem is_path_connected.union {X : Type*} [topological_space X] {U V : set X}\n\t(hU : is_path_connected U) (hV : is_path_connected V) (hUV : (U \u2229 V).nonempty) :\n\tis_path_connected (U \u222a V)\n\ntheorem is_connected.union {\u03b1 : Type u} [topological_space \u03b1] {s t : set \u03b1}\n\t(H : (s \u2229 t).nonempty) (Hs : is_connected s) (Ht : is_connected t) :\n\tis_connected (s \u222a t)\n\ntheorem is_clopen.bUnion_connected_component_eq {\u03b1 : Type u}\n\t[topological_space \u03b1] {Z : set \u03b1} (h : is_clopen Z) :\n\t(\u22c3 (x : \u03b1) (H : x \u2208 Z), connected_component x) = Z\n\nThe following is the natural language theorem statement: \"Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " connected_of_connected_inter_connected_union {X : Type*} \n  [topological_space X] {A : set X} (hA : is_connected A) \n  {A\u03b1 : Type*} {B : A\u03b1 \u2192 set X} (hB : \u2200 (\u03b1 : A\u03b1), is_connected (B \u03b1)) \n  (h : \u2200 (\u03b1 : A\u03b1), A \u2229 B \u03b1 \u2260 \u2205) :\n  is_connected (A \u222a (\u22c3 (\u03b1 : A\u03b1), B \u03b1)) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_23_6", "nl_statement": "Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$.", "nl_proof": "\\begin{proof}\n\n    Suppose that $C \\cap B d A=C \\cap \\bar{A} \\cap \\overline{X-A}=\\emptyset$. Then $C \\cap A$ and $C \\cap(X \\backslash A)$ are a pair of disjoint non-empty sets whose union is all of $C$, neither of which contains a limit point of the other. Indeed, if $C \\cap(X-A)$ contains a limit point $x$ of $C \\cap A$, then $x \\in C \\cap(X-A) \\cap A^{\\prime} \\subset C \\cap \\bar{A} \\cap \\overline{X-A}=\\emptyset$, a contradiction, and similarly $C \\cap A$ does not contain a limit point of $C \\cap(X-A)$. Then $C \\cap A$ and $C \\cap(X-A)$ constitute a separation of $C$, contradicting the fact that $C$ is connected (Lemma 23.1).\n\n\\end{proof}", "formal_statement": "theorem exercise_23_6 {X : Type*}\n  [topological_space X] {A C : set X} (hc : is_connected C)\n  (hCA : C \u2229 A \u2260 \u2205) (hCXA : C \u2229 A\u1d9c \u2260 \u2205) :\n  C \u2229 (frontier A) \u2260 \u2205 :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " connected_of_inter_compl_inter_boundary {X : Type*} [topological_space X]\n  {A C : set X} (hC : connected C) (hCA : C \u2229 A \u2260 \u2205) (hCC : C \u2229 -A \u2260 \u2205) :\n  C \u2229 closure (-A) \u2260 \u2205 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem perfect.closure_nhds_inter {\u03b1 : Type*} [topological_space \u03b1]\n\t{C U : set \u03b1} (hC : perfect C) (x : \u03b1) (xC : x \u2208 C) (xU : x \u2208 U)\n\t(Uop : is_open U) :\n\tperfect (closure (U \u2229 C)) \u2227 (closure (U \u2229 C)).nonempty\n\ntheorem is_exposed.inter {\ud835\udd5c E : Type*} [normed_linear_ordered_field \ud835\udd5c]\n\t[add_comm_monoid E] [module \ud835\udd5c E] [topological_space E] {A B C : set E}\n\t(hB : is_exposed \ud835\udd5c A B) (hC : is_exposed \ud835\udd5c A C) :\n\tis_exposed \ud835\udd5c A (B \u2229 C)\n\ntheorem is_exposed.inter_right {\ud835\udd5c E : Type*} [normed_linear_ordered_field \ud835\udd5c]\n\t[add_comm_monoid E] [module \ud835\udd5c E] [topological_space E] {A B C : set E}\n\t(hC : is_exposed \ud835\udd5c B C) (hCA : C \u2286 A) :\n\tis_exposed \ud835\udd5c (A \u2229 B) C\n\ntheorem is_exposed.inter_left {\ud835\udd5c E : Type*} [normed_linear_ordered_field \ud835\udd5c]\n\t[add_comm_monoid E] [module \ud835\udd5c E] [topological_space E] {A B C : set E}\n\t(hC : is_exposed \ud835\udd5c A C) (hCB : C \u2286 B) :\n\tis_exposed \ud835\udd5c (A \u2229 B) C\n\nThe following is the natural language theorem statement: \"Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " connected_inter_of_inter_compl_inter_boundary {X : Type*} [topological_space X]\n  (A : set X) (C : set X) (hC : is_connected C) (hC_inter_A : C \u2229 A \u2260 \u2205)\n  (hC_inter_compl_A : C \u2229 set.compl A \u2260 \u2205) :\n  C \u2229 set.boundary A \u2260 \u2205 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_23_11", "nl_statement": "Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected.", "nl_proof": "\\begin{proof}\n\n    Suppose that $U$ and $V$ constitute a separation of $X$. If $y \\in p(U)$, then $y=p(x)$ for some $x \\in U$, so that $x \\in p^{-1}(\\{y\\})$. Since $p^{-1}(\\{y\\})$ is connected and $x \\in U \\cap p^{-1}(\\{y\\})$, we have $p^{-1}(\\{y\\}) \\subset U$. Thus $p^{-1}(\\{y\\}) \\subset U$ for all $y \\in p(U)$, so that $p^{-1}(p(U)) \\subset U$. The inclusion $U \\subset p^{-1}(p(U))$ if true for any subset and function, so we have the equality $U=p^{-1}(p(U))$ and therefore $U$ is saturated. Similarly, $V$ is saturated. Since $p$ is a quotient map, $p(U)$ and $p(V)$ are disjoint non-empty open sets in $Y$. But $p(U) \\cup p(V)=Y$ as $p$ is surjective, so $p(U)$ and $p(V)$ constitute a separation of $Y$, contradicting the fact that $Y$ is connected. We conclude that $X$ is connected.\n\n\\end{proof}", "formal_statement": "theorem exercise_23_11 {X Y : Type*} [topological_space X] [topological_space Y]\n  (p : X \u2192 Y) (hq : quotient_map p)\n  (hY : connected_space Y) (hX : \u2200 y : Y, is_connected (p \u207b\u00b9' {y})) :\n  connected_space X :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " quotient_map.connected_of_connected_preimage {X : Type*}\n  [topological_space X] {Y : Type*} [topological_space Y] {f : X \u2192 Y}\n  (hf : quotient_map f) (hY : connected_space Y)\n  (h : \u2200 (y : Y), connected_space (f \u207b\u00b9' {y})) : connected_space X ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem continuous_map.homotopy_equiv.continuous {X : Type u} {Y : Type v}\n\t[topological_space X] [topological_space Y]\n\t(h : continuous_map.homotopy_equiv X Y) :\n\tcontinuous \u21d1h\n\ntheorem discrete_quotient.map_comp {X : Type*} [topological_space X] {Y : Type*}\n\t[topological_space Y] {f : Y \u2192 X} {cont : continuous f}\n\t{A : discrete_quotient Y} {B : discrete_quotient X} {Z : Type*}\n\t[topological_space Z] {g : Z \u2192 Y} {cont' : continuous g}\n\t{C : discrete_quotient Z} (h1 : discrete_quotient.le_comap cont' C A)\n\t(h2 : discrete_quotient.le_comap cont A B) :\n\tdiscrete_quotient.map _ = discrete_quotient.map h2 \u2218 discrete_quotient.map h1\n\ntheorem preconnected_space.constant {\u03b1 : Type u} [topological_space \u03b1]\n\t{Y : Type*} [topological_space Y] [discrete_topology Y]\n\t(hp : preconnected_space \u03b1) {f : \u03b1 \u2192 Y} (hf : continuous f) {x y : \u03b1} :\n\tf x = f y\n\ntheorem discrete_quotient.map_of_le {X : Type*} [topological_space X]\n\t{Y : Type*} [topological_space Y] {f : Y \u2192 X} {cont : continuous f}\n\t{A : discrete_quotient Y} {B : discrete_quotient X} {C : discrete_quotient Y}\n\t(cond : discrete_quotient.le_comap cont A B) (h : C \u2264 A) :\n\tdiscrete_quotient.map _ = discrete_quotient.map cond \u2218 discrete_quotient.of_le h\n\nThe following is the natural language theorem statement: \"Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " connected_of_connected_quotient_map {X Y : Type*} [topological_space X]\n  [topological_space Y] (p : X \u2192 Y) (hp : quotient_map p)\n  (hY : connected_space Y) (hX : \u2200 y : Y, connected_space (p \u207b\u00b9' {y})) :\n  connected_space X ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_24_3a", "nl_statement": "Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.)", "nl_proof": "\\begin{proof}\n\n    If $f(0)=0$ or $f(1)=1$ we are done, so suppose $f(0)>0$ and $f(1)<1$. Let $g:[0,1] \\rightarrow[0,1]$ be given by $g(x)=f(x)-x$. Then $g$ is continuous, $g(0)>0$ and $g(1)<0$. Since $[0,1]$ is connected and $g(1)<0<g(0)$, by the intermediate value theorem there exists $x \\in(0,1)$ such that $g(x)=0$, that is, such that $f(x)=x$.\n\n\\end{proof}", "formal_statement": "theorem exercise_24_3a [topological_space I]\n  (f : I \u2192 I) (hf : continuous f) :\n  \u2203 (x : I), f x = x :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " exists_fixed_point_of_continuous_of_compact_to_t2 {X : Type*}\n  [topological_space X] [compact_space X] [t2_space X] {f : X \u2192 X}\n  (hf : continuous f) :\n  \u2203 (x : X), f x = x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_locally_constant.continuous {X Y : Type*} [topological_space X]\n\t[topological_space Y] {f : X \u2192 Y} (hf : is_locally_constant f) :\n\tcontinuous f\n\ntheorem is_closed_fixed_points {\u03b1 : Type*} [topological_space \u03b1] [t2_space \u03b1]\n\t{f : \u03b1 \u2192 \u03b1} (hf : continuous f) :\n\tis_closed (function.fixed_points f)\n\ntheorem is_locally_homeomorph.continuous {X Y : Type*} [topological_space X]\n\t[topological_space Y] {f : X \u2192 Y} (hf : is_locally_homeomorph f) :\n\tcontinuous f\n\ntheorem continuous.continuous_symm_of_equiv_compact_to_t2 {\u03b1 \u03b2 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] [compact_space \u03b1] [t2_space \u03b2]\n\t{f : \u03b1 \u2243 \u03b2} (hf : continuous \u21d1f) :\n\tcontinuous \u21d1(f.symm)\n\nThe following is the natural language theorem statement: \"Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.)\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " exists_fixed_point_of_continuous_of_compact {X : Type*} [topological_space X]\n  [compact_space X] {f : X \u2192 X} (hf : continuous f) :\n  \u2203 (x : X), f x = x ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.)\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_25_9", "nl_statement": "Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$.", "nl_proof": "\\begin{proof}\n\n    Given $x \\in G$, the maps $y \\mapsto x y$ and $y \\mapsto y x$ are homeomorphisms of $G$ onto itself. Since $C$ is a component, $x C$ and $C x$ are both components that contain $x$, so they are equal. Hence $x C=C x$ for all $x \\in G$, so $C$ is a normal subgroup of $G$.\n\n\\end{proof}", "formal_statement": "theorem exercise_25_9 {G : Type*} [topological_space G] [group G]\n  [topological_group G] (C : set G) (h : C = connected_component 1) :\n  is_normal_subgroup C :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_normal_subgroup_of_component {G : Type*} [topological_group G]\n  (C : set G) (hC : is_component C) :\n  is_normal_subgroup C ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem category_theory.subgroupoid.top_is_normal {C : Type u}\n\t[category_theory.groupoid C] :\n\t\u22a4.is_normal\n\ntheorem subgroup.normal.comap {G : Type*} [group G] {N : Type*} [group N]\n\t{H : subgroup N} (hH : H.normal) (f : G \u2192* N) :\n\t(subgroup.comap f H).normal\n\ntheorem subgroup.of_normal {G : Type*} [group G] (s : set G) (h : is_subgroup s)\n\t(n : is_normal_subgroup s) :\n\t(subgroup.of h).normal\n\ntheorem is_normal_subgroup_of_comm_group {G : Type*} [comm_group G] {s : set G}\n\t(hs : is_subgroup s) :\n\tis_normal_subgroup s\n\nThe following is the natural language theorem statement: \"Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " component_is_normal (G : Type*) [topological_space G] [group G]\n  [topological_group G] (C : set G) (hC : is_connected C)\n  (hC_id : (1 : G) \u2208 C) : is_normal_subgroup C ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_26_12", "nl_statement": "Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact.", "nl_proof": "\\begin{proof}\n\n    We first show that if $U$ is an open set containing $p^{-1}(\\{y\\})$, then there is a neighbourhood $W$ of $y$ such that $p^{-1}(W)$ is contained in $U$. Since $X-U$ is closed in $X$, $p(X-U)$ is closed in $Y$ and does not contain $y$, so $W=Y \\backslash p(X \\backslash U)$ is a neighbourhood of $y$. Moreover, since $X \\backslash U \\subset p^{-1}(p(X \\backslash U)$ ) (by elementary set theory), we have\n\n$$\n\np^{-1}(W)=p^{-1}(Y \\backslash p(X \\backslash U))=p^{-1}(Y) \\backslash p^{-1}(p(X \\backslash U)) \\subset X \\backslash(X \\backslash U)=U .\n\n$$\n\nNow let $\\mathcal{A}$ be an open covering of $X$. For each $y \\in Y$, let $\\mathcal{A}_y$ be a subcollection of $\\mathcal{A}$ such that\n\n$$\n\np^{-1}(\\{y\\}) \\subset \\bigcup_{A \\in \\mathcal{A}_y} A .\n\n$$\n\nSince $p^{-1}(\\{y\\})$ is compact, there exists a finite subcollection of $\\mathcal{A}_y$ that also covers $p^{-1}(\\{y\\})$, say $\\left\\{A_y^1, \\ldots, A_y^{n_y}\\right\\}$. Thus $\\bigcup_{i=1}^{n_y} A_y^i$ is open and contains $p^{-1}(\\{y\\})$, so there exists a neighbourhood $W_y$ of $y$ such that $p^{-1}\\left(W_y\\right)$ is contained in $\\bigcup_{i=1}^{n_y} A_y^i$. Then $\\left\\{W_y\\right\\}_{y \\in Y}$ is an open covering of $Y$, so there exist $y_1, \\ldots, y_k \\in Y$ such that $\\left\\{W_{y_j}\\right\\}_{j=1}^k$ also covers $Y$. Then\n\n$$\n\nX=p^{-1}(Y) \\subset p^{-1}\\left(\\bigcup_{j=1}^k W_{y_j}\\right)=\\bigcup_{j=1}^k p^{-1}\\left(W_{y_j}\\right) \\subset \\bigcup_{j=1}^k\\left(\\bigcup_{i=1}^{n_{y_j}} A_{y_j}^i\\right)\n\n$$\n\nso\n\n$$\n\n\\left\\{A_{y_j}^i\\right\\}_{\\substack{j=1, \\ldots, k . \\\\ i=1, \\ldots, n_{y_j}}}\n\n$$\n\nis a finite subcollection of $\\mathcal{A}$ that also covers $X$. Therefore, $X$ is compact.\n\n\\end{proof}", "formal_statement": "theorem exercise_26_12 {X Y : Type*} [topological_space X] [topological_space Y]\n  (p : X \u2192 Y) (h : function.surjective p) (hc : continuous p) (hp : \u2200 y, is_compact (p \u207b\u00b9' {y}))\n  (hY : compact_space Y) : compact_space X :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " compact_of_perfect_map_compact {X Y : Type*} [topological_space X]\n  [topological_space Y] (p : X \u2192 Y) (hc : continuous p) (hsc : surjective p)\n  (hpc : \u2200 (y : Y), compact (p \u207b\u00b9' {y})) (hY : compact_space Y) :\n  compact_space X ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem continuous_map.continuous.comp' {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [topological_space \u03b3] {X : Type*} [topological_space X]\n\t[locally_compact_space \u03b2] {f : X \u2192 C(\u03b1, \u03b2)} {g : X \u2192 C(\u03b2, \u03b3)}\n\t(hf : continuous f) (hg : continuous g) :\n\tcontinuous (\u03bb (x : X), (g x).comp (f x))\n\ntheorem continuous_map.homotopy_equiv.continuous {X : Type u} {Y : Type v}\n\t[topological_space X] [topological_space Y]\n\t(h : continuous_map.homotopy_equiv X Y) :\n\tcontinuous \u21d1h\n\ntheorem topological_space.compact_opens.map_to_compacts {\u03b1 \u03b2 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : continuous f)\n\t(hf' : is_open_map f) (s : topological_space.compact_opens \u03b1) :\n\t(topological_space.compact_opens.map f hf hf' s).to_compacts = topological_space.compacts.map f hf s.to_compacts\n\ntheorem topological_space.compacts.coe_map {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : continuous f)\n\t(s : topological_space.compacts \u03b1) :\n\t\u2191(topological_space.compacts.map f hf s) = f '' \u2191s\n\nThe following is the natural language theorem statement: \"Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " compact_of_perfect_map_compact_space {X Y : Type*} [topological_space X]\n  [topological_space Y] [compact_space Y] (p : X \u2192 Y) (hc : continuous p)\n  (hsc : surjective p) (hpc : \u2200 y : Y, compact_space (p \u207b\u00b9' {y})) :\n  compact_space X ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_28_4", "nl_statement": "A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness.", "nl_proof": "\\begin{proof}\n\n    First let $X$ be a countable compact space. Note that if $Y$ is a closed subset of $X$, then $Y$ is countable compact as well, for if $\\left\\{U_n\\right\\}_{n \\in \\mathbb{Z}_{+}}$is a countable open covering of $Y$, then $\\left\\{U_n\\right\\}_{n \\in \\mathbb{Z}_{+}} \\cup(X \\backslash Y)$ is a countable open covering of $X$; there is a finite subcovering of $X$, hence a finite subcovering of $Y$. Now let $A$ be an infinite subset. We show that $A$ has a limit point. Let $B$ be a countable infinite subset of $A$. Suppose that $B$ has no limit point, so that $B$ is closed in $X$. Then $B$ is countable compact. Since $B$ has no limit point, for each $b \\in B$ there is a neighbourhood $U_b$ of $b$ that intersects $B$ in the point $b$ alone. Then $\\left\\{U_b\\right\\}_{b \\in B}$ is an open covering of $B$ with no finite subcovering, contradicting the fact that $B$ is countable compact. Hence $B$ has a limit point, so that $A$ has a limit point as well. Since $A$ was arbitrary, we deduce that $X$ is limit point compact. (Note that the $T_1$ property is not necessary in this direction.)\n\n\n\nNow assume that $X$ is a limit point compact $T_1$ space. We show that $X$ is countable compact. Suppose, on the contrary, that $\\left\\{U_n\\right\\}_{n \\in \\mathbb{Z}_{+}}$is a countable open covering of $X$ with no finite subcovering. For each $n$, take a point $x_n$ in $X$ not in $U_1 \\cup \\cdots \\cup U_n$. By assumption, the infinite set $A=\\left\\{x_n \\mid n \\in \\mathbb{Z}_{+}\\right\\}$has a limit point $y \\in X$. Since $\\left\\{U_n\\right\\}_{n \\in \\mathbb{Z}_{+}}$covers $X$, there exists $N \\in \\mathbb{Z}_{+}$such that $y \\in U_1 \\cup \\cdots \\cup U_N$. Now $X$ is $T_1$, so for each $i=1, \\ldots, N$ there exists a neighbourhood $V_i$ of $y$ that does not contain $x_i$. Then\n\n$$\n\nV=\\left(V_1 \\cap \\cdots \\cap V_N\\right) \\cap\\left(U_1 \\cup \\cdots \\cup U_N\\right)\n\n$$\n\nis a neighbourhood of $y$ that does not contain any of the points $x_i$, contradicting the fact that $y$ is a limit point of $A$. It follows that every countable open covering of $X$ must have a finite subcovering, so $X$ is countable compact.\n\n\\end{proof}", "formal_statement": "theorem exercise_28_4 {X : Type*}\n  [topological_space X] (hT1 : t1_space X) :\n  countably_compact X \u2194 limit_point_compact X :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " countably_compact_iff_limit_point_compact {X : Type*}\n  [topological_space X] [t1_space X] :\n  countably_compact_space X \u2194 limit_point_compact_space X ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef topological_space.pseudo_metrizable_space.first_countable_topology\n\t{X : Type*} [topological_space X]\n\t[h : topological_space.pseudo_metrizable_space X] :\n\ttopological_space.first_countable_topology X\n\ntheorem sigma_compact_space.of_countable {\u03b1 : Type u} [topological_space \u03b1]\n\t(S : set (set \u03b1)) (Hc : S.countable)\n\t(Hcomp : \u2200 (s : set \u03b1), s \u2208 S \u2192 is_compact s) (HU : \u22c3\u2080 S = set.univ) :\n\tsigma_compact_space \u03b1\n\ntheorem is_compact.is_seq_compact {X : Type*} [topological_space X]\n\t[topological_space.first_countable_topology X] {s : set X} (hs : is_compact s) :\n\tis_seq_compact s\n\ntheorem is_compact.tendsto_subseq {X : Type*} [topological_space X]\n\t[topological_space.first_countable_topology X] {s : set X} {x : \u2115 \u2192 X}\n\t(hs : is_compact s) (hx : \u2200 (n : \u2115), x n \u2208 s) :\n\t\u2203 (a : X) (H : a \u2208 s) (\u03c6 : \u2115 \u2192 \u2115), strict_mono \u03c6 \u2227 filter.tendsto (x \u2218 \u03c6) filter.at_top (nhds a)\n\nThe following is the natural language theorem statement: \"A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " countably_compact_of_limit_point_compact {X : Type*} [topological_space X]\n  (hX : t1_space X) (hX\u2081 : limit_point_compact X) :\n  countably_compact X ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_28_6", "nl_statement": "Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.", "nl_proof": "\\begin{proof}\n\n    Note that $f$ is an imbedding. It remains to prove that $f$ is surjective. Suppose it is not, and let $a \\in f(X)$. Since $X$ is compact, $f(X)$ is compact and hence closed (every metric space is Hausdorff). Thus, there exists $\\varepsilon>0$ such that the $\\varepsilon^{-}$ neighbourhood of $a$ is contained in $X \\backslash f(X)$. Set $x_1=a$, and inductively $x_{n+1}=f\\left(x_n\\right)$ for $n \\in \\mathbb{Z}_{+}$. We show that $d\\left(x_n, x_m\\right) \\geq \\varepsilon$ for $n \\neq m$. Indeed, we may assume $n<m$. If $n \\geq 1$, then $d\\left(x_n, x_m\\right)=$ $d\\left(f^{-1}\\left(x_n\\right), f^{-1}\\left(x_m\\right)\\right)=d\\left(x_{n-1}, x_{m-1}\\right)$. By induction it follows that $d\\left(x_n, x_m\\right)=d\\left(x_{n-i}, x_{m-i}\\right)$ for all $i \\geq 1$, and hence $d\\left(x_n, x_m\\right)=d\\left(a, x_{m-n}\\right)=d\\left(a, f\\left(x_{m-n-1}\\right)\\right)$. Since $f\\left(x_{m-n-1}\\right) \\in f(X)$ and $B(a, \\varepsilon) \\cap f(X)=\\emptyset$, we have $d\\left(x_n, x_m\\right) \\geq \\varepsilon$, as claimed. Thus $\\left\\{x_n\\right\\}_{n \\in \\mathbb{Z}_{+}}$is a sequence with no convergent subsequence, so $X$ is not sequentially compact. This contradicts the fact that $X$ is compact. Therefore $f$ is surjective and hence a homeomorphism.\n\n\\end{proof}", "formal_statement": "theorem exercise_28_6 {X : Type*} [metric_space X]\n  [compact_space X] {f : X \u2192 X} (hf : isometry f) :\n  function.bijective f :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " isometry.bijective_of_compact {X : Type*} [emetric_space X]\n  (f : X \u2192 X) (hf : isometry f) (hX : compact_space X) :\n  function.bijective f ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem isometry.dimH_image {X Y : Type*} [emetric_space X] [emetric_space Y]\n\t{f : X \u2192 Y} (hf : isometry f) (s : set X) :\n\tdimH (f '' s) = dimH s\n\ntheorem isometric.bijective {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2) :\n\tfunction.bijective \u21d1h\n\ntheorem CompHaus.is_iso_of_bijective {X Y : CompHaus} (f : X \u27f6 Y)\n\t(bij : function.bijective \u21d1f) :\n\tcategory_theory.is_iso f\n\ndef CompHaus.iso_of_bijective {X Y : CompHaus} (f : X \u27f6 Y)\n\t(bij : function.bijective \u21d1f) :\n\tX \u2245 Y\n\nThe following is the natural language theorem statement: \"Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " isometry_of_compact_space_is_bijective {X : Type*} [metric_space X]\n  (hX : compact_space X) (f : X \u2192 X) (hf : \u2200 x y : X, dist x y = dist (f x) (f y)) :\n  function.bijective f ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_29_4", "nl_statement": "Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology.", "nl_proof": "\\begin{proof}\n\n    Consider $\\mathbf{0} \\in[0,1]^\\omega$ and suppose that $[0,1]^\\omega$ is locally compact at $\\mathbf{0}$. Then there exists a compact $C$ containing an open ball $B=B_\\rho(\\mathbf{0}, \\varepsilon) \\subset[0,1]^\\omega$. Note that $\\bar{B}=[0, \\varepsilon]^\\omega$. Then $[0, \\varepsilon]^\\omega$ is closed and contained in the compact $C$, so it is compact. But $[0, \\varepsilon]^\\omega$ is homeomorphic to $[0,1]^\\omega$, which is not compact by Exercise 28.1. This contradiction proves that $[0,1]^\\omega$ is not locally compact in the uniform topology.\n\n\\end{proof}", "formal_statement": "theorem exercise_29_4 [topological_space (\u2115 \u2192 I)] :\n  \u00ac locally_compact_space (\u2115 \u2192 I) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " not_locally_compact_space_Ioo_pow_omega :\n  \u00aclocally_compact_space (set.Ioo 0 1) ^ (\u2115 : Type*) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem not_compact_space_iff {\u03b1 : Type u} [topological_space \u03b1] :\n\t\u00accompact_space \u03b1 \u2194 noncompact_space \u03b1\n\ntheorem real.is_topological_basis_Ioo_rat :\n\ttopological_space.is_topological_basis (\u22c3 (a b : \u211a) (h : a < b), {set.Ioo \u2191a \u2191b})\n\ndef locally_compact_space.prod (\u03b1 \u03b2 : Type*) [topological_space \u03b1]\n\t[topological_space \u03b2] [locally_compact_space \u03b1] [locally_compact_space \u03b2] :\n\tlocally_compact_space (\u03b1 \u00d7 \u03b2)\n\ntheorem to_topological_space_infi {\u03b1 : Type*} {\u03b9 : Sort u_2}\n\t{u : \u03b9 \u2192 uniform_space \u03b1} :\n\tuniform_space.to_topological_space = \u2a05 (i : \u03b9), uniform_space.to_topological_space\n\nThe following is the natural language theorem statement: \"Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " not_locally_compact_uniform_topology_prod_Ioo_omega :\n  \u00ac locally_compact_space (uniform_space.prod_Ioo_omega) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_30_10", "nl_statement": "Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.", "nl_proof": "\\begin{proof}\n\n    Let $\\left(X_n\\right)$ be spaces having countable dense subsets $\\left(A_n\\right)$. For each $n$, fix an arbitrary $x_n \\in X_n$. Consider the subset $A$ of $X$ defined by\n\n$$\n\nA=\\bigcup\\left\\{\\prod U_n: U_n=A_n \\text { for finitely many } n \\text { and is }\\left\\{x_n\\right\\} \\text { otherwise }\\right\\} .\n\n$$\n\nThis set is countable because the set of finite subsets of $\\mathbb{N}$ is countable and each of the inner sets is countable. Now, let $x \\in X$ and $V=\\prod V_n$ be a basis element containing $x$ such that each $V_n$ is open in $X_n$ and $V_n=X_n$ for all but finitely many $n$. For each $n$, if $V_n \\neq X_n$, choose a $y_n \\in\\left(A_n \\cap V_n\\right)$ (such a $y_n$ exists since $A_n$ is dense in $\\left.X_n\\right)$. Otherwise, let $y_n=x_n$. Then $\\left(y_n\\right) \\in(A \\cap V)$, proving that $A$ is dense in $X$.\n\n\\end{proof}", "formal_statement": "theorem exercise_30_10\n  {X : \u2115 \u2192 Type*} [\u2200 i, topological_space (X i)]\n  (h : \u2200 i, \u2203 (s : set (X i)), countable s \u2227 dense s) :\n  \u2203 (s : set (\u03a0 i, X i)), countable s \u2227 dense s :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " countable_dense_subset_of_countable_product_of_countable_dense_subsets\n  {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, topological_space (X i)]\n  [\u2200 i, topological_space.first_countable_topology (X i)]\n  [\u2200 i, topological_space.t2_space (X i)]\n  [\u2200 i, topological_space.countable_topology (X i)]\n  [\u2200 i, topological_space.separated (X i)]\n  [\u2200 i, topological_space.t2_space (X i)]\n  [\u2200 i, topological_space.countable_topology (X i)]\n  [\u2200 i, topological_space.separated (X i)]\n  [\u2200 i, topological_space.t2_space (X i)]\n  [\u2200 i, topological_space.countable_topology (X i)]\n  [\u2200 i, topological_space.separated (X i)]\n  [\u2200 i, topological_space.t2_space (X i)]\n  [\u2200 i, topological_space.countable_topology (X i)]\n  [\u2200 i, topological_space.separated (X i)]\n  [\u2200 i, topological_space.t2_space (X i)]\n  [\u2200 i, topological_space.countable_topology (X i)]\n  [\u2200 i, topological_space.separated (X i)]\n  [\u2200 i, topological_space.t2_space (X i)]\n  [\u2200 i", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem continuous_finprod {\u03b9 X M : Type*} [topological_space X]\n\t[topological_space M] [comm_monoid M] [has_continuous_mul M] {f : \u03b9 \u2192 X \u2192 M}\n\t(hc : \u2200 (i : \u03b9), continuous (f i))\n\t(hf : locally_finite (\u03bb (i : \u03b9), function.mul_support (f i))) :\n\tcontinuous (\u03bb (x : X), finprod (\u03bb (i : \u03b9), f i x))\n\ntheorem continuous_finset_prod {\u03b9 X M : Type*} [topological_space X]\n\t[topological_space M] [comm_monoid M] [has_continuous_mul M] {f : \u03b9 \u2192 X \u2192 M}\n\t(s : finset \u03b9) :\n\t(\u2200 (i : \u03b9), i \u2208 s \u2192 continuous (f i)) \u2192 continuous (\u03bb (a : X), s.prod (\u03bb (i : \u03b9), f i a))\n\ndef topological_space.prod.first_countable_topology {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {\u03b2 : Type*} [topological_space \u03b2]\n\t[topological_space.first_countable_topology \u03b1]\n\t[topological_space.first_countable_topology \u03b2] :\n\ttopological_space.first_countable_topology (\u03b1 \u00d7 \u03b2)\n\ntheorem continuous_on_finset_prod {\u03b9 X M : Type*} [topological_space X]\n\t[topological_space M] [comm_monoid M] [has_continuous_mul M] {f : \u03b9 \u2192 X \u2192 M}\n\t(s : finset \u03b9) {t : set X} :\n\t(\u2200 (i : \u03b9), i \u2208 s \u2192 continuous_on (f i) t) \u2192 continuous_on (\u03bb (a : X), s.prod (\u03bb (i : \u03b9), f i a)) t\n\nThe following is the natural language theorem statement: \"Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " countable_dense_of_countable_dense_prod {\u03b9 : Type*} {X : \u03b9 \u2192 Type*}\n  [\u2200 i, topological_space (X i)] [\u2200 i, countable_topology (X i)]\n  [\u2200 i, dense_subset (X i)] :\n  dense_subset (prod_topology X) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_31_1", "nl_statement": "Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint.", "nl_proof": "\\begin{proof}\n\n    Let $x, y \\in X$ be two points such that $x \\neq y$. Since $X$ is regular (and thus Hausdorff), there exist disjoint open sets $U, V \\subseteq X$ such that $x \\in U$ and $y \\in V$.\n\nNote that $y \\notin \\bar{U}$. Otherwise $V$ must intersect $U$ in a point different from $y$ since $V$ is an open neighborhood of $y$, which is a contradiction since $U$ and $V$ are disjoint.\n\nSince $X$ is regular and $\\bar{U}$ is closed, there exist disjoint open sets $U^{\\prime}, V^{\\prime} \\subseteq X$ such that $\\bar{U} \\subseteq U^{\\prime}$ and $y \\in V^{\\prime}$.\n\n\n\nAnd now $U$ and $V^{\\prime}$ are neighborhoods of $x$ and $y$ whose closures are disjoint. If $\\bar{U} \\cap \\overline{V^{\\prime}} \\neq \\emptyset$, then it follows that $U^{\\prime} \\supseteq U$ intersects $\\overline{V^{\\prime}}$. Since $U^{\\prime}$ is open, it follows that $U^{\\prime}$ intersects $V^{\\prime}$, which is a contradiction.\n\n\\end{proof}", "formal_statement": "theorem exercise_31_1 {X : Type*} [topological_space X]\n  (hX : regular_space X) (x y : X) :\n  \u2203 (U V : set X), is_open U \u2227 is_open V \u2227 x \u2208 U \u2227 y \u2208 V \u2227 closure U \u2229 closure V = \u2205 :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " exists_nhds_disjoint_closure {\u03b1 : Type u} [topological_space \u03b1]\n  [regular_space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n  \u2203 (s : set \u03b1) (H : s \u2208 nhds x) (t : set \u03b1) (H : t \u2208 nhds y), disjoint (closure s) (closure t) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem exists_open_nhds_disjoint_closure {\u03b1 : Type u} [topological_space \u03b1]\n\t[t2_5_space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n\t\u2203 (u : set \u03b1), x \u2208 u \u2227 is_open u \u2227 \u2203 (v : set \u03b1), y \u2208 v \u2227 is_open v \u2227 disjoint (closure u) (closure v)\n\ntheorem exists_nhds_disjoint_closure {\u03b1 : Type u} [topological_space \u03b1]\n\t[t2_5_space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n\t\u2203 (s : set \u03b1) (H : s \u2208 nhds x) (t : set \u03b1) (H : t \u2208 nhds y), disjoint (closure s) (closure t)\n\ntheorem exists_clopen_of_totally_separated {\u03b1 : Type*} [topological_space \u03b1]\n\t[totally_separated_space \u03b1] {x y : \u03b1} (hxy : x \u2260 y) :\n\t\u2203 (U : set \u03b1) (hU : is_clopen U), x \u2208 U \u2227 y \u2208 U\u1d9c\n\ntheorem disjoint_pure_nhds {\u03b1 : Type u} [topological_space \u03b1] [t1_space \u03b1]\n\t{x y : \u03b1} (h : x \u2260 y) :\n\tdisjoint (has_pure.pure x) (nhds y)\n\nThe following is the natural language theorem statement: \"Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " regular_of_disjoint_closure_of_neighborhoods {X : Type*} [topological_space X]\n  (hX : regular_space X) (x y : X) :\n  \u2203 (U V : set X), is_open U \u2227 is_open V \u2227 x \u2208 U \u2227 y \u2208 V \u2227 closure U \u2229 closure V = \u2205 ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_31_3", "nl_statement": "Show that every order topology is regular.", "nl_proof": "\\begin{proof}\n\n    Let $X$ be an ordered set.\n\nFirst we show that $X$ is a $T_1$-space. For $x \\in X$ we have that\n\n$$\n\nX \\backslash\\{x\\}=\\langle-\\infty, x\\rangle \\cup\\langle x,+\\infty\\rangle\n\n$$\n\nwhich is an open set as an union of two open intervals. Therefore, the set $\\{x\\}$ is closed.\n\nStep 2\n\n2 of 3\n\nNow to prove that $X$ is regular we use Lemma $\\mathbf{3 1 . 1 .}$\n\nLet $x \\in X$ be any point and $U \\subseteq X$ any open neighborhood of $x$. Then there exist $a, b \\in X$ such that $x \\in\\langle a, b\\rangle \\subseteq U$. Now we have four possibilities.\n\n1. If there exist $x_1, x_2 \\in U$ such that $a<x_1<x<x_2<b$, then\n\n$$\n\nx \\in\\left\\langle x_1, x_2\\right\\rangle \\subseteq \\overline{\\left\\langle x_1, x_2\\right\\rangle} \\subseteq\\left[x_1, x_2\\right] \\subseteq\\langle a, b\\rangle \\subseteq U\n\n$$\n\n2. If there exists $x_1 \\in U$ such that $a<x_1<x$, but there's no $x_2 \\in U$ such that $x<x_2<b$, then\n\n$$\n\nx \\in\\left\\langle x_1, b\\right\\rangle=\\left(x_1, x\\right] \\subseteq \\overline{\\left(x_1, x\\right]} \\subseteq\\left[x_1, x\\right] \\subseteq\\langle a, b\\rangle \\subseteq U\n\n$$\n\n3. If there exists $x_2 \\in U$ such that $x<x_2<b$, but there's no $x_1 \\in U$ such that $a<x_1<x$, then\n\n$$\n\nx \\in\\left\\langle a, x_2\\right\\rangle=\\left[x, x_2\\right) \\subseteq \\overline{\\left[x, x_2\\right)} \\subseteq\\left[x, x_2\\right] \\subseteq\\langle a, b\\rangle \\subseteq U\n\n$$\n\n4. If there's no $x_1 \\in U$ such that $a<x_1<x$ and no $x_2 \\in U$ such that $x<x_2<b$, then\n\n$$\n\nx \\in\\langle a, b\\rangle=\\{x\\}=\\overline{\\{x\\}}=\\{x\\} \\subseteq U\n\n$$\n\nWe have that $\\overline{\\{x\\}}=\\{x\\}$ because $X$ is a $T_1$-space.\n\nIn all four cases we proved that there exists an open interval $V$ such that $x \\in V \\subseteq \\bar{V} \\subseteq U$, so $X$ is regular.\n\n\\end{proof}", "formal_statement": "theorem exercise_31_3 {\u03b1 : Type*} [partial_order \u03b1]\n  [topological_space \u03b1] (h : order_topology \u03b1) : regular_space \u03b1 :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " regular_of_order_topology {\u03b1 : Type u} [topological_space \u03b1]\n  [linear_order \u03b1] [order_topology \u03b1] : regular_space \u03b1 ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem continuous_of_dual {\u03b1 : Type u} [topological_space \u03b1] :\n\tcontinuous \u21d1order_dual.of_dual\n\ndef order_topology.to_order_closed_topology {\u03b1 : Type u} [topological_space \u03b1]\n\t[linear_order \u03b1] [order_topology \u03b1] :\n\torder_closed_topology \u03b1\n\nstructure topological_space (\u03b1 : Type u) :\n\tType u\n\ntheorem continuous_to_dual {\u03b1 : Type u} [topological_space \u03b1] :\n\tcontinuous \u21d1order_dual.to_dual\n\nThe following is the natural language theorem statement: \"Show that every order topology is regular.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " regular_of_order_topology {\u03b1 : Type*} [linear_order \u03b1] :\n  regular_space (order_topology \u03b1) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that every order topology is regular.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_32_2a", "nl_statement": "Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.", "nl_proof": "\\begin{proof}\n\n    Suppose that $X=\\prod_\\beta X_\\beta$ is Hausdorff and let $\\alpha$ be any index.\n\nLet $x, y \\in X_\\alpha$ be any points such that $x \\neq y$. Since all $X_\\beta$ are nonempty, there exist points $\\mathbf{x}, \\mathbf{y} \\in X$ such that $x_\\beta=y_\\beta$ for every $\\beta \\neq \\alpha$ and $x_\\alpha=x, y_\\alpha=y$.\n\nSince $x \\neq y$, it follows that $\\mathbf{x} \\neq \\mathbf{y}$. Since $X$ is Hausdorff, there exist open disjoint sets $U, V \\subseteq X$ such that $\\mathbf{x} \\in U$ and $\\mathbf{y} \\in V$.\n\nFor $\\beta \\neq \\alpha$ we have that $x_\\beta=y_\\beta \\in \\pi_\\beta(U) \\cap \\pi_\\beta(V)$, hence $\\pi_\\beta(U)$ and $\\pi_\\beta(V)$ are not disjoint.\n\nSince $U$ and $V$ are disjoint, it follows that $\\pi_\\alpha(U) \\cap \\pi_\\alpha(V)=\\emptyset$.\n\nWe also have that $x \\in \\pi_\\alpha(U)$ and $y \\in \\pi_\\alpha(V)$ and since the projections are open maps, it follows that the sets $\\pi_\\alpha(U)$ and $\\pi_\\alpha(V)$ are open.\n\nThis proves that $x$ and $y$ can be separated by open sets, so $X_\\alpha$ is Hausdorff.\n\n\\end{proof}", "formal_statement": "theorem exercise_32_2a\n  {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, topological_space (X i)]\n  (h : \u2200 i, nonempty (X i)) (h2 : t2_space (\u03a0 i, X i)) :\n  \u2200 i, t2_space (X i) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_Hausdorff_of_prod_is_Hausdorff {\u03b1 : Type*} {X : \u03b1 \u2192 Type*}\n  [\u2200 a, nonempty (X a)] [\u2200 a, topological_space (X a)]\n  (h : is_Hausdorff (prod.topological_space X)) :\n  \u2200 a, is_Hausdorff (X a) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ndef Hausdorffification.is_Hausdorff {R : Type*} [comm_ring R] (I : ideal R)\n\t(M : Type*) [add_comm_group M] [module R M] :\n\tis_Hausdorff I (Hausdorffification I M)\n\ndef is_Hausdorff.of_subsingleton {R : Type*} [comm_ring R] (I : ideal R)\n\t(M : Type*) [add_comm_group M] [module R M] [subsingleton M] :\n\tis_Hausdorff I M\n\ndef adic_completion.is_Hausdorff {R : Type*} [comm_ring R] (I : ideal R)\n\t(M : Type*) [add_comm_group M] [module R M] :\n\tis_Hausdorff I \u21a5(adic_completion I M)\n\ntheorem dimH_of_hausdorff_measure_ne_zero_ne_top {X : Type*} [emetric_space X]\n\t[measurable_space X] [borel_space X] {d : nnreal} {s : set X}\n\t(h : \u21d1(measure_theory.measure.hausdorff_measure \u2191d) s \u2260 0)\n\t(h' : \u21d1(measure_theory.measure.hausdorff_measure \u2191d) s \u2260 \u22a4) :\n\tdimH s = \u2191d\n\nThe following is the natural language theorem statement: \"Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " hausdorff_of_prod_hausdorff {\u03b9 : Type*} {X : \u03b9 \u2192 Type*}\n  [\u2200 i, nonempty (X i)] [\u2200 i, topological_space (X i)]\n  (h : hausdorff_space (\u03a0 i, X i)) :\n  \u2200 i, hausdorff_space (X i) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_32_2c", "nl_statement": "Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.", "nl_proof": "\\begin{proof}\n\n    Suppose that $X=\\prod_\\beta X_\\beta$ is normal and let $\\alpha$ be any index.\n\nSince $X$ is normal, it follows that $X$ is Hausdorff (or regular), which then implies that $X_\\alpha$ is Hausdorff (or regular). This imples that $X_\\alpha$ satisfies the $T_1$ axiom.\n\nNow the proof that $X_\\alpha$ satisfies the $T_4$ axiom is the same as for regular spaces.\n\nIf $F, G \\subseteq X_\\alpha$ are disjoint closed sets, then $\\prod_\\beta F_\\beta$ and $\\prod_\\beta G_\\beta$, where $F_\\alpha=F, G_\\alpha=G$ and $F_\\beta=G_\\beta=X_\\beta$ for $\\beta \\neq \\alpha$, are disjoint closed sets in $X$.\n\nSince $X$ is normal (and therefore satisfies the $T_4$ axiom), there exist disjoint open sets $U, V \\subseteq X$ such that $\\prod_\\beta F_\\beta \\subseteq U$ and $\\prod_\\beta G_\\beta \\subseteq V$\n\nThen $\\pi_\\alpha(U)$ and $\\pi_\\alpha(V)$ are disjoint open sets in $X_\\alpha$ such that $F \\subseteq \\pi_\\alpha(U)$ and $G \\subseteq \\pi_\\alpha(V)$.\n\n\\end{proof}", "formal_statement": "theorem exercise_32_2c\n  {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, topological_space (X i)]\n  (h : \u2200 i, nonempty (X i)) (h2 : normal_space (\u03a0 i, X i)) :\n  \u2200 i, normal_space (X i) :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " normal_space_of_prod_normal_space {\u03b1 : Type u} {X : \u03b1 \u2192 Type*}\n  [topological_space X] [normal_space (\u03a0 a, X a)] (h : \u2200 a, nonempty (X a)) :\n  \u2200 a, normal_space (X a) ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem homeomorph.normal_space {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [normal_space \u03b1] (h : \u03b1 \u2243\u209c \u03b2) :\n\tnormal_space \u03b2\n\ntheorem topological_space.is_topological_basis.prod {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {\u03b2 : Type*} [topological_space \u03b2] {B\u2081 : set (set \u03b1)}\n\t{B\u2082 : set (set \u03b2)} (h\u2081 : topological_space.is_topological_basis B\u2081)\n\t(h\u2082 : topological_space.is_topological_basis B\u2082) :\n\ttopological_space.is_topological_basis (set.image2 set.prod B\u2081 B\u2082)\n\ntheorem uniform_continuous.prod_mk_right {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] [uniform_space \u03b3] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (h : uniform_continuous f)\n\t(a : \u03b1) :\n\tuniform_continuous (\u03bb (b : \u03b2), f (a, b))\n\ntheorem local_homeomorph.prod_eq_prod_of_nonempty' {\u03b1 \u03b2 \u03b3 \u03b4 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] [topological_space \u03b3]\n\t[topological_space \u03b4] {e\u2081 e\u2081' : local_homeomorph \u03b1 \u03b2}\n\t{e\u2082 e\u2082' : local_homeomorph \u03b3 \u03b4}\n\t(h : (e\u2081'.prod e\u2082').to_local_equiv.source.nonempty) :\n\te\u2081.prod e\u2082 = e\u2081'.prod e\u2082' \u2194 e\u2081 = e\u2081' \u2227 e\u2082 = e\u2082'\n\nThe following is the natural language theorem statement: \"Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " normal_of_prod_normal {\u03b1 : Type*} {X : \u03b1 \u2192 Type*} [\u2200 a, topological_space (X a)]\n  [\u2200 a, nonempty (X a)] [\u2200 a, normal_space (X a)]\n  (h : normal_space (prod_topology X)) :\n  \u2200 a, normal_space (X a) ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_33_7", "nl_statement": "Show that every locally compact Hausdorff space is completely regular.", "nl_proof": "\\begin{proof}\n\n    $X$ is a subspace of a compact Hausdorff space $Y$, its one-point compactification. $Y$ is normal, and so by the Urysohn lemma $Y$ is completely regular. Therefore by corollary $X$ is completely regular.\n\n\\end{proof}", "formal_statement": "theorem exercise_33_7 {X : Type*} [topological_space X]\n  (hX : locally_compact_space X) (hX' : t2_space X) :\n  \u2200 x A, is_closed A \u2227 \u00ac x \u2208 A \u2192\n  \u2203 (f : X \u2192 I), continuous f \u2227 f x = 1 \u2227 f '' A = {0}\n  :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " t2_space.is_completely_regular {X : Type*} [topological_space X]\n  [locally_compact_space X] [t2_space X] :\n  is_completely_regular X ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem Gromov_Hausdorff.to_GH_space_continuous {X : Type u} [metric_space X] :\n\tcontinuous topological_space.nonempty_compacts.to_GH_space\n\ndef alexandroff.normal_space {X : Type*} [topological_space X]\n\t[locally_compact_space X] [t2_space X] :\n\tnormal_space (alexandroff X)\n\ntheorem Gromov_Hausdorff.to_GH_space_lipschitz {X : Type u} [metric_space X] :\n\tlipschitz_with 1 topological_space.nonempty_compacts.to_GH_space\n\ndef CompHaus.compact_space {X : CompHaus} :\n\tcompact_space \u21a5X\n\nThe following is the natural language theorem statement: \"Show that every locally compact Hausdorff space is completely regular.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " completely_regular_of_locally_compact_hausdorff {X : Type*} \n  [topological_space X] [locally_compact_space X] [hausdorff_space X] :\n  completely_regular_space X ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Show that every locally compact Hausdorff space is completely regular.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_34_9", "nl_statement": "Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable.", "nl_proof": "\\begin{proof}\n\n    Both $X_1$ and $X_2$ are compact, Hausdorff and metrizable, so by exercise 3 they are second countable, i.e. there are countable bases $\\left\\{U_{i, n} \\subset X_i \\mid n \\in \\mathbb{N}\\right\\}$ for $i \\in\\{1,2\\}$. By the same exercise it is enough to show that $X$ is second countable. If $X_1 \\cap X_2=\\emptyset$ both $X_1$ and $X_2$ are open and the union $\\left\\{U_{i, n} \\mid i \\in\\{1,2\\} ; n \\in \\mathbb{N}\\right\\}$ of their countable bases form a countable base for $X$.\n\n\n\nSuppose now $X_1 \\cap X_2 \\neq \\emptyset$. Let $x \\in X$ and $U \\subset X$ be an open neighborhood of $x$. If $x \\in X_i-X_j=X-$ $X_j$ then $U \\cap X_i$ is open in $X_i$ and there is a basis neighborhood $U_{i, n}$ of $x$ such that $x \\in U_{i, n} \\cap X-X_j$ is an open neighborhood of $x$ in the open subset $X-X_j$, so $U_{i, n} \\cap X-X_j$ is also open in $X$.\n\nSuppose now that $x \\in X_1 \\cap X_2$. We have that $U \\cap X_i$ is open in $X_i$ so there is a basis neighborhood $U_{i, n_i}$ contained in $U \\cap X_i$. By definition of sub-space topology there is some open subset $V_{i, n_i} \\subset X$ such that $U_{i, n_i}=$ $X_i \\cap V_{i, n_i}$. Then\n\n$$\n\nx \\in V_{1, n_1} \\cap V_{2, n_2}=\\left(V_{1, n_1} \\cap V_{2, n_2} \\cap X_1\\right) \\cup\\left(V_{1, n_1} \\cap V_{2, n_2} \\cap X_2\\right)=\\left(U_{1, n_1} \\cap V_{2, n_2}\\right) \\cup\\left(V_{1, n_1} \\cap U_{2, n_2}\\right) \\subset U\n\n$$\n\nTherefore the open subsets $U_{i, n} \\cap X-X_j$ and $V_{1, n_1} \\cap V_{2, n_2}$ form a countable base for $X$.\n\n\\end{proof}", "formal_statement": "theorem exercise_34_9\n  (X : Type*) [topological_space X] [compact_space X]\n  (X1 X2 : set X) (hX1 : is_closed X1) (hX2 : is_closed X2)\n  (hX : X1 \u222a X2 = univ) (hX1m : metrizable_space X1)\n  (hX2m : metrizable_space X2) : metrizable_space X :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " is_metrizable_of_union_of_closed_metrizable {X : Type*}\n  [topological_space X] [compact_space X] [t2_space X]\n  {X\u2081 X\u2082 : set X} (hX\u2081 : is_closed X\u2081) (hX\u2082 : is_closed X\u2082)\n  (hX\u2081m : is_metrizable X\u2081) (hX\u2082m : is_metrizable X\u2082)\n  (hX : X = X\u2081 \u222a X\u2082) : is_metrizable X ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem is_metric_separated.union_right {X : Type*} [emetric_space X]\n\t{s t t' : set X} (h : is_metric_separated s t) (h' : is_metric_separated s t') :\n\tis_metric_separated s (t \u222a t')\n\ntheorem is_metric_separated.union_left {X : Type*} [emetric_space X]\n\t{s t s' : set X} (h : is_metric_separated s t) (h' : is_metric_separated s' t) :\n\tis_metric_separated (s \u222a s') t\n\ntheorem is_compact.union {\u03b1 : Type u} [topological_space \u03b1] {s t : set \u03b1}\n\t(hs : is_compact s) (ht : is_compact t) :\n\tis_compact (s \u222a t)\n\ntheorem alexandroff.infty_mem_opens_of_compl {X : Type*} [topological_space X]\n\t{s : set X} (h\u2081 : is_closed s) (h\u2082 : is_compact s) :\n\talexandroff.infty \u2208 alexandroff.opens_of_compl s h\u2081 h\u2082\n\nThe following is the natural language theorem statement: \"Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " metrizable_of_compact_union_of_metrizable_closed_subspaces\n  {X : Type*} [topological_space X] [compact_space X] [t2_space X]\n  {X\u2081 X\u2082 : set X} (hX\u2081 : is_closed X\u2081) (hX\u2082 : is_closed X\u2082)\n  (hX\u2081m : metrizable_space X\u2081) (hX\u2082m : metrizable_space X\u2082)\n  (hX\u2081X\u2082 : X\u2081 \u222a X\u2082 = univ) : metrizable_space X ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
{"id": "Munkres|exercise_43_2", "nl_statement": "Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous.", "nl_proof": "\\begin{proof}\n\n    Let $\\left(X, d_X\\right)$ and $\\left(Y, d_Y\\right)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. It is also given that $f: A \\longrightarrow X$ is a uniformly continuous function. Then we have to show that $f$ can be uniquely extended to a continuous function $g: \\bar{A} \\longrightarrow Y$, and $g$ is uniformly coninuous.\n\nWe define the function $g$ as follows:\n\n$$\n\ng(x)= \\begin{cases}f(x) & \\text { if } x \\in A \\\\ \\lim _{n \\rightarrow \\infty} f\\left(x_n\\right) & \\text { if } x \\in \\bar{A},\\end{cases}\n\n$$\n\nwhere $\\left\\{x_n\\right\\} \\subset A$ is some sequence in $A$ such that $\\lim _{n \\rightarrow \\infty} x_n=x$. Now we have to check that the above definition is well defined. We first note that since $\\left\\{x_n\\right\\} \\subset A$ is convergent in $X,\\left\\{x_n\\right\\}$ is Cauchy in $A$ and since $f$ is uniformly continuous on $A,\\left\\{f\\left(x_n\\right)\\right\\}$ is Cauchy in $Y$. Further, since $Y$ is complete $\\left\\{f\\left(x_n\\right)\\right\\}$ is convergent. So let us now consider two sequences $\\left\\{x_n\\right\\}$ and $\\left\\{y_n\\right\\}$ such that $\\lim _{n \\rightarrow \\infty} x_n=\\lim _{n \\rightarrow \\infty} y_n=x$. Then we need to prove that $\\lim _{n \\rightarrow \\infty} f\\left(x_n\\right)=\\lim _{n \\rightarrow \\infty} f\\left(y_n\\right)=f(x)$. Let\n\n$$\n\n\\lim _{n \\rightarrow \\infty} f\\left(x_n\\right)=a \\text { and } b=\\lim _{n \\rightarrow \\infty} f\\left(y_n\\right)\n\n$$\n\nNow since $f$ is uniformly continuous for any given $\\epsilon>0$ there exists $\\delta>0$ such that\n\n$$\n\nd_Y(f(x), f(y))<\\epsilon \\text { whenever } d_X(x, y)<\\delta \\text { and } x, y \\in A\n\n$$\n\nSo for this $\\delta>0$ there exists $N \\in \\mathbb{N}$ such that\n\n$$\n\nd_X\\left(x_n, x\\right)<\\frac{\\delta}{2} \\text { and } d_X\\left(y_n, x\\right)<\\frac{\\delta}{2}, \\text { foe all } n \\geq N .\n\n$$\n\nTherefore, we have that for all $n \\geq N$,\n\n$$\n\nd_X\\left(x_n, y_n\\right)<\\delta\n\n$$\n\nThus the equation (1) yields us that\n\n$$\n\nd_Y\\left(f\\left(x_n\\right), f\\left(y_n\\right)\\right)<\\epsilon \\text { for all } n \\geq N .\n\n$$\n\nNow since $\\lim _{n \\rightarrow \\infty} f\\left(x_n\\right)=a$ and $b=\\lim _{n \\rightarrow \\infty} f\\left(y_n\\right)$, so for the above $\\epsilon>0$ we have a natural number $K \\geq N$ such that\n\n$$\n\n\\begin{gathered}\n\nd_Y\\left(f\\left(x_n\\right), a\\right)<\\epsilon \\text { for all } n \\geq K \\text { and } \\\\\n\nd_Y\\left(f\\left(y_n\\right), b\\right)<\\epsilon \\text { for all } n \\geq K .\n\n\\end{gathered}\n\n$$\n\nMoreover, since $K \\geq N$, from $(2)$ we get\n\n$$\n\nd_Y\\left(f\\left(x_n\\right), f\\left(y_n\\right)\\right)<\\epsilon \\text { for all } n \\geq K .\n\n$$\n\nNow we calculate the following, for $n \\geq K$,\n\n$$\n\n\\begin{array}{rlr}\n\nd_Y(a, b) & \\leq & d_Y\\left(a, f\\left(x_n\\right)\\right)+d_Y\\left(f\\left(x_n\\right), f\\left(y_n\\right)\\right)+d\\left(f\\left(y_n\\right), b\\right) \\\\\n\n& < & \\epsilon+\\epsilon+\\epsilon \\text { by }(3),(4) \\text { and }(5) \\\\\n\n& = & 3 \\epsilon\n\n\\end{array}\n\n$$\n\nwhere the first inequality holds because of triangular inequality. Since $\\epsilon>0$ is arbitrary the above calculation shows that $d_Y(a, b)=0$. Thus, the above definition is independent of the choice of the sequence $\\left\\{x_n\\right\\}$ and hence the map $g$ is well defined. Moreover, from the construction it follows that $g$ is continuous on $\\bar{A}$.\n\nMoreover, we observe that $g$ is unique extension of $f$ by the construction.\n\nSo it remains to show that $g$ is uniformly continuous. In order to that we take a Cauchy sequence $\\left\\{a_n\\right\\} \\subset \\bar{A}$. Then since $\\bar{A}$ is a closed set so the sequence $\\left\\{a_n\\right\\}$ is convergent and hence $\\left\\{g\\left(a_n\\right)\\right\\}$ is also a convergent sequence as $g$ is continuous on $\\bar{A}$. So $\\left\\{g\\left(a_n\\right)\\right\\}$ is a Cauchy sequence in $Y$. Since a function is uniformly continuous if and only if it sends Cauchy sequences to Cauchy sequences, we conclude that $g$ is uniformly continuous.\n\n\\end{proof}", "formal_statement": "theorem exercise_43_2 {X : Type*} [metric_space X]\n  {Y : Type*} [metric_space Y] [complete_space Y] (A : set X)\n  (f : X \u2192 Y) (hf : uniform_continuous_on f A) :\n  \u2203! (g : X \u2192 Y), continuous_on g (closure A) \u2227\n  uniform_continuous_on g (closure A) \u2227 \u2200 (x : A), g x = f x :=", "src_header": "import .common \n\nopen set topological_space filter \nopen_locale classical topology filter \nnoncomputable theory \n\n", "gpt_formal_statement": " uniform_continuous_extend_from_uniform_continuous {X Y : Type*}\n  [metric_space X] [metric_space Y] (hY : complete_space Y)\n  (A : set X) (f : A \u2192 Y) (hf : uniform_continuous f) :\n  \u2203 (g : closure A \u2192 Y), uniform_continuous g \u2227\n  \u2200 (x : closure A), g x = extend_from A f x ", "prompt": "You are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem nat.arithmetic_function.is_multiplicative.pmul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f.pmul g).is_multiplicative \n    \ntheorem nat.arithmetic_function.is_multiplicative.mul {R : Type*}\n    [comm_semiring R] {f g : nat.arithmetic_function R} (hf : f.is_multiplicative)\n    (hg : g.is_multiplicative) :\n    (f * g).is_multiplicative \n\ntheorem finprod_mul_distrib {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n    (hf : (function.mul_support f).finite) (hg : (function.mul_support g).finite) :\n    finprod (\u03bb (i : \u03b1), f i * g i) = finprod (\u03bb (i : \u03b1), f i) * finprod (\u03bb (i : \u03b1), g i)\n\ntheorem monoid_hom.ext_mnat {M : Type u} [monoid M]\n    \u2983f g : multiplicative \u2115 \u2192* M\u2984\n    (h : \u21d1f (\u21d1multiplicative.of_add 1) = \u21d1g (\u21d1multiplicative.of_add 1)) :\n    f = g \n\nThe following is the natural language theorem statement: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem is_p_group.exists_le_sylow {p : \u2115} {G : Type*} [group G]\n\t{P : subgroup G} (hP : is_p_group p \u21a5P) :\n\t\u2203 (Q : sylow p G), P \u2264 \u2191Q \n\ntheorem sylow.exists_comap_subtype_eq {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (P : sylow p \u21a5H) :\n\t\u2203 (Q : sylow p G), subgroup.comap H.subtype \u2191Q = \u2191P \n\ntheorem sylow.exists_comap_eq_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : Type*} [group H] (P : sylow p H) {f : H \u2192* G} (hf : is_p_group p \u21a5(f.ker)) :\n\t\u2203 (Q : sylow p G), subgroup.comap f \u2191Q = \u2191P \n\ntheorem sylow.smul_subtype {p : \u2115} {G : Type*} [group G] {P : sylow p G}\n\t{H : subgroup G} (hP : \u2191P \u2264 H) (h : \u21a5H) :\n\th \u2022 P.subtype hP = (h \u2022 P).subtype _ \n\nThe following is the natural language theorem statement: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version:\ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly. \n\nHere are the four formal statements: \n\ntheorem uniform_continuous.comp {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1]\n    [uniform_space \u03b2] [uniform_space \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : uniform_continuous g) (hf : uniform_continuous f) :\n    uniform_continuous (g \u2218 f) \n\t\ntheorem quotient_map.continuous_lift_prod_left {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : X \u00d7 Y \u2192 Z}\n    (hg : continuous (\u03bb (p : X\u2080 \u00d7 Y), g (f p.fst, p.snd))) :\n    continuous g \n\t\ntheorem quotient_map.continuous_lift_prod_right {X\u2080 X Y Z : Type*}\n    [topological_space X\u2080] [topological_space X] [topological_space Y]\n    [topological_space Z] [locally_compact_space Y] {f : X\u2080 \u2192 X}\n    (hf : quotient_map f) {g : Y \u00d7 X \u2192 Z}\n    (hg : continuous (\u03bb (p : Y \u00d7 X\u2080), g (p.fst, f p.snd))) :\n    continuous g \n\t\ntheorem is_locally_constant.comp_continuous {X Y Z : Type*}\n    [topological_space X] [topological_space Y] {g : Y \u2192 Z} {f : X \u2192 Y}\n    (hg : is_locally_constant g) (hf : continuous f) :\n    is_locally_constant (g \u2218 f) \n\nThe following is the natural language theorem statement: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nYou are an expert Lean user. I am going to ask you to translate a natural language theorem statement into a Lean mathlib theorem statement. But first, I am going to show you four Lean formal statements from the same area of mathematics in order to refresh your memory of the mathlib API and make sure you are using it correctly.\n\nHere are the four formal statements:\n\ntheorem uniform_space.completion.ext {\u03b1 : Type*} [uniform_space \u03b1] {Y : Type*}\n\t[topological_space Y] [t2_space Y] {f g : uniform_space.completion \u03b1 \u2192 Y}\n\t(hf : continuous f) (hg : continuous g) (h : \u2200 (a : \u03b1), f \u2191a = g \u2191a) :\n\tf = g\n\ntheorem uniform_space.completion.ext' {\u03b1 : Type*} [uniform_space \u03b1] {Y : Type*}\n\t[topological_space Y] [t2_space Y] {f g : uniform_space.completion \u03b1 \u2192 Y}\n\t(hf : continuous f) (hg : continuous g) (h : \u2200 (a : \u03b1), f \u2191a = g \u2191a)\n\t(a : uniform_space.completion \u03b1) :\n\tf a = g a\n\ntheorem continuous.seq_continuous {X Y : Type*} [topological_space X]\n\t[topological_space Y] {f : X \u2192 Y} (hf : continuous f) :\n\tseq_continuous f\n\ntheorem extend_from_extends {X Y : Type*} [topological_space X]\n\t[topological_space Y] [t2_space Y] {f : X \u2192 Y} {A : set X}\n\t(hf : continuous_on f A) (x : X) (H : x \u2208 A) :\n\textend_from A f x = f x\n\nThe following is the natural language theorem statement: \"Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem", "gpt_original_formal_statement": " uniform_continuous_extend_closure {X Y : Type*} [metric_space X] \n  [metric_space Y] [complete_space Y] (A : set X) (f : A \u2192 Y) \n  (hf : uniform_continuous f) :\n  \u2203 (g : closure A \u2192 Y), continuous g \u2227 uniform_continuous g \u2227 \n  \u2200 (x : closure A), x \u2208 A \u2192 g x = f x ", "original_prompt": "Natural language version: \"Let $P$ be a $p$-subgroup of $G$. Then $P$ is contained in a Sylow $p$-subgroup of $G$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_le_sylow {p : \u2115} {G : Type*} [group G] {P : subgroup G} \n  (hP : is_p_group p P) :\n  \u2203 (Q : sylow p G), P \u2264 Q :=\n\nNatural language version: \"Let $E$ and $F$ be complex normed spaces and let $f:E\\to F$. If $f$ is differentiable and bounded, then $f$ is constant.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_eq_const_of_bounded {E : Type u} [normed_group E]\n  [normed_space \u2102 E] {F : Type v} [normed_group F] [normed_space \u2102 F]\n  {f : E \u2192 F} (hf : differentiable \u2102 f) (hb : metric.bounded (set.range f)) :\n  \u2203 (c : F), f = function.const E c :=\n\nNatural language version: \"Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x\\in A$ there is an open set $U$ containing $x$ such that $U\\subset A$. Then $A$ is open in $X$.\" Translate the natural language version to a Lean mathlib version: \ntheorem subset_of_open_subset_is_open (X : Type*) [topological_space X]\n  (A : set X) (hA : \u2200 x \u2208 A, \u2203 U : set X, is_open U \u2227 x \u2208 U \u2227 U \u2286 A): \n  is_open A :=\n\nNatural language version: \"Two multiplicative functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(p^i)=f(g^i)$ for all primes $p$.\" Translate the natural language version to a Lean mathlib version: \ntheorem is_multiplicative.eq_iff_eq_on_prime_powers {R : Type*} \n  [comm_monoid_with_zero R] (f : nat.arithmetic_function R) \n  (hf : f.is_multiplicative) (g : nat.arithmetic_function R) \n  (hg : g.is_multiplicative) :\n  f = g \u2194 \u2200 (p i : \u2115), nat.prime p \u2192 f (p ^ i) = g (p ^ i) :=\n\nNatural language version: \"If $z_1, \\\\dots, z_n$ are complex, then $|z_1 + z_2 + \\\\dots + z_n|\\\\leq |z_1| + |z_2| + \\\\dots + |z_n|$.\" Translate the natural language version to a Lean mathlib version:\ntheorem abs_sum_leq_sum_abs (n : \u2115) (f : \u2115 \u2192 \u2102) :\n  abs (\u2211 i in finset.range n, f i) \u2264 \u2211 i in finset.range n, abs (f i) :=\n\nNatural language version: \"If x and y are in $\\\\mathbb{R}^n$, then $|x+y|^2 + |x-y|^2 = 2|x|^2 + 2|y|^2$.\" Translate the natural language version to a Lean mathlib version:\ntheorem sum_add_square_sub_square_eq_sum_square (n : \u2115) (x y : euclidean_space \u211d (fin n)) :\n  \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :=\n\nNatural language version: \"If $x$ is an element of infinite order in $G$, prove that the elements $x^n$, $n\\\\in\\\\mathbb{Z}$ are all distinct.\" Translate the natural language version to a Lean mathlib version:\ntheorem distinct_powers_of_infinite_order_element (G : Type*) [group G] (x : G)\n  (hx_inf : \u2200 n : \u2115, x ^ n \u2260 1) :\n  \u2200 m n : \u2124, m \u2260 n \u2192 x ^ m \u2260 x ^ n :=\n\nNatural language version \"A set of vectors $\\{v_i\\}_{i\\in I}$ orthogonal with respect to some bilinear form $B: V\\times V\\to K$ is linearly independent if for all $i \\in I, B(v_i, v_i)\\neq 0$.\" Translate the natural language version to a Lean mathlib version:\ntheorem linear_independent_of_is_Ortho {V K : Type*} [field K] \n  [add_comm_group V] [module K V] {n : Type*} {B : bilin_form K V} \n  {v : n \u2192 V} (hv\u2081 : B.is_Ortho v) \n  (hv\u2082 : \u2200 (i : n), \u00acB.is_ortho (v i) (v i)) :\n  linear_independent K v :=\n\nNatural language version: \"Suppose that $V$ is an $n$-dimensional vector space. Then for some set of vectors $\\{v_i\\}_{i=1}^k$, if $k>n$ then there exist scalars $f_1, \\dots, f_k$ such that $\\sum_{i=1}^k f_kv_k = 0$.\" Translate the natural language version to a Lean mathlib version: \ntheorem exists_nontrivial_relation_sum_zero_of_dim_succ_lt_card {K V : Type*} \n  [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] \n  {t : finset V} (h : finite_dimensional.finrank K V + 1 < t.card) :\n  \u2203 (f : V \u2192 K), t.sum (\u03bb (e : V), f e \u2022 e) = 0 \u2227 t.sum (\u03bb (e : V), f e) = 0 \n  \u2227 \u2203 (x : V) (H : x \u2208 t), f x \u2260 0 := \n\nNatural language version: \"A group is commutative if the quotient by the center is cyclic.\" Translate the natural language version to a Lean mathlib version: \ntheorem comm_group_of_cycle_center_quotient {G H : Type*} [group G] [group H]\n  [is_cyclic H] (f : G \u2192* H) (hf : f.ker \u2264 center G) :\n  comm_group G :=\n\nNatural language version: \"If $H$ is a $p$-subgroup of $G$, then the index of $H$ inside its normalizer is congruent modulo $p$ to the index of $H$.\" Translate the natural language version to a Lean mathlib version: \ntheorem card_quotient_normalizer_modeq_card_quotient {G : Type*} [group G] \n  [fintype G] {p n : \u2115} [hp : fact (nat.prime p)] {H : subgroup G} \n  (hH : card H = p ^ n) :\n  card (H.normalizer \u29f8 subgroup.comap H.normalizer.subtype H) \u2261  card (G \u29f8 H) [MOD p] :=\n\nNatural language version: \"Suppose $X, Y, Z$ are metric spaces, and $Y$ is compact. Let $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, and put $h(x)=g(f(x))$ for $x \\in X$. Prove that $f$ is uniformly continuous if $h$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp\n  {X Y Z : Type*} [metric_space X] [metric_space Y] [metric_space Z]\n  (hY : compact_space Y) (f : X \u2192 Y) (g : Y \u2192 Z) (hgc : continuous g)\n  (hgi : function.injective g)\n  (h : uniform_continuous (g \u2218 f)) : uniform_continuous f :=\n\nNatural language version: \"Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous.\" Translate the natural language version to a Lean mathlib version:\ntheorem"}
