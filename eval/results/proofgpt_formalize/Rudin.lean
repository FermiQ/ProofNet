

complex.exists_eq_mul_of_abs_eq_one {z : ‚ÑÇ} (hz : ‚àÉ (r : ‚Ñù), 0 ‚â§ r ‚àß |w| = 1) :
	‚àÉ (w : ‚ÑÇ), z = r * w :=
sorry

complex.abs_sq_le_of_le_coe {z : ‚ÑÇ} {n : ‚Ñï} :
	z.re = ‚Üëz.re ‚Üí z.im = ‚Üë(z.im) :=
sorry

complex.abs_sub_le_abs_sub (x y : ‚ÑÇ) :
	complex.abs x - complex.abs y ‚â§ complex.abs (x - y) :=
sorry

complex.coe_im_eq_of_re_eq_one {z : ‚ÑÇ} (hz : complex.abs z = 1)
	(hz' : z.re = 1) :
	‚Üë(z.im) = 1 :=
sorry

real.of_real_fract_of_card_eq_of_infinite_of_infinite_of_card_eq_finrank
	{k : ‚Ñù} {x y : ‚Ñù} (h : 3 ‚â§ k) (hx : x ‚àà set.Icc 0 (linear_order.max k (set.Icc 0 1)))
	(hy : y ‚àà set.Icc 0 (linear_order.max k (set.Icc 0 1))))
	(hxy : |x - y| = finite_dimensional.finrank ‚Ñù ‚Ñù)
	(r : ‚Ñù) (hr : 0 < r) :
	‚àÉ·∂† (z : ‚Ñù) in nhds_within 0 (set.Ioi 0), |z - x| = r :=
sorry

algebraic_geometry.Scheme.Spec_obj_2 (R : CommRing)
	(k : ‚Ñï) (f : R ‚ü∂ algebraic_geometry.Scheme.Spec.obj (opposite.op (algebraic_geometry.Scheme.Spec_obj R k)) :
	algebraic_geometry.Scheme.Spec_obj R k f = 2 * algebraic_geometry.Scheme.Spec_obj_2 R k f + 2 * algebraic_geometry.Scheme.Spec_obj_2 R k f :=
sorry

pow_of_two_le_of_exists_mul_eq_zero {R : Type*} [comm_monoid R] {k : ‚Ñï}
	(hk : 2 ‚â§ k) (h : ‚àÉ (x : R) (H : x ‚â† 0), x * x = 0) :
	‚àÉ (x : R) (H : x ‚â† 0), x * x = 0 :=
sorry

k = 1$.<SEP>theorem nat.not_exists_mul_eq_zero {R : Type*} [comm_monoid R] {k : ‚Ñï}
	(hk : k = 1) {h : ‚àÉ (x : R) (H : x ‚â† 0), x * k = 0) :
	¬¨‚àÉ (y : R) (H : y ‚â† 0), x * k = 0 :=
sorry

quaternion_algebra.norm_sq_eq_mul_norm_sq_iff {R : Type*} [comm_ring R]
	{k : Type*} [field k] [algebra R k] (a b : quaternion_algebra R k) { : R ^ k}
	{r : R} (hr : 0 < r) :
	‚à•x - a‚à• * ‚à•x - b‚à• = r ‚Üî ‚à•x - c‚à• * ‚à•x - a‚à• = 2 * ‚à•x - c‚à• * ‚à•x - b‚à• :=
sorry

rat. irrational_add_of_ne_zero_of_irrational {r x : ‚Ñö} (hr : r ‚â† 0)
	(h : irrational r) :
	irrational (‚Üër + x) :=
sorry

irrational_rat_mul {r : ‚Ñö} {x : ‚Ñù} (hr : r ‚â† 0) (h : irrational r) :
	irrational (‚Üër * x) :=
sorry

rat.not_irrational_sq :
	¬¨irrational 2 :=
sorry

is_glb_of_le_of_nonempty {Œ± : Type u} {Œ≤ : Type v} [preorder Œ±]
	[preorder Œ≤] {E : set Œ±} (hE : E.nonempty) (hE : is_glb E E) (h : Œ± ‚â§ Œ≤) :
	is_glb E E :=
sorry

cInf_neg {Œ± : Type*} [conditionally_complete_lattice Œ±] [add_group Œ±]
	[covariant_class Œ± Œ± has_add.add has_le.le]
	[covariant_class Œ± Œ± (function.swap has_add.add) has_le.le] {a : Œ±} (ha : bdd_below a)
	{s : set Œ±} (hs : bdd_below s) :
	has_Inf.Inf s - a = -has_Sup.Sup (-s) :=
sorry

complex.of_real_clm_apply (x : ‚Ñù) :
	‚Üë(‚áëcomplex.of_real_clm x) = ‚Üëx :=
sorry

is_closed.disjoint_closed_eq {Œ± : Type u} [pseudo_metric_space Œ±]
	{s t : set Œ±} (h : is_closed s) (h' : is_closed t) (h'' : disjoint s t) :
	is_separated s t :=
sorry

emetric.is_separable_of_infinite_limits {Œ± : Type u}
	[emetric_space Œ±] [is_separable_space Œ±] {s : set Œ±} (hs : s.nonempty) :
	is_separable s :=
sorry

Gromov_Hausdorff.exists_GH_basis_is_compact (X : Type u) (Y : Type v)
	[metric_space X] [compact_space X] [nonempty X] [metric_space Y]
	[compact_space Y] [nonempty Y] :
	‚àÉ (K : topological_space.positive_compacts X), (‚àÄ (V : set X), V ‚àà K ‚Üí is_open V) ‚àß (‚àÄ (s : set X), s ‚àà K ‚Üí (s ‚à© V).nonempty) ‚àß (‚àÄ (s : set Y), s ‚àà K ‚Üí (s ‚à© V).nonempty) :=
sorry

besicovitch.satellite_config.is_internal {Œ± : Type*} [metric_space Œ±]
	{E : set Œ±} {k : ‚Ñï} (h : is_countably_generated E) (h0 : E ‚äÜ set.range k)
	(hle : E ‚äÜ finset.range k) :
	is_internal (Œª (x : ‚Ü•(E.to_finset)), ‚Üëx) :=
sorry

measure_theory.content.outer_measure_of_function_not_mem {k : ‚Ñï}
	{E : Type*} [normed_group E] [normed_space ‚Ñù E] [complete_space E]
	(P : set (E ‚ÜíL[‚Ñù] ‚Ñù)) (h : ‚àÄ (x : E), x ‚àâ P ‚Üí 0 ‚â§ ‚áë(measure_theory.content.outer_measure_of_function P) x) :
	‚áë(measure_theory.content.outer_measure_of_function (Œª (x : E), ¬¨x ‚àà P)) measure_theory.measure_space.volume = 0 :=
sorry

metric.countable_Union_nat {Œ± : Type u} [pseudo_metric_space Œ±]
	{f : ‚Ñï ‚Üí set Œ±} (hf : ‚àÄ (n : ‚Ñï), is_closed (f n)) (h'f : ‚àÄ (n : ‚Ñï), metric.bounded (f n)) :
	countable (‚ãÉ (n : ‚Ñï), f n) :=
sorry

real.disj_union_open_eq_Union_disjoint_segment {s : set ‚Ñù}
	(hs : ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí ‚àÄ (y : ‚Ñù), y ‚àà s ‚Üí x ‚â§ y) :
	s ‚à™ {0} = ‚ãÉ (l : list ‚Ñù) (H : l ‚àà s), l.disjoint_segment :=
sorry

real.of_cauchy_mul_of_cauchy_mul_cauchy {a b : ‚Ñù} :
	(a * b).cauchy = a.cauchy * b.cauchy :=
sorry

pi.Ico_def {Œπ œÄ : Œπ ‚Üí Type*} [decidable_eq Œπ]
	[Œ† (i : Œπ), linear_order (œÄ i)] [Œ† (i : Œπ), has_zero (œÄ i)]
	[‚àÄ (i : Œπ), order_top (œÄ i)] {s : Œ† (i : Œπ), set (œÄ i)} :
	s = Œª (i : Œπ), set.Ico (s i) (s i) :=
sorry

cauchy_seq.tendsto_nhds_within_range_of_tendsto_cofinite_top
	{Œ± : Type u} {Œ≤ : Type v} [pseudo_metric_space Œ±] [nonempty Œ≤] [semilattice_sup Œ≤]
	{p : Œ≤ ‚Üí Prop} (hp : cauchy_seq p) :
	filter.tendsto (Œª (n : Œ≤), (nhds_within p (set.range p)).ne_bot) filter.at_top (nhds p) :=
sorry

is_closed.Inter_eq_singleton_of_bounded_of_tendsto_zero {Œ± : Type*}
	[metric_space Œ±] {E : ‚Ñï ‚Üí set Œ±} (hE : ‚àÄ (n : ‚Ñï), is_closed (E n))
	(h : ‚àÄ (n : ‚Ñï), metric.bounded (E n)) (h0 : filter.tendsto 0 (nhds 0))
	(hle : filter.is_bounded_under has_le.le filter.at_top (Œª (n : ‚Ñï), E n)) :
	(‚ãÇ (n : ‚Ñï), E n) = {n} :=
sorry

is_complete.dense_Inter_ne_bot {Œ± : Type*} [topological_space Œ±]
	[nonempty_complete_space Œ±] {G : ‚Ñï ‚Üí set Œ±} (hG : ‚àÄ (n : ‚Ñï), is_open (G n))
	(hne : ‚àÄ (n : ‚Ñï), (G n).nonempty) :
	dense (‚ãÇ (n : ‚Ñï), G n) :=
sorry

real.sqrt_aux_1 (n : ‚Ñï) :
	real.sqrt_aux n 1 0 = 1 / 2 :=
sorry

real.of_sqrt_two_add_series_step_of_sqrt_two_add_series_aux
	(s : ‚Ñù) (n : ‚Ñï) (h‚ÇÅ : s 1 = real.sqrt 2) (h‚ÇÇ : s n = real.sqrt (2 + real.sqrt (n + 1)))
	(h‚ÇÉ : s (n + 1) = real.sqrt (2 + real.sqrt (n + 1))) :
	‚àÉ (a : ‚Ñù), filter.tendsto (Œª (n : ‚Ñï), s (n + 1)) filter.at_top (nhds a) :=
sorry

ennreal.not_top_limsup_le_limsup_add {a b : ennreal} :
	¬¨‚ä§.limsup (Œª (n : ‚Ñï), a.nth n + b.nth n) ‚â§ a.limsup b + b.limsup a :=
sorry

real.of_sqrt_aux_succ (r : ‚Ñù) (h : 0 ‚â§ r) {n : ‚Ñï} :
	r = real.sqrt_aux r n + real.sqrt_aux r n - real.sqrt n :=
sorry

real.sqrt_aux_nonneg (n : ‚Ñï) :
	0 ‚â§ real.sqrt_aux n :=
sorry

summable_of_sigma_of_bdd_of_summable_of_abv {n : ‚Ñï} {b : fin n ‚Üí ‚Ñï} :
	summable (Œª (a : Œ£ (n : fin n), fin n), b a.fst) ‚Üí summable b :=
sorry

cauchy_seq_of_is_complete {Œ± : Type u} {Œ≤ : Type v} [uniform_space Œ±]
	[semilattice_sup Œ≤] [nonempty Œ≤] [is_complete Œ≤] {f : Œ± ‚Üí Œ≤} :
	cauchy_seq f :=
sorry

uniform_continuous.uniform_continuous {Œ± Œ≤ : Type*} [uniform_space Œ±]
	[uniform_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : uniform_continuous f) :
	uniform_continuous f :=
sorry

continuous_map.coe_of_Icc_of_forall_mem_Icc_apply {Œ± : Type*}
	[topological_space Œ±] {I : set Œ±} (hI : I ‚àà nhds 1) (f : C(‚Ü•I, Œ±))
	(h : ‚àÄ (x : Œ±), x ‚àà I ‚Üí ‚áëf x ‚àà set.Icc 0 I) (x : Œ±) :
	‚Üë(‚áë(continuous_map.of_Icc_of_forall_mem_Icc h I f h) x) = ‚áëf x :=
sorry

continuous_map.monotone_of_open_of_monotone {R : Type*} [ring R]
	{M‚ÇÅ : Type*} [topological_space M‚ÇÅ] [add_comm_group M‚ÇÅ] [module R M‚ÇÅ]
	[topological_ring M‚ÇÅ] [has_continuous_smul R M‚ÇÅ] :
	monotone (continuous_map.of_open_of_monotone R M‚ÇÅ) :=
sorry

ratfunc.int_fract_of_ratfunc_lt_ratfunc_of_continuous {K : Type*}
	[linear_ordered_field K] [floor_ring K] {R : Type*} [comm_ring R]
	[topological_space R] [topological_add_group R] [borel_space R] {f : polynomial R}
	{ : R} (h : continuous f) (h' : f.ratfunc K)
	(hcont : ‚àÄ {x : ratfunc K}, f.coeff x < c) (hR : is_closed {x : ratfunc R | ‚áëf x = r}) :
	‚àÉ (x : R), f.int_fract x = c :=
sorry

not_differentiable_on_Icc_of_Ioi_zero_le_Ioi {ùïú : Type*}
	[nondiscrete_normed_field ùïú] [complete_space ùïú] {E : Type*} [normed_group E]
	[normed_space ùïú E] [no_zero_smul_divisors ùïú E] {f : ùïú ‚Üí E} {s : set ùïú}
	(h : 0 ‚â§ s) (hf : ‚àÄ (x : ùïú), x ‚àà s ‚Üí f x ‚àâ set.Ioi 0) :
	¬¨differentiable_on ùïú f s :=
sorry

Gromov_Hausdorff.GH_dist_spec {X : Type u} [metric_space X]
	{K F : set X} (hK : is_compact K) (hF : is_closed F)
	(hK' : is_closed K) (hF' : ‚àÉ (Œ¥ : ‚Ñù), 0 < Œ¥ ‚àß metric.ball p Œ¥ ‚àà F) :
	‚àÉ (Œ¥ : ‚Ñù) (H : Œ¥ > 0), Gromov_Hausdorff.GH_dist X K ‚â§ Œ¥ :=
sorry

continuous_on_div_two_interval {Œ± : Type u} [linear_ordered_field Œ±]
	{f : Œ± ‚Üí Œ±} {a b : Œ±} (hf : continuous_on f (set.interval a b))
	(h : ‚àÄ (x : Œ±), x ‚àà set.interval a b ‚Üí f x ‚àà set.interval (f a) (f b)) :
	continuous_on f (set.interval a b) :=
sorry

continuous_map.closure_preimage_subset_closure_image {Œ± Œ≤ : Type*}
	[topological_space Œ±] [compact_space Œ±] [metric_space Œ≤] (f : C(Œ±, Œ≤)) :
	closure (‚áëf ‚Åª¬π' {s : set Œ± | ‚àÉ (t : set Œ≤), is_closed t ‚àß s ‚äÜ t) :=
sorry

zero_at_infty_continuous_map.zero_of_closed_set {Œ± : Type u}
	{Œ≤ : Type v} [topological_space Œ±] [metric_space Œ≤] [has_zero Œ≤]
	{f : zero_at_infty_continuous_map Œ± Œ≤} {Z : set Œ±}
	(hZ : is_closed Z) (hf : continuous f) :
	is_closed {x : Œ± | ‚áëf x = 0} :=
sorry

continuous_map.continuous_map_of_closure_image_mem_aux {Œ± Œ≤ : Type*}
	[topological_space Œ±] [topological_space Œ≤] (f : C(Œ±, Œ≤)) (g : C(Œ±, Œ≤))
	(E : set Œ±) (hE : is_open E) (h : f.closure '' E ‚àà f.aux)
	(H : g.closure '' E ‚àà g.aux) :
	‚áëf (continuous_map.of_closure_image f g E h) ‚àà continuous_map.of_closure_aux (f.rec_on h E) f g :=
sorry

continuous_map.mk_of_closure_eq_of_closure_eq {Œ± : Type u‚ÇÅ}
	{Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [metric_space Œ≤] {f : C(Œ±, Œ≤)}
	{g : C(Œ±, Œ≤)} {E : set Œ±} (hE : dense E)
	(h : ‚àÄ (p : C(Œ±, Œ≤)), p ‚àà E ‚Üí ‚áëg p = ‚áëf p) (hfg : ‚àÄ (p : C(Œ±, Œ≤)), p ‚àà E ‚Üí g p = ‚áëf p) :
	continuous_map.mk_of_closure E hE = f :=
sorry

continuous_on.exists_real_deriv_within_eq {E : Type*} [normed_group E]
	[normed_space ‚Ñù E] [complete_space E] {f : ‚Ñù ‚Üí E} {s : set ‚Ñù}
	(hf : continuous_on f s) (hs : is_closed s)
	(hfs : ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí f x ‚àà closure (s ‚à© set.Icc 0 1)) :
	‚àÉ (g : ‚Ñù ‚Üí E), continuous_on g s ‚àß ‚àÄ (x : ‚Ñù), x ‚àà s ‚Üí deriv_within f s x = f x :=
sorry

continuous_map.not_exists_real_eq_of_exists_not_mem {E : Type*}
	[topological_space E] [compact_space E] [nonempty E] (f : C(E, ‚Ñù)) :
	¬¨‚àÉ (g : E ‚ÜíL[‚Ñù] ‚Ñù), continuous_map.restrict_scalars ‚Ñù f = g :=
sorry

is_compact.continuous_on_iff_of_continuous_on_of_continuous_on {E : Type*}
	[normed_group E] [normed_space ‚Ñù E] [complete_space E] {f : E ‚Üí ‚Ñù} {s : set E}
	(hf : is_compact s) (hs : s ‚àà nhds f) :
	continuous_on f s ‚Üî is_compact (s ‚à© f '' s) :=
sorry

real.of_cauchy_of_bounded_on_of_cauchy_aux {E : Type*}
	[normed_group E] [normed_space ‚Ñù E] [complete_space E] {f : ‚Ñù ‚Üí E}
	(hf : cauchy_seq f) (hbounded : ‚àÄ (s : set ‚Ñù), cauchy_seq f ‚Üí (‚àÉ (x : ‚Ñù) (H : x ‚àà s), ‚à•f x‚à• ‚â§ 2)) :
	‚àÉ (x : ‚Ñù), x ‚àà {y : ‚Ñù | ‚àÉ (z : ‚Ñù) (H : z ‚àà {y : ‚Ñù | ‚àÉ (z : ‚Ñù) (H : z ‚àà {y : ‚Ñù | ‚àÉ (z : ‚Ñù) (H : z ‚àà {y : ‚Ñù | ‚àÉ (z : ‚Ñù) (H : z ‚àà {y : ‚Ñù | ‚àÉ (z : ‚Ñù) (H : z ‚àà {y}), ‚à•f z‚à• ‚â§ 2}) :=
sorry

bounded_continuous_function.exists_not_is_bounded_of_compact {Œ± : Type u}
	{E : Type v} [topological_space Œ±] [compact_space Œ±] [normed_group E]
	(ùïú : Type*) [normed_field ùïú] [normed_space ùïú E] :
	(‚àÉ (f : bounded_continuous_function Œ± E), continuous_map.restrict_scalars ùïú f) ‚àß ¬¨is_bounded_under has_le.le ‚ä§ f :=
sorry

circle_deg1_lift.mk_aux_spec (f : ‚Ñù ‚Üí ‚Ñù) (x y : ‚Ñù)
	(h : ‚àÄ (x : ‚Ñù), x ‚àà set.Icc 0 1 ‚Üí ‚àÄ (y : ‚Ñù), y ‚àà set.Icc 0 1 ‚Üí |f x - f y| ‚â§ (x - y) ^ 2) :
	circle_deg1_lift.mk_aux f x y h = f x - f y :=
sorry

is_lub_of_le_geometric_two {R : Type*} [linear_ordered_field R]
	{a : R} {f : R ‚Üí R} {M‚ÇÄ M‚ÇÅ M‚ÇÇ : R} (ha : a ‚â§ 1) (h : ‚àÄ (x : R), f x ‚â† 0)
	(h'a : ‚àÄ (x : R), f x ‚â† 0 ‚Üí M‚ÇÅ ‚â§ |f x|) (hM‚ÇÄ : M‚ÇÄ ‚â§ M‚ÇÅ)
	(hM‚ÇÅ : M‚ÇÅ ‚â§ M‚ÇÇ) :
	is_lub (set.Ioi a) f ‚Üí is_lub (set.Ioi a) (Œª (x : R), M‚ÇÅ) :=
sorry

real.exists_three_le_of_differentiable_on_Icc_of_le_of_neg_one
	{f : ‚Ñù ‚Üí ‚Ñù} (h : differentiable_on ‚Ñù f (set.Icc (-1) 1))
	(h' : f (-1) = 0) (hle : f 1 = 1) (h'pos : 0 < f 0)
	(hle : f 1 = 1 ‚à® f (-1) = 0) :
	‚àÉ (x : ‚Ñù), 3 ‚â§ f x :=
sorry

strict_mono_on.inv_fun_mul_deriv {a b : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} (h : strict_mono_on f (set.Ioo a b))
	(h‚ÇÄ : ‚àÄ (x : ‚Ñù), x ‚àà set.Ioo a b ‚Üí 0 < f x) (h‚ÇÅ : 0 < f a) (h‚ÇÇ : f b < (f a) / (f b)) :
	strict_mono_on (Œª (x : ‚Ñù), (f x)‚Åª¬π * deriv f x) (set.Ioo a b) :=
sorry

real.to_nnreal_of_le_add_bound {g : ‚Ñù ‚Üí ‚Ñù} (M : ‚Ñù) (h : ‚àÄ (x : ‚Ñù), ‚Üëx ‚â§ g x)
	(h' : ‚àÄ (x : ‚Ñù), ‚Üëx + 1 ‚â§ g x) (Œµ : ‚Ñù) (pos : 0 < Œµ) :
	‚àÉ (f : ‚Ñù ‚Üí ‚Ñù), (‚àÄ (x : ‚Ñù), ‚Üëx ‚â§ f x) ‚àß ‚àÄ (x : ‚Ñù), ‚Üëx + 1 ‚â§ g x :=
sorry

real.cramer_eq_zero_of_is_empty {C : ‚Ñù} {n : ‚Ñï} (hC : C 0 + C 1 / 2 + C n = 0)
	(h : is_empty (C n)) :
	‚áë(algebra_map ‚Ñù (fin n)) (‚áëmatrix.of![![0, 1],![1, 2],![0, 2],![1, 2],![0, 1]])) = 0 :=
sorry

deriv_within_succ_at_bot {ùïú : Type u} [nondiscrete_normed_field ùïú]
	{F : Type v} [normed_group F] [normed_space ùïú F] {f : ùïú ‚Üí F} {x : ùïú}
	{s : set ùïú} (hxs : unique_diff_within_at ùïú s x) :
	deriv_within f s x.succ = f x - 1 - f x :=
sorry

real.continuous_on_div_pow_of_zero_le {a b c d : ‚Ñù} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b)
	(hab : a ‚â§ b) (hcd : 0 ‚â§ c) (hcd : 0 < d) (f : ‚Ñù ‚Üí ‚Ñù) (g : ‚Ñù ‚Üí ‚Ñù)
	(hfa : continuous_on f (set.Ici 0)) (hga : continuous_on g (set.Icc a b))
	(hdiv : 0 < (f / g) ‚àß (g / f) ‚â§ linear_order.max (f / g) (a / f)) :
	continuous_on (Œª (x : ‚Ñù), f x / x * g x) (set.Icc a b) :=
sorry

tendsto_div_comp_div_tendsto_zero {Œ± : Type u} [linear_ordered_field Œ±]
	{Œ≤ : Type*} [comm_ring Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} {x : Œ≤}
	(hf : filter.tendsto f filter.at_top (nhds x))
	(hg : filter.tendsto g filter.at_top (nhds x)) (h : g x ‚â† 0) :
	filter.tendsto (Œª (t : Œ≤), f t / g t) filter.at_top (nhds (x / g x)) :=
sorry