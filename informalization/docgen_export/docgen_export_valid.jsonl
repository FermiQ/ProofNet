{"name": "nat.arithmetic_function.mul_zeta_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/arithmetic_function.lean", "formal_statement": "theorem nat.arithmetic_function.mul_zeta_apply {f : nat.arithmetic_function \u2115}\n\t{x : \u2115} :\n\t\u21d1(f * nat.arithmetic_function.zeta) x = x.divisors.sum (\u03bb (i : \u2115), \u21d1f i) :=", "nl_statement_of_codex": "Let $f$ be an arithmetic function. Then $\\sum_{d|x}f(d)=\\sum_{d|x}f(x/d)$."}
{"name": "finset.subset_map_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/preimage.lean", "formal_statement": "theorem finset.subset_map_iff {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u21aa \u03b2}\n\t{s : finset \u03b2} {t : finset \u03b1} :\n\ts \u2286 finset.map f t \u2194 \u2203 (u : finset \u03b1) (H : u \u2286 t), s = finset.map f u :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $S\\subseteq f(T)$ if and only if there is a subset $U\\subseteq T$ such that $S=f(U)$."}
{"name": "deriv_within_sinh", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem deriv_within_sinh {f : \u211d \u2192 \u211d} {x : \u211d} {s : set \u211d}\n\t(hf : differentiable_within_at \u211d f s x) (hxs : unique_diff_within_at \u211d s x) :\n\tderiv_within (\u03bb (x : \u211d), real.sinh (f x)) s x = real.cosh (f x) * deriv_within f s x :=", "nl_statement_of_codex": "Let $f:I\\to\\mathbb{R}$ be differentiable at $x\\in I$. Then the function $g(x)=\\sinh(f(x))$ is differentiable at $x$ and $g'(x)=\\cosh(f(x))f'(x)$."}
{"name": "cardinal.sum_lt_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.sum_lt_prod {\u03b9 : Type*} (f g : \u03b9 \u2192 cardinal)\n\t(H : \u2200 (i : \u03b9), f i < g i) :\n\tcardinal.sum f < cardinal.prod g :=", "nl_statement_of_codex": "Let $f,g:\\iota\\to\\mathrm{Card}$ be two functions. If $f(i)<g(i)$ for all $i\\in\\iota$, then $\\sum_{i\\in\\iota}f(i)<\\prod_{i\\in\\iota}g(i)$."}
{"name": "interior_ae_eq_of_null_frontier", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/borel_space.lean", "formal_statement": "theorem interior_ae_eq_of_null_frontier {\u03b1' : Type*} [topological_space \u03b1']\n\t[measurable_space \u03b1'] {\u03bc : measure_theory.measure \u03b1'} {s : set \u03b1'}\n\t(h : \u21d1\u03bc (frontier s) = 0) :\n\tinterior s =\u1d50[\u03bc] s :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $\u03bc$ be a measure on $X$. Let $s$ be a measurable subset of $X$. If the boundary of $s$ has measure zero, then the interior of $s$ is equal to $s$ almost everywhere."}
{"name": "add_lt_of_neg_of_lt'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem add_lt_of_neg_of_lt' {\u03b1 : Type*} [add_zero_class \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b c : \u03b1}\n\t(ha : a < 0) (hbc : b < c) :\n\ta + b < c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of an ordered additive group. If $a<0$ and $b<c$, then $a+b<c$."}
{"name": "list.length_take_le", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/list/lemmas.lean", "formal_statement": "theorem list.length_take_le {\u03b1 : Type u} (n : \u2115) (l : list \u03b1) :\n\t(list.take n l).length \u2264 n :=", "nl_statement_of_codex": "The length of the list obtained by taking the first $n$ elements of a list $l$ is less than or equal to $n$."}
{"name": "polynomial.reverse_leading_coeff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/reverse.lean", "formal_statement": "theorem polynomial.reverse_leading_coeff {R : Type*} [semiring R]\n\t(f : polynomial R) :\n\tf.reverse.leading_coeff = f.trailing_coeff :=", "nl_statement_of_codex": "The leading coefficient of the reverse of a polynomial is the trailing coefficient of the polynomial."}
{"name": "hahn_series.mul_single_coeff_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/hahn_series.lean", "formal_statement": "theorem hahn_series.mul_single_coeff_add {\u0393 R : Type*}\n\t[ordered_cancel_add_comm_monoid \u0393] [non_unital_non_assoc_semiring R] {r : R}\n\t{x : hahn_series \u0393 R} {a b : \u0393} :\n\t(x * \u21d1(hahn_series.single b) r).coeff (a + b) = x.coeff a * r :=", "nl_statement_of_codex": "Let $R$ be a non-unital non-associative semiring and let $x$ be a Hahn series over $R$. Then the coefficient of $a+b$ in $x\\cdot\\delta_b(r)$ is equal to the coefficient of $a$ in $x$ times $r$."}
{"name": "closure_compl_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem closure_compl_singleton {\u03b1 : Type u} [topological_space \u03b1] (x : \u03b1)\n\t[(nhds_within x {x}\u1d9c).ne_bot] :\n\tclosure {x}\u1d9c = set.univ :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $x\\in X$. Then the closure of the complement of $\\{x\\}$ is $X$."}
{"name": "measure_theory.le_ae_restrict", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.le_ae_restrict {\u03b1 : Type*} {m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} :\n\t\u03bc.ae \u2293 filter.principal s \u2264 (\u03bc.restrict s).ae :=", "nl_statement_of_codex": "Let $\u03bc$ be a measure on a measurable space $\u03b1$. Then the set of points of $\u03b1$ where $\u03bc$ is finite is a subset of the set of points of $\u03b1$ where $\u03bc$ restricted to $s$ is finite."}
{"name": "cont_diff_on_of_continuous_on_differentiable_on_deriv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/iterated_deriv.lean", "formal_statement": "theorem cont_diff_on_of_continuous_on_differentiable_on_deriv {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f : \ud835\udd5c \u2192 F} {s : set \ud835\udd5c} {n : with_top \u2115}\n\t(Hcont : \u2200 (m : \u2115), \u2191m \u2264 n \u2192 continuous_on (\u03bb (x : \ud835\udd5c), iterated_deriv_within m f s x) s)\n\t(Hdiff : \u2200 (m : \u2115), \u2191m < n \u2192 differentiable_on \ud835\udd5c (\u03bb (x : \ud835\udd5c), iterated_deriv_within m f s x) s) :\n\tcont_diff_on \ud835\udd5c n f s :=", "nl_statement_of_codex": "Let $f:U\\to\\mathbb{R}^n$ be a function defined on an open set $U\\subset\\mathbb{R}^n$. Suppose that for each $k\\in\\mathbb{N}$ the $k$-th derivative $f^{(k)}$ is continuous on $U$ and differentiable on $U$. Then $f$ is continuously differentiable on $U$."}
{"name": "linear_map.comap_prod_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/prod.lean", "formal_statement": "theorem linear_map.comap_prod_prod {R : Type u} {M : Type v} {M\u2082 : Type w}\n\t{M\u2083 : Type y} [semiring R] [add_comm_monoid M] [add_comm_monoid M\u2082]\n\t[add_comm_monoid M\u2083] [module R M] [module R M\u2082] [module R M\u2083] (f : M \u2192\u2097[R] M\u2082)\n\t(g : M \u2192\u2097[R] M\u2083) (p : submodule R M\u2082) (q : submodule R M\u2083) :\n\tsubmodule.comap (f.prod g) (p.prod q) = submodule.comap f p \u2293 submodule.comap g q :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M, M_2, M_3$ be $R$-modules. Let $f:M\\to M_2$ and $g:M\\to M_3$ be $R$-linear maps. Let $p$ be a submodule of $M_2$ and $q$ be a submodule of $M_3$. Then the preimage of $p\\times q$ under $f\\times g$ is the intersection of the preimages of $p$ and $q$ under $f$ and $g$ respectively."}
{"name": "bool.band_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bool/basic.lean", "formal_statement": "theorem bool.band_comm (a b : bool) :\n\ta && b = b && a :=", "nl_statement_of_codex": "The conjunction of two booleans is commutative."}
{"name": "nnreal.supr_mul_supr_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/nnreal.lean", "formal_statement": "theorem nnreal.supr_mul_supr_le {\u03b9 : Sort u_1} [nonempty \u03b9] {a : nnreal}\n\t{g h : \u03b9 \u2192 nnreal} (H : \u2200 (i j : \u03b9), g i * h j \u2264 a) :\n\tsupr g * supr h \u2264 a :=", "nl_statement_of_codex": "Let $g, h:I\\to\\mathbb{R}_{\\geq 0}$ be functions. If $g(i)h(j)\\leq a$ for all $i, j\\in I$, then $\\sup_{i\\in I}g(i)\\sup_{j\\in I}h(j)\\leq a$."}
{"name": "set.maps_to_Inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.maps_to_Inter {\u03b1 \u03b2 : Type*} {\u03b9 : Sort u_4} {s : set \u03b1}\n\t{t : \u03b9 \u2192 set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 (i : \u03b9), set.maps_to f s (t i)) :\n\tset.maps_to f s (\u22c2 (i : \u03b9), t i) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $A$ be a set. Let $\\{B_i\\}_{i\\in I}$ be a family of subsets of $B$. If $f(A)\\subset B_i$ for all $i\\in I$, then $f(A)\\subset \\bigcap_{i\\in I}B_i$."}
{"name": "hash_map.find_erase", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/hash_map.lean", "formal_statement": "theorem hash_map.find_erase {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1]\n\t(m : hash_map \u03b1 \u03b2) (a' a : \u03b1) :\n\t(m.erase a).find a' = ite (a = a') option.none (m.find a') :=", "nl_statement_of_codex": "Let $m$ be a hash map from $A$ to $B$. Let $a,a'\\in A$. Then $(m\\setminus\\{a\\})(a')=m(a')$ if $a\\neq a'$ and $(m\\setminus\\{a\\})(a')=\\emptyset$ if $a=a'$."}
{"name": "sum.lex.to_lex_strict_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sum/order.lean", "formal_statement": "theorem sum.lex.to_lex_strict_mono {\u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] :\n\tstrict_mono \u21d1to_lex :=", "nl_statement_of_codex": "The function $f:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$ defined by $f(i,j)=i+j$ is strictly monotone."}
{"name": "polynomial.trailing_degree_ne_of_nat_trailing_degree_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/trailing_degree.lean", "formal_statement": "theorem polynomial.trailing_degree_ne_of_nat_trailing_degree_ne {R : Type u}\n\t[semiring R] {p : polynomial R} {n : \u2115} :\n\tp.nat_trailing_degree \u2260 n \u2192 p.trailing_degree \u2260 \u2191n :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. If the natural trailing degree of $p$ is not $n$, then the trailing degree of $p$ is not $n$."}
{"name": "concept.swap_equiv_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/concept.lean", "formal_statement": "theorem concept.swap_equiv_symm_apply {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b2 \u2192 Prop}\n\t(\u1fb0 : concept \u03b2 \u03b1 (function.swap r)) :\n\t\u21d1(rel_iso.symm concept.swap_equiv) \u1fb0 = (\u21d1order_dual.to_dual \u2218 concept.swap) \u1fb0 :=", "nl_statement_of_codex": "Let $r$ be a relation between $A$ and $B$. Then the concept of $B$ in $A$ is the same as the concept of $A$ in $B$."}
{"name": "is_topological_fiber_bundle.quotient_map_proj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/fiber_bundle.lean", "formal_statement": "theorem is_topological_fiber_bundle.quotient_map_proj {B F Z : Type*}\n\t[topological_space B] [topological_space F] {proj : Z \u2192 B}\n\t[topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) :\n\tquotient_map proj :=", "nl_statement_of_codex": "Let $B$ be a topological space, let $F$ be a nonempty topological space, and let $Z$ be a topological space. Let $p:Z\\to B$ be a map. If $p$ is a topological fiber bundle, then $p$ is a quotient map."}
{"name": "filter.tendsto_principal_principal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.tendsto_principal_principal {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}\n\t{s : set \u03b1} {t : set \u03b2} :\n\tfilter.tendsto f (filter.principal s) (filter.principal t) \u2194 \u2200 (a : \u03b1), a \u2208 s \u2192 f a \u2208 t :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function. Then $f$ tends to $Y$ along $X$ if and only if $f(x)\\in Y$ for all $x\\in X$."}
{"name": "prod.fst_to_sigma", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sigma/basic.lean", "formal_statement": "theorem prod.fst_to_sigma {\u03b1 \u03b2 : Type*} (x : \u03b1 \u00d7 \u03b2) :\n\tx.to_sigma.fst = x.fst :=", "nl_statement_of_codex": "Let $x=(x_1,x_2)$ be an element of $\\alpha\\times\\beta$. Then $x_1=\\pi_1(x)$."}
{"name": "CompHaus.to_Profinite_obj'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Profinite/default.lean", "formal_statement": "theorem CompHaus.to_Profinite_obj' (X : CompHaus) :\n\t\u21a5(CompHaus.to_Profinite.obj X) = connected_components \u21a5X :=", "nl_statement_of_codex": "The underlying topological space of the profinite completion of a compact Hausdorff space is the set of connected components of the underlying topological space of the compact Hausdorff space."}
{"name": "deriv_const_mul_field", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem deriv_const_mul_field {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c}\n\t{\ud835\udd5c' : Type*} [normed_field \ud835\udd5c'] [normed_algebra \ud835\udd5c \ud835\udd5c'] {v : \ud835\udd5c \u2192 \ud835\udd5c'} (u : \ud835\udd5c') :\n\tderiv (\u03bb (y : \ud835\udd5c), u * v y) x = u * deriv v x :=", "nl_statement_of_codex": "Let $K$ be a nondiscrete normed field, $L$ a normed field, and $A$ a normed algebra over $K$. Let $u\\in A$ and $v:K\\to A$. Then the derivative of $u\\cdot v$ is $u\\cdot v'$."}
{"name": "omega_complete_partial_order.continuous_hom.coe_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/omega_complete_partial_order.lean", "formal_statement": "theorem omega_complete_partial_order.continuous_hom.coe_apply {\u03b1 : Type u}\n\t{\u03b2 : Type v} [omega_complete_partial_order \u03b1] [omega_complete_partial_order \u03b2]\n\t(a : \u03b1) (f : \u03b1 \u2192\ud835\udc84 \u03b2) :\n\t\u21d1\u2191f a = \u21d1f a :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a continuous function between omega-complete partial orders. Then $f$ is continuous as a function from $A$ to $B$."}
{"name": "category_theory.split_mono.id_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/epi_mono.lean", "formal_statement": "theorem category_theory.split_mono.id_assoc {C : Type u\u2081}\n\t[category_theory.category C] {X Y : C} (f : X \u27f6 Y)\n\t[category_theory.split_mono f] {X' : C} (f' : X \u27f6 X') :\n\tf \u226b category_theory.retraction f \u226b f' = f' :=", "nl_statement_of_codex": "Let $C$ be a category and let $f:X\\to Y$ be a split monomorphism. Then for any morphism $f':X\\to X'$, we have $f\\circ r\\circ f'=f'$, where $r$ is the retraction of $f$."}
{"name": "monotone.add_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem monotone.add_const {\u03b1 \u03b2 : Type*} [has_add \u03b1] [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b2 \u2192 \u03b1} [covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le]\n\t(hf : monotone f) (a : \u03b1) :\n\tmonotone (\u03bb (x : \u03b2), f x + a) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a monotone function. Then the function $g:X\\to Y$ defined by $g(x)=f(x)+a$ is monotone."}
{"name": "int.nat_abs_inj_of_nonpos_of_nonpos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.nat_abs_inj_of_nonpos_of_nonpos {a b : \u2124} (ha : a \u2264 0) (hb : b \u2264 0) :\n\ta.nat_abs = b.nat_abs \u2194 a = b :=", "nl_statement_of_codex": "Let $a, b\\in\\mathbb{Z}$. If $a\\leq 0$ and $b\\leq 0$, then $|a|=|b|$ if and only if $a=b$."}
{"name": "minpoly.map_ne_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/minpoly.lean", "formal_statement": "theorem minpoly.map_ne_one (A : Type*) {B : Type*} [comm_ring A] [ring B]\n\t[algebra A B] (x : B) [nontrivial B] {R : Type*} [semiring R] [nontrivial R]\n\t(f : A \u2192+* R) :\n\tpolynomial.map f (minpoly A x) \u2260 1 :=", "nl_statement_of_codex": "Let $A$ be a commutative ring, $B$ a ring, and $x\\in B$. Suppose that $B$ is nontrivial and that $A$ is an $A$-algebra. Let $R$ be a nontrivial semiring and let $f:A\\to R$ be a ring homomorphism. Then the minimal polynomial of $x$ over $A$ is not mapped to $1$ under $f$."}
{"name": "normed_group.uniformity_basis_dist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem normed_group.uniformity_basis_dist {E : Type*} [semi_normed_group E] :\n\t(uniformity E).has_basis (\u03bb (\u03b5 : \u211d), 0 < \u03b5) (\u03bb (\u03b5 : \u211d), {p : E \u00d7 E | \u2225p.fst - p.snd\u2225 < \u03b5}) :=", "nl_statement_of_codex": "The uniformity on a semi-normed group $E$ has a basis of sets of the form $\\{(x,y)\\in E\\times E\\mid \\|x-y\\|<\\epsilon\\}$."}
{"name": "convolution_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convolution.lean", "formal_statement": "theorem convolution_assoc {\ud835\udd5c G E E' E'' F F' F'' : Type*} [normed_group E]\n\t[normed_group E'] [normed_group E''] [normed_group F] {f : G \u2192 E} {g : G \u2192 E'}\n\t[is_R_or_C \ud835\udd5c] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c E'] [normed_space \ud835\udd5c E'']\n\t[normed_space \u211d F] [normed_space \ud835\udd5c F] [complete_space F] [measurable_space G]\n\t{\u03bc : measure_theory.measure G} (L : E \u2192L[\ud835\udd5c] E' \u2192L[\ud835\udd5c] F) [normed_group F']\n\t[normed_space \u211d F'] [normed_space \ud835\udd5c F'] [complete_space F'] [normed_group F'']\n\t[normed_space \u211d F''] [normed_space \ud835\udd5c F''] [complete_space F''] {k : G \u2192 E''}\n\t(L\u2082 : F \u2192L[\ud835\udd5c] E'' \u2192L[\ud835\udd5c] F') (L\u2083 : E \u2192L[\ud835\udd5c] F'' \u2192L[\ud835\udd5c] F')\n\t(L\u2084 : E' \u2192L[\ud835\udd5c] E'' \u2192L[\ud835\udd5c] F'') [add_group G] [has_measurable_add G]\n\t[measure_theory.sigma_finite \u03bc] {\u03bd : measure_theory.measure G}\n\t[measure_theory.sigma_finite \u03bd] [\u03bd.is_add_right_invariant]\n\t(hL : \u2200 (x : E) (y : E') (z : E''), \u21d1(\u21d1L\u2082 (\u21d1(\u21d1L x) y)) z = \u21d1(\u21d1L\u2083 x) (\u21d1(\u21d1L\u2084 y) z))\n\t{x\u2080 : G} (h\u2084 : convolution_exists g k L\u2084 \u03bd) (h\u2081 : convolution_exists f g L \u03bc)\n\t(hi : measure_theory.integrable (function.uncurry (\u03bb (x y : G), \u21d1(\u21d1L\u2083 (f y)) (\u21d1(\u21d1L\u2084 (g (x - y))) (k (x\u2080 - x))))) (\u03bd.prod \u03bc)) :\n\tconvolution (convolution f g L \u03bc) k L\u2082 \u03bd x\u2080 = convolution f (convolution g k L\u2084 \u03bd) L\u2083 \u03bc x\u2080 :=", "nl_statement_of_codex": "Let $E, E', E'', F, F', F''$ be normed groups, $f:G\\to E$, $g:G\\to E'$, $k:G\\to E''$, $L:E\\times E'\\to F$, $L_2:F\\times E''\\to F'$, $L_3:E\\times F''\\to F'$, $L_4:E'\\times E''\\to F''$, $G$ a measurable space, $\\mu$ a measure on $G$, $\\nu$ a measure on $G$ such that $\\nu$ is right-invariant. Suppose that $L_2("}
{"name": "category_theory.limits.biproduct.\u03b9_desc_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.biproduct.\u03b9_desc_assoc {J : Type w} {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{f : J \u2192 C} [category_theory.limits.has_biproduct f] {P : C}\n\t(p : \u03a0 (b : J), f b \u27f6 P) (j : J) {X' : C} (f' : P \u27f6 X') :\n\tcategory_theory.limits.biproduct.\u03b9 f j \u226b category_theory.limits.biproduct.desc p \u226b f' = p j \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms and let $f:J\\to C$ be a functor. Let $P$ be an object of $C$ and let $p:J\\to C(f(j),P)$ be a natural transformation. Let $X'$ be an object of $C$ and let $f':P\\to X'$ be a morphism. Then the following diagram commutes:\n$$\\require{AMScd}\n\\begin{CD}\n\\coprod_{j\\in J} f(j) @>{\\coprod_{j\\in J} p(j)}>> P\\\\\n@V{\\iota_j"}
{"name": "cardinal.to_nat_lift", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.to_nat_lift ( : cardinal) :\n\t\u21d1cardinal.to_nat c.lift = \u21d1cardinal.to_nat c :=", "nl_statement_of_codex": "The cardinality of the lift of a cardinal $c$ is equal to the cardinality of $c$."}
{"name": "is_add_group_hom.is_normal_add_subgroup_ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_group_hom.is_normal_add_subgroup_ker {G H : Type*} [add_group G]\n\t[add_group H] {f : G \u2192 H} (hf : is_add_group_hom f) :\n\tis_normal_add_subgroup (is_add_group_hom.ker f) :=", "nl_statement_of_codex": "Let $G$ and $H$ be additive groups and let $f:G\\to H$ be an additive group homomorphism. Then the kernel of $f$ is a normal subgroup of $G$."}
{"name": "padic_int.zmod_congr_of_sub_mem_span_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/ring_homs.lean", "formal_statement": "theorem padic_int.zmod_congr_of_sub_mem_span_aux {p : \u2115}\n\t[hp_prime : fact (nat.prime p)] (n : \u2115) (x : \u2124_[p]) (a b : \u2124)\n\t(ha : x - \u2191a \u2208 ideal.span {\u2191p ^ n}) (hb : x - \u2191b \u2208 ideal.span {\u2191p ^ n}) :\n\t\u2191a = \u2191b :=", "nl_statement_of_codex": "Let $p$ be a prime number, let $n$ be a natural number, let $x$ be an element of $\\mathbb{Z}_p$, and let $a, b$ be integers. If $x-a$ and $x-b$ are both in the span of $p^n$, then $a=b$."}
{"name": "measure_theory.quasi_measure_preserving.prod_of_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/prod.lean", "formal_statement": "theorem measure_theory.quasi_measure_preserving.prod_of_right {\u03b1 \u03b2 \u03b3 : Type*}\n\t[measurable_space \u03b1] [measurable_space \u03b2] [measurable_space \u03b3] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3}\n\t{\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2}\n\t{\u03c4 : measure_theory.measure \u03b3} (hf : measurable f)\n\t[measure_theory.sigma_finite \u03bd]\n\t(h2f : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, measure_theory.measure.quasi_measure_preserving (\u03bb (y : \u03b2), f (x, y)) \u03bd \u03c4) :\n\tmeasure_theory.measure.quasi_measure_preserving f (\u03bc.prod \u03bd) \u03c4 :=", "nl_statement_of_codex": "Let $f:X\\times Y\\to Z$ be a measurable function. If $f$ is quasi-measure-preserving on $X\\times Y$ for each $x\\in X$, then $f$ is quasi-measure-preserving on $X\\times Y$."}
{"name": "set.Union_inter_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Union_inter_subset {\u03b9 : Sort u_1} {\u03b1 : Type*} {s t : \u03b9 \u2192 set \u03b1} :\n\t(\u22c3 (i : \u03b9), s i \u2229 t i) \u2286 (\u22c3 (i : \u03b9), s i) \u2229 \u22c3 (i : \u03b9), t i :=", "nl_statement_of_codex": "Let $s_i$ and $t_i$ be sets indexed by $i\\in I$. Then $\\bigcup_{i\\in I}(s_i\\cap t_i)\\subseteq \\bigcup_{i\\in I}s_i\\cap \\bigcup_{i\\in I}t_i$."}
{"name": "alg_equiv.congr_arg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.congr_arg {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w}\n\t[comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082]\n\t{f : A\u2081 \u2243\u2090[R] A\u2082} {x x' : A\u2081} :\n\tx = x' \u2192 \u21d1f x = \u21d1f x' :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A_1$ and $A_2$ be $R$-algebras, and $f:A_1\\to A_2$ be an $R$-algebra isomorphism. Then $f$ is a function."}
{"name": "list.perm_of_mem_permutations", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/perm.lean", "formal_statement": "theorem list.perm_of_mem_permutations {\u03b1 : Type uu} {l\u2081 l\u2082 : list \u03b1}\n\t(h : l\u2081 \u2208 l\u2082.permutations) :\n\tl\u2081 ~ l\u2082 :=", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of elements of a type $\u03b1$. If $l_1$ is a permutation of $l_2$, then $l_1$ is equal to $l_2$ up to permutation."}
{"name": "pfun.image_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pfun.lean", "formal_statement": "theorem pfun.image_def {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192. \u03b2) (s : set \u03b1) :\n\tf.image s = {y : \u03b2 | \u2203 (x : \u03b1) (H : x \u2208 s), y \u2208 f x} :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a partial function. Then $f(X)$ is the set of all $y\\in Y$ such that there is an $x\\in X$ with $f(x)=y$."}
{"name": "complex.tan_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/exponential.lean", "formal_statement": "theorem complex.tan_zero :\n\tcomplex.tan 0 = 0 :=", "nl_statement_of_codex": "The tangent of $0$ is $0$."}
{"name": "subalgebra.center_eq_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem subalgebra.center_eq_top (R : Type u) [comm_semiring R] (A : Type*)\n\t[comm_semiring A] [algebra R A] :\n\tsubalgebra.center R A = \u22a4 :=", "nl_statement_of_codex": "The center of an algebra over a commutative ring is the whole algebra."}
{"name": "alg_hom.finite.finite_type", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/finiteness.lean", "formal_statement": "theorem alg_hom.finite.finite_type {R A B : Type*} [comm_ring R] [comm_ring A]\n\t[comm_ring B] [algebra R A] [algebra R B] {f : A \u2192\u2090[R] B} (hf : f.finite) :\n\tf.finite_type :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $A$ and $B$ be $R$-algebras, and let $f:A\\to B$ be an $R$-algebra homomorphism. If $f$ is finite, then $f$ is of finite type."}
{"name": "polynomial.nat_trailing_degree_nat_cast", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/trailing_degree.lean", "formal_statement": "theorem polynomial.nat_trailing_degree_nat_cast {R : Type u} [semiring R]\n\t(n : \u2115) :\n\t\u2191n.nat_trailing_degree = 0 :=", "nl_statement_of_codex": "The natural trailing degree of a natural number is zero."}
{"name": "Mon_.one_mul_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/Mon_.lean", "formal_statement": "theorem Mon_.one_mul_hom {C : Type u\u2081} [category_theory.category C]\n\t[category_theory.monoidal_category C] {M : Mon_ C} {Z : C} (f : Z \u27f6 M.X) :\n\t(M.one \u2297 f) \u226b M.mul = (\u03bb_ Z).hom \u226b f :=", "nl_statement_of_codex": "Let $C$ be a monoidal category and let $M$ be a monoid in $C$. Let $Z$ be an object of $C$ and let $f:Z\\to M$ be a morphism in $C$. Then the diagram\n\\[\n\\begin{tikzcd}\nM\\otimes Z \\arrow[r, "}
{"name": "basis.orientation_comp_linear_equiv_eq_neg_iff_det_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/orientation.lean", "formal_statement": "theorem basis.orientation_comp_linear_equiv_eq_neg_iff_det_neg {R : Type*}\n\t[linear_ordered_comm_ring R] {M : Type*} [add_comm_group M] [module R M]\n\t{\u03b9 : Type*} [decidable_eq \u03b9] [fintype \u03b9] (e : basis \u03b9 R M) (f : M \u2243\u2097[R] M) :\n\t(e.map f).orientation = -e.orientation \u2194 \u21d1linear_map.det \u2191f < 0 :=", "nl_statement_of_codex": "Let $R$ be a linear ordered commutative ring, $M$ an $R$-module, and $e$ a basis of $M$. Let $f:M\\to M$ be a linear map. Then $f$ reverses the orientation of $e$ if and only if $\\det(f)<0$."}
{"name": "filter.pi_mem_pi_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pi.lean", "formal_statement": "theorem filter.pi_mem_pi_iff {\u03b9 \u03b1 : \u03b9 \u2192 Type*} {f : \u03a0 (i : \u03b9), filter (\u03b1 i)}\n\t{s : \u03a0 (i : \u03b9), set (\u03b1 i)} [\u2200 (i : \u03b9), (f i).ne_bot] {I : set \u03b9}\n\t(hI : I.finite) :\n\tI.pi s \u2208 filter.pi f \u2194 \u2200 (i : \u03b9), i \u2208 I \u2192 s i \u2208 f i :=", "nl_statement_of_codex": "Let $f_i$ be a filter on $A_i$ for each $i\\in I$. Then $I$ is finite and $s_i\\in f_i$ for each $i\\in I$ if and only if $\\prod_{i\\in I}s_i\\in\\prod_{i\\in I}f_i$."}
{"name": "multiset.coe_sigma", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/bind.lean", "formal_statement": "theorem multiset.coe_sigma {\u03b1 \u03c3 : \u03b1 \u2192 Type*} (l\u2081 : list \u03b1)\n\t(l\u2082 : \u03a0 (a : \u03b1), list (\u03c3 a)) :\n\t\u2191l\u2081.sigma (\u03bb (a : \u03b1), \u2191(l\u2082 a)) = \u2191(l\u2081.sigma l\u2082) :=", "nl_statement_of_codex": "The multiset of a sigma type is the same as the multiset of the sigma type."}
{"name": "circle.of_conj_div_self_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/circle.lean", "formal_statement": "theorem circle.of_conj_div_self_coe (z : \u2102) (hz : z \u2260 0) :\n\t\u2191(circle.of_conj_div_self z hz) = \u21d1(star_ring_end \u2102) z / z :=", "nl_statement_of_codex": "The circle of conjugate-divide-self of $z$ is equal to the star-ring-end of $z$ divided by $z$."}
{"name": "subtype.preimage_coe_eq_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem subtype.preimage_coe_eq_empty {\u03b1 : Type*} {s t : set \u03b1} :\n\tcoe \u207b\u00b9' t = \u2205 \u2194 s \u2229 t = \u2205 :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $s\\cap t=\\emptyset$ if and only if $\\{x\\in s\\mid x\\in t\\}=\\emptyset$."}
{"name": "measure_theory.outer_measure.comap_bounded_by", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.comap_bounded_by {\u03b1 : Type*}\n\t{m : set \u03b1 \u2192 ennreal} {\u03b2 : Type*} (f : \u03b2 \u2192 \u03b1)\n\t(h : monotone (\u03bb (s : {s // s.nonempty}), m \u2191s) \u2228 function.surjective f) :\n\t\u21d1(measure_theory.outer_measure.comap f) (measure_theory.outer_measure.bounded_by m) = measure_theory.outer_measure.bounded_by (\u03bb (s : set \u03b2), m (f '' s)) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function. Then the outer measure of the preimage of a bounded set is equal to the outer measure of the image of the set."}
{"name": "padic_int.mem_nonunits", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_integers.lean", "formal_statement": "theorem padic_int.mem_nonunits {p : \u2115} [hp_prime : fact (nat.prime p)]\n\t{z : \u2124_[p]} :\n\tz \u2208 nonunits \u2124_[p] \u2194 \u2225z\u2225 < 1 :=", "nl_statement_of_codex": "Let $p$ be a prime. Then $z\\in\\mathbb{Z}_p$ is a nonunit if and only if $\\|z\\|<1$."}
{"name": "ideal.mem_Sup_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/basic.lean", "formal_statement": "theorem ideal.mem_Sup_of_mem {R : Type u} [semiring R] {S : set (ideal R)}\n\t{s : ideal R} (hs : s \u2208 S) {x : R} :\n\tx \u2208 s \u2192 x \u2208 has_Sup.Sup S :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $S$ be a set of ideals of $R$. Let $s$ be an ideal of $R$ such that $s\\in S$. Then for any $x\\in s$, $x\\in \\sup S$."}
{"name": "exterior_algebra.algebra_map_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/exterior_algebra/basic.lean", "formal_statement": "theorem exterior_algebra.algebra_map_inj {R : Type u1} [comm_ring R]\n\t(M : Type u2) [add_comm_group M] [module R M] (x y : R) :\n\t\u21d1(algebra_map R (exterior_algebra R M)) x = \u21d1(algebra_map R (exterior_algebra R M)) y \u2194 x = y :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $M$ be an $R$-module. Then the map $R\\to \\bigwedge^*(M)$ is injective."}
{"name": "strict_concave_on.subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/function.lean", "formal_statement": "theorem strict_concave_on.subset {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [ordered_add_comm_monoid \u03b2] [has_smul \ud835\udd5c E] [has_smul \ud835\udd5c \u03b2]\n\t{s : set E} {f : E \u2192 \u03b2} {t : set E} (hf : strict_concave_on \ud835\udd5c t f)\n\t(hst : s \u2286 t) (hs : convex \ud835\udd5c s) :\n\tstrict_concave_on \ud835\udd5c s f :=", "nl_statement_of_codex": "Let $E$ be a vector space over $\\mathbb{R}$ and let $f:E\\to\\mathbb{R}$. If $f$ is strictly concave on a convex set $S\\subset E$, then $f$ is strictly concave on any convex subset $T\\subset S$."}
{"name": "polynomial.exists_forall_norm_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/polynomial.lean", "formal_statement": "theorem polynomial.exists_forall_norm_le {R : Type*} [normed_ring R]\n\t[is_absolute_value has_norm.norm] [proper_space R] (p : polynomial R) :\n\t\u2203 (x : R), \u2200 (y : R), \u2225polynomial.eval x p\u2225 \u2264 \u2225polynomial.eval y p\u2225 :=", "nl_statement_of_codex": "Let $R$ be a normed ring. Then there exists $x\\in R$ such that $\\|p(x)\\|\\leq \\|p(y)\\|$ for all $y\\in R$."}
{"name": "category_theory.Cat.has_limits.hom_diagram_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/Cat/limit.lean", "formal_statement": "theorem category_theory.Cat.has_limits.hom_diagram_map {J : Type v}\n\t[category_theory.small_category J] {F : J \u2964 category_theory.Cat}\n\t(X : category_theory.limits.limit (F \u22d9 category_theory.Cat.objects))\n\t(Y : category_theory.limits.limit (F \u22d9 category_theory.Cat.objects)) (j j' : J)\n\t(f : j \u27f6 j')\n\t(g : category_theory.limits.limit.\u03c0 (F \u22d9 category_theory.Cat.objects) j X \u27f6 category_theory.limits.limit.\u03c0 (F \u22d9 category_theory.Cat.objects) j Y) :\n\t(category_theory.Cat.has_limits.hom_diagram X Y).map f g = category_theory.eq_to_hom _ \u226b (F.map f).map g \u226b category_theory.eq_to_hom _ :=", "nl_statement_of_codex": "Let $F:J\\to\\mathbf{Cat}$ be a functor from a small category $J$ to the category of categories. Let $X$ and $Y$ be limits of $F\\circ\\mathbf{ob}$. Let $j,j'\\in J$ and $f:j\\to j'$ be a morphism in $J$. Let $g:X_j\\to Y_j$ be a morphism in $\\mathbf{Cat}$. Then the diagram $X\\to Y$ induced by $g$ is equal to the composition of the following three morphisms: the morphism induced by the identity morphism of $X_j$, the morph"}
{"name": "set.Iio_subset_Iic_union_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Iio_subset_Iic_union_Ico {\u03b1 : Type*} [linear_order \u03b1] {a b : \u03b1} :\n\tset.Iio b \u2286 set.Iic a \u222a set.Ico a b :=", "nl_statement_of_codex": "Let $a,b\\in\\alpha$ be elements of a linear order. Then $(-\\infty,b]\\subseteq (-\\infty,a]\\cup [a,b]$."}
{"name": "first_order.language.bounded_formula.is_qf.to_prenex_imp_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/syntax.lean", "formal_statement": "theorem first_order.language.bounded_formula.is_qf.to_prenex_imp_right\n\t{L : first_order.language} {\u03b1 : Type u'} {n : \u2115} {\u03c6 \u03c8 : L.bounded_formula \u03b1 n} :\n\t\u03c8.is_qf \u2192 \u03c6.to_prenex_imp_right \u03c8 = \u03c6.imp \u03c8 :=", "nl_statement_of_codex": "Let $L$ be a first-order language, let $n$ be a natural number, and let $\\phi$ and $\\psi$ be $n$-ary bounded formulas in $L$. If $\\psi$ is quantifier-free, then $\\phi\\to\\psi$ is equivalent to $\\phi\\to\\psi$."}
{"name": "measure_theory.ae_measure_preimage_add_right_lt_top_of_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/prod.lean", "formal_statement": "theorem measure_theory.ae_measure_preimage_add_right_lt_top_of_ne_zero\n\t{G : Type*} [measurable_space G] [add_group G] [has_measurable_add\u2082 G]\n\t(\u03bc \u03bd : measure_theory.measure G) [measure_theory.sigma_finite \u03bd]\n\t[measure_theory.sigma_finite \u03bc] {E : set G} [has_measurable_neg G]\n\t[\u03bc.is_add_left_invariant] [\u03bd.is_add_left_invariant] (Em : measurable_set E)\n\t(h2E : \u21d1\u03bd E \u2260 0) (h3E : \u21d1\u03bd E \u2260 \u22a4) :\n\t\u2200\u1d50 (x : G) \u2202\u03bc, \u21d1\u03bd ((\u03bb (y : G), y + x) \u207b\u00b9' E) < \u22a4 :=", "nl_statement_of_codex": "Let $G$ be a measurable space, let $\\mu$ and $\\nu$ be sigma-finite measures on $G$, and let $E$ be a measurable subset of $G$. If $\\nu(E)\\neq 0$ and $\\nu(E)\\neq \\infty$, then $\\nu(E+x)<\\infty$ for almost every $x\\in G$."}
{"name": "set.preimage_const_mul_Ioi_of_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/image_preimage.lean", "formal_statement": "theorem set.preimage_const_mul_Ioi_of_neg {k : Type u} [linear_ordered_field k]\n\t(a : k) { : k} (h : c < 0) :\n\thas_mul.mul c \u207b\u00b9' set.Ioi a = set.Iio (a / c) :=", "nl_statement_of_codex": "Let $c<0$. Then $c^{-1}\\cdot(a,\\infty)=(-\\infty,a/c)$."}
{"name": "eq_of_dist_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem eq_of_dist_eq_zero {\u03b3 : Type w} [metric_space \u03b3] {x y : \u03b3} :\n\thas_dist.dist x y = 0 \u2192 x = y :=", "nl_statement_of_codex": "Let $X$ be a metric space and let $x,y\\in X$. If $d(x,y)=0$, then $x=y$."}
{"name": "category_theory.limits.binary_bicone_of_split_epi_of_kernel_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.binary_bicone_of_split_epi_of_kernel_X\n\t{C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t{X Y : C} {f : X \u27f6 Y} [category_theory.split_epi f]\n\t{ : category_theory.limits.kernel_fork f}\n\t(i : category_theory.limits.is_limit c) :\n\t(category_theory.limits.binary_bicone_of_split_epi_of_kernel i).X = X :=", "nl_statement_of_codex": "Let $C$ be a category, $X, Y$ objects of $C$, and $f:X\\to Y$ a split epimorphism. Let $c$ be the kernel fork of $f$. Then the binary bicone of $c$ is the object $X$."}
{"name": "filter.eventually_le.union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.eventually_le.union {\u03b1 : Type u} {s t s' t' : set \u03b1}\n\t{l : filter \u03b1} (h : s \u2264\u1da0[l] t) (h' : s' \u2264\u1da0[l] t') :\n\ts \u222a s' \u2264\u1da0[l] t \u222a t' :=", "nl_statement_of_codex": "Let $s,t,s',t'$ be sets and let $l$ be a filter on $\u03b1$. If $s\\leq_l t$ and $s'\\leq_l t'$, then $s\\cup s'\\leq_l t\\cup t'$."}
{"name": "simple_graph.inc_matrix_apply_eq_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/inc_matrix.lean", "formal_statement": "theorem simple_graph.inc_matrix_apply_eq_one_iff {R \u03b1 : Type*}\n\t(G : simple_graph \u03b1) [mul_zero_one_class R] {a : \u03b1} {e : sym2 \u03b1} [nontrivial R] :\n\tsimple_graph.inc_matrix R G a e = 1 \u2194 e \u2208 G.incidence_set a :=", "nl_statement_of_codex": "Let $G$ be a simple graph. Then the $(a,e)$-entry of the incidence matrix of $G$ is $1$ if and only if $e$ is incident with $a$."}
{"name": "category_theory.limits.inr_pushout_left_pushout_inr_iso_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/pullbacks.lean", "formal_statement": "theorem category_theory.limits.inr_pushout_left_pushout_inr_iso_hom {C : Type u}\n\t[category_theory.category C] {W X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) (g' : Z \u27f6 W)\n\t[category_theory.limits.has_pushout f g]\n\t[category_theory.limits.has_pushout category_theory.limits.pushout.inr g']\n\t[category_theory.limits.has_pushout f (g \u226b g')] :\n\tcategory_theory.limits.pushout.inr \u226b (category_theory.limits.pushout_left_pushout_inr_iso f g g').hom = category_theory.limits.pushout.inr :=", "nl_statement_of_codex": "Let $C$ be a category. Let $f:X\\to Y$, $g:X\\to Z$, and $g':Z\\to W$ be morphisms in $C$. Suppose that $f$ and $g$ have a pushout and that $g'$ and $g$ have a pushout. Then the pushout of $f$ and $g\\circ g'$ is isomorphic to the pushout of $g'$ and $g$."}
{"name": "finsupp.indicator_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/indicator.lean", "formal_statement": "theorem finsupp.indicator_apply {\u03b9 \u03b1 : Type*} [has_zero \u03b1] (s : finset \u03b9)\n\t(f : \u03a0 (i : \u03b9), i \u2208 s \u2192 \u03b1) (i : \u03b9) :\n\t\u21d1(finsupp.indicator s f) i = dite (i \u2208 s) (\u03bb (hi : i \u2208 s), f i hi) (\u03bb (hi : i \u2209 s), 0) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\alpha$. Then the indicator function of $f$ is given by $\\chi_f(i)=f(i)$ if $i\\in s$ and $\\chi_f(i)=0$ if $i\\notin s$."}
{"name": "lie_subalgebra.top_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/submodule.lean", "formal_statement": "theorem lie_subalgebra.top_equiv_apply {R : Type u} {L : Type v} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] (x : \u21a5\u22a4) :\n\t\u21d1lie_subalgebra.top_equiv x = \u2191x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $L$ be a Lie ring over $R$. Let $x\\in L$. Then the map $f:L\\to L$ defined by $f(y)=x+y$ is a Lie algebra isomorphism."}
{"name": "emetric.le_inf_edist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean", "formal_statement": "theorem emetric.le_inf_edist {\u03b1 : Type u} [pseudo_emetric_space \u03b1] {x : \u03b1}\n\t{s : set \u03b1} {d : ennreal} :\n\td \u2264 emetric.inf_edist x s \u2194 \u2200 (y : \u03b1), y \u2208 s \u2192 d \u2264 has_edist.edist x y :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x\\in X$. Let $s\\subset X$ and let $d\\in\\mathbb{R}$. Then $d\\leq\\inf_{y\\in s}d(x,y)$ if and only if $d\\leq d(x,y)$ for all $y\\in s$."}
{"name": "AddCommGroup.injective_of_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Group/basic.lean", "formal_statement": "theorem AddCommGroup.injective_of_mono {G H : AddCommGroup} (f : G \u27f6 H)\n\t[category_theory.mono f] :\n\tfunction.injective \u21d1f :=", "nl_statement_of_codex": "Let $G$ and $H$ be additive commutative groups and let $f:G\\to H$ be a monomorphism. Then $f$ is injective."}
{"name": "cardinal.ord_aleph_is_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/ordinal.lean", "formal_statement": "theorem cardinal.ord_aleph_is_limit (o : ordinal) :\n\t(cardinal.aleph o).ord.is_limit :=", "nl_statement_of_codex": "The ordinal of the cardinal $\\aleph_\\alpha$ is a limit ordinal."}
{"name": "multiplicity.finite_int_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/int/basic.lean", "formal_statement": "theorem multiplicity.finite_int_iff {a b : \u2124} :\n\tmultiplicity.finite a b \u2194 a.nat_abs \u2260 1 \u2227 b \u2260 0 :=", "nl_statement_of_codex": "The multiplicity of $a$ in $b$ is finite if and only if $a$ is not a unit and $b$ is not zero."}
{"name": "measure_theory.integrable.ae_convolution_exists", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convolution.lean", "formal_statement": "theorem measure_theory.integrable.ae_convolution_exists {\ud835\udd5c G E E' F : Type*}\n\t[normed_group E] [normed_group E'] [normed_group F] {f : G \u2192 E} {g : G \u2192 E'}\n\t[nondiscrete_normed_field \ud835\udd5c] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c E']\n\t[normed_space \ud835\udd5c F] (L : E \u2192L[\ud835\udd5c] E' \u2192L[\ud835\udd5c] F) [measurable_space G]\n\t{\u03bc : measure_theory.measure G} [add_group G] [has_measurable_add\u2082 G]\n\t[has_measurable_neg G] [measure_theory.sigma_finite \u03bc]\n\t[\u03bc.is_add_right_invariant] (hf : measure_theory.integrable f \u03bc)\n\t(hg : measure_theory.integrable g \u03bc) :\n\t\u2200\u1d50 (x : G) \u2202\u03bc, convolution_exists_at f g x L \u03bc :=", "nl_statement_of_codex": "Let $E, E', F$ be normed groups, $G$ a measurable space, $f:G\\to E$, $g:G\\to E'$, and $L:E\\to E'\\to F$ a continuous linear map. Suppose that $f$ and $g$ are integrable with respect to a measure $\\mu$ on $G$. Then the convolution $f*g$ exists almost everywhere with respect to $\\mu$."}
{"name": "ideal.is_prime_of_is_prime_prod_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/prod.lean", "formal_statement": "theorem ideal.is_prime_of_is_prime_prod_top {R : Type u} {S : Type v} [ring R]\n\t[ring S] {I : ideal R} (h : (I.prod \u22a4).is_prime) :\n\tI.is_prime :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $I$ be an ideal of $R$. If $I\\cdot S$ is a prime ideal of $R\\otimes S$, then $I$ is a prime ideal of $R$."}
{"name": "set.mem_diff_singleton_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.mem_diff_singleton_empty {\u03b1 : Type u} {s : set \u03b1} {t : set (set \u03b1)} :\n\ts \u2208 t \\ {\u2205} \u2194 s \u2208 t \u2227 s.nonempty :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $s\\in t\\setminus\\{\\emptyset\\}$ if and only if $s\\in t$ and $s$ is nonempty."}
{"name": "real.totally_bounded_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/real.lean", "formal_statement": "theorem real.totally_bounded_ball (x \u03b5 : \u211d) :\n\ttotally_bounded (metric.ball x \u03b5) :=", "nl_statement_of_codex": "The ball of radius $\\epsilon$ around $x$ is totally bounded."}
{"name": "convolution_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convolution.lean", "formal_statement": "theorem convolution_smul {\ud835\udd5c G E E' F : Type*} [normed_group E] [normed_group E']\n\t[normed_group F] {f : G \u2192 E} {g : G \u2192 E'} [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_space \ud835\udd5c E] [normed_space \ud835\udd5c E'] [normed_space \ud835\udd5c F]\n\t{L : E \u2192L[\ud835\udd5c] E' \u2192L[\ud835\udd5c] F} [measurable_space G] {\u03bc : measure_theory.measure G}\n\t[normed_space \u211d F] [complete_space F] [add_group G] [smul_comm_class \u211d \ud835\udd5c F]\n\t{y : \ud835\udd5c} :\n\tconvolution f (y \u2022 g) L \u03bc = y \u2022 convolution f g L \u03bc :=", "nl_statement_of_codex": "Let $E, E', F$ be normed groups, $f:G\\to E$, $g:G\\to E'$, $L:E\\to E'\\to F$ be a bilinear map, and $\\mu$ be a measure on $G$. Then the convolution of $f$ and $y\\cdot g$ is equal to $y\\cdot$ the convolution of $f$ and $g$."}
{"name": "alg_equiv.restrict_normal_commutes", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/normal.lean", "formal_statement": "theorem alg_equiv.restrict_normal_commutes {F : Type*} [field F] {K\u2081 K\u2082 : Type*}\n\t[field K\u2081] [field K\u2082] [algebra F K\u2081] [algebra F K\u2082] (\u03c7 : K\u2081 \u2243\u2090[F] K\u2082)\n\t(E : Type*) [field E] [algebra F E] [algebra E K\u2081] [algebra E K\u2082]\n\t[is_scalar_tower F E K\u2081] [is_scalar_tower F E K\u2082] [normal F E] (x : E) :\n\t\u21d1(algebra_map E K\u2082) (\u21d1(\u03c7.restrict_normal E) x) = \u21d1\u03c7 (\u21d1(algebra_map E K\u2081) x) :=", "nl_statement_of_codex": "Let $F$ be a field, let $K_1$ and $K_2$ be $F$-algebras, and let $\\chi:K_1\\to K_2$ be an $F$-algebra isomorphism. Let $E$ be a field extension of $F$ such that $E$ is normal over $F$ and $K_1$ and $K_2$ are $E$-algebras. Then the restriction of $\\chi$ to $E$ commutes with the algebra maps $E\\to K_1$ and $E\\to K_2$."}
{"name": "emetric.tendsto_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean", "formal_statement": "theorem emetric.tendsto_nhds {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t{f : filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n\tfilter.tendsto u f (nhds a) \u2194 \u2200 (\u03b5 : ennreal), \u03b5 > 0 \u2192 (\u2200\u1da0 (x : \u03b2) in f, has_edist.edist (u x) a < \u03b5) :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $f:Y\\to X$ be a function. Then $f$ converges to $x\\in X$ if and only if for every $\\epsilon>0$ there is a neighborhood $U$ of $x$ such that $f(y)\\in U$ for all $y$ in a neighborhood of $x$."}
{"name": "seq1.map_join'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/seq.lean", "formal_statement": "theorem seq1.map_join' {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (S : seq (seq1 \u03b1)) :\n\tseq.map f S.join = (seq.map (seq1.map f) S).join :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $S$ be a sequence of sequences of elements of $A$. Then the sequence of sequences of elements of $B$ obtained by applying $f$ to each element of $S$ is equal to the sequence obtained by applying $f$ to each element of each sequence in $S$."}
{"name": "simple_graph.preconnected.set_univ_walk_nonempty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.preconnected.set_univ_walk_nonempty {V : Type u}\n\t{G : simple_graph V} (hconn : G.preconnected) (u v : V) :\n\tset.univ.nonempty :=", "nl_statement_of_codex": "Let $G$ be a simple graph. If $G$ is preconnected, then the set of all walks from $u$ to $v$ is nonempty."}
{"name": "algebraic_geometry.structure_sheaf.to_stalk_stalk_specializes_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.structure_sheaf.to_stalk_stalk_specializes_assoc\n\t{R : Type*} [comm_ring R] {x y : prime_spectrum R} (h : x \u2933 y) {X' : CommRing}\n\t(f' : (algebraic_geometry.Spec.structure_sheaf R).val.stalk x \u27f6 X') :\n\talgebraic_geometry.structure_sheaf.to_stalk R y \u226b (algebraic_geometry.Spec.structure_sheaf R).val.stalk_specializes h \u226b f' = algebraic_geometry.structure_sheaf.to_stalk R x \u226b f' :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $x, y$ be prime ideals of $R$, and let $f':R_x\\to X'$ be a ring homomorphism. If $x\\subset y$, then the diagram\n\\[\n\\begin{tikzcd}\nR_y \\arrow[r, "}
{"name": "equiv.perm.is_cycle.exists_unique_cycle_nontrivial_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/concrete.lean", "formal_statement": "theorem equiv.perm.is_cycle.exists_unique_cycle_nontrivial_subtype {\u03b1 : Type*}\n\t[fintype \u03b1] [decidable_eq \u03b1] {f : equiv.perm \u03b1} (hf : f.is_cycle) :\n\t\u2203! (s : {s // s.nodup \u2227 s.nontrivial}), \u2191s.form_perm _ = f :=", "nl_statement_of_codex": "Let $f$ be a permutation of a finite set $X$. Then there is a unique cycle $s$ of $f$ such that $s$ is a nontrivial subset of $X$."}
{"name": "disjoint.image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem disjoint.image {\u03b1 \u03b2 : Type*} {s t u : set \u03b1} {f : \u03b1 \u2192 \u03b2}\n\t(h : disjoint s t) (hf : set.inj_on f u) (hs : s \u2286 u) (ht : t \u2286 u) :\n\tdisjoint (f '' s) (f '' t) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be an injective function. If $A,B\\subset X$ are disjoint, then $f(A),f(B)\\subset Y$ are disjoint."}
{"name": "linear_equiv.ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_equiv.ker {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] {module_M : module R M}\n\t{module_M\u2082 : module R\u2082 M\u2082} {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}\n\t{re\u2081\u2082 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2081 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082}\n\t(e : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n\t\u2191e.ker = \u22a5 :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $M$ and $M'$ be $R$-modules, and let $\u03c3:R\\to R'$ be a ring homomorphism. Then the kernel of a linear equivalence $e:M\\to M'$ is the trivial submodule of $M$."}
{"name": "continuous_linear_map.smul_comp_Lp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/lp_space.lean", "formal_statement": "theorem continuous_linear_map.smul_comp_Lp {\u03b1 E F : Type*}\n\t{m0 : measurable_space \u03b1} {p : ennreal} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group E] [normed_group F] {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_space \ud835\udd5c E] [normed_space \ud835\udd5c F] {\ud835\udd5c' : Type*} [normed_field \ud835\udd5c']\n\t[normed_space \ud835\udd5c' F] [smul_comm_class \ud835\udd5c \ud835\udd5c' F] ( : \ud835\udd5c') (L : E \u2192L[\ud835\udd5c] F)\n\t(f : \u21a5(measure_theory.Lp E p \u03bc)) :\n\t(c \u2022 L).comp_Lp f = c \u2022 L.comp_Lp f :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed groups, let $L:E\\to F$ be a continuous linear map, and let $f\\in L^p(E)$. Then $cL\\circ f=c(L\\circ f)$."}
{"name": "cont_diff_at.ccos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem cont_diff_at.ccos {E : Type*} [normed_group E] [normed_space \u2102 E]\n\t{f : E \u2192 \u2102} {x : E} {n : with_top \u2115} (hf : cont_diff_at \u2102 n f x) :\n\tcont_diff_at \u2102 n (\u03bb (x : E), complex.cos (f x)) x :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{C}$ and let $f:E\\to\\mathbb{C}$. If $f$ is $n$ times continuously differentiable at $x$, then $\\cos(f)$ is $n$ times continuously differentiable at $x$."}
{"name": "measure_theory.ae_eq_set_inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space_def.lean", "formal_statement": "theorem measure_theory.ae_eq_set_inter {\u03b1 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {s t s' t' : set \u03b1} (h : s =\u1d50[\u03bc] t)\n\t(h' : s' =\u1d50[\u03bc] t') :\n\ts \u2229 s' =\u1d50[\u03bc] t \u2229 t' :=", "nl_statement_of_codex": "Let $s,t,s',t'$ be measurable sets. If $s$ and $t$ are equal almost everywhere and $s'$ and $t'$ are equal almost everywhere, then $s\\cap s'$ and $t\\cap t'$ are equal almost everywhere."}
{"name": "interval_integrable.sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/interval_integral.lean", "formal_statement": "theorem interval_integrable.sub {E : Type*} [normed_group E] {f g : \u211d \u2192 E}\n\t{a b : \u211d} {\u03bc : measure_theory.measure \u211d} (hf : interval_integrable f \u03bc a b)\n\t(hg : interval_integrable g \u03bc a b) :\n\tinterval_integrable (\u03bb (x : \u211d), f x - g x) \u03bc a b :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{R}\\to E$ be two integrable functions on the interval $[a,b]$. Then $f-g$ is integrable on $[a,b]$."}
{"name": "convex_join_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/join.lean", "formal_statement": "theorem convex_join_mono {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[module \ud835\udd5c E] {s\u2081 s\u2082 t\u2081 t\u2082 : set E} (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) :\n\tconvex_join \ud835\udd5c s\u2081 t\u2081 \u2286 convex_join \ud835\udd5c s\u2082 t\u2082 :=", "nl_statement_of_codex": "Let $E$ be a vector space over a field $K$ and let $s_1, s_2, t_1, t_2$ be subsets of $E$. If $s_1\\subset s_2$ and $t_1\\subset t_2$, then $s_1+t_1\\subset s_2+t_2$."}
{"name": "to_boolalg_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/boolean_ring.lean", "formal_statement": "theorem to_boolalg_inj {\u03b1 : Type*} {a b : \u03b1} :\n\t\u21d1to_boolalg a = \u21d1to_boolalg b \u2194 a = b :=", "nl_statement_of_codex": "The map $a\\mapsto \\overline{a}$ is injective."}
{"name": "set.inter_Inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.inter_Inter {\u03b2 : Type*} {\u03b9 : Sort u_4} [nonempty \u03b9] (s : set \u03b2)\n\t(t : \u03b9 \u2192 set \u03b2) :\n\t(s \u2229 \u22c2 (i : \u03b9), t i) = \u22c2 (i : \u03b9), s \u2229 t i :=", "nl_statement_of_codex": "Let $s$ be a set and let $\\{t_i\\}_{i\\in I}$ be a family of sets. Then $s\\cap\\bigcap_{i\\in I}t_i=\\bigcap_{i\\in I}(s\\cap t_i)$."}
{"name": "infi_Union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem infi_Union {\u03b1 \u03b2 : Type*} {\u03b9 : Sort u_4} [complete_lattice \u03b2]\n\t(s : \u03b9 \u2192 set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n\t(\u2a05 (a : \u03b1) (H : a \u2208 \u22c3 (i : \u03b9), s i), f a) = \u2a05 (i : \u03b9) (a : \u03b1) (H : a \u2208 s i), f a :=", "nl_statement_of_codex": "Let $s$ be a family of sets and let $f$ be a function. Then $\\inf_{a\\in\\bigcup_{i\\in I}s_i}f(a)=\\inf_{i\\in I}\\inf_{a\\in s_i}f(a)$."}
{"name": "padic_val_int.one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_val.lean", "formal_statement": "theorem padic_val_int.one {p : \u2115} :\n\tpadic_val_int p 1 = 0 :=", "nl_statement_of_codex": "The $p$-adic valuation of $1$ is $0$."}
{"name": "open_subgroup.is_closed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/open_subgroup.lean", "formal_statement": "theorem open_subgroup.is_closed {G : Type*} [group G] [topological_space G]\n\t[has_continuous_mul G] (U : open_subgroup G) :\n\tis_closed \u2191U :=", "nl_statement_of_codex": "Let $G$ be a topological group. Then the closure of an open subgroup of $G$ is closed."}
{"name": "self_eq_mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem self_eq_mul_left {M : Type u} [right_cancel_monoid M] {a b : M} :\n\tb = a * b \u2194 a = 1 :=", "nl_statement_of_codex": "Let $M$ be a right-cancellative monoid. Then $b=ab$ if and only if $a=1$."}
{"name": "supr_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/complete_lattice.lean", "formal_statement": "theorem supr_subtype {\u03b1 : Type*} {\u03b9 : Sort u_5} [complete_lattice \u03b1]\n\t{p : \u03b9 \u2192 Prop} {f : subtype p \u2192 \u03b1} :\n\tsupr f = \u2a06 (i : \u03b9) (h : p i), f \u27e8i, h\u27e9 :=", "nl_statement_of_codex": "Let $X$ be a complete lattice and let $f:X\\to X$ be a function. Then $\\sup f=\\sup_{x\\in X}f(x)$."}
{"name": "Top.presheaf.sheaf_condition_pairwise_intersections.pushforward_sheaf_of_sheaf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sheaves/functors.lean", "formal_statement": "theorem Top.presheaf.sheaf_condition_pairwise_intersections.pushforward_sheaf_of_sheaf\n\t{C : Type u\u2081} [category_theory.category C] {X Y : Top} (f : X \u27f6 Y)\n\t{F : Top.presheaf C X} (h : F.is_sheaf_pairwise_intersections) :\n\t(f _* F).is_sheaf_pairwise_intersections :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous map of topological spaces. If $F$ is a sheaf on $X$, then $f_*F$ is a sheaf on $Y$."}
{"name": "with_top.range_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/with_bot_top.lean", "formal_statement": "theorem with_top.range_coe {\u03b1 : Type*} [partial_order \u03b1] :\n\tset.range coe = set.Iio \u22a4 :=", "nl_statement_of_codex": "The range of the coe function is the set of all elements less than or equal to the top element."}
{"name": "box_integral.box.subbox_induction_on'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/box/subbox_induction.lean", "formal_statement": "theorem box_integral.box.subbox_induction_on' {\u03b9 : Type*}\n\t{p : box_integral.box \u03b9 \u2192 Prop} (I : box_integral.box \u03b9)\n\t(H_ind : \u2200 (J : box_integral.box \u03b9), J \u2264 I \u2192 (\u2200 (s : set \u03b9), p (J.split_center_box s)) \u2192 p J)\n\t(H_nhds : \u2200 (z : \u03b9 \u2192 \u211d), z \u2208 \u21d1box_integral.box.Icc I \u2192 (\u2203 (U : set (\u03b9 \u2192 \u211d)) (H : U \u2208 nhds_within z (\u21d1box_integral.box.Icc I)), \u2200 (J : box_integral.box \u03b9), J \u2264 I \u2192 \u2200 (m : \u2115), z \u2208 \u21d1box_integral.box.Icc J \u2192 \u21d1box_integral.box.Icc J \u2286 U \u2192 (\u2200 (i : \u03b9), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) \u2192 p J)) :\n\tp I :=", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$. Suppose that for each box $J$ contained in $I$ and for each subset $s$ of $\\{1,\\ldots,n\\}$, the box $J$ can be split into two boxes $J_1$ and $J_2$ such that $J_1$ is contained in $I$ and $J_2$ is contained in $I$ and $J_1$ and $J_2$ are disjoint and $J_1$ and $J_2$ are contained in $I$ and $J_1$ and $J_2$ are disjoint and $"}
{"name": "intermediate_field.induction_on_adjoin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/adjoin.lean", "formal_statement": "theorem intermediate_field.induction_on_adjoin {F : Type*} [field F] {E : Type*}\n\t[field E] [algebra F E] [fd : finite_dimensional F E]\n\t(P : intermediate_field F E \u2192 Prop) (base : P \u22a5)\n\t(ih : \u2200 (K : intermediate_field F E) (x : E), P K \u2192 P (intermediate_field.restrict_scalars F (\u21a5K)\u27eex\u27ef))\n\t(K : intermediate_field F E) :\n\tP K :=", "nl_statement_of_codex": "Let $F$ be a field, let $E$ be a finite dimensional $F$-algebra, and let $K$ be an intermediate field of $F$ and $E$. Let $P$ be a property of intermediate fields of $F$ and $E$. Suppose that $P$ holds for the trivial intermediate field, and suppose that if $K$ is an intermediate field of $F$ and $E$ and $x\\in E$, then $P(K)$ implies $P(K(x))$. Then $P(K)$ holds."}
{"name": "power_series.order_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_series/basic.lean", "formal_statement": "theorem power_series.order_X {R : Type*} [semiring R] [nontrivial R] :\n\tpower_series.X.order = 1 :=", "nl_statement_of_codex": "The order of the power series $X$ is $1$."}
{"name": "category_theory.limits.\u03b9_colimit_const_initial_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/terminal.lean", "formal_statement": "theorem category_theory.limits.\u03b9_colimit_const_initial_hom {J : Type*}\n\t[category_theory.category J] {C : Type*} [category_theory.category C]\n\t[category_theory.limits.has_initial C] {j : J} :\n\tcategory_theory.limits.colimit.\u03b9 ((category_theory.functor.const J).obj (\u22a5_ C)) j \u226b category_theory.limits.colimit_const_initial.hom = category_theory.limits.initial.to (\u22a5_ C) :=", "nl_statement_of_codex": "Let $J$ be a category and $C$ be a category with an initial object. Then the colimit of the constant functor $J\\to C$ is the initial object of $C$."}
{"name": "and_congr_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem and_congr_left {a b c : Prop} (h : c \u2192 (a \u2194 b)) :\n\ta \u2227 c \u2194 b \u2227 c :=", "nl_statement_of_codex": "If $a$ and $b$ are propositions and $c$ is a proposition such that $c$ implies $a$ if and only if $b$, then $a$ and $c$ if and only if $b$ and $c$."}
{"name": "power_basis.equiv_of_root_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_basis.lean", "formal_statement": "theorem power_basis.equiv_of_root_apply {S : Type*} [comm_ring S] {A : Type*}\n\t[comm_ring A] [algebra A S] {S' : Type*} [comm_ring S'] [algebra A S']\n\t[is_domain A] (pb : power_basis A S) (pb' : power_basis A S')\n\t(h\u2081 : \u21d1(polynomial.aeval pb.gen) (minpoly A pb'.gen) = 0)\n\t(h\u2082 : \u21d1(polynomial.aeval pb'.gen) (minpoly A pb.gen) = 0) (\u1fb0 : S) :\n\t\u21d1(pb.equiv_of_root pb' h\u2081 h\u2082) \u1fb0 = \u21d1(pb.lift pb'.gen h\u2082) \u1fb0 :=", "nl_statement_of_codex": "Let $A$ be a domain and let $S$ and $S'$ be $A$-algebras. Let $pb$ and $pb'$ be power bases of $A$ over $S$ and $S'$, respectively. Suppose that the minimal polynomial of $pb'$ over $S$ is zero and that the minimal polynomial of $pb$ over $S'$ is zero. Then the map $pb.equiv_of_root pb' h\u2081 h\u2082$ is the same as the map $pb.lift pb'.gen h\u2082$."}
{"name": "bdd_below.union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem bdd_below.union {\u03b3 : Type w} [semilattice_inf \u03b3] {s t : set \u03b3} :\n\tbdd_below s \u2192 bdd_below t \u2192 bdd_below (s \u222a t) :=", "nl_statement_of_codex": "Let $s$ and $t$ be subsets of a complete lattice. If $s$ and $t$ are bounded below, then $s\\cup t$ is bounded below."}
{"name": "measure_theory.ae_strongly_measurable'.strongly_measurable_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/conditional_expectation.lean", "formal_statement": "theorem measure_theory.ae_strongly_measurable'.strongly_measurable_mk\n\t{\u03b1 \u03b2 : Type*} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hfm : measure_theory.ae_strongly_measurable' m f \u03bc) :\n\tmeasure_theory.strongly_measurable (measure_theory.ae_strongly_measurable'.mk f hfm) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between measurable spaces. If $f$ is almost everywhere strongly measurable, then $f$ is strongly measurable."}
{"name": "Sup_inf_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/complete_boolean_algebra.lean", "formal_statement": "theorem Sup_inf_eq {\u03b1 : Type u} [order.frame \u03b1] {s : set \u03b1} {b : \u03b1} :\n\thas_Sup.Sup s \u2293 b = \u2a06 (a : \u03b1) (H : a \u2208 s), a \u2293 b :=", "nl_statement_of_codex": "Let $s$ be a set of elements of a frame $\u03b1$. Then $\\sup s\\wedge b=\\bigvee_{a\\in s}a\\wedge b$."}
{"name": "formal_multilinear_series.comp_along_composition_nnnorm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/analytic/composition.lean", "formal_statement": "theorem formal_multilinear_series.comp_along_composition_nnnorm\n\t{\ud835\udd5c E F G : Type*} [nondiscrete_normed_field \ud835\udd5c] [normed_group E]\n\t[normed_space \ud835\udd5c E] [normed_group F] [normed_space \ud835\udd5c F] [normed_group G]\n\t[normed_space \ud835\udd5c G] {n : \u2115} (q : formal_multilinear_series \ud835\udd5c F G)\n\t(p : formal_multilinear_series \ud835\udd5c E F) ( : composition n) :\n\t\u2225q.comp_along_composition p c\u2225\u208a \u2264 \u2225q c.length\u2225\u208a * finset.univ.prod (\u03bb (i : fin c.length), \u2225p (c.blocks_fun i)\u2225\u208a) :=", "nl_statement_of_codex": "Let $E, F, G$ be normed groups over a nondiscrete normed field $K$. Let $p:E\\to F$ and $q:F\\to G$ be formal multilinear series. Then $\\|q\\circ p\\|\\leq \\|q\\|\\prod_{i=1}^n\\|p_i\\|$."}
{"name": "is_antichain.eq'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/antichain.lean", "formal_statement": "theorem is_antichain.eq' {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : set \u03b1}\n\t(hs : is_antichain r s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (h : r b a) :\n\ta = b :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $S$. If $S$ is an antichain with respect to $r$, then $a,b\\in S$ and $r(b,a)$ implies $a=b$."}
{"name": "Pointed_to_PartialFun_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/PartialFun.lean", "formal_statement": "theorem Pointed_to_PartialFun_map (X Y : Pointed) (f : X \u27f6 Y)\n\t(\u1fb0 : {x // x \u2260 X.point}) :\n\tPointed_to_PartialFun.map f \u1fb0 = (pfun.to_subtype (\u03bb (x : \u21a5Y), x \u2260 Y.point) f.to_fun \u2218 subtype.val) \u1fb0 :=", "nl_statement_of_codex": "Let $X$ and $Y$ be pointed spaces and let $f:X\\to Y$ be a pointed map. Then the map $f$ induces a map $f:X\\setminus\\{x_0\\}\\to Y\\setminus\\{y_0\\}$."}
{"name": "category_theory.endofunctor.coalgebra.forget_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/endofunctor/algebra.lean", "formal_statement": "theorem category_theory.endofunctor.coalgebra.forget_map {C : Type u}\n\t[category_theory.category C] (F : C \u2964 C)\n\t(A B : category_theory.endofunctor.coalgebra F) (f : A \u27f6 B) :\n\t(category_theory.endofunctor.coalgebra.forget F).map f = f.f :=", "nl_statement_of_codex": "Let $F$ be an endofunctor on a category $C$. Let $A$ and $B$ be coalgebras for $F$. Let $f:A\\to B$ be a morphism. Then the forgetful map $F$ sends $f$ to $f$."}
{"name": "hamming_norm_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/information_theory/hamming.lean", "formal_statement": "theorem hamming_norm_comp {\u03b9 \u03b2 : \u03b9 \u2192 Type*} [fintype \u03b9]\n\t[\u03a0 (i : \u03b9), decidable_eq (\u03b2 i)] {\u03b3 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), decidable_eq (\u03b3 i)]\n\t[\u03a0 (i : \u03b9), has_zero (\u03b2 i)] [\u03a0 (i : \u03b9), has_zero (\u03b3 i)]\n\t(f : \u03a0 (i : \u03b9), \u03b3 i \u2192 \u03b2 i) {x : \u03a0 (i : \u03b9), \u03b3 i}\n\t(hf\u2081 : \u2200 (i : \u03b9), function.injective (f i)) (hf\u2082 : \u2200 (i : \u03b9), f i 0 = 0) :\n\thamming_norm (\u03bb (i : \u03b9), f i (x i)) = hamming_norm x :=", "nl_statement_of_codex": "Let $f_i: \\gamma_i\\to \\beta_i$ be injective functions for each $i\\in I$. Then the Hamming norm of $f_i(x_i)$ is equal to the Hamming norm of $x_i$."}
{"name": "pi_nat.apply_eq_of_lt_first_diff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/pi_nat.lean", "formal_statement": "theorem pi_nat.apply_eq_of_lt_first_diff {E : \u2115 \u2192 Type*} {x y : \u03a0 (n : \u2115), E n}\n\t{n : \u2115} (hn : n < pi_nat.first_diff x y) :\n\tx n = y n :=", "nl_statement_of_codex": "Let $x,y:\\mathbb{N}\\to E$ be two sequences. If $n<\\pi_\\mathbb{N}(x,y)$, then $x(n)=y(n)$."}
{"name": "nat.tendsto_pow_at_top_at_top_of_one_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/specific_limits/basic.lean", "formal_statement": "theorem nat.tendsto_pow_at_top_at_top_of_one_lt {m : \u2115} (h : 1 < m) :\n\tfilter.tendsto (\u03bb (n : \u2115), m ^ n) filter.at_top filter.at_top :=", "nl_statement_of_codex": "For $m>1$, the sequence $m^n$ tends to infinity."}
{"name": "pgame.restricted.le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.restricted.le {x y : pgame} (r : x.restricted y) :\n\tx \u2264 y :=", "nl_statement_of_codex": "Let $x$ and $y$ be partial games. If $x$ is a restriction of $y$, then $x\\leq y$."}
{"name": "fintype.pi_finset_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem fintype.pi_finset_singleton {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1]\n\t{\u03b4 : \u03b1 \u2192 Type*} (f : \u03a0 (i : \u03b1), \u03b4 i) :\n\tfintype.pi_finset (\u03bb (i : \u03b1), {f i}) = {f} :=", "nl_statement_of_codex": "Let $\u03b1$ be a finite type and let $\\delta$ be a family of types indexed by $\u03b1$. Then the set of functions from $\u03b1$ to $\\delta$ is equal to the set of functions from $\u03b1$ to $\\delta$ that are constant on $\u03b1$."}
{"name": "model_prod_range_prod_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/charted_space.lean", "formal_statement": "theorem model_prod_range_prod_id {H H' \u03b1 : Type*} (f : H \u2192 \u03b1) :\n\tset.range (\u03bb (p : model_prod H H'), (f p.fst, p.snd)) = set.range f \u00d7\u02e2 set.univ :=", "nl_statement_of_codex": "Let $H$ and $H'$ be sets and let $f:H\\to\\alpha$. Then the range of the function $g:H\\times H'\\to\\alpha\\times H'$ defined by $g(h,h')=(f(h),h')$ is equal to the product of the range of $f$ and the universe of $H'$."}
{"name": "linear_pmap.map_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_pmap.lean", "formal_statement": "theorem linear_pmap.map_add {R : Type*} [ring R] {E : Type*} [add_comm_group E]\n\t[module R E] {F : Type*} [add_comm_group F] [module R F]\n\t(f : linear_pmap R E F) (x y : \u21a5(f.domain)) :\n\t\u21d1f (x + y) = \u21d1f x + \u21d1f y :=", "nl_statement_of_codex": "Let $R$ be a ring, $E$ and $F$ be $R$-modules, and $f:E\\to F$ be a linear map. Then $f(x+y)=f(x)+f(y)$ for all $x,y\\in E$."}
{"name": "Sup_le_Sup_of_forall_exists_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/complete_lattice.lean", "formal_statement": "theorem Sup_le_Sup_of_forall_exists_le {\u03b1 : Type*} [complete_semilattice_Sup \u03b1]\n\t{s t : set \u03b1} (h : \u2200 (x : \u03b1), x \u2208 s \u2192 (\u2203 (y : \u03b1) (H : y \u2208 t), x \u2264 y)) :\n\thas_Sup.Sup s \u2264 has_Sup.Sup t :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets of elements of a complete lattice. If for each $x\\in s$ there is an element $y\\in t$ such that $x\\leq y$, then $\\sup s\\leq \\sup t$."}
{"name": "order.lt_succ_iff_eq_or_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/succ_pred/basic.lean", "formal_statement": "theorem order.lt_succ_iff_eq_or_lt {\u03b1 : Type*} [partial_order \u03b1] [succ_order \u03b1]\n\t{a b : \u03b1} [no_max_order \u03b1] :\n\ta < order.succ b \u2194 a = b \u2228 a < b :=", "nl_statement_of_codex": "Let $P$ be a poset with a unique maximal element. Then $a<b$ if and only if $a=b$ or $a<b$."}
{"name": "finset.filter_inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.filter_inter {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t[decidable_eq \u03b1] (s t : finset \u03b1) :\n\tfinset.filter p s \u2229 t = finset.filter p (s \u2229 t) :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a set $A$. Then the intersection of the set of elements of $A$ satisfying $p$ with a finite set $S$ is equal to the intersection of $S$ with the set of elements of $A$ satisfying $p$."}
{"name": "znum.cast_zero'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem znum.cast_zero' {\u03b1 : Type*} [has_zero \u03b1] [has_one \u03b1] [has_add \u03b1]\n\t[has_neg \u03b1] :\n\t\u2191znum.zero = 0 :=", "nl_statement_of_codex": "The zero of the type `znum` is equal to the zero of the type `\u2124`."}
{"name": "inv_mul_le_iff'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/field.lean", "formal_statement": "theorem inv_mul_le_iff' {\u03b1 : Type*} [linear_ordered_semifield \u03b1] {a b c : \u03b1}\n\t(h : 0 < b) :\n\tb\u207b\u00b9 * a \u2264 c \u2194 a \u2264 c * b :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear ordered semifield $R$. Then $b^{-1}a\\leq c$ if and only if $a\\leq cb$."}
{"name": "measure_theory.measure.sum_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.sum_apply {\u03b1 \u03b9 : Type*} {m0 : measurable_space \u03b1}\n\t(f : \u03b9 \u2192 measure_theory.measure \u03b1) {s : set \u03b1} (hs : measurable_set s) :\n\t\u21d1(measure_theory.measure.sum f) s = \u2211' (i : \u03b9), \u21d1(f i) s :=", "nl_statement_of_codex": "Let $f$ be a function from a set $I$ to the set of measures on a measurable space $(X,\\mathcal{A})$. Then $\\sum_{i\\in I}f(i)(A)=\\sum_{i\\in I}f(i)(A)$ for all $A\\in\\mathcal{A}$."}
{"name": "fractional_ideal.span_singleton_eq_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.span_singleton_eq_zero_iff {R : Type*} [comm_ring R]\n\t{S : submonoid R} {P : Type*} [comm_ring P] [algebra R P]\n\t[loc : is_localization S P] {y : P} :\n\tfractional_ideal.span_singleton S y = 0 \u2194 y = 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a submonoid of $R$, $P$ a commutative ring, and $y\\in P$. Then $y$ is in the fractional ideal generated by $1$ if and only if $y=0$."}
{"name": "locally_bounded_map.to_fun_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bornology/hom.lean", "formal_statement": "theorem locally_bounded_map.to_fun_eq_coe {\u03b1 \u03b2 : Type*} [bornology \u03b1]\n\t[bornology \u03b2] {f : locally_bounded_map \u03b1 \u03b2} :\n\tf.to_fun = \u21d1f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a locally bounded map between bornological spaces. Then $f$ is equal to the map $x\\mapsto f(x)$."}
{"name": "matrix.one_fin_three", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/notation.lean", "formal_statement": "theorem matrix.one_fin_three {\u03b1 : Type u} [has_zero \u03b1] [has_one \u03b1] :\n\t1 = \u21d1matrix.of ![![1, 0, 0], ![0, 1, 0], ![0, 0, 1]] :=", "nl_statement_of_codex": "The identity matrix in dimension $3$ is the matrix $I_3$."}
{"name": "linear_ordered_field.induced_map_inv_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/complete_field.lean", "formal_statement": "theorem linear_ordered_field.induced_map_inv_self (\u03b2 \u03b3 : Type*)\n\t[conditionally_complete_linear_ordered_field \u03b2]\n\t[conditionally_complete_linear_ordered_field \u03b3] (b : \u03b2) :\n\tlinear_ordered_field.induced_map \u03b3 \u03b2 (linear_ordered_field.induced_map \u03b2 \u03b3 b) = b :=", "nl_statement_of_codex": "Let $\u03b2$ and $\u03b3$ be conditionally complete ordered fields. Then the map $\u03b3\\to \u03b2$ induced by the map $\u03b2\\to \u03b3$ induced by $b\\in \u03b2$ is the identity map."}
{"name": "filter.tendsto.const_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/monoid.lean", "formal_statement": "theorem filter.tendsto.const_add {\u03b1 M : Type*} [topological_space M] [has_add M]\n\t[has_continuous_add M] (b : M) { : M} {f : \u03b1 \u2192 M} {l : filter \u03b1}\n\t(h : filter.tendsto (\u03bb (k : \u03b1), f k) l (nhds c)) :\n\tfilter.tendsto (\u03bb (k : \u03b1), b + f k) l (nhds (b + c)) :=", "nl_statement_of_codex": "Let $M$ be a topological space with continuous addition. Let $f:X\\to M$ be a function and let $b\\in M$. Then $f$ tends to $c$ if and only if $b+f$ tends to $b+c$."}
{"name": "path.homotopic.equivalence", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homotopy/path.lean", "formal_statement": "theorem path.homotopic.equivalence {X : Type u} [topological_space X]\n\t{x\u2080 x\u2081 : X} :\n\tequivalence path.homotopic :=", "nl_statement_of_codex": "The relation of homotopy between paths in a topological space is an equivalence relation."}
{"name": "fractional_ideal.span_singleton_eq_span_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.span_singleton_eq_span_singleton {R : Type*}\n\t[comm_ring R] {S : submonoid R} {P : Type*} [comm_ring P] [algebra R P]\n\t[loc : is_localization S P] [no_zero_smul_divisors R P] {x y : P} :\n\tfractional_ideal.span_singleton S x = fractional_ideal.span_singleton S y \u2194 \u2203 (z : R\u02e3), z \u2022 x = y :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a submonoid of $R$, $P$ a commutative ring, and $x,y\\in P$. Then $x$ and $y$ are in the same fractional ideal of $S$ if and only if there is an element $z\\in R^\\times$ such that $zx=y$."}
{"name": "list.subset_append_right", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/list/lemmas.lean", "formal_statement": "theorem list.subset_append_right {\u03b1 : Type u} (l\u2081 l\u2082 : list \u03b1) :\n\tl\u2082 \u2286 l\u2081 ++ l\u2082 :=", "nl_statement_of_codex": "The list $l_2$ is a subset of the concatenation of $l_1$ and $l_2$."}
{"name": "tsub_add_tsub_cancel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem tsub_add_tsub_cancel {\u03b1 : Type*} [canonically_ordered_add_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b c : \u03b1} (hab : b \u2264 a) (hbc : c \u2264 b) :\n\ta - b + (b - c) = a - c :=", "nl_statement_of_codex": "Let $a, b, c$ be elements of a canonically ordered additive monoid with a subtraction operation. If $b\\leq a$ and $c\\leq b$, then $a-b+b-c=a-c$."}
{"name": "nat.frequently_at_top_modeq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/primes_congruent_one.lean", "formal_statement": "theorem nat.frequently_at_top_modeq_one {k : \u2115} (hpos : 0 < k) :\n\t\u2203\u1da0 (p : \u2115) in filter.at_top, nat.prime p \u2227 p \u2261 1 [MOD k] :=", "nl_statement_of_codex": "For each $k\\in\\mathbb{N}$, there are infinitely many primes $p$ such that $p\\equiv 1\\pmod{k}$."}
{"name": "measure_theory.simple_func.norm_approx_on_zero_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/simple_func_dense_lp.lean", "formal_statement": "theorem measure_theory.simple_func.norm_approx_on_zero_le {\u03b2 E : Type*}\n\t[measurable_space \u03b2] [measurable_space E] [normed_group E]\n\t[opens_measurable_space E] {f : \u03b2 \u2192 E} (hf : measurable f) {s : set E}\n\t(h\u2080 : 0 \u2208 s) [topological_space.separable_space \u21a5s] (x : \u03b2) (n : \u2115) :\n\t\u2225\u21d1(measure_theory.simple_func.approx_on f hf s 0 h\u2080 n) x\u2225 \u2264 \u2225f x\u2225 + \u2225f x\u2225 :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $f:X\\to E$ be a measurable function. Then for any $x\\in X$ and any $n\\in\\mathbb{N}$, we have $\\|\\mathrm{approx}_n(f,0)(x)\\|\\leq\\|f(x)\\|+\\|f(x)\\|$."}
{"name": "is_add_subgroup.add_mem_cancel_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_subgroup.add_mem_cancel_left {G : Type*} {a b : G} [add_group G]\n\t{s : set G} (hs : is_add_subgroup s) (h : a \u2208 s) :\n\ta + b \u2208 s \u2194 b \u2208 s :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $s$ be a subgroup of $G$. Then $a+b\\in s$ if and only if $b\\in s$."}
{"name": "multiset.quot_mk_to_coe'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.quot_mk_to_coe' {\u03b1 : Type*} (l : list \u03b1) :\n\tquot.mk has_equiv.equiv l = \u2191l :=", "nl_statement_of_codex": "The multiset $[l]$ is equal to the multiset $l$."}
{"name": "abs_nonpos_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem abs_nonpos_iff {\u03b1 : Type u} [add_group \u03b1] [linear_order \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a : \u03b1} :\n\t|a| \u2264 0 \u2194 a = 0 :=", "nl_statement_of_codex": "Let $a$ be an element of an ordered additive group. Then $|a|\\leq 0$ if and only if $a=0$."}
{"name": "loc_path_connected_of_is_open", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/path_connected.lean", "formal_statement": "theorem loc_path_connected_of_is_open {X : Type*} [topological_space X]\n\t[loc_path_connected_space X] {U : set X} (h : is_open U) :\n\tloc_path_connected_space \u21a5U :=", "nl_statement_of_codex": "Let $X$ be a locally path-connected space. If $U$ is an open subset of $X$, then $U$ is locally path-connected."}
{"name": "bilin_form.ne_zero_of_not_is_ortho_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/bilinear_form.lean", "formal_statement": "theorem bilin_form.ne_zero_of_not_is_ortho_self {V K : Type*0} [field K]\n\t[add_comm_group V] [module K V] {B : bilin_form K V} (x : V)\n\t(hx\u2081 : \u00acB.is_ortho x x) :\n\tx \u2260 0 :=", "nl_statement_of_codex": "Let $V$ be a vector space over a field $K$ and let $B$ be a bilinear form on $V$. If $x\\in V$ is not orthogonal to itself, then $x\\neq 0$."}
{"name": "polynomial.C_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.C_inj {R : Type u} {a b : R} [semiring R] :\n\t\u21d1polynomial.C a = \u21d1polynomial.C b \u2194 a = b :=", "nl_statement_of_codex": "The constant polynomial $a$ is equal to the constant polynomial $b$ if and only if $a=b$."}
{"name": "nat.totient_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/totient.lean", "formal_statement": "theorem nat.totient_zero :\n\t0.totient = 0 :=", "nl_statement_of_codex": "The totient of $0$ is $0$."}
{"name": "ordnode.all_iff_forall", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.all_iff_forall {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} {t : ordnode \u03b1} :\n\tordnode.all P t \u2194 \u2200 (x : \u03b1), ordnode.emem x t \u2192 P x :=", "nl_statement_of_codex": "Let $t$ be an ordered node. Then $t$ satisfies the predicate $P$ if and only if $P$ holds for all elements of $t$."}
{"name": "ennreal.summable_to_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.summable_to_real {\u03b1 : Type*} {f : \u03b1 \u2192 ennreal}\n\t(hsum : \u2211' (x : \u03b1), f x \u2260 \u22a4) :\n\tsummable (\u03bb (x : \u03b1), (f x).to_real) :=", "nl_statement_of_codex": "Let $f:\\alpha\\to\\mathbb{R}_{\\geq 0}$ be a function. If $\\sum_{x\\in\\alpha}f(x)$ is finite, then $\\sum_{x\\in\\alpha}f(x)$ is finite."}
{"name": "array.write_eq_write'", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/array/basic.lean", "formal_statement": "theorem array.write_eq_write' {n : \u2115} {\u03b1 : Type u} (a : array n \u03b1) {i : \u2115}\n\t(h : i < n) (v : \u03b1) :\n\ta.write \u27e8i, h\u27e9 v = a.write' i v :=", "nl_statement_of_codex": "Let $a$ be an array of length $n$ and let $i$ be an integer such that $0\\leq i<n$. Then $a.write(i,v)=a.write'(i,v)$."}
{"name": "real.continuous_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/real.lean", "formal_statement": "theorem real.continuous_mul :\n\tcontinuous (\u03bb (p : \u211d \u00d7 \u211d), p.fst * p.snd) :=", "nl_statement_of_codex": "The function $(x,y)\\mapsto xy$ is continuous on $\\mathbb{R}^2$."}
{"name": "le_or_gt", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/algebra/order.lean", "formal_statement": "theorem le_or_gt {\u03b1 : Type u} [linear_order \u03b1] (a b : \u03b1) :\n\ta \u2264 b \u2228 a > b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a linear order. Then $a\\leq b$ or $a>b$."}
{"name": "affine_equiv.surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_equiv.lean", "formal_statement": "theorem affine_equiv.surjective {k P\u2081 P\u2082 V\u2081 V\u2082 : Type*} [ring k]\n\t[add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081] [add_comm_group V\u2082]\n\t[module k V\u2082] [add_torsor V\u2082 P\u2082] (e : P\u2081 \u2243\u1d43[k] P\u2082) :\n\tfunction.surjective \u21d1e :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ and $V_2$ be $k$-modules, and $P_1$ and $P_2$ be $k$-affine spaces. If $e:P_1\\to P_2$ is an affine equivalence, then $e$ is surjective."}
{"name": "subalgebra.to_subsemiring_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem subalgebra.to_subsemiring_injective {R : Type u} {A : Type v}\n\t[comm_semiring R] [semiring A] [algebra R A] :\n\tfunction.injective subalgebra.to_subsemiring :=", "nl_statement_of_codex": "The map from subalgebras of $A$ to subsemigroups of $A$ is injective."}
{"name": "mul_eq_one_iff_eq_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem mul_eq_one_iff_eq_inv {G : Type*} [group G] {a b : G} :\n\ta * b = 1 \u2194 a = b\u207b\u00b9 :=", "nl_statement_of_codex": "Let $G$ be a group and let $a, b\\in G$. Then $ab=1$ if and only if $a=b^{-1}$."}
{"name": "linear_pmap.ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_pmap.lean", "formal_statement": "theorem linear_pmap.ext_iff {R : Type*} [ring R] {E : Type*} [add_comm_group E]\n\t[module R E] {F : Type*} [add_comm_group F] [module R F]\n\t{f g : linear_pmap R E F} :\n\tf = g \u2194 \u2203 (domain_eq : f.domain = g.domain), \u2200 \u2983x : \u21a5(f.domain)\u2984 \u2983y : \u21a5(g.domain)\u2984, \u2191x = \u2191y \u2192 \u21d1f x = \u21d1g y :=", "nl_statement_of_codex": "Two linear maps $f, g:E\\to F$ are equal if and only if they have the same domain and $f(x)=g(x)$ for all $x\\in E$."}
{"name": "path.homotopy.continuous_trans_refl_reparam_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_topology/fundamental_groupoid/basic.lean", "formal_statement": "theorem path.homotopy.continuous_trans_refl_reparam_aux :\n\tcontinuous path.homotopy.trans_refl_reparam_aux :=", "nl_statement_of_codex": "The function $path.homotopy.trans_refl_reparam_aux$ is continuous."}
{"name": "inner_self_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem inner_self_nonneg {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E]\n\t{x : E} :\n\t0 \u2264 \u21d1is_R_or_C.re (has_inner.inner x x) :=", "nl_statement_of_codex": "Let $E$ be an inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Then the inner product of a vector with itself is nonnegative."}
{"name": "zsqrtd.coe_int_dvd_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.coe_int_dvd_iff {d : \u2124} (z : \u2124) (a : \u2124\u221ad) :\n\t\u2191z \u2223 a \u2194 z \u2223 a.re \u2227 z \u2223 a.im :=", "nl_statement_of_codex": "Let $d$ be a square-free integer and let $a$ be an element of $\\mathbb{Z}[\\sqrt{d}]$. Then $z\\mid a$ if and only if $z\\mid a.re$ and $z\\mid a.im$."}
{"name": "basis.constr_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basis.lean", "formal_statement": "theorem basis.constr_comp {\u03b9 R M M' : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] [add_comm_monoid M'] [module R M'] (b : basis \u03b9 R M) (S : Type*)\n\t[semiring S] [module S M'] [smul_comm_class R S M'] (f : M' \u2192\u2097[R] M')\n\t(v : \u03b9 \u2192 M') :\n\t\u21d1(b.constr S) (\u21d1f \u2218 v) = f.comp (\u21d1(b.constr S) v) :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, $M'$ an $R$-module, $S$ a semiring, $f:M'\\to M'$ an $R$-linear map, and $v:\\iota\\to M'$ a map. Then the composition of the map $b.constr S$ with the map $f\\circ v$ is equal to the composition of the map $f$ with the map $b.constr S$ applied to $v$."}
{"name": "equiv.set.image_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/set.lean", "formal_statement": "theorem equiv.set.image_symm_apply {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (s : set \u03b1)\n\t(H : function.injective f) (x : \u03b1) (h : x \u2208 s) :\n\t\u21d1((equiv.set.image f s H).symm) \u27e8f x, _\u27e9 = \u27e8x, h\u27e9 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then the inverse of the function $f:A\\to f(A)$ is the function $f^{-1}:f(A)\\to A$."}
{"name": "bitvec.of_fin_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bitvec/basic.lean", "formal_statement": "theorem bitvec.of_fin_val {n : \u2115} (i : fin (2 ^ n)) :\n\t(bitvec.of_fin i).to_nat = i.val :=", "nl_statement_of_codex": "The natural number corresponding to a finite bitvector is the same as the value of the finite bitvector."}
{"name": "uniform_continuous_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/uniform_group.lean", "formal_statement": "theorem uniform_continuous_div {\u03b1 : Type*} [uniform_space \u03b1] [group \u03b1]\n\t[uniform_group \u03b1] :\n\tuniform_continuous (\u03bb (p : \u03b1 \u00d7 \u03b1), p.fst / p.snd) :=", "nl_statement_of_codex": "The function $f:\\alpha\\times\\alpha\\to\\alpha$ defined by $f(x,y)=x/y$ is uniformly continuous."}
{"name": "complex.abs_im_div_abs_le_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/basic.lean", "formal_statement": "theorem complex.abs_im_div_abs_le_one (z : \u2102) :\n\t|z.im / complex.abs z| \u2264 1 :=", "nl_statement_of_codex": "$|\\mathrm{Im}(z)/|z||\\leq 1$."}
{"name": "set.pi_univ_Ioo_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/pi.lean", "formal_statement": "theorem set.pi_univ_Ioo_subset {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), preorder (\u03b1 i)]\n\t(x y : \u03a0 (i : \u03b9), \u03b1 i) [nonempty \u03b9] :\n\tset.univ.pi (\u03bb (i : \u03b9), set.Ioo (x i) (y i)) \u2286 set.Ioo x y :=", "nl_statement_of_codex": "Let $x,y:\\mathbb{N}\\to\\mathbb{R}$. Then $\\prod_{i\\in\\mathbb{N}}(x_i,y_i)\\subseteq (x,y)$."}
{"name": "finsupp.zip_with_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.zip_with_apply {\u03b1 M N P : Type*} [has_zero M] [has_zero N]\n\t[has_zero P] {f : M \u2192 N \u2192 P} {hf : f 0 0 = 0} {g\u2081 : \u03b1 \u2192\u2080 M} {g\u2082 : \u03b1 \u2192\u2080 N}\n\t{a : \u03b1} :\n\t\u21d1(finsupp.zip_with f hf g\u2081 g\u2082) a = f (\u21d1g\u2081 a) (\u21d1g\u2082 a) :=", "nl_statement_of_codex": "Let $f:M\\times N\\to P$ be a function such that $f(0,0)=0$. Let $g_1:A\\to M$ and $g_2:A\\to N$ be finitely supported functions. Then the finitely supported function $f\\circ (g_1,g_2):A\\to P$ is given by $(f\\circ (g_1,g_2))(a)=f(g_1(a),g_2(a))$."}
{"name": "mul_semiring_action.to_alg_equiv_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem mul_semiring_action.to_alg_equiv_injective {G : Type*} (R A : Type*)\n\t[comm_semiring R] [semiring A] [algebra R A] [group G]\n\t[mul_semiring_action G A] [smul_comm_class G R A] [has_faithful_smul G A] :\n\tfunction.injective (mul_semiring_action.to_alg_equiv R A) :=", "nl_statement_of_codex": "Let $G$ be a group acting on a semiring $A$ by semiring automorphisms. Then the map $G\\to \\mathrm{Aut}_R(A)$ is injective."}
{"name": "measure_theory.with_density_congr_ae", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.with_density_congr_ae {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f g : \u03b1 \u2192 ennreal}\n\t(h : f =\u1d50[\u03bc] g) :\n\t\u03bc.with_density f = \u03bc.with_density g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\mathbb{R}$ be measurable functions. If $f=g$ almost everywhere, then the measures $\\mu_f$ and $\\mu_g$ are equal."}
{"name": "direct_sum.ring_hom_ext'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/ring.lean", "formal_statement": "theorem direct_sum.ring_hom_ext' {\u03b9 : Type*} [decidable_eq \u03b9] {A R : Type*}\n\t[\u03a0 (i : \u03b9), add_comm_monoid (A i)] [add_monoid \u03b9] [direct_sum.gsemiring A]\n\t[semiring R] \u2983F G : direct_sum \u03b9 (\u03bb (i : \u03b9), A i) \u2192+* R\u2984\n\t(h : \u2200 (i : \u03b9), \u2191F.comp (direct_sum.of A i) = \u2191G.comp (direct_sum.of A i)) :\n\tF = G :=", "nl_statement_of_codex": "Let $A$ be a direct sum of commutative monoids. Let $F, G:A\\to R$ be ring homomorphisms. Then $F=G$ if and only if $F(a)=G(a)$ for all $a\\in A$."}
{"name": "simple_graph.subgraph.coe_adj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/subgraph.lean", "formal_statement": "theorem simple_graph.subgraph.coe_adj {V : Type u} {G : simple_graph V}\n\t(G' : G.subgraph) (v w : \u21a5(G'.verts)) :\n\tG'.coe.adj v w = G'.adj \u2191v \u2191w :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $G'$ be a subgraph of $G$. Then $G'.adj(v,w)=G.adj(v,w)$ for all $v,w\\in G'$."}
{"name": "category_theory.adjunction.cones_iso_component_inv_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/limits.lean", "formal_statement": "theorem category_theory.adjunction.cones_iso_component_inv_app {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t{F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) {J : Type u} [category_theory.category J]\n\t{K : J \u2964 D} (X : C\u1d52\u1d56) (t : ((category_theory.cones J C).obj (K \u22d9 G)).obj X)\n\t(j : J) :\n\t(adj.cones_iso_component_inv X t).app j = \u21d1((adj.hom_equiv (opposite.unop X) (K.obj j)).symm) (t.app j) :=", "nl_statement_of_codex": "Let $F:C\\to D$ and $G:D\\to C$ be adjoint functors. Let $X$ be an object of $C^\\text{op}$ and let $t$ be a cone over $K\\circ G$ with vertex $X$. Then the $j$-th component of the inverse of the isomorphism between the cone over $K\\circ G$ with vertex $X$ and the cone over $K\\circ F$ with vertex $G(X)$ is the inverse of the isomorphism between $G(X)$ and $X$ composed with the $j$-th component of $t$."}
{"name": "Twop_swap_comp_forget_to_Bipointed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/Twop.lean", "formal_statement": "theorem Twop_swap_comp_forget_to_Bipointed :\n\tTwop.swap \u22d9 category_theory.forget\u2082 Twop Bipointed = category_theory.forget\u2082 Twop Bipointed \u22d9 Bipointed.swap :=", "nl_statement_of_codex": "The functor $Twop\\to Bipointed$ is the composition of the functor $Twop\\to Bipointed$ with the functor $Bipointed\\to Bipointed$."}
{"name": "magma.free_semigroup.of_mul_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/free.lean", "formal_statement": "theorem magma.free_semigroup.of_mul_assoc {\u03b1 : Type u} [has_mul \u03b1] (x y z : \u03b1) :\n\tmagma.free_semigroup.of (x * y * z) = magma.free_semigroup.of (x * (y * z)) :=", "nl_statement_of_codex": "Let $x,y,z$ be elements of a magma. Then the free semigroup generated by $x*y*z$ is equal to the free semigroup generated by $x*(y*z)$."}
{"name": "linear_equiv.map_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/equiv.lean", "formal_statement": "theorem linear_equiv.map_zero {R S M M\u2082 : Type*} [semiring R] [semiring S]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] {module_M : module R M}\n\t{module_S_M\u2082 : module S M\u2082} {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}\n\t{re\u2081 : ring_hom_inv_pair \u03c3 \u03c3'} {re\u2082 : ring_hom_inv_pair \u03c3' \u03c3} (e : M \u2243\u209b\u2097[\u03c3] M\u2082) :\n\t\u21d1e 0 = 0 :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings, let $M$ and $M_2$ be $R$-modules, and let $\u03c3:R\\to S$ be a ring homomorphism. If $e:M\\to M_2$ is a linear equivalence, then $e(0)=0$."}
{"name": "first_order.language.embedding.cod_restrict_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/substructures.lean", "formal_statement": "theorem first_order.language.embedding.cod_restrict_apply\n\t{L : first_order.language} {M : Type w} {N : Type*} [L.Structure M]\n\t[L.Structure N] (p : L.substructure N) (f : L.embedding M N)\n\t{h : \u2200 (c : M), \u21d1f c \u2208 p} (x : M) :\n\t\u2191(\u21d1(first_order.language.embedding.cod_restrict p f h) x) = \u21d1f x :=", "nl_statement_of_codex": "Let $L$ be a first-order language, let $M$ and $N$ be $L$-structures, and let $p$ be an $L$-substructure of $N$. Let $f:M\\to N$ be an $L$-embedding. Suppose that $f(c)\\in p$ for all $c\\in M$. Then $f(x)\\in p$ for all $x\\in M$."}
{"name": "finsupp.support_inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/order.lean", "formal_statement": "theorem finsupp.support_inf {\u03b9 \u03b1 : Type*}\n\t[canonically_linear_ordered_add_monoid \u03b1] [decidable_eq \u03b9] {f g : \u03b9 \u2192\u2080 \u03b1} :\n\t(f \u2293 g).support = f.support \u2229 g.support :=", "nl_statement_of_codex": "The support of the infimum of two finitely supported functions is the intersection of their supports."}
{"name": "same_ray_pos_smul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/ray.lean", "formal_statement": "theorem same_ray_pos_smul_right {R : Type*} [ordered_comm_semiring R]\n\t{M : Type*} [add_comm_monoid M] [module R M] (v : M) {r : R} (h : 0 < r) :\n\tsame_ray R v (r \u2022 v) :=", "nl_statement_of_codex": "Let $R$ be an ordered commutative semiring, $M$ a module over $R$, and $v\\in M$. Then $v$ and $rv$ are on the same ray for all $r>0$."}
{"name": "subgroup.fg_of_index_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/schreier.lean", "formal_statement": "theorem subgroup.fg_of_index_ne_zero {G : Type*} [group G] {H : subgroup G}\n\t[hG : group.fg G] (hH : H.index \u2260 0) :\n\tgroup.fg \u21a5H :=", "nl_statement_of_codex": "Let $G$ be a finitely generated group and let $H$ be a subgroup of $G$. If $H$ has finite index in $G$, then $H$ is finitely generated."}
{"name": "star_mul_self_nonneg'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/star/basic.lean", "formal_statement": "theorem star_mul_self_nonneg' {R : Type u} [non_unital_semiring R]\n\t[partial_order R] [star_ordered_ring R] {r : R} :\n\t0 \u2264 r * has_star.star r :=", "nl_statement_of_codex": "Let $R$ be a non-unital semiring with a partial order and a star operation. Then $0\\leq r\\star r$ for all $r\\in R$."}
{"name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/continued_fractions/computation/approximations.lean", "formal_statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one\n\t{K : Type*} {v : K} {n : \u2115} [linear_ordered_field K] [floor_ring K]\n\t{ifp_n : generalized_continued_fraction.int_fract_pair K}\n\t(nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) :\n\tifp_n.fr < 1 :=", "nl_statement_of_codex": "Let $K$ be a linear ordered field with floor function. Let $v\\in K$ and $n\\in\\mathbb{N}$. Let $ifp_n$ be the $n$-th stream of the continued fraction expansion of $v$. Then the fractional part of $ifp_n$ is less than $1$."}
{"name": "sup_hom.cancel_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/lattice.lean", "formal_statement": "theorem sup_hom.cancel_right {\u03b1 \u03b2 \u03b3 : Type*} [has_sup \u03b1] [has_sup \u03b2] [has_sup \u03b3]\n\t{g\u2081 g\u2082 : sup_hom \u03b2 \u03b3} {f : sup_hom \u03b1 \u03b2} (hf : function.surjective \u21d1f) :\n\tg\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082 :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g_1, g_2:B\\to C$ be sup-preserving functions. Then $g_1\\circ f=g_2\\circ f$ if and only if $g_1=g_2$."}
{"name": "uniform_space.replace_topology_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem uniform_space.replace_topology_eq {\u03b1 : Type*} [i : topological_space \u03b1]\n\t(u : uniform_space \u03b1) (h : i = uniform_space.to_topological_space) :\n\tu.replace_topology h = u :=", "nl_statement_of_codex": "Let $X$ be a uniform space. Then $X$ is equal to itself with the topology replaced by the uniform space topology."}
{"name": "subtype.restrict_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/subtype.lean", "formal_statement": "theorem subtype.restrict_injective {\u03b1 : Sort u_1} {\u03b2 : Type*} {f : \u03b1 \u2192 \u03b2}\n\t(p : \u03b1 \u2192 Prop) (h : function.injective f) :\n\tfunction.injective (subtype.restrict p f) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then the restriction of $f$ to the subset $A'\\subset A$ is injective."}
{"name": "discrete_quotient.of_le_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/discrete_quotient.lean", "formal_statement": "theorem discrete_quotient.of_le_map {X : Type*} [topological_space X]\n\t{Y : Type*} [topological_space Y] {f : Y \u2192 X} {cont : continuous f}\n\t{A : discrete_quotient Y} {B C : discrete_quotient X}\n\t(cond : discrete_quotient.le_comap cont A B) (h : B \u2264 C) :\n\tdiscrete_quotient.map _ = discrete_quotient.of_le h \u2218 discrete_quotient.map cond :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $f:Y\\to X$ be a continuous function. Let $A$ be a discrete quotient of $Y$ and let $B$ and $C$ be discrete quotients of $X$. If $A\\leq B$, then $f(A)\\leq C$ if and only if $f(A)\\leq f(B)$."}
{"name": "asymptotics.is_O.comp_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O.comp_tendsto {\u03b1 \u03b2 E F : Type*} [has_norm E]\n\t[has_norm F] {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : filter \u03b1} (hfg : f =O[l] g)\n\t{k : \u03b2 \u2192 \u03b1} {l' : filter \u03b2} (hk : filter.tendsto k l' l) :\n\t(f \u2218 k) =O[l'] (g \u2218 k) :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E$ and $k:\\beta\\to\\alpha$. If $f=O(g)$ and $k$ tends to infinity, then $f\\circ k=O(g\\circ k)$."}
{"name": "list.suffix_rfl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.suffix_rfl {\u03b1 : Type*} {l : list \u03b1} :\n\tl <:+ l :=", "nl_statement_of_codex": "The list $l$ is a suffix of itself."}
{"name": "category_theory.monoidal_category.id_tensor_right_unitor_inv_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/coherence_lemmas.lean", "formal_statement": "theorem category_theory.monoidal_category.id_tensor_right_unitor_inv_assoc\n\t{C : Type*} [category_theory.category C] [category_theory.monoidal_category C]\n\t(X Y : C) {X' : C} (f' : X \u2297 Y \u2297 \ud835\udfd9_ C \u27f6 X') :\n\t(\ud835\udfd9 X \u2297 (\u03c1_ Y).inv) \u226b f' = (\u03c1_ (X \u2297 Y)).inv \u226b (\u03b1_ X Y (\ud835\udfd9_ C)).hom \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X, Y, X'$ be objects of $C$. Let $f':X\\otimes Y\\otimes I\\to X'$ be a morphism. Then $(I_X\\otimes \\rho_Y^{-1})\\circ f'=(\\rho_{X\\otimes Y})^{-1}\\circ (\\alpha_{X,Y,I})\\circ f'$."}
{"name": "measure_theory.L1.simple_func.coe_neg_part", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/bochner.lean", "formal_statement": "theorem measure_theory.L1.simple_func.coe_neg_part {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t(f : \u21a5(measure_theory.Lp.simple_func \u211d 1 \u03bc)) :\n\t\u2191(measure_theory.L1.simple_func.neg_part f) = measure_theory.Lp.neg_part \u2191f :=", "nl_statement_of_codex": "The negative part of a simple function $f$ is equal to the negative part of the function $f$."}
{"name": "right.self_lt_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem right.self_lt_inv {\u03b1 : Type u} [group \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt] {a : \u03b1} (h : a < 1) :\n\ta < a\u207b\u00b9 :=", "nl_statement_of_codex": "Let $G$ be a group with a preorder $\\leq$ such that $a\\leq b$ implies $ab^{-1}\\leq 1$. Then $a\\leq 1$ implies $a\\leq a^{-1}$."}
{"name": "seq1.join_cons", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/seq.lean", "formal_statement": "theorem seq1.join_cons {\u03b1 : Type u} (a b : \u03b1) (s : seq \u03b1) (S : seq (seq1 \u03b1)) :\n\tseq1.join ((a, seq.cons b s), S) = (a, (seq.cons (b, s) S).join) :=", "nl_statement_of_codex": "Let $a,b$ be elements of a type $\u03b1$ and let $s$ be a sequence of elements of $\u03b1$. Let $S$ be a sequence of sequences of elements of $\u03b1$. Then $(a,b,s)$ joined with $S$ is equal to $a$ joined with $(b,s)$ joined with $S$."}
{"name": "filter.eventually_eq.differentiable_at_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem filter.eventually_eq.differentiable_at_iff {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {f\u2080 f\u2081 : E \u2192 F} {x : E}\n\t(h : f\u2080 =\u1da0[nhds x] f\u2081) :\n\tdifferentiable_at \ud835\udd5c f\u2080 x \u2194 differentiable_at \ud835\udd5c f\u2081 x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $\ud835\udd5c$. Let $f_0, f_1:E\\to F$ and $x\\in E$. Then $f_0$ is differentiable at $x$ if and only if $f_1$ is differentiable at $x$."}
{"name": "list.mem_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.mem_map {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {l : list \u03b1} :\n\tb \u2208 list.map f l \u2194 \u2203 (a : \u03b1), a \u2208 l \u2227 f a = b :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $b\\in B$. Then $b\\in f(A)$ if and only if there is an $a\\in A$ such that $f(a)=b$."}
{"name": "is_closed_map_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/const_mul_action.lean", "formal_statement": "theorem is_closed_map_smul {\u03b1 G : Type*} [topological_space \u03b1] [group G]\n\t[mul_action G \u03b1] [has_continuous_const_smul G \u03b1] ( : G) :\n\tis_closed_map (\u03bb (x : \u03b1), c \u2022 x) :=", "nl_statement_of_codex": "The map $x\\mapsto c\\cdot x$ is a closed map."}
{"name": "tensor_product.lie_module.lie_tmul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/tensor_product.lean", "formal_statement": "theorem tensor_product.lie_module.lie_tmul_right {R : Type u} [comm_ring R]\n\t{L : Type v} {M : Type w} {N : Type w\u2081} [lie_ring L] [lie_algebra R L]\n\t[add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M]\n\t[add_comm_group N] [module R N] [lie_ring_module L N] [lie_module R L N]\n\t(x : L) (m : M) (n : N) :\n\t\u2045x,m \u2297\u209c[R] n\u2046 = \u2045x,m\u2046 \u2297\u209c[R] n + m \u2297\u209c[R] \u2045x,n\u2046 :=", "nl_statement_of_codex": "Let $L$ be a Lie ring, $M$ and $N$ be Lie $L$-modules. Then the tensor product $M\\otimes_R N$ is a Lie $L$-module."}
{"name": "has_fderiv_at.comp_has_fderiv_within_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem has_fderiv_at.comp_has_fderiv_within_at {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [normed_group G]\n\t[normed_space \ud835\udd5c G] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} (x : E) {s : set E} {g : F \u2192 G}\n\t{g' : F \u2192L[\ud835\udd5c] G} (hg : has_fderiv_at g g' (f x))\n\t(hf : has_fderiv_within_at f f' s x) :\n\thas_fderiv_within_at (g \u2218 f) (g'.comp f') s x :=", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over $\\mathbb{K}$ and let $f:E\\to F$ and $g:F\\to G$ be differentiable at $x\\in E$. Then $g\\circ f$ is differentiable at $x$."}
{"name": "int.neg_neg", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/basic.lean", "formal_statement": "theorem int.neg_neg (a : \u2124) :\n\t--a = a :=", "nl_statement_of_codex": "The negation of an integer is equal to the integer."}
{"name": "measure_theory.average_congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/average.lean", "formal_statement": "theorem measure_theory.average_congr {\u03b1 E : Type*} {m0 : measurable_space \u03b1}\n\t[normed_group E] [normed_space \u211d E] [complete_space E]\n\t{\u03bc : measure_theory.measure \u03b1} {f g : \u03b1 \u2192 E} (h : f =\u1d50[\u03bc] g) :\n\t\u2a0d (x : \u03b1), f x \u2202\u03bc = \u2a0d (x : \u03b1), g x \u2202\u03bc :=", "nl_statement_of_codex": "Let $f,g:X\\to E$ be measurable functions on a measure space $(X,\\mathcal{A},\\mu)$. If $f=g$ almost everywhere, then $\\int_X f\\,d\\mu=\\int_X g\\,d\\mu$."}
{"name": "cardinal.lift_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.lift_succ (a : cardinal) :\n\t(order.succ a).lift = order.succ a.lift :=", "nl_statement_of_codex": "The lift of the successor of a cardinal is the successor of the lift of the cardinal."}
{"name": "denumerable.of_nat_encode", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/denumerable.lean", "formal_statement": "theorem denumerable.of_nat_encode {\u03b1 : Type*} [denumerable \u03b1] (a : \u03b1) :\n\tdenumerable.of_nat \u03b1 (encodable.encode a) = a :=", "nl_statement_of_codex": "Let $\u03b1$ be a denumerable set. Then the function $f:\\mathbb{N}\\to \u03b1$ defined by $f(n)=\\text{denumerable.of_nat \u03b1 n}$ is a bijection."}
{"name": "le_infi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/complete_lattice.lean", "formal_statement": "theorem le_infi {\u03b1 : Type*} {\u03b9 : Sort u_5} [complete_lattice \u03b1] {f : \u03b9 \u2192 \u03b1}\n\t{a : \u03b1} (h : \u2200 (i : \u03b9), a \u2264 f i) :\n\ta \u2264 infi f :=", "nl_statement_of_codex": "Let $f$ be a function from an index set $I$ to a complete lattice $L$. Then $a\\leq \\inf_{i\\in I} f(i)$."}
{"name": "conformal_factor_at_inner_eq_mul_inner'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/conformal/inner_product.lean", "formal_statement": "theorem conformal_factor_at_inner_eq_mul_inner' {E F : Type*}\n\t[inner_product_space \u211d E] [inner_product_space \u211d F] {f : E \u2192 F} {x : E}\n\t(h : conformal_at f x) (u v : E) :\n\thas_inner.inner (\u21d1(fderiv \u211d f x) u) (\u21d1(fderiv \u211d f x) v) = conformal_factor_at h * has_inner.inner u v :=", "nl_statement_of_codex": "Let $E$ and $F$ be inner product spaces over $\\mathbb{R}$ and let $f:E\\to F$ be a conformal map at $x\\in E$. Then for all $u,v\\in E$, we have $\\langle Df(x)u,Df(x)v\\rangle=\\lambda(x)\\langle u,v\\rangle$."}
{"name": "measure_theory.ae_eq_fun.zero_to_germ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ae_eq_fun.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.zero_to_germ {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2] [has_zero \u03b2] :\n\t0.to_germ = 0 :=", "nl_statement_of_codex": "The germ of the zero function is the zero function."}
{"name": "measure_theory.condexp_L2_ae_eq_zero_of_ae_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/conditional_expectation.lean", "formal_statement": "theorem measure_theory.condexp_L2_ae_eq_zero_of_ae_eq_zero {\u03b1 : Type*}\n\t{m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1}\n\t{hm : m \u2264 m0} (hs : measurable_set s) (h\u03bcs : \u21d1\u03bc s \u2260 \u22a4)\n\t{f : \u21a5(measure_theory.Lp \u211d 2 \u03bc)} (hf : \u21d1f =\u1d50[\u03bc.restrict s] 0) :\n\t\u21d1(\u21d1(measure_theory.condexp_L2 \u211d hm) f) =\u1d50[\u03bc.restrict s] 0 :=", "nl_statement_of_codex": "Let $m$ and $m_0$ be two $\\sigma$-algebras on a set $X$ such that $m\\subset m_0$. Let $\\mu$ be a measure on $m$. Let $s$ be a measurable set with respect to $m$ such that $\\mu(s)<\\infty$. Let $f$ be a function in $L^2(\\mu)$ such that $f=0$ almost everywhere with respect to $\\mu$ on $s$. Then the conditional expectation of $f$ with respect to $m$ is $0$ almost everywhere with respect to $\\mu$ on $s$."}
{"name": "onote.of_nat_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/notation.lean", "formal_statement": "theorem onote.of_nat_one :\n\tonote.of_nat 1 = 1 :=", "nl_statement_of_codex": "The onote of 1 is 1."}
{"name": "complex.nat_cast_im", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/basic.lean", "formal_statement": "theorem complex.nat_cast_im (n : \u2115) :\n\t\u2191n.im = 0 :=", "nl_statement_of_codex": "The imaginary part of a natural number is zero."}
{"name": "nat.set_induction_bounded", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.set_induction_bounded {b : \u2115} {S : set \u2115} (hb : b \u2208 S)\n\t(h_ind : \u2200 (k : \u2115), k \u2208 S \u2192 k + 1 \u2208 S) {n : \u2115} (hbn : b \u2264 n) :\n\tn \u2208 S :=", "nl_statement_of_codex": "Let $S$ be a set of natural numbers. If $b\\in S$ and $n\\geq b$, then $n\\in S$."}
{"name": "filter.has_basis.small_sets", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/small_sets.lean", "formal_statement": "theorem filter.has_basis.small_sets {\u03b1 : Type*} {\u03b9 : Sort u_3} {l : filter \u03b1}\n\t{p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 set \u03b1} (h : l.has_basis p s) :\n\tl.small_sets.has_basis p (\u03bb (i : \u03b9), \ud835\udcabs i) :=", "nl_statement_of_codex": "Let $l$ be a filter on a set $X$. Then the filter of small sets of $l$ has a basis of sets of the form $\\mathcal{P}(s_i)$ where $s_i$ is a basis set of $l$."}
{"name": "category_theory.types_comp_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/types.lean", "formal_statement": "theorem category_theory.types_comp_apply {X Y Z : Type u} (f : X \u27f6 Y)\n\t(g : Y \u27f6 Z) (x : X) :\n\t(f \u226b g) x = g (f x) :=", "nl_statement_of_codex": "Let $X, Y, Z$ be types and let $f:X\\to Y$ and $g:Y\\to Z$. Then $(f\\circ g)(x)=g(f(x))$."}
{"name": "free_abelian_group.of_mul_hom_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/free_abelian_group.lean", "formal_statement": "theorem free_abelian_group.of_mul_hom_coe {\u03b1 : Type u} [monoid \u03b1] :\n\t\u21d1free_abelian_group.of_mul_hom = free_abelian_group.of :=", "nl_statement_of_codex": "The free abelian group on a monoid is the same as the free abelian group on the monoid with the multiplication homomorphism."}
{"name": "finset.mem_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.mem_subtype {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [decidable_pred p]\n\t{s : finset \u03b1} {a : subtype p} :\n\ta \u2208 finset.subtype p s \u2194 \u2191a \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $p$ be a predicate on $s$. Then $a\\in s$ if and only if $a\\in\\{x\\in s\\mid p(x)\\}$."}
{"name": "list.subperm.filter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/perm.lean", "formal_statement": "theorem list.subperm.filter {\u03b1 : Type uu} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t\u2983l l' : list \u03b1\u2984 (h : l <+~ l') :\n\tlist.filter p l <+~ list.filter p l' :=", "nl_statement_of_codex": "Let $p$ be a predicate on a type $\\alpha$. Let $l$ and $l'$ be lists of elements of $\\alpha$. If $l$ is a subpermutation of $l'$, then the list of elements of $l$ satisfying $p$ is a subpermutation of the list of elements of $l'$ satisfying $p$."}
{"name": "direct_sum.lift_ring_hom_symm_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/ring.lean", "formal_statement": "theorem direct_sum.lift_ring_hom_symm_apply_coe {\u03b9 : Type*} [decidable_eq \u03b9]\n\t{A R : Type*} [\u03a0 (i : \u03b9), add_comm_monoid (A i)] [add_monoid \u03b9]\n\t[direct_sum.gsemiring A] [semiring R] (F : direct_sum \u03b9 (\u03bb (i : \u03b9), A i) \u2192+* R)\n\t(i : \u03b9) :\n\t\u2191(\u21d1(direct_sum.lift_ring_hom.symm) F) = \u2191F.comp (direct_sum.of A i) :=", "nl_statement_of_codex": "Let $A$ be a direct sum of commutative monoids. Let $R$ be a ring. Let $F:A\\to R$ be a ring homomorphism. Then $F$ is the direct sum of the restrictions of $F$ to the summands of $A$."}
{"name": "nat.ceil_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/floor.lean", "formal_statement": "theorem nat.ceil_le {\u03b1 : Type*} [linear_ordered_semiring \u03b1] [floor_semiring \u03b1]\n\t{a : \u03b1} {n : \u2115} :\n\t\u2308a\u2309\u208a \u2264 n \u2194 a \u2264 \u2191n :=", "nl_statement_of_codex": "For any real number $a$ and any natural number $n$, we have $a\\leq n$ if and only if $\\lceil a\\rceil\\leq n$."}
{"name": "has_deriv_at_filter.congr_of_eventually_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_at_filter.congr_of_eventually_eq {\ud835\udd5c : Type u}\n\t[nondiscrete_normed_field \ud835\udd5c] {F : Type v} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f f\u2081 : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {L : filter \ud835\udd5c}\n\t(h : has_deriv_at_filter f f' x L) (hL : f\u2081 =\u1da0[L] f) (hx : f\u2081 x = f x) :\n\thas_deriv_at_filter f\u2081 f' x L :=", "nl_statement_of_codex": "Let $f, f_1: \\mathbb{R}\\to \\mathbb{R}$ be functions and let $x\\in \\mathbb{R}$. If $f$ has a derivative at $x$ and $f_1$ is eventually equal to $f$ near $x$, then $f_1$ has a derivative at $x$."}
{"name": "int.cast_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/cast.lean", "formal_statement": "theorem int.cast_nonneg {\u03b1 : Type*} [ordered_ring \u03b1] [nontrivial \u03b1] {n : \u2124} :\n\t0 \u2264 \u2191n \u2194 0 \u2264 n :=", "nl_statement_of_codex": "Let $R$ be an ordered ring. Then $0\\leq n$ if and only if $0\\leq \\overline{n}$."}
{"name": "category_theory.is_iso.inv_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/isomorphism.lean", "formal_statement": "theorem category_theory.is_iso.inv_comp {C : Type u}\n\t[category_theory.category C] {X Y Z : C} {f : X \u27f6 Y} {h : Y \u27f6 Z}\n\t[category_theory.is_iso f] [category_theory.is_iso h] :\n\tcategory_theory.inv (f \u226b h) = category_theory.inv h \u226b category_theory.inv f :=", "nl_statement_of_codex": "Let $C$ be a category. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$ and $h:Y\\to Z$ be morphisms of $C$. If $f$ and $h$ are isomorphisms, then $h\\circ f$ is an isomorphism and $(h\\circ f)^{-1}=f^{-1}\\circ h^{-1}$."}
{"name": "measure_theory.measure.restrict_prod_eq_prod_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/prod.lean", "formal_statement": "theorem measure_theory.measure.restrict_prod_eq_prod_univ {\u03b1 \u03b2 : Type*}\n\t[measurable_space \u03b1] [measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1}\n\t{\u03bd : measure_theory.measure \u03b2} [measure_theory.sigma_finite \u03bd]\n\t[measure_theory.sigma_finite \u03bc] (s : set \u03b1) :\n\t(\u03bc.restrict s).prod \u03bd = (\u03bc.prod \u03bd).restrict (s \u00d7\u02e2 set.univ) :=", "nl_statement_of_codex": "Let $X$ and $Y$ be measurable spaces and let $\\mu$ and $\\nu$ be $\\sigma$-finite measures on $X$ and $Y$, respectively. Then $\\mu\\times\\nu$ is a $\\sigma$-finite measure on $X\\times Y$ and $(\\mu\\times\\nu)|_{X\\times Y}=\\mu|_X\\times\\nu|_Y$."}
{"name": "has_continuous_add_infi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/monoid.lean", "formal_statement": "theorem has_continuous_add_infi {M : Type*} {\u03b9' : Sort u_6} [has_add M]\n\t{ts' : \u03b9' \u2192 topological_space M} (h' : \u2200 (i : \u03b9'), has_continuous_add M) :\n\thas_continuous_add M :=", "nl_statement_of_codex": "Let $M$ be a topological space and let $\\{M_i\\}_{i\\in I}$ be a family of topological spaces. If $M_i$ has continuous addition for each $i\\in I$, then $M$ has continuous addition."}
{"name": "matrix.norm_transpose", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/matrix.lean", "formal_statement": "theorem matrix.norm_transpose {m n \u03b1 : Type*} [fintype m] [fintype n]\n\t[semi_normed_group \u03b1] (A : matrix m n \u03b1) :\n\t\u2225A.transpose\u2225 = \u2225A\u2225 :=", "nl_statement_of_codex": "Let $A$ be an $m\\times n$ matrix over a semi-normed group. Then $\\|A^T\\|=\\|A\\|$."}
{"name": "order_dual.of_dual_lt_of_dual", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/synonym.lean", "formal_statement": "theorem order_dual.of_dual_lt_of_dual {\u03b1 : Type*} [has_lt \u03b1] {a b : \u03b1\u1d52\u1d48} :\n\t\u21d1order_dual.of_dual a < \u21d1order_dual.of_dual b \u2194 b < a :=", "nl_statement_of_codex": "Let $a,b$ be elements of the dual order of a poset $P$. Then $a<b$ if and only if $b<a$."}
{"name": "list.maximum_eq_coe_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/min_max.lean", "formal_statement": "theorem list.maximum_eq_coe_iff {\u03b1 : Type*} [linear_order \u03b1] {l : list \u03b1}\n\t{m : \u03b1} :\n\tl.maximum = \u2191m \u2194 m \u2208 l \u2227 \u2200 (a : \u03b1), a \u2208 l \u2192 a \u2264 m :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a linear order $\u03b1$. Then $l$ has a maximum if and only if there is an element $m\\in l$ such that $a\\leq m$ for all $a\\in l$."}
{"name": "metric.is_open_singleton_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.is_open_singleton_iff {\u03b1 : Type*} [pseudo_metric_space \u03b1] {x : \u03b1} :\n\tis_open {x} \u2194 \u2203 (\u03b5 : \u211d) (H : \u03b5 > 0), \u2200 (y : \u03b1), has_dist.dist y x < \u03b5 \u2192 y = x :=", "nl_statement_of_codex": "The singleton set $\\{x\\}$ is open if and only if there is an $\\epsilon>0$ such that for all $y\\in X$, if $d(y,x)<\\epsilon$, then $y=x$."}
{"name": "add_group_seminorm.comp_add_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/seminorm.lean", "formal_statement": "theorem add_group_seminorm.comp_add_le {A B : Type*} [add_comm_group A]\n\t[add_comm_group B] (p : add_group_seminorm B) (f g : A \u2192+ B) :\n\tp.comp (f + g) \u2264 p.comp f + p.comp g :=", "nl_statement_of_codex": "Let $A$ and $B$ be additive commutative groups and let $p$ be an additive seminorm on $B$. Then $p(f+g)\\leq p(f)+p(g)$ for all $f,g:A\\to B$."}
{"name": "localization.mk_algebra_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/basic.lean", "formal_statement": "theorem localization.mk_algebra_map {R : Type*} [comm_semiring R]\n\t{M : submonoid R} {A : Type*} [comm_semiring A] [algebra A R] (m : A) :\n\tlocalization.mk (\u21d1(algebra_map A R) m) 1 = \u21d1(algebra_map A (localization M)) m :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ a submonoid of $R$, $A$ a commutative semiring and $R$-algebra, and $m\\in A$. Then the map $A\\to A_M$ sending $m$ to $m/1$ is an $R$-algebra homomorphism."}
{"name": "finite_of_fin_dim_affine_independent", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/finite_dimensional.lean", "formal_statement": "theorem finite_of_fin_dim_affine_independent (k : Type*) {V P : Type*}\n\t[division_ring k] [add_comm_group V] [module k V] [add_torsor V P]\n\t[finite_dimensional k V] {s : set P} (hi : affine_independent k coe) :\n\ts.finite :=", "nl_statement_of_codex": "Let $V$ be a finite dimensional vector space over a division ring $k$. Let $P$ be an affine space over $V$. Let $s$ be a set of points in $P$. If $s$ is affinely independent, then $s$ is finite."}
{"name": "mul_basis_to_matrix", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/basis.lean", "formal_statement": "theorem mul_basis_to_matrix {\u03b9 \u03b9' \u03ba R M : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [module R M] {N : Type*} [add_comm_monoid N] [module R N]\n\t[fintype \u03b9'] [fintype \u03ba] [fintype \u03b9] [decidable_eq \u03b9] [decidable_eq \u03b9']\n\t(b\u2081 : basis \u03b9 R M) (b\u2082 : basis \u03b9' R M) (b\u2083 : basis \u03ba R N) (A : matrix \u03ba \u03b9 R) :\n\tA.mul (b\u2081.to_matrix \u21d1b\u2082) = \u21d1(linear_map.to_matrix b\u2082 b\u2083) (\u21d1(matrix.to_lin b\u2081 b\u2083) A) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ and $N$ be $R$-modules, $b_1$ be a basis of $M$, $b_2$ be a basis of $M$, $b_3$ be a basis of $N$, and $A$ be a matrix with entries in $R$ and with $\\kappa$ rows and $\\iota$ columns. Then $A\\cdot b_1\\cdot b_2^T=b_2\\cdot b_3^T\\cdot b_1\\cdot b_3\\cdot A$."}
{"name": "order_top.upper_bounds_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem order_top.upper_bounds_univ {\u03b3 : Type w} [partial_order \u03b3] [order_top \u03b3] :\n\tupper_bounds set.univ = {\u22a4} :=", "nl_statement_of_codex": "The set of upper bounds of the empty set is the set containing only the top element."}
{"name": "complex.cos_two_pi_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem complex.cos_two_pi_sub (x : \u2102) :\n\tcomplex.cos (2 * \u2191real.pi - x) = complex.cos x :=", "nl_statement_of_codex": "$\\cos(2\\pi-x)=\\cos(x)$."}
{"name": "equiv.add_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/transfer_instance.lean", "formal_statement": "theorem equiv.add_equiv_apply {\u03b1 : Type u} {\u03b2 : Type v} (e : \u03b1 \u2243 \u03b2) [has_add \u03b2]\n\t(a : \u03b1) :\n\t\u21d1(e.add_equiv) a = \u21d1e a :=", "nl_statement_of_codex": "Let $e: \\alpha \\to \\beta$ be an equivalence. Then $e(a+b)=e(a)+e(b)$."}
{"name": "projectivization.submodule_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/projective_space/basic.lean", "formal_statement": "theorem projectivization.submodule_injective {K V : Type*} [field K]\n\t[add_comm_group V] [module K V] :\n\tfunction.injective projectivization.submodule :=", "nl_statement_of_codex": "The map $V\\mapsto \\mathbb{P}(V)$ is injective."}
{"name": "mul_le_cancellable.le_mul_iff_one_le_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem mul_le_cancellable.le_mul_iff_one_le_right {\u03b1 : Type*} [has_le \u03b1]\n\t[mul_one_class \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] {a b : \u03b1}\n\t(ha : mul_le_cancellable a) :\n\ta \u2264 a * b \u2194 1 \u2264 b :=", "nl_statement_of_codex": "Let $a, b$ be elements of a commutative monoid with $1$. If $a$ is cancellable, then $a\\leq ab$ if and only if $1\\leq b$."}
{"name": "finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/combination.lean", "formal_statement": "theorem finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero {k : Type*}\n\t[division_ring k] {\u03b9 : Type*} (s : finset \u03b9) (h : \u2191(s.card) \u2260 0) :\n\ts.sum (\u03bb (i : \u03b9), finset.centroid_weights k s i) = 1 :=", "nl_statement_of_codex": "Let $k$ be a division ring and let $s$ be a finite set. If $s$ is nonempty, then the sum of the centroid weights of $s$ is $1$."}
{"name": "orthonormal.inner_left_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem orthonormal.inner_left_sum {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] {\u03b9 : Type*} {v : \u03b9 \u2192 E} (hv : orthonormal \ud835\udd5c v)\n\t(l : \u03b9 \u2192 \ud835\udd5c) {s : finset \u03b9} {i : \u03b9} (hi : i \u2208 s) :\n\thas_inner.inner (s.sum (\u03bb (i : \u03b9), l i \u2022 v i)) (v i) = \u21d1(star_ring_end \ud835\udd5c) (l i) :=", "nl_statement_of_codex": "Let $E$ be an inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $v$ be an orthonormal basis of $E$. Let $s$ be a finite set and let $l$ be a function from $s$ to $\\mathbb{R}$ or $\\mathbb{C}$. Then $\\langle \\sum_{i\\in s} l(i)v(i), v(i)\\rangle = l(i)$."}
{"name": "ennreal.one_le_rpow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem ennreal.one_le_rpow {x : ennreal} {z : \u211d} (hx : 1 \u2264 x) (hz : 0 < z) :\n\t1 \u2264 x ^ z :=", "nl_statement_of_codex": "If $x\\geq 1$ and $z>0$, then $x^z\\geq 1$."}
{"name": "order.succ_le_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/succ_pred/basic.lean", "formal_statement": "theorem order.succ_le_succ {\u03b1 : Type*} [preorder \u03b1] [succ_order \u03b1] {a b : \u03b1}\n\t(h : a \u2264 b) :\n\torder.succ a \u2264 order.succ b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a preordered set $X$ with a successor function. If $a\\leq b$, then $s(a)\\leq s(b)$."}
{"name": "topological_space.closeds.gc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sets/closeds.lean", "formal_statement": "theorem topological_space.closeds.gc {\u03b1 : Type*} [topological_space \u03b1] :\n\tgalois_connection topological_space.closeds.closure coe :=", "nl_statement_of_codex": "The closure of a set $A$ is the smallest closed set containing $A$."}
{"name": "measure_theory.null_measurable.measurable_of_complete", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/null_measurable.lean", "formal_statement": "theorem measure_theory.null_measurable.measurable_of_complete {\u03b1 \u03b2 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [\u03bc.is_complete]\n\t{m1 : measurable_space \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : measure_theory.null_measurable f \u03bc) :\n\tmeasurable f :=", "nl_statement_of_codex": "Let $(X,\\mathcal{A},\\mu)$ be a complete measure space and let $f:X\\to Y$ be a function. If $f$ is $\\mu$-null measurable, then $f$ is measurable."}
{"name": "has_sbtw.sbtw.not_sbtw", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/circular.lean", "formal_statement": "theorem has_sbtw.sbtw.not_sbtw {\u03b1 : Type*} [circular_preorder \u03b1] {a b c : \u03b1}\n\t(h : has_sbtw.sbtw a b c) :\n\t\u00achas_sbtw.sbtw c b a :=", "nl_statement_of_codex": "If $a\\sbtw b\\sbtw c$, then $c\\not\\sbtw b\\sbtw a$."}
{"name": "measure_theory.submartingale.ae_le_condexp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/martingale.lean", "formal_statement": "theorem measure_theory.submartingale.ae_le_condexp {\u03b1 E \u03b9 : Type*} [preorder \u03b9]\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_group E]\n\t[normed_space \u211d E] [complete_space E] {f : \u03b9 \u2192 \u03b1 \u2192 E}\n\t{\u2131 : measure_theory.filtration \u03b9 m0} [has_le E]\n\t(hf : measure_theory.submartingale f \u2131 \u03bc) {i j : \u03b9} (hij : i \u2264 j) :\n\tf i \u2264\u1d50[\u03bc] measure_theory.condexp (\u21d1\u2131 i) \u03bc (f j) :=", "nl_statement_of_codex": "Let $f$ be a submartingale. Then $f_i\\leq E[f_j|\\mathcal{F}_i]$ for all $i\\leq j$."}
{"name": "mul_char.to_fun_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/legendre_symbol/mul_character.lean", "formal_statement": "theorem mul_char.to_fun_eq_coe {R : Type u} [comm_monoid R] {R' : Type v}\n\t[comm_monoid_with_zero R'] (\u03c7 : mul_char R R') :\n\t\u03c7.to_monoid_hom.to_fun = \u21d1\u03c7 :=", "nl_statement_of_codex": "Let $R$ be a commutative monoid and let $R'$ be a commutative monoid with zero. Let $\\chi:R\\to R'$ be a multiplicative character. Then $\\chi$ is a monoid homomorphism if and only if $\\chi(1)=1$."}
{"name": "affine_map.ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_map.lean", "formal_statement": "theorem affine_map.ext_iff {k V1 P1 V2 P2 : Type*} [ring k] [add_comm_group V1]\n\t[module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2]\n\t[add_torsor V2 P2] {f g : P1 \u2192\u1d43[k] P2} :\n\tf = g \u2194 \u2200 (p : P1), \u21d1f p = \u21d1g p :=", "nl_statement_of_codex": "Two affine maps $f, g:P_1\\to P_2$ are equal if and only if $f(p)=g(p)$ for all $p\\in P_1$."}
{"name": "option.bind_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/option/basic.lean", "formal_statement": "theorem option.bind_assoc {\u03b1 \u03b2 \u03b3 : Type*} (x : option \u03b1) (f : \u03b1 \u2192 option \u03b2)\n\t(g : \u03b2 \u2192 option \u03b3) :\n\t(x.bind f).bind g = x.bind (\u03bb (y : \u03b1), (f y).bind g) :=", "nl_statement_of_codex": "Let $x$ be an option of type $\\alpha$, and let $f:\\alpha\\to\\beta$ and $g:\\beta\\to\\gamma$ be functions. Then $(x\\bind f)\\bind g = x\\bind (\\lambda y, (f y)\\bind g)$."}
{"name": "mvpfunctor.comp.mk_get", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pfunctor/multivariate/basic.lean", "formal_statement": "theorem mvpfunctor.comp.mk_get {n m : \u2115} {P : mvpfunctor n}\n\t{Q : fin2 n \u2192 mvpfunctor m} {\u03b1 : typevec m} (x : (P.comp Q).obj \u03b1) :\n\tmvpfunctor.comp.mk (mvpfunctor.comp.get x) = x :=", "nl_statement_of_codex": "Let $P$ be an $n$-ary multi-variable polynomial functor, and let $Q$ be a family of $m$-ary multi-variable polynomial functors indexed by $n$-tuples of natural numbers. Then the map $P\\circ Q\\to P\\circ Q$ given by $x\\mapsto (P\\circ Q).mk(P\\circ Q).get(x)$ is the identity map."}
{"name": "measure_theory.simple_func.integral_eq_lintegral", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/bochner.lean", "formal_statement": "theorem measure_theory.simple_func.integral_eq_lintegral {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{f : measure_theory.simple_func \u03b1 \u211d} (hf : measure_theory.integrable \u21d1f \u03bc)\n\t(h_pos : 0 \u2264\u1d50[\u03bc] \u21d1f) :\n\tmeasure_theory.simple_func.integral \u03bc f = (\u222b\u207b (a : \u03b1), ennreal.of_real (\u21d1f a) \u2202\u03bc).to_real :=", "nl_statement_of_codex": "Let $f$ be a simple function on a measurable space $(X,\\mathcal{A})$ with values in $\\mathbb{R}$. If $f$ is integrable with respect to a measure $\\mu$ on $(X,\\mathcal{A})$ and $f\\geq 0$, then $\\int f\\,d\\mu=\\int f\\,d\\mu$."}
{"name": "asymptotics.is_o_norm_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_o_norm_right {\u03b1 E F' : Type*} [has_norm E]\n\t[semi_normed_group F'] {f : \u03b1 \u2192 E} {g' : \u03b1 \u2192 F'} {l : filter \u03b1} :\n\t(f =o[l] \u03bb (x : \u03b1), \u2225g' x\u2225) \u2194 f =o[l] g' :=", "nl_statement_of_codex": "Let $E$ be a normed space and let $F'$ be a semi-normed group. Let $f,g':X\\to E$ be functions. Then $f=o_l(g')$ if and only if $f=o_l(\\|g'\\|)$."}
{"name": "real.has_strict_deriv_at_arccos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/inverse_deriv.lean", "formal_statement": "theorem real.has_strict_deriv_at_arccos {x : \u211d} (h\u2081 : x \u2260 -1) (h\u2082 : x \u2260 1) :\n\thas_strict_deriv_at real.arccos (-(1 / real.sqrt (1 - x ^ 2))) x :=", "nl_statement_of_codex": "The derivative of the arccosine function is $-\\frac{1}{\\sqrt{1-x^2}}$."}
{"name": "real.cocompact_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/real.lean", "formal_statement": "theorem real.cocompact_eq :\n\tfilter.cocompact \u211d = filter.at_bot \u2294 filter.at_top :=", "nl_statement_of_codex": "The cocompact filter on $\\mathbb{R}$ is the filter generated by the sets $\\{x\\in\\mathbb{R}:x\\leq a\\}$ and $\\{x\\in\\mathbb{R}:x\\geq b\\}$."}
{"name": "add_submonoid.closure_induction_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/membership.lean", "formal_statement": "theorem add_submonoid.closure_induction_right {M : Type*} [add_monoid M]\n\t{s : set M} {p : M \u2192 Prop} {x : M} (h : x \u2208 add_submonoid.closure s) (H1 : p 0)\n\t(Hmul : \u2200 (x y : M), y \u2208 s \u2192 p x \u2192 p (x + y)) :\n\tp x :=", "nl_statement_of_codex": "Let $M$ be an additive monoid, let $s$ be a subset of $M$, and let $p$ be a property of elements of $M$. Suppose that $p(0)$ holds and that $p(x+y)$ holds whenever $y\\in s$ and $p(x)$ holds. Then $p(x)$ holds for all $x\\in\\overline{s}$."}
{"name": "monoid_algebra.single_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/monoid_algebra/basic.lean", "formal_statement": "theorem monoid_algebra.single_hom_apply {k : Type u\u2081} {G : Type u\u2082} [semiring k]\n\t[mul_one_class G] (a : k \u00d7 G) :\n\t\u21d1monoid_algebra.single_hom a = finsupp.single a.snd a.fst :=", "nl_statement_of_codex": "Let $k$ be a semiring and $G$ a monoid. Then the map $f:k\\times G\\to k[G]$ defined by $f(a,g)=a\\cdot g$ is a homomorphism of monoids."}
{"name": "nhds_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem nhds_mul {G : Type w} [topological_space G] [comm_group G]\n\t[topological_group G] (x y : G) :\n\tnhds (x * y) = nhds x * nhds y :=", "nl_statement_of_codex": "Let $G$ be a topological group. Then the product of the neighborhoods of $x$ and $y$ is a neighborhood of $xy$."}
{"name": "measure_theory.L1.set_to_L1_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/set_to_l1.lean", "formal_statement": "theorem measure_theory.L1.set_to_L1_smul {\u03b1 E F \ud835\udd5c : Type*} [normed_group E]\n\t[normed_space \u211d E] [normed_group F] [normed_space \u211d F] {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [nondiscrete_normed_field \ud835\udd5c] [normed_space \ud835\udd5c E]\n\t[normed_space \ud835\udd5c F] [complete_space F] {T : set \u03b1 \u2192 (E \u2192L[\u211d] F)} {C : \u211d}\n\t(hT : measure_theory.dominated_fin_meas_additive \u03bc T C)\n\t(h_smul : \u2200 (c : \ud835\udd5c) (s : set \u03b1) (x : E), \u21d1(T s) (c \u2022 x) = c \u2022 \u21d1(T s) x) ( : \ud835\udd5c)\n\t(f : \u21a5(measure_theory.Lp E 1 \u03bc)) :\n\t\u21d1(measure_theory.L1.set_to_L1 hT) (c \u2022 f) = c \u2022 \u21d1(measure_theory.L1.set_to_L1 hT) f :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over $\\mathbb{R}$ and let $T:E\\to F$ be a linear map. Let $f\\in L^1(\\mu)$. Then $T(f)\\in L^1(\\mu)$ and $\\|T(f)\\|_{L^1(\\mu)}\\leq C\\|f\\|_{L^1(\\mu)}$."}
{"name": "znum.cmp_to_int", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem znum.cmp_to_int (m n : znum) :\n\t(m.cmp n).cases_on (\u2191m < \u2191n) (m = n) (\u2191n < \u2191m) :=", "nl_statement_of_codex": "Let $m,n$ be integers. Then $m<n$ if and only if $m.cmp(n)=lt$."}
{"name": "contracting_with.edist_efixed_point_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/contracting.lean", "formal_statement": "theorem contracting_with.edist_efixed_point_le {\u03b1 : Type*} [emetric_space \u03b1]\n\t[cs : complete_space \u03b1] {K : nnreal} {f : \u03b1 \u2192 \u03b1} (hf : contracting_with K f)\n\t{x : \u03b1} (hx : has_edist.edist x (f x) \u2260 \u22a4) :\n\thas_edist.edist x (contracting_with.efixed_point f hf x hx) \u2264 has_edist.edist x (f x) / (1 - \u2191K) :=", "nl_statement_of_codex": "Let $f:X\\to X$ be a contraction with constant $K$. Let $x\\in X$ be such that $d(x,f(x))\\neq\\infty$. Then $d(x,f^\\infty(x))\\leq d(x,f(x))/(1-K)$."}
{"name": "lipschitz_with_min", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/lipschitz.lean", "formal_statement": "theorem lipschitz_with_min :\n\tlipschitz_with 1 (\u03bb (p : \u211d \u00d7 \u211d), linear_order.min p.fst p.snd) :=", "nl_statement_of_codex": "The function $f:\\mathbb{R}^2\\to\\mathbb{R}$ defined by $f(x,y)=\\min\\{x,y\\}$ is Lipschitz with constant $1$."}
{"name": "measure_theory.interval_oc_ae_eq_interval", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.interval_oc_ae_eq_interval {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measure_theory.has_no_atoms \u03bc] [linear_order \u03b1] {a b : \u03b1} :\n\tset.interval_oc a b =\u1d50[\u03bc] set.interval a b :=", "nl_statement_of_codex": "Let $X$ be a measurable space with a measure $\\mu$ that has no atoms. Let $a,b\\in X$ be such that $a<b$. Then $\\mu(a,b)=\\mu[a,b]$."}
{"name": "power_series.eq_X_mul_shift_add_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_series/basic.lean", "formal_statement": "theorem power_series.eq_X_mul_shift_add_const {R : Type*} [semiring R]\n\t(\u03c6 : power_series R) :\n\t\u03c6 = power_series.X * power_series.mk (\u03bb (p : \u2115), \u21d1(power_series.coeff R (p + 1)) \u03c6) + \u21d1(power_series.C R) (\u21d1(power_series.constant_coeff R) \u03c6) :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $\\phi$ be a power series with coefficients in $R$. Then $\\phi$ is equal to $X\\cdot\\phi'+\\phi(0)$."}
{"name": "homological_complex.hom.f_add_monoid_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/additive.lean", "formal_statement": "theorem homological_complex.hom.f_add_monoid_hom_apply {\u03b9 : Type*} {V : Type u}\n\t[category_theory.category V] [category_theory.preadditive V]\n\t{ : complex_shape \u03b9} {C\u2081 C\u2082 : homological_complex V c} (i : \u03b9) (f : C\u2081 \u27f6 C\u2082) :\n\t\u21d1(homological_complex.hom.f_add_monoid_hom i) f = f.f i :=", "nl_statement_of_codex": "Let $V$ be a preadditive category. Let $C_1$ and $C_2$ be homological complexes in $V$ and let $f:C_1\\to C_2$ be a morphism of homological complexes. Then $f_i=f(i)$."}
{"name": "equiv.perm.decompose_fin_symm_apply_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/fin.lean", "formal_statement": "theorem equiv.perm.decompose_fin_symm_apply_one {n : \u2115}\n\t(e : equiv.perm (fin (n + 1))) (p : fin (n + 2)) :\n\t\u21d1(\u21d1(equiv.perm.decompose_fin.symm) (p, e)) 1 = \u21d1(equiv.swap 0 p) (\u21d1e 0).succ :=", "nl_statement_of_codex": "Let $n$ be a natural number. Let $e$ be a permutation of $\\{0,1,\\ldots,n\\}$. Let $p$ be an element of $\\{0,1,\\ldots,n+1\\}$. Then the image of $1$ under the permutation obtained by applying the inverse of the permutation $e$ to the element $p$ is the image of $0$ under the permutation obtained by applying the permutation $e$ to the element $0$ plus $1$."}
{"name": "abs_sub_lt_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem abs_sub_lt_iff {\u03b1 : Type u} [linear_ordered_add_comm_group \u03b1]\n\t{a b c : \u03b1} :\n\t|a - b| < c \u2194 a - b < c \u2227 b - a < c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linearly ordered abelian group. Then $|a-b|<c$ if and only if $a-b<c$ and $b-a<c$."}
{"name": "lie_module_hom.mem_ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/submodule.lean", "formal_statement": "theorem lie_module_hom.mem_ker {R : Type u} {L : Type v} {M : Type w}\n\t{N : Type w\u2081} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M]\n\t[module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group N]\n\t[module R N] [lie_ring_module L N] [lie_module R L N] {f : M \u2192\u2097\u2045R,L\u2046 N} (m : M) :\n\tm \u2208 f.ker \u2194 \u21d1f m = 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ and $N$ $R$-modules. Let $f:M\\to N$ be a Lie module homomorphism. Then $m\\in\\ker f$ if and only if $f(m)=0$."}
{"name": "right_distrib", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/basic.lean", "formal_statement": "theorem right_distrib {R : Type x} [has_mul R] [has_add R]\n\t[right_distrib_class R] (a b c : R) :\n\t(a + b) * c = a * c + b * c :=", "nl_statement_of_codex": "Let $R$ be a ring with right distributivity. Then $(a+b)c=ac+bc$ for all $a,b,c\\in R$."}
{"name": "spectrum.star_mem_resolvent_set_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/spectrum.lean", "formal_statement": "theorem spectrum.star_mem_resolvent_set_iff {R : Type u} {A : Type v}\n\t[comm_semiring R] [ring A] [algebra R A] [has_involutive_star R] [star_ring A]\n\t[star_module R A] {r : R} {a : A} :\n\thas_star.star r \u2208 resolvent_set R a \u2194 r \u2208 resolvent_set R (has_star.star a) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a ring, and $a\\in A$. Then $r\\in\\sigma(a)$ if and only if $r^*\\in\\sigma(a^*)$."}
{"name": "is_R_or_C.norm_sq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/is_R_or_C.lean", "formal_statement": "theorem is_R_or_C.norm_sq_one {K : Type*} [is_R_or_C K] :\n\t\u21d1is_R_or_C.norm_sq 1 = 1 :=", "nl_statement_of_codex": "The square of the norm of $1$ is $1$."}
{"name": "add_subgroup.is_complement.exists_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/complement.lean", "formal_statement": "theorem add_subgroup.is_complement.exists_unique {G : Type*} [add_group G]\n\t{S T : set G} (h : add_subgroup.is_complement S T) (g : G) :\n\t\u2203! (x : \u21a5S \u00d7 \u21a5T), x.fst.val + x.snd.val = g :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $S,T$ be subgroups of $G$ such that $S\\oplus T=G$. Then for each $g\\in G$ there is a unique pair $(s,t)\\in S\\times T$ such that $s+t=g$."}
{"name": "set.subset.trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.subset.trans {\u03b1 : Type u} {a b c : set \u03b1} (ab : a \u2286 b) (bc : b \u2286 c) :\n\ta \u2286 c :=", "nl_statement_of_codex": "If $A\\subset B$ and $B\\subset C$, then $A\\subset C$."}
{"name": "padic_val_int.self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_val.lean", "formal_statement": "theorem padic_val_int.self {p : \u2115} (hp : 1 < p) :\n\tpadic_val_int p \u2191p = 1 :=", "nl_statement_of_codex": "The $p$-adic valuation of $p$ is $1$."}
{"name": "differentiable.clog", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/log_deriv.lean", "formal_statement": "theorem differentiable.clog {E : Type*} [normed_group E] [normed_space \u2102 E]\n\t{f : E \u2192 \u2102} (h\u2081 : differentiable \u2102 f)\n\t(h\u2082 : \u2200 (x : E), 0 < (f x).re \u2228 (f x).im \u2260 0) :\n\tdifferentiable \u2102 (\u03bb (t : E), complex.log (f t)) :=", "nl_statement_of_codex": "Let $E$ be a complex normed space and let $f:E\\to\\mathbb{C}$. If $f$ is differentiable and $f(x)$ is not on the negative real axis, then $\\log(f)$ is differentiable."}
{"name": "list.length_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.length_eq_zero {\u03b1 : Type u} {l : list \u03b1} :\n\tl.length = 0 \u2194 l = list.nil :=", "nl_statement_of_codex": "The length of a list is zero if and only if the list is empty."}
{"name": "linear_independent.repr_eq_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_independent.lean", "formal_statement": "theorem linear_independent.repr_eq_single {\u03b9 R M : Type*} {v : \u03b9 \u2192 M} [ring R]\n\t[add_comm_group M] [module R M] (hv : linear_independent R v) (i : \u03b9)\n\t(x : \u21a5(submodule.span R (set.range v))) (hx : \u2191x = v i) :\n\t\u21d1(hv.repr) x = finsupp.single i 1 :=", "nl_statement_of_codex": "Let $v$ be a linear independent set of vectors in a module $M$ over a ring $R$. Let $x$ be a vector in $M$ such that $x$ is in the span of $v$ and $x=v_i$ for some $i$. Then the representation of $x$ in terms of $v$ is $v_i$."}
{"name": "is_localization.lift_surjective_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/basic.lean", "formal_statement": "theorem is_localization.lift_surjective_iff {R : Type*} [comm_semiring R]\n\t{M : submonoid R} {S : Type*} [comm_semiring S] [algebra R S] {P : Type*}\n\t[comm_semiring P] [is_localization M S] {g : R \u2192+* P}\n\t(hg : \u2200 (y : \u21a5M), is_unit (\u21d1g \u2191y)) :\n\tfunction.surjective \u21d1(is_localization.lift hg) \u2194 \u2200 (v : P), \u2203 (x : R \u00d7 \u21a5M), v * \u21d1g \u2191(x.snd) = \u21d1g x.fst :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ a submonoid of $R$, $S$ a commutative semiring, $P$ a commutative semiring, and $g:R\\to P$ a ring homomorphism. Suppose that $S$ is an $M$-localization of $R$ and that $g$ is a ring homomorphism such that $g(y)$ is a unit in $P$ for all $y\\in M$. Then the map $g$ is surjective if and only if for every $v\\in P$ there exists $x\\in R\\times M$ such that $v\\cdot"}
{"name": "category_theory.is_detector.def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/generator.lean", "formal_statement": "theorem category_theory.is_detector.def {C : Type u}\n\t[category_theory.category C] {G : C} :\n\tcategory_theory.is_detector G \u2192 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 (h : G \u27f6 Y), \u2203! (h' : G \u27f6 X), h' \u226b f = h) \u2192 category_theory.is_iso f :=", "nl_statement_of_codex": "Let $C$ be a category and let $G$ be an object of $C$. If $G$ is a detector, then for any morphisms $f:X\\to Y$ in $C$, if for any morphism $h:G\\to Y$ there is a unique morphism $h':G\\to X$ such that $h'\\circ f=h$, then $f$ is an isomorphism."}
{"name": "category_theory.monad.forget_creates_colimits.\u03b3_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/limits.lean", "formal_statement": "theorem category_theory.monad.forget_creates_colimits.\u03b3_app {C : Type u\u2081}\n\t[category_theory.category C] {T : category_theory.monad C} {J : Type u}\n\t[category_theory.category J] {D : J \u2964 T.algebra} (j : J) :\n\tcategory_theory.monad.forget_creates_colimits.\u03b3.app j = (D.obj j).a :=", "nl_statement_of_codex": "Let $C$ be a category, $T$ a monad on $C$, $J$ a category, and $D:J\\to T\\text{-}\\mathbf{Alg}$ a functor. Then the $j$-th component of the counit of the adjunction $\\mathbf{Alg}(T,D)\\dashv D$ is the algebra homomorphism $D(j)\\to T(D(j))$."}
{"name": "lattice_hom.id_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/lattice.lean", "formal_statement": "theorem lattice_hom.id_apply {\u03b1 : Type*} [lattice \u03b1] (a : \u03b1) :\n\t\u21d1(lattice_hom.id \u03b1) a = a :=", "nl_statement_of_codex": "The identity function on a lattice is a lattice homomorphism."}
{"name": "pequiv.trans_eq_some", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pequiv.lean", "formal_statement": "theorem pequiv.trans_eq_some {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : \u03b1 \u2243. \u03b2)\n\t(g : \u03b2 \u2243. \u03b3) (a : \u03b1) ( : \u03b3) :\n\t\u21d1(f.trans g) a = option.some c \u2194 \u2203 (b : \u03b2), \u21d1f a = option.some b \u2227 \u21d1g b = option.some c :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be partial equivalences. Then $g\\circ f:A\\to C$ is a partial equivalence and for all $a\\in A$ and $c\\in C$ we have $g\\circ f(a)=c$ if and only if there is $b\\in B$ such that $f(a)=b$ and $g(b)=c$."}
{"name": "category_theory.limits.limit_obj_iso_limit_comp_evaluation_inv_limit_map_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/functor_category.lean", "formal_statement": "theorem category_theory.limits.limit_obj_iso_limit_comp_evaluation_inv_limit_map_assoc\n\t{C : Type u} [category_theory.category C] {J : Type u\u2081}\n\t[category_theory.category J] {K : Type u\u2082} [category_theory.category K]\n\t[category_theory.limits.has_limits_of_shape J C] {i j : K} (F : J \u2964 K \u2964 C)\n\t(f : i \u27f6 j) {X' : C} (f' : (category_theory.limits.limit F).obj j \u27f6 X') :\n\t(category_theory.limits.limit_obj_iso_limit_comp_evaluation F i).inv \u226b (category_theory.limits.limit F).map f \u226b f' = category_theory.limits.lim_map (category_theory.whisker_left F ((category_theory.evaluation K C).map f)) \u226b (category_theory.limits.limit_obj_iso_limit_comp_evaluation F j).inv \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, $J$ and $K$ be categories, and $F:J\\to K\\to C$ be a functor. Let $i,j:K$ be objects, $f:i\\to j$ be a morphism, and $X'$ be an object of $C$. Let $f':(lim F)_j\\to X'$ be a morphism. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\n(lim F)_i \\arrow[r, "}
{"name": "ennreal.div_mul_cancel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.div_mul_cancel {a b : ennreal} (h0 : a \u2260 0) (hI : a \u2260 \u22a4) :\n\tb / a * a = b :=", "nl_statement_of_codex": "Let $a,b$ be extended non-negative reals. If $a\\neq 0$ and $a\\neq \\infty$, then $b/a\\cdot a=b$."}
{"name": "category_theory.abelian.epi_of_cokernel_\u03c0_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/basic.lean", "formal_statement": "theorem category_theory.abelian.epi_of_cokernel_\u03c0_eq_zero {C : Type u}\n\t[category_theory.category C] [category_theory.abelian C] {P Q : C} (f : P \u27f6 Q)\n\t(h : category_theory.limits.cokernel.\u03c0 f = 0) :\n\tcategory_theory.epi f :=", "nl_statement_of_codex": "Let $C$ be an abelian category. Let $f:P\\to Q$ be a morphism in $C$. If the cokernel of $f$ is zero, then $f$ is an epimorphism."}
{"name": "pos_of_mul_neg_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem pos_of_mul_neg_right {\u03b1 : Type u} [linear_ordered_ring \u03b1] {a b : \u03b1}\n\t(h : a * b < 0) (ha : a \u2264 0) :\n\t0 < b :=", "nl_statement_of_codex": "Let $R$ be a linear ordered ring. If $a\\leq 0$ and $ab<0$, then $b>0$."}
{"name": "le_iff_forall_one_lt_le_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem le_iff_forall_one_lt_le_mul {\u03b1 : Type u} [group \u03b1] [linear_order \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] [densely_ordered \u03b1] {a b : \u03b1} :\n\ta \u2264 b \u2194 \u2200 (\u03b5 : \u03b1), 1 < \u03b5 \u2192 a \u2264 b * \u03b5 :=", "nl_statement_of_codex": "Let $G$ be a group with a linear order and a dense order. Then $a\\leq b$ if and only if $a\\leq b\\cdot \\epsilon$ for all $\\epsilon\\in G$ with $1<\\epsilon$."}
{"name": "nat.succ_ne_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.succ_ne_succ {n m : \u2115} :\n\tn.succ \u2260 m.succ \u2194 n \u2260 m :=", "nl_statement_of_codex": "$n+1\\neq m+1$ if and only if $n\\neq m$."}
{"name": "uniform_equiv.uniform_inducing", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/equiv.lean", "formal_statement": "theorem uniform_equiv.uniform_inducing {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] (h : \u03b1 \u2243\u1d64 \u03b2) :\n\tuniform_inducing \u21d1h :=", "nl_statement_of_codex": "Let $h:X\\to Y$ be a uniform equivalence. Then $h$ is a uniform embedding."}
{"name": "measurable_equiv.to_equiv_add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/measurable_equiv.lean", "formal_statement": "theorem measurable_equiv.to_equiv_add_left {G : Type*} [measurable_space G]\n\t[add_group G] [has_measurable_add G] (g : G) :\n\t(measurable_equiv.add_left g).to_equiv = equiv.add_left g :=", "nl_statement_of_codex": "The measurable function $f:G\\to G$ defined by $f(x)=g+x$ is an equivalence."}
{"name": "polynomial.cyclotomic_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/cyclotomic/basic.lean", "formal_statement": "theorem polynomial.cyclotomic_two (R : Type*) [ring R] :\n\tpolynomial.cyclotomic 2 R = polynomial.X + 1 :=", "nl_statement_of_codex": "The cyclotomic polynomial of order $2$ is $X+1$."}
{"name": "finset.insert_eq_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.insert_eq_self {\u03b1 : Type*} [decidable_eq \u03b1] {s : finset \u03b1}\n\t{a : \u03b1} :\n\thas_insert.insert a s = s \u2194 a \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $a$ be an element of $s$. Then $s$ is equal to $s\\cup\\{a\\}$ if and only if $a\\in s$."}
{"name": "is_coprime.neg_neg_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/coprime/basic.lean", "formal_statement": "theorem is_coprime.neg_neg_iff {R : Type u} [comm_ring R] (x y : R) :\n\tis_coprime (-x) (-y) \u2194 is_coprime x y :=", "nl_statement_of_codex": "Two elements $x,y$ of a commutative ring $R$ are coprime if and only if $-x$ and $-y$ are coprime."}
{"name": "affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/finite_dimensional.lean", "formal_statement": "theorem affine_independent.affine_span_eq_top_iff_card_eq_finrank_add_one\n\t{k V P \u03b9 : Type*} [division_ring k] [add_comm_group V] [module k V]\n\t[add_torsor V P] [finite_dimensional k V] [fintype \u03b9] {p : \u03b9 \u2192 P}\n\t(hi : affine_independent k p) :\n\taffine_span k (set.range p) = \u22a4 \u2194 fintype.card \u03b9 = finite_dimensional.finrank k V + 1 :=", "nl_statement_of_codex": "Let $V$ be a finite dimensional vector space over a division ring $k$. Let $P$ be an affine space over $V$. Let $p:\\{1,\\ldots,n\\}\\to P$ be a map. Then $p$ is affine independent if and only if the affine span of the image of $p$ is all of $P$ and $n=\\dim_k V+1$."}
{"name": "multiset.disj_sum_lt_disj_sum_of_le_of_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/sum.lean", "formal_statement": "theorem multiset.disj_sum_lt_disj_sum_of_le_of_lt {\u03b1 \u03b2 : Type*}\n\t{s\u2081 s\u2082 : multiset \u03b1} {t\u2081 t\u2082 : multiset \u03b2} (hs : s\u2081 \u2264 s\u2082) (ht : t\u2081 < t\u2082) :\n\ts\u2081.disj_sum t\u2081 < s\u2082.disj_sum t\u2082 :=", "nl_statement_of_codex": "Let $s_1, s_2$ be multisets of elements of $\\alpha$ and let $t_1, t_2$ be multisets of elements of $\\beta$. If $s_1\\leq s_2$ and $t_1<t_2$, then $s_1\\uplus t_1<s_2\\uplus t_2$."}
{"name": "zsqrtd.norm_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.norm_one {d : \u2124} :\n\t1.norm = 1 :=", "nl_statement_of_codex": "The norm of $1$ is $1$."}
{"name": "ordnode.dual_rotate_l", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.dual_rotate_l {\u03b1 : Type*} (l : ordnode \u03b1) (x : \u03b1)\n\t(r : ordnode \u03b1) :\n\t(l.rotate_l x r).dual = r.dual.rotate_r x l.dual :=", "nl_statement_of_codex": "Let $l, r$ be ordered nodes and let $x$ be an element. Then the dual of the left rotation of $l$ by $x$ and $r$ is the right rotation of the dual of $r$ by $x$ and the dual of $l$."}
{"name": "symmetric_rel.mk_mem_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem symmetric_rel.mk_mem_comm {\u03b1 : Type*} {V : set (\u03b1 \u00d7 \u03b1)}\n\t(hV : symmetric_rel V) {x y : \u03b1} :\n\t(x, y) \u2208 V \u2194 (y, x) \u2208 V :=", "nl_statement_of_codex": "Let $V$ be a symmetric relation on a set $X$. Then $(x,y)\\in V$ if and only if $(y,x)\\in V$."}
{"name": "relation.cut_expand_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/hydra.lean", "formal_statement": "theorem relation.cut_expand_singleton {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t{s : multiset \u03b1} {x : \u03b1} (h : \u2200 (x' : \u03b1), x' \u2208 s \u2192 r x' x) :\n\trelation.cut_expand r s {x} :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $A$ and let $s$ be a multiset of elements of $A$. If $x$ is related to every element of $s$, then $x$ is related to $s$."}
{"name": "category_theory.abelian.functor.left_derived_zero_to_self_natural", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/left_derived.lean", "formal_statement": "theorem category_theory.abelian.functor.left_derived_zero_to_self_natural\n\t{C : Type u} [category_theory.category C] {D : Type u}\n\t[category_theory.category D] (F : C \u2964 D) [category_theory.abelian C]\n\t[category_theory.abelian D] [F.additive] [category_theory.enough_projectives C]\n\t{X Y : C} (f : X \u27f6 Y) (P : category_theory.ProjectiveResolution X)\n\t(Q : category_theory.ProjectiveResolution Y) :\n\t(F.left_derived 0).map f \u226b category_theory.abelian.functor.left_derived_zero_to_self_app F Q = category_theory.abelian.functor.left_derived_zero_to_self_app F P \u226b F.map f :=", "nl_statement_of_codex": "Let $F:C\\to D$ be an additive functor between abelian categories. Let $X,Y$ be objects of $C$ and let $P$ and $Q$ be projective resolutions of $X$ and $Y$, respectively. Then the following diagram commutes:\n$$\\require{AMScd}\n\\begin{CD}\n\\operatorname{Hom}_C(P_0,X) @>{\\operatorname{Hom}_C(P_0,f)}>> \\operatorname{Hom}_C(P_0,Y)\\\\\n@V{\\operatorname{Hom}_D(F("}
{"name": "eq_iff_eq_of_sub_eq_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem eq_iff_eq_of_sub_eq_sub {G : Type*} [add_group G] {a b c d : G}\n\t(H : a - b = c - d) :\n\ta = b \u2194 c = d :=", "nl_statement_of_codex": "Let $G$ be an additive group. Then $a=b$ if and only if $c=d$ if and only if $a-b=c-d$."}
{"name": "simple_graph.walk.darts_append", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.darts_append {V : Type u} {G : simple_graph V}\n\t{u v w : V} (p : G.walk u v) (p' : G.walk v w) :\n\t(p.append p').darts = p.darts ++ p'.darts :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $u,v,w$ be vertices of $G$. Let $p$ be a walk from $u$ to $v$ and let $p'$ be a walk from $v$ to $w$. Then the darts of the walk $p\\circ p'$ are the concatenation of the darts of $p$ and $p'$."}
{"name": "submonoid.localization_map.map_units", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.map_units {M : Type*} [comm_monoid M]\n\t{S : submonoid M} {N : Type*} [comm_monoid N] (f : S.localization_map N)\n\t(y : \u21a5S) :\n\tis_unit (\u21d1(f.to_map) \u2191y) :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, and let $f:S\\to N$ be a map of monoids. Then $f(y)$ is a unit in $N$ for each $y\\in S$."}
{"name": "box_integral.has_integral_of_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/basic.lean", "formal_statement": "theorem box_integral.has_integral_of_mul {\u03b9 : Type u} {E : Type v} {F : Type w}\n\t[normed_group E] [normed_space \u211d E] [normed_group F] [normed_space \u211d F]\n\t{I : box_integral.box \u03b9} [fintype \u03b9] {l : box_integral.integration_params}\n\t{f : (\u03b9 \u2192 \u211d) \u2192 E} {vol : box_integral.box_additive_map \u03b9 (E \u2192L[\u211d] F) \u22a4} {y : F}\n\t(a : \u211d)\n\t(h : \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 (\u2203 (r : nnreal \u2192 (\u03b9 \u2192 \u211d) \u2192 \u21a5(set.Ioi 0)), (\u2200 (c : nnreal), l.r_cond (r c)) \u2227 \u2200 (c : nnreal) (\u03c0 : box_integral.tagged_prepartition I), l.mem_base_set I c (r c) \u03c0 \u2192 \u03c0.is_partition \u2192 has_dist.dist (box_integral.integral_sum f vol \u03c0) y \u2264 a * \u03b5)) :\n\tbox_integral.has_integral I l f vol y :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed groups and let $f:I\\to E$ be a function. Suppose that for each $\\epsilon>0$ there is a function $r:\\mathbb{R}_{\\geq 0}\\to I$ such that $r(c)$ is in the base set of $I$ for each $c\\in\\mathbb{R}_{\\geq 0}$ and such that for each $c\\in\\mathbb{R}_{\\geq 0}$ and each tagged partition $\\pi$ of $I$ with $r(c)$ in the base set of $I$ and $\\pi$ a partition,"}
{"name": "linear_map.mul_eq_one_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean", "formal_statement": "theorem linear_map.mul_eq_one_comm {K : Type u} {V : Type v} [field K]\n\t[add_comm_group V] [module K V] [finite_dimensional K V] {f g : V \u2192\u2097[K] V} :\n\tf * g = 1 \u2194 g * f = 1 :=", "nl_statement_of_codex": "Let $K$ be a field, $V$ a finite dimensional $K$-vector space. Then $f,g:V\\to V$ are inverses of each other if and only if $g,f:V\\to V$ are inverses of each other."}
{"name": "polynomial.eval_bit0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/eval.lean", "formal_statement": "theorem polynomial.eval_bit0 {R : Type u} [semiring R] {p : polynomial R}\n\t{x : R} :\n\tpolynomial.eval x (bit0 p) = bit0 (polynomial.eval x p) :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. Then $p(2x)=2p(x)$."}
{"name": "is_add_subgroup.mem_norm_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_subgroup.mem_norm_comm {G : Type*} [add_group G] {s : set G}\n\t(hs : is_normal_add_subgroup s) {a b : G} (hab : a + b \u2208 s) :\n\tb + a \u2208 s :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $s$ be a normal subgroup of $G$. Then $s$ is closed under commutators."}
{"name": "option.cases_on'_none", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/option/basic.lean", "formal_statement": "theorem option.cases_on'_none {\u03b1 \u03b2 : Type*} (x : \u03b2) (f : \u03b1 \u2192 \u03b2) :\n\toption.none.cases_on' x f = x :=", "nl_statement_of_codex": "The function $f$ applied to the value $x$ is equal to $x$."}
{"name": "finsupp.sum_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.sum_apply {\u03b1 \u03b2 M N : Type*} [has_zero M] [add_comm_monoid N]\n\t{f : \u03b1 \u2192\u2080 M} {g : \u03b1 \u2192 M \u2192 \u03b2 \u2192\u2080 N} {a\u2082 : \u03b2} :\n\t\u21d1(f.sum g) a\u2082 = f.sum (\u03bb (a\u2081 : \u03b1) (b : M), \u21d1(g a\u2081 b) a\u2082) :=", "nl_statement_of_codex": "Let $f:A\\to M$ and $g:A\\times M\\to B\\to N$ be finitely supported functions. Then $\\sum_{a\\in A}g(a,f(a))=\\sum_{a\\in A}\\sum_{b\\in B}g(a,f(a))(b)$."}
{"name": "finset.card_singleton_inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/card.lean", "formal_statement": "theorem finset.card_singleton_inter {\u03b1 : Type*} {s : finset \u03b1} {a : \u03b1}\n\t[decidable_eq \u03b1] :\n\t({a} \u2229 s).card \u2264 1 :=", "nl_statement_of_codex": "The cardinality of the intersection of a singleton set and a finite set is at most $1$."}
{"name": "simple_graph.walk.darts_drop_until_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.darts_drop_until_subset {V : Type u}\n\t{G : simple_graph V} [decidable_eq V] {u v w : V} (p : G.walk v w)\n\t(h : u \u2208 p.support) :\n\t(p.drop_until u h).darts \u2286 p.darts :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $u,v,w$ be vertices of $G$. Let $p$ be a walk from $v$ to $w$. If $u$ is a vertex of $p$, then the darts of the walk $p$ from $u$ to $w$ are a subset of the darts of $p$."}
{"name": "zmod.cast_one'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/zmod/basic.lean", "formal_statement": "theorem zmod.cast_one' {n : \u2115} {R : Type*} [ring R] [char_p R n] :\n\t\u21911 = 1 :=", "nl_statement_of_codex": "If $R$ is a ring of characteristic $n$, then $1=1$."}
{"name": "differentiable.comp_differentiable_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem differentiable.comp_differentiable_on {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [normed_group G]\n\t[normed_space \ud835\udd5c G] {f : E \u2192 F} {s : set E} {g : F \u2192 G}\n\t(hg : differentiable \ud835\udd5c g) (hf : differentiable_on \ud835\udd5c f s) :\n\tdifferentiable_on \ud835\udd5c (g \u2218 f) s :=", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over $\\mathbb{K}$ and let $f:E\\to F$ and $g:F\\to G$. If $g$ is differentiable and $f$ is differentiable on $s$, then $g\\circ f$ is differentiable on $s$."}
{"name": "measure_theory.measure.measurable_dirac", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/giry_monad.lean", "formal_statement": "theorem measure_theory.measure.measurable_dirac {\u03b1 : Type*} [measurable_space \u03b1] :\n\tmeasurable measure_theory.measure.dirac :=", "nl_statement_of_codex": "The Dirac measure is measurable."}
{"name": "cauchy_seq_iff_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean", "formal_statement": "theorem cauchy_seq_iff_tendsto {\u03b1 : Type u} {\u03b2 : Type v} [uniform_space \u03b1]\n\t[nonempty \u03b2] [semilattice_sup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n\tcauchy_seq u \u2194 filter.tendsto (prod.map u u) filter.at_top (uniformity \u03b1) :=", "nl_statement_of_codex": "A sequence $u$ in a uniform space $X$ is Cauchy if and only if the product map $u\\times u$ tends to the diagonal in $X\\times X$."}
{"name": "add_con.lift_on_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/congruence.lean", "formal_statement": "theorem add_con.lift_on_coe {M : Type*} [has_add M] {\u03b2 : Sort u_2}\n\t( : add_con M) (f : M \u2192 \u03b2) (h : \u2200 (a b : M), \u21d1c a b \u2192 f a = f b) (x : M) :\n\tadd_con.lift_on \u2191x f h = f x :=", "nl_statement_of_codex": "Let $M$ be a type with an addition operation. Let $f:M\\to\\beta$ be a function. Let $c$ be an equivalence relation on $M$ such that $a\\sim b$ implies $f(a)=f(b)$. Then $f(x)=f(y)$ for all $x,y\\in M$ such that $x\\sim y$."}
{"name": "supr_nhds_le_uniformity", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem supr_nhds_le_uniformity {\u03b1 : Type*} [uniform_space \u03b1] :\n\t(\u2a06 (x : \u03b1), nhds (x, x)) \u2264 uniformity \u03b1 :=", "nl_statement_of_codex": "The uniformity on a uniform space is the supremum of the diagonal neighborhoods."}
{"name": "set.sep_false", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.sep_false {\u03b1 : Type u} {s : set \u03b1} :\n\t{a \u2208 s | false} = \u2205 :=", "nl_statement_of_codex": "The set of elements of $s$ that are false is the empty set."}
{"name": "is_bounded_bilinear_map.differentiable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem is_bounded_bilinear_map.differentiable {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [normed_group G]\n\t[normed_space \ud835\udd5c G] {b : E \u00d7 F \u2192 G} (h : is_bounded_bilinear_map \ud835\udd5c b) :\n\tdifferentiable \ud835\udd5c b :=", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over a nondiscrete normed field $K$ and let $b:E\\times F\\to G$ be a bounded bilinear map. Then $b$ is differentiable."}
{"name": "matrix.det_one_add_mul_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/nonsingular_inverse.lean", "formal_statement": "theorem matrix.det_one_add_mul_comm {m : Type u} {n : Type u'} {\u03b1 : Type v}\n\t[fintype n] [decidable_eq n] [comm_ring \u03b1] [fintype m] [decidable_eq m]\n\t(A : matrix m n \u03b1) (B : matrix n m \u03b1) :\n\t(1 + A.mul B).det = (1 + B.mul A).det :=", "nl_statement_of_codex": "Let $A$ and $B$ be matrices over a commutative ring. Then $\\det(1+AB)=\\det(1+BA)$."}
{"name": "nonempty.congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/nonempty.lean", "formal_statement": "theorem nonempty.congr {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n\tnonempty \u03b1 \u2194 nonempty \u03b2 :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to A$ be functions. Then $A$ is nonempty if and only if $B$ is nonempty."}
{"name": "nnreal.coe_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/nnreal.lean", "formal_statement": "theorem nnreal.coe_sub {r\u2081 r\u2082 : nnreal} (h : r\u2082 \u2264 r\u2081) :\n\t\u2191(r\u2081 - r\u2082) = \u2191r\u2081 - \u2191r\u2082 :=", "nl_statement_of_codex": "Let $r_1, r_2$ be nonnegative real numbers. If $r_2\\leq r_1$, then $r_1-r_2$ is a nonnegative real number and $r_1-r_2=r_1-r_2$."}
{"name": "first_order.language.Lequiv.refl_inv_Lhom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/language_map.lean", "formal_statement": "theorem first_order.language.Lequiv.refl_inv_Lhom (L : first_order.language) :\n\t(first_order.language.Lequiv.refl L).inv_Lhom = first_order.language.Lhom.id L :=", "nl_statement_of_codex": "The inverse of the identity homomorphism of a language $L$ is the identity homomorphism of $L$."}
{"name": "nat.partrec'.comp'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/halting.lean", "formal_statement": "theorem nat.partrec'.comp' {n m : \u2115} {f : vector \u2115 m \u2192. \u2115}\n\t{g : vector \u2115 n \u2192 vector \u2115 m} (hf : nat.partrec' f) (hg : nat.partrec'.vec g) :\n\tnat.partrec' (\u03bb (v : vector \u2115 n), f (g v)) :=", "nl_statement_of_codex": "If $f:\\mathbb{N}^m\\to\\mathbb{N}$ and $g:\\mathbb{N}^n\\to\\mathbb{N}^m$ are primitive recursive, then $f\\circ g:\\mathbb{N}^n\\to\\mathbb{N}$ is primitive recursive."}
{"name": "isometric.dimH_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_dimension.lean", "formal_statement": "theorem isometric.dimH_univ {X Y : Type*} [emetric_space X] [emetric_space Y]\n\t(e : X \u2243\u1d62 Y) :\n\tdimH set.univ = dimH set.univ :=", "nl_statement_of_codex": "Let $X$ and $Y$ be metric spaces. If $X$ and $Y$ are isometric, then $\\dim_H(X)=\\dim_H(Y)$."}
{"name": "topological_division_ring.continuous_units_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/field.lean", "formal_statement": "theorem topological_division_ring.continuous_units_inv (K : Type*)\n\t[division_ring K] [topological_space K] [topological_division_ring K] :\n\tcontinuous (\u03bb (x : K\u02e3), \u2191x\u207b\u00b9) :=", "nl_statement_of_codex": "The function $x\\mapsto x^{-1}$ is continuous on the units of a topological division ring."}
{"name": "holor.slice_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/holor.lean", "formal_statement": "theorem holor.slice_eq {\u03b1 : Type} {d : \u2115} {ds : list \u2115}\n\t(x y : holor \u03b1 (d :: ds)) (h : x.slice = y.slice) :\n\tx = y :=", "nl_statement_of_codex": "Let $x,y$ be holors of the same shape. If the slices of $x$ and $y$ are equal, then $x=y$."}
{"name": "finset.prod_finset_product", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.prod_finset_product {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w}\n\t[comm_monoid \u03b2] (r : finset (\u03b3 \u00d7 \u03b1)) (s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b1)\n\t(h : \u2200 (p : \u03b3 \u00d7 \u03b1), p \u2208 r \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t p.fst) {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2} :\n\tr.prod (\u03bb (p : \u03b3 \u00d7 \u03b1), f p) = s.prod (\u03bb (c : \u03b3), (t c).prod (\u03bb (a : \u03b1), f (c, a))) :=", "nl_statement_of_codex": "Let $r$ be a finite set of pairs of elements of $\\gamma$ and $\\alpha$. Let $s$ be a finite set of elements of $\\gamma$ and let $t$ be a function from $\\gamma$ to finite sets of elements of $\\alpha$. Suppose that for each pair $(c,a)$ of elements of $\\gamma$ and $\\alpha$, $(c,a)\\in r$ if and only if $c\\in s$ and $a\\in t(c)$. Then the product of the elements of $r$ is equal to the product of the products of the elements of the sets $t(c)$ for $c\\in s$."}
{"name": "with_bot.coe_sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem with_bot.coe_sup {\u03b1 : Type u} [semilattice_sup \u03b1] (a b : \u03b1) :\n\t\u2191(a \u2294 b) = \u2191a \u2294 \u2191b :=", "nl_statement_of_codex": "Let $\u03b1$ be a semilattice with top. Then the supremum of $a$ and $b$ in $\u03b1$ is equal to the supremum of $a$ and $b$ in $\u03b1$ with top."}
{"name": "emetric.Hausdorff_edist_self_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean", "formal_statement": "theorem emetric.Hausdorff_edist_self_closure {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1] {s : set \u03b1} :\n\temetric.Hausdorff_edist s (closure s) = 0 :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $A$ be a subset of $X$. Then the pseudo-metric distance between $A$ and the closure of $A$ is zero."}
{"name": "set.piecewise_eq_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/function.lean", "formal_statement": "theorem set.piecewise_eq_on {\u03b1 : Type u} {\u03b2 : Type v} (s : set \u03b1)\n\t[\u03a0 (j : \u03b1), decidable (j \u2208 s)] (f g : \u03b1 \u2192 \u03b2) :\n\tset.eq_on (s.piecewise f g) f s :=", "nl_statement_of_codex": "Let $s$ be a set and let $f,g:s\\to\\beta$. Then the piecewise function $f\\cup g$ is equal to $f$ on $s$."}
{"name": "list.take_append", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.take_append {\u03b1 : Type u} {l\u2081 l\u2082 : list \u03b1} (i : \u2115) :\n\tlist.take (l\u2081.length + i) (l\u2081 ++ l\u2082) = l\u2081 ++ list.take i l\u2082 :=", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists. Then the first $l_1.length+i$ elements of $l_1++l_2$ are the first $l_1.length$ elements of $l_1$ followed by the first $i$ elements of $l_2$."}
{"name": "algebraic_geometry.is_affine_open.Spec_\u0393_identity_hom_app_from_Spec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/AffineScheme.lean", "formal_statement": "theorem algebraic_geometry.is_affine_open.Spec_\u0393_identity_hom_app_from_Spec\n\t{X : algebraic_geometry.Scheme}\n\t{U : topological_space.opens \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)}\n\t(hU : algebraic_geometry.is_affine_open U) :\n\talgebraic_geometry.Spec_\u0393_identity.hom.app (X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U)) \u226b hU.from_Spec.val.c.app (opposite.op U) = (algebraic_geometry.Scheme.Spec.obj (opposite.op (X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U)))).to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.map (category_theory.eq_to_hom _).op :=", "nl_statement_of_codex": "Let $X$ be a scheme and let $U$ be an open affine subscheme of $X$. Then the morphism $\\operatorname{Spec}(\\Gamma(U,\\mathcal{O}_X))\\to U$ is the identity."}
{"name": "list.index_of_nth", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.index_of_nth {\u03b1 : Type u} [decidable_eq \u03b1] {a : \u03b1} {l : list \u03b1}\n\t(h : a \u2208 l) :\n\tl.nth (list.index_of a l) = option.some a :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b1$ and let $a$ be an element of $\u03b1$. If $a$ is in $l$, then $l$ contains $a$ at the index $l.index_of(a)$."}
{"name": "finset.le_fold_max", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/fold.lean", "formal_statement": "theorem finset.le_fold_max {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : finset \u03b1}\n\t[linear_order \u03b2] ( : \u03b2) :\n\tc \u2264 finset.fold linear_order.max b f s \u2194 c \u2264 b \u2228 \u2203 (x : \u03b1) (H : x \u2208 s), c \u2264 f x :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $b\\in B$. Then $c\\leq \\max_{x\\in A} f(x)$ if and only if $c\\leq b$ or there is $x\\in A$ such that $c\\leq f(x)$."}
{"name": "category_theory.limits.biproduct.lift_matrix", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.biproduct.lift_matrix {C : Type u}\n\t[category_theory.category C] [category_theory.preadditive C] {J : Type}\n\t[fintype J] {K : Type} [fintype K]\n\t[category_theory.limits.has_finite_biproducts C] {f : J \u2192 C} {g : K \u2192 C}\n\t{P : C} (x : \u03a0 (j : J), P \u27f6 f j) (m : \u03a0 (j : J) (k : K), f j \u27f6 g k) :\n\tcategory_theory.limits.biproduct.lift x \u226b category_theory.limits.biproduct.matrix m = category_theory.limits.biproduct.lift (\u03bb (k : K), finset.univ.sum (\u03bb (j : J), x j \u226b m j k)) :=", "nl_statement_of_codex": "Let $C$ be a category with finite biproducts. Let $f:J\\to C$ and $g:K\\to C$ be functors. Let $P$ be an object of $C$. Let $x:J\\to C(P,f)$ and $m:J\\times K\\to C(f,g)$ be morphisms. Then the following diagram commutes:\n\\begin{tikzcd}\nP \\arrow[r, "}
{"name": "real.rpow_def_of_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem real.rpow_def_of_nonneg {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) :\n\tx ^ y = ite (x = 0) (ite (y = 0) 1 0) (real.exp (real.log x * y)) :=", "nl_statement_of_codex": "If $x\\geq 0$ and $y\\in\\mathbb{R}$, then $x^y=\\exp(y\\log x)$."}
{"name": "quotient_add_group.hom_quotient_zsmul_of_hom_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/quotient_group.lean", "formal_statement": "theorem quotient_add_group.hom_quotient_zsmul_of_hom_id {A : Type u}\n\t[add_comm_group A] (n : \u2124) :\n\tquotient_add_group.hom_quotient_zsmul_of_hom (add_monoid_hom.id A) n = add_monoid_hom.id (A \u29f8 (zsmul_add_group_hom n).range) :=", "nl_statement_of_codex": "Let $A$ be an abelian group. Then the identity map on $A$ induces the identity map on $A/nA$."}
{"name": "add_valuation.map_add_of_distinct_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/valuation/basic.lean", "formal_statement": "theorem add_valuation.map_add_of_distinct_val {R \u0393\u2080 : Type*}\n\t[linear_ordered_add_comm_group_with_top \u0393\u2080] [ring R] (v : add_valuation R \u0393\u2080)\n\t{x y : R} (h : \u21d1v x \u2260 \u21d1v y) :\n\t\u21d1v (x + y) = linear_order.min (\u21d1v x) (\u21d1v y) :=", "nl_statement_of_codex": "Let $R$ be a ring and let $v$ be an additive valuation on $R$. Let $x,y\\in R$ be such that $v(x)\\neq v(y)$. Then $v(x+y)=\\min\\{v(x),v(y)\\}$."}
{"name": "first_order.language.Theory.simple_graph_model_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/graph.lean", "formal_statement": "theorem first_order.language.Theory.simple_graph_model_iff {V : Type w'}\n\t[first_order.language.graph.Structure V] :\n\tV \u22a8 first_order.language.Theory.simple_graph \u2194 irreflexive (\u03bb (x y : V), first_order.language.Structure.rel_map first_order.language.adj ![x, y]) \u2227 symmetric (\u03bb (x y : V), first_order.language.Structure.rel_map first_order.language.adj ![x, y]) :=", "nl_statement_of_codex": "A graph $G$ is simple if and only if the adjacency relation of $G$ is irreflexive and symmetric."}
{"name": "add_commute.add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/commute.lean", "formal_statement": "theorem add_commute.add_left {S : Type*} [add_semigroup S] {a b c : S}\n\t(hac : add_commute a c) (hbc : add_commute b c) :\n\tadd_commute (a + b) c :=", "nl_statement_of_codex": "Let $S$ be an additive semigroup. If $a$ and $c$ commute and $b$ and $c$ commute, then $a+b$ and $c$ commute."}
{"name": "finset.prod_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/order.lean", "formal_statement": "theorem finset.prod_pos {\u03b9 R : Type*} [ordered_comm_semiring R] {f : \u03b9 \u2192 R}\n\t{s : finset \u03b9} [nontrivial R] (h0 : \u2200 (i : \u03b9), i \u2208 s \u2192 0 < f i) :\n\t0 < s.prod (\u03bb (i : \u03b9), f i) :=", "nl_statement_of_codex": "Let $R$ be a nontrivial ordered commutative semiring. Let $f:I\\to R$ be a function and let $s$ be a finite set. If $f(i)>0$ for all $i\\in s$, then $\\prod_{i\\in s}f(i)>0$."}
{"name": "affine_equiv.to_equiv_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_equiv.lean", "formal_statement": "theorem affine_equiv.to_equiv_inj {k P\u2081 P\u2082 V\u2081 V\u2082 : Type*} [ring k]\n\t[add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081] [add_comm_group V\u2082]\n\t[module k V\u2082] [add_torsor V\u2082 P\u2082] {e e' : P\u2081 \u2243\u1d43[k] P\u2082} :\n\te.to_equiv = e'.to_equiv \u2194 e = e' :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ and $V_2$ be $k$-modules, and $P_1$ and $P_2$ be $k$-torsors. Then two affine equivalences $e, e':P_1\\to P_2$ are equal if and only if the underlying equivalences $e.to\\_equiv=e'.to\\_equiv$ are equal."}
{"name": "measure_theory.ae_strongly_measurable.nnnorm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem measure_theory.ae_strongly_measurable.nnnorm {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {\u03b2 : Type*}\n\t[normed_group \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : measure_theory.ae_strongly_measurable f \u03bc) :\n\tmeasure_theory.ae_strongly_measurable (\u03bb (x : \u03b1), \u2225f x\u2225\u208a) \u03bc :=", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{R}$ be a strongly measurable function. Then the function $x\\mapsto |f(x)|$ is strongly measurable."}
{"name": "int.mod_add_div'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.mod_add_div' (m k : \u2124) :\n\tm % k + m / k * k = m :=", "nl_statement_of_codex": "For all integers $m$ and $k$, $m\\%k+m/k\\cdot k=m$."}
{"name": "filter.at_bot_countable_basis", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.at_bot_countable_basis {\u03b1 : Type*} [nonempty \u03b1]\n\t[semilattice_inf \u03b1] [encodable \u03b1] :\n\tfilter.at_bot.has_countable_basis (\u03bb (_x : \u03b1), true) set.Iic :=", "nl_statement_of_codex": "The filter at $\\bot$ has a countable basis."}
{"name": "lt_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/field.lean", "formal_statement": "theorem lt_inv {\u03b1 : Type*} [linear_ordered_semifield \u03b1] {a b : \u03b1} (ha : 0 < a)\n\t(hb : 0 < b) :\n\ta < b\u207b\u00b9 \u2194 b < a\u207b\u00b9 :=", "nl_statement_of_codex": "Let $a, b$ be positive elements of a linearly ordered semifield. Then $a<b^{-1}$ if and only if $b<a^{-1}$."}
{"name": "parser.one_of_eq_done", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/buffer/parser/basic.lean", "formal_statement": "theorem parser.one_of_eq_done {cb : char_buffer} {n n' : \u2115} { : char}\n\t{cs : list char} :\n\tparser.one_of cs cb n = parse_result.done n' c \u2194 \u2203 (hn : n < buffer.size cb), c \u2208 cs \u2227 n' = n + 1 \u2227 buffer.read cb \u27e8n, hn\u27e9 = c :=", "nl_statement_of_codex": "Let $cb$ be a character buffer, $n$ and $n'$ be natural numbers, $c$ be a character, and $cs$ be a list of characters. Then the parser `parser.one_of cs cb n` returns `parse_result.done n' c` if and only if there is an $n<$size of $cb$ such that $c\\in cs$, $n'=n+1$, and the $n$th character of $cb$ is $c$."}
{"name": "associates.factors_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/unique_factorization_domain.lean", "formal_statement": "theorem associates.factors_prod {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1]\n\t[unique_factorization_monoid \u03b1] [dec : decidable_eq \u03b1]\n\t[dec' : decidable_eq (associates \u03b1)] (a : associates \u03b1) :\n\ta.factors.prod = a :=", "nl_statement_of_codex": "Let $R$ be a unique factorization domain. Then the product of the associates of the prime factors of $a\\in R$ is equal to $a$."}
{"name": "matrix.to_lin_eq_to_lin'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/to_lin.lean", "formal_statement": "theorem matrix.to_lin_eq_to_lin' {R : Type*} [comm_semiring R] {m n : Type*}\n\t[fintype n] [fintype m] [decidable_eq n] :\n\tmatrix.to_lin (pi.basis_fun R n) (pi.basis_fun R m) = matrix.to_lin' :=", "nl_statement_of_codex": "The matrix of the linear map $f:R^n\\to R^m$ with respect to the standard bases of $R^n$ and $R^m$ is the same as the matrix of $f$ with respect to the bases $\\{e_1,\\ldots,e_n\\}$ and $\\{e_1,\\ldots,e_m\\}$."}
{"name": "complex.closure_set_of_lt_im", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/re_im_topology.lean", "formal_statement": "theorem complex.closure_set_of_lt_im (a : \u211d) :\n\tclosure {z : \u2102 | a < z.im} = {z : \u2102 | a \u2264 z.im} :=", "nl_statement_of_codex": "The closure of the set $\\{z\\in\\mathbb{C}\\mid a<\\mathrm{Im}(z)\\}$ is the set $\\{z\\in\\mathbb{C}\\mid a\\leq\\mathrm{Im}(z)\\}$."}
{"name": "linear_equiv.dim_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/dimension.lean", "formal_statement": "theorem linear_equiv.dim_eq {R : Type u} [ring R] {M : Type v}\n\t[add_comm_group M] [module R M] {M\u2081 : Type v} [add_comm_group M\u2081] [module R M\u2081]\n\t(f : M \u2243\u2097[R] M\u2081) :\n\tmodule.rank R M = module.rank R M\u2081 :=", "nl_statement_of_codex": "Let $R$ be a ring and let $M$ and $M_1$ be $R$-modules. If $f:M\\to M_1$ is a linear equivalence, then $\\dim_R M=\\dim_R M_1$."}
{"name": "vector_span_eq_span_vsub_set_right_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_subspace.lean", "formal_statement": "theorem vector_span_eq_span_vsub_set_right_ne (k : Type*) {V P : Type*} [ring k]\n\t[add_comm_group V] [module k V] [add_torsor V P] {s : set P} {p : P}\n\t(hp : p \u2208 s) :\n\tvector_span k s = submodule.span k ((\u03bb (_x : P), _x -\u1d65 p) '' (s \\ {p})) :=", "nl_statement_of_codex": "Let $V$ be a $k$-module and let $P$ be an $k$-additive torsor over $V$. Let $s$ be a subset of $P$ and let $p\\in s$. Then the vector span of $s$ is equal to the span of the set $\\{x-p\\mid x\\in s\\setminus\\{p\\}\\}$."}
{"name": "fderiv_within_sub_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem fderiv_within_sub_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} {s : set E}\n\t(hxs : unique_diff_within_at \ud835\udd5c s x) ( : F) :\n\tfderiv_within \ud835\udd5c (\u03bb (y : E), f y - c) s x = fderiv_within \ud835\udd5c f s x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be a function and let $x\\in E$. Suppose that $f$ is differentiable at $x$. Then $f$ is differentiable at $x$ if and only if $f-c$ is differentiable at $x$."}
{"name": "bilin_form.symm_comp_of_nondegenerate_left_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/bilinear_form.lean", "formal_statement": "theorem bilin_form.symm_comp_of_nondegenerate_left_apply {V K : Type*0}\n\t[field K] [add_comm_group V] [module K V] [finite_dimensional K V]\n\t(B\u2081 : bilin_form K V) {B\u2082 : bilin_form K V} (b\u2082 : B\u2082.nondegenerate) (v w : V) :\n\t\u21d1B\u2082 (\u21d1(B\u2081.symm_comp_of_nondegenerate B\u2082 b\u2082) w) v = \u21d1B\u2081 w v :=", "nl_statement_of_codex": "Let $V$ be a finite dimensional vector space over a field $K$. Let $B_1$ and $B_2$ be bilinear forms on $V$. If $B_2$ is nondegenerate, then $B_1(w,v)=B_2(B_1^*(w),v)$ for all $w,v\\in V$."}
{"name": "category_theory.with_initial.lift_to_initial_unique_inv_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/with_terminal.lean", "formal_statement": "theorem category_theory.with_initial.lift_to_initial_unique_inv_app {C : Type u}\n\t[category_theory.category C] {D : Type*} [category_theory.category D] {Z : D}\n\t(F : C \u2964 D) (hZ : category_theory.limits.is_initial Z)\n\t(G : category_theory.with_initial C \u2964 D)\n\t(h : category_theory.with_initial.incl \u22d9 G \u2245 F)\n\t(hG : G.obj category_theory.with_initial.star \u2245 Z)\n\t(X : category_theory.with_initial C) :\n\t(category_theory.with_initial.lift_to_initial_unique F hZ G h hG).inv.app X = (category_theory.with_initial.lift_unique._match_1 F (\u03bb (z : C), hZ.to (F.obj z)) _ G h hG X).inv :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ be a functor. Let $Z$ be an initial object of $D$. Let $G:C\\to D$ be a functor such that $G(*)=Z$. Then the inverse of the unique morphism $G\\to F$ is the inverse of the unique morphism $G(X)\\to F(X)$ for each object $X$ of $C$."}
{"name": "nat.gcd_mul_right_add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.gcd_mul_right_add_left (m n k : \u2115) :\n\t(k * n + m).gcd n = m.gcd n :=", "nl_statement_of_codex": "For all $m,n,k\\in\\mathbb{N}$, $\\gcd(kn+m,n)=\\gcd(m,n)$."}
{"name": "finprod_mem_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finprod_mem_one {\u03b1 M : Type*} [comm_monoid M] (s : set \u03b1) :\n\tfinprod (\u03bb (i : \u03b1), finprod (\u03bb (H : i \u2208 s), 1)) = 1 :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid. Then $\\prod_{i\\in s}\\prod_{i\\in s}1=1$."}
{"name": "nnreal.tsum_mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/nnreal.lean", "formal_statement": "theorem nnreal.tsum_mul_left {\u03b1 : Type*} (a : nnreal) (f : \u03b1 \u2192 nnreal) :\n\t\u2211' (x : \u03b1), a * f x = a * \u2211' (x : \u03b1), f x :=", "nl_statement_of_codex": "Let $a$ be a nonnegative real number and let $f$ be a function from a set $A$ to the nonnegative reals. Then $\\sum_{x\\in A} a\\cdot f(x)=a\\cdot \\sum_{x\\in A} f(x)$."}
{"name": "set.range_quot_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.range_quot_mk {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n\tset.range (quot.mk r) = set.univ :=", "nl_statement_of_codex": "The range of the quotient map $q:X\\to X/\\sim$ is the whole set $X/\\sim$."}
{"name": "nat.gcd_mul_left_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.gcd_mul_left_left (m n : \u2115) :\n\t(m * n).gcd n = n :=", "nl_statement_of_codex": "The greatest common divisor of $m\\cdot n$ and $n$ is $n$."}
{"name": "direct_sum.equiv_congr_left_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/basic.lean", "formal_statement": "theorem direct_sum.equiv_congr_left_apply {\u03b9 : Type v} {\u03b2 : \u03b9 \u2192 Type w}\n\t[\u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)] {\u03ba : Type*} (h : \u03b9 \u2243 \u03ba)\n\t(f : direct_sum \u03b9 (\u03bb (i : \u03b9), \u03b2 i)) (k : \u03ba) :\n\t\u21d1(\u21d1(direct_sum.equiv_congr_left h) f) k = \u21d1f (\u21d1(h.symm) k) :=", "nl_statement_of_codex": "Let $f:I\\to\\bigoplus_{i\\in I}B_i$ be a function. Then $f$ is equal to the function $g:J\\to\\bigoplus_{j\\in J}B_{h(j)}$ defined by $g(j)=f(h^{-1}(j))$."}
{"name": "simple_graph.subgraph.is_perfect_matching_iff_forall_degree", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/matching.lean", "formal_statement": "theorem simple_graph.subgraph.is_perfect_matching_iff_forall_degree {V : Type u}\n\t{G : simple_graph V} {M : G.subgraph} [\u03a0 (v : V), fintype \u21a5(M.neighbor_set v)] :\n\tM.is_perfect_matching \u2194 \u2200 (v : V), M.degree v = 1 :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $M$ be a subgraph of $G$. Then $M$ is a perfect matching if and only if the degree of each vertex in $M$ is $1$."}
{"name": "pmf.filter_apply_ne_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/probability_mass_function/constructions.lean", "formal_statement": "theorem pmf.filter_apply_ne_zero_iff {\u03b1 : Type*} {p : pmf \u03b1} {s : set \u03b1}\n\t(h : \u2203 (a : \u03b1) (H : a \u2208 s), a \u2208 p.support) (a : \u03b1) :\n\t\u21d1(p.filter s h) a \u2260 0 \u2194 a \u2208 s \u2227 a \u2208 p.support :=", "nl_statement_of_codex": "Let $p$ be a probability mass function on $\u03b1$ and let $s$ be a subset of $\u03b1$. Suppose that $s$ is nonempty and that $s$ is contained in the support of $p$. Then $p(s)$ is the probability mass function on $\u03b1$ defined by $p(s)(a)=p(a)$ if $a\\in s$ and $p(s)(a)=0$ otherwise."}
{"name": "fin.univ_cast_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem fin.univ_cast_succ (n : \u2115) :\n\tfinset.univ = finset.cons (fin.last n) (finset.map fin.cast_succ.to_embedding finset.univ) _ :=", "nl_statement_of_codex": "The set of all finite subsets of $\\{1,\\ldots,n\\}$ is equal to the set of all finite subsets of $\\{1,\\ldots,n-1\\}$ together with the set $\\{n\\}$."}
{"name": "codisjoint.eq_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem codisjoint.eq_top {\u03b1 : Type u} [semilattice_sup \u03b1] [order_top \u03b1]\n\t{a b : \u03b1} :\n\tcodisjoint a b \u2192 a \u2294 b = \u22a4 :=", "nl_statement_of_codex": "Let $a$ and $b$ be elements of a complete lattice. If $a$ and $b$ are codisjoint, then $a\\vee b=1$."}
{"name": "affine_isometry_equiv.coe_to_homeomorph", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/affine_isometry.lean", "formal_statement": "theorem affine_isometry_equiv.coe_to_homeomorph {\ud835\udd5c V V\u2082 P P\u2082 : Type*}\n\t[normed_field \ud835\udd5c] [semi_normed_group V] [semi_normed_group V\u2082]\n\t[normed_space \ud835\udd5c V] [normed_space \ud835\udd5c V\u2082] [pseudo_metric_space P]\n\t[pseudo_metric_space P\u2082] [normed_add_torsor V P] [normed_add_torsor V\u2082 P\u2082]\n\t(e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) :\n\t\u21d1(e.to_homeomorph) = \u21d1e :=", "nl_statement_of_codex": "Let $P$ and $P_2$ be normed add torsors over $V$ and $V_2$, respectively. Let $e:P\\to P_2$ be an affine isometry. Then $e$ is a homeomorphism."}
{"name": "polynomial.map_dvd_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/div.lean", "formal_statement": "theorem polynomial.map_dvd_map {R : Type u} {S : Type v} [comm_ring R]\n\t[comm_ring S] (f : R \u2192+* S) (hf : function.injective \u21d1f) {x y : polynomial R}\n\t(hx : x.monic) :\n\tpolynomial.map f x \u2223 polynomial.map f y \u2194 x \u2223 y :=", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings and let $f:R\\to S$ be a ring homomorphism. If $f$ is injective, then $f(x)$ divides $f(y)$ in $S$ if and only if $x$ divides $y$ in $R$."}
{"name": "set.Iic_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Iic_bot {\u03b1 : Type*} [partial_order \u03b1] [order_bot \u03b1] :\n\tset.Iic \u22a5 = {\u22a5} :=", "nl_statement_of_codex": "The set $\\{x\\in X\\mid x\\leq \\bot\\}$ is equal to $\\{\\bot\\}$."}
{"name": "category_theory.limits.concrete.limit_ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/concrete_category.lean", "formal_statement": "theorem category_theory.limits.concrete.limit_ext {C : Type u}\n\t[category_theory.category C] [category_theory.concrete_category C] {J : Type w}\n\t[category_theory.small_category J] (F : J \u2964 C)\n\t[category_theory.limits.preserves_limit F (category_theory.forget C)]\n\t[category_theory.limits.has_limit F] (x y : \u21a5(category_theory.limits.limit F)) :\n\t(\u2200 (j : J), \u21d1(category_theory.limits.limit.\u03c0 F j) x = \u21d1(category_theory.limits.limit.\u03c0 F j) y) \u2192 x = y :=", "nl_statement_of_codex": "Let $C$ be a category and let $F:J\\to C$ be a functor. If $F$ has a limit, then the limit is unique up to isomorphism."}
{"name": "add_subsemigroup.mem_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/basic.lean", "formal_statement": "theorem add_subsemigroup.mem_closure {M : Type*} [has_add M] {s : set M} {x : M} :\n\tx \u2208 add_subsemigroup.closure s \u2194 \u2200 (S : add_subsemigroup M), s \u2286 \u2191S \u2192 x \u2208 S :=", "nl_statement_of_codex": "Let $M$ be a set with an addition operation. Let $s$ be a subset of $M$. Then $x\\in\\overline{s}$ if and only if $x$ is in every additive subsemigroup of $M$ that contains $s$."}
{"name": "algebraic_geometry.Scheme.open_cover.pushforward_iso_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/open_immersion.lean", "formal_statement": "theorem algebraic_geometry.Scheme.open_cover.pushforward_iso_map\n\t{X Y : algebraic_geometry.Scheme} (\ud835\udcb0 : X.open_cover) (f : X \u27f6 Y)\n\t[category_theory.is_iso f] (_x : \ud835\udcb0.J) :\n\t(\ud835\udcb0.pushforward_iso f).map _x = \ud835\udcb0.map _x \u226b f :=", "nl_statement_of_codex": "Let $X$ and $Y$ be schemes and let $f:X\\to Y$ be an isomorphism. Let $\\mathcal{U}$ be an open cover of $X$. Then the map $\\mathcal{U}\\to f(\\mathcal{U})$ is an isomorphism."}
{"name": "probability_theory.ident_distrib.ae_strongly_measurable_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/ident_distrib.lean", "formal_statement": "theorem probability_theory.ident_distrib.ae_strongly_measurable_iff\n\t{\u03b1 \u03b2 \u03b3 : Type*} [measurable_space \u03b1] [measurable_space \u03b2] [measurable_space \u03b3]\n\t{\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} {f : \u03b1 \u2192 \u03b3}\n\t{g : \u03b2 \u2192 \u03b3} [topological_space \u03b3] [topological_space.metrizable_space \u03b3]\n\t[borel_space \u03b3] (h : probability_theory.ident_distrib f g \u03bc \u03bd) :\n\tmeasure_theory.ae_strongly_measurable f \u03bc \u2194 measure_theory.ae_strongly_measurable g \u03bd :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\gamma$ be measurable functions. Then $f$ is strongly measurable if and only if $g$ is strongly measurable."}
{"name": "finset.piecewise_le_of_le_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.piecewise_le_of_le_of_le {\u03b1 : Type*} (s : finset \u03b1)\n\t[\u03a0 (j : \u03b1), decidable (j \u2208 s)] {\u03b4 : \u03b1 \u2192 Type*} [\u03a0 (i : \u03b1), preorder (\u03b4 i)]\n\t{f g h : \u03a0 (i : \u03b1), \u03b4 i} (Hf : f \u2264 h) (Hg : g \u2264 h) :\n\ts.piecewise f g \u2264 h :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f,g,h:s\\to R$ be functions. If $f\\leq h$ and $g\\leq h$, then $f\\vee g\\leq h$."}
{"name": "Top.sheaf.inter_union_pullback_cone_fst", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sheaves/sheaf_condition/pairwise_intersections.lean", "formal_statement": "theorem Top.sheaf.inter_union_pullback_cone_fst {X : Top} {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_products C]\n\t(F : Top.sheaf C X) (U V : topological_space.opens \u21a5X) :\n\t(F.inter_union_pullback_cone U V).fst = F.val.map (category_theory.hom_of_le le_sup_left).op :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $F$ be a sheaf on $X$. Let $U$ and $V$ be open subsets of $X$. Then the first component of the pullback of $F$ along the inclusion of $U\\cup V$ into $X$ is the pullback of $F$ along the inclusion of $U$ into $X$."}
{"name": "filter.liminf_nat_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/liminf_limsup.lean", "formal_statement": "theorem filter.liminf_nat_add {\u03b1 : Type*} [complete_lattice \u03b1] (f : \u2115 \u2192 \u03b1)\n\t(k : \u2115) :\n\tfilter.at_top.liminf (\u03bb (i : \u2115), f (i + k)) = filter.at_top.liminf f :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\alpha$ be a function. Then $\\liminf_{i\\to\\infty}f(i+k)=\\liminf_{i\\to\\infty}f(i)$."}
{"name": "ordinal.opow_dvd_opow_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.opow_dvd_opow_iff {a b c : ordinal} (a1 : 1 < a) :\n\ta ^ b \u2223 a ^ c \u2194 b \u2264 c :=", "nl_statement_of_codex": "Let $a, b, c$ be ordinals. If $a>1$, then $a^b$ divides $a^c$ if and only if $b\\leq c$."}
{"name": "finsupp_lequiv_dfinsupp_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/to_dfinsupp.lean", "formal_statement": "theorem finsupp_lequiv_dfinsupp_symm_apply {\u03b9 : Type*} (R : Type*) {M : Type*}\n\t[decidable_eq \u03b9] [semiring R] [add_comm_monoid M]\n\t[\u03a0 (m : M), decidable (m \u2260 0)] [module R M] :\n\t\u21d1((finsupp_lequiv_dfinsupp R).symm) = dfinsupp.to_finsupp :=", "nl_statement_of_codex": "The map from finitely supported functions to finitely supported functions is the inverse of the map from finitely supported functions to finitely supported functions."}
{"name": "measure_theory.measure.prod_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/prod.lean", "formal_statement": "theorem measure_theory.measure.prod_zero {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[measurable_space \u03b2] (\u03bc : measure_theory.measure \u03b1) :\n\t\u03bc.prod 0 = 0 :=", "nl_statement_of_codex": "Let $\\mu$ be a measure on a measurable space $(X,\\mathcal{A})$. Then $\\mu\\times 0=0$."}
{"name": "direct_sum.lie_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/direct_sum.lean", "formal_statement": "theorem direct_sum.lie_of (R : Type u) (\u03b9 : Type v) [comm_ring R]\n\t(L : \u03b9 \u2192 Type w) [\u03a0 (i : \u03b9), lie_ring (L i)] [\u03a0 (i : \u03b9), lie_algebra R (L i)]\n\t[decidable_eq \u03b9] {i j : \u03b9} (x : L i) (y : L j) :\n\t\u2045\u21d1(direct_sum.of L i) x,\u21d1(direct_sum.of L j) y\u2046 = dite (j = i) (\u03bb (hij : j = i), \u21d1(direct_sum.lie_algebra_of R \u03b9 L i) \u2045x,hij.rec_on y\u2046) (\u03bb (hij : \u00acj = i), 0) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $\\mathcal{I}$ be a set, and let $L_i$ be a Lie ring for each $i\\in\\mathcal{I}$. Then the Lie bracket on the direct sum $\\bigoplus_{i\\in\\mathcal{I}}L_i$ is given by\n$$\\left[\\sum_{i\\in\\mathcal{I}}x_i,\\sum_{i\\in\\mathcal{I}}y_i\\right]=\\sum_{i\\in\\mathcal{I}}\\left[x_i,y_i\\right]$$\nwhere $x_i\\in"}
{"name": "fintype.card_eq_one_iff_nonempty_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem fintype.card_eq_one_iff_nonempty_unique {\u03b1 : Type*} [fintype \u03b1] :\n\tfintype.card \u03b1 = 1 \u2194 nonempty (unique \u03b1) :=", "nl_statement_of_codex": "The cardinality of a finite type is $1$ if and only if it has a unique element."}
{"name": "cont_diff_on_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff_on_snd {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {n : with_top \u2115} {s : set (E \u00d7 F)} :\n\tcont_diff_on \ud835\udd5c n prod.snd s :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Then the projection map $p:E\\times F\\to F$ is $n$-times continuously differentiable on any set $S\\subset E\\times F$."}
{"name": "zero_lt.le_mul_iff_one_le_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas_zero_lt.lean", "formal_statement": "theorem zero_lt.le_mul_iff_one_le_right {\u03b1 : Type u} {a b : \u03b1} [mul_one_class \u03b1]\n\t[has_zero \u03b1] [preorder \u03b1] [zero_lt.pos_mul_mono \u03b1] [zero_lt.pos_mul_mono_rev \u03b1]\n\t(a0 : 0 < a) :\n\ta \u2264 a * b \u2194 1 \u2264 b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a preordered monoid with $0<a$. Then $a\\leq ab$ if and only if $1\\leq b$."}
{"name": "picard_lindelof.fun_space.lipschitz", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/ODE/picard_lindelof.lean", "formal_statement": "theorem picard_lindelof.fun_space.lipschitz {E : Type*} [normed_group E]\n\t[normed_space \u211d E] {v : picard_lindelof E} (f : v.fun_space) :\n\tlipschitz_with v.C \u21d1f :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $v$ be a Picard-Lindel\u00f6f space. Then the function $f:v\\to E$ is Lipschitz."}
{"name": "finsupp.is_pwo", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/pwo.lean", "formal_statement": "theorem finsupp.is_pwo {\u03b1 \u03c3 : Type*} [has_zero \u03b1] [linear_order \u03b1]\n\t[is_well_order \u03b1 has_lt.lt] [fintype \u03c3] (S : set (\u03c3 \u2192\u2080 \u03b1)) :\n\tS.is_pwo :=", "nl_statement_of_codex": "Let $S$ be a set of finitely supported functions from $\\sigma$ to $\\alpha$. Then $S$ is a principal well-ordered set."}
{"name": "algebra.mem_Inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem algebra.mem_Inf {R : Type u} {A : Type v} [comm_semiring R] [semiring A]\n\t[algebra R A] {S : set (subalgebra R A)} {x : A} :\n\tx \u2208 has_Inf.Inf S \u2194 \u2200 (p : subalgebra R A), p \u2208 S \u2192 x \u2208 p :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a semiring, and $R\\to A$ an algebra. Let $S$ be a set of subalgebras of $A$. Then $x\\in\\bigcap S$ if and only if $x\\in p$ for all $p\\in S$."}
{"name": "num.of_nat'_bit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem num.of_nat'_bit (b : bool) (n : \u2115) :\n\tnum.of_nat' (nat.bit b n) = cond b num.bit1 num.bit0 (num.of_nat' n) :=", "nl_statement_of_codex": "The binary representation of $2n+1$ is obtained from the binary representation of $n$ by adding a $1$ at the beginning."}
{"name": "continuous_map.homotopy_with.coe_to_continuous_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homotopy/basic.lean", "formal_statement": "theorem continuous_map.homotopy_with.coe_to_continuous_map {X : Type u}\n\t{Y : Type v} [topological_space X] [topological_space Y] {f\u2080 f\u2081 : C(X, Y)}\n\t{P : C(X, Y) \u2192 Prop} (F : f\u2080.homotopy_with f\u2081 P) :\n\t\u21d1(F.to_homotopy.to_continuous_map) = \u21d1F :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces. Let $f_0, f_1:X\\to Y$ be continuous maps. Let $P:C(X,Y)\\to\\mathbb{R}$ be a property of continuous maps. Let $F:X\\times[0,1]\\to Y$ be a homotopy between $f_0$ and $f_1$ such that $P(F(x,t))$ holds for all $x\\in X$ and $t\\in[0,1]$. Then $F$ is a continuous map."}
{"name": "alg_equiv.map_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.map_div {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w} [comm_ring R]\n\t[division_ring A\u2081] [division_ring A\u2082] [algebra R A\u2081] [algebra R A\u2082]\n\t(e : A\u2081 \u2243\u2090[R] A\u2082) (x y : A\u2081) :\n\t\u21d1e (x / y) = \u21d1e x / \u21d1e y :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $A_1$ and $A_2$ be division rings, and $e:A_1\\to A_2$ be an algebra isomorphism. Then $e(x/y)=e(x)/e(y)$."}
{"name": "measure_theory.outer_measure.of_function_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.of_function_le {\u03b1 : Type*}\n\t{m : set \u03b1 \u2192 ennreal} {m_empty : m \u2205 = 0} (s : set \u03b1) :\n\t\u21d1(measure_theory.outer_measure.of_function m m_empty) s \u2264 m s :=", "nl_statement_of_codex": "Let $m$ be an outer measure on a set $X$. Then the outer measure of a set $A\\subset X$ is less than or equal to $m(A)$."}
{"name": "is_subgroup.mul_mem_cancel_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_subgroup.mul_mem_cancel_right {G : Type*} {a b : G} [group G]\n\t{s : set G} (hs : is_subgroup s) (h : a \u2208 s) :\n\tb * a \u2208 s \u2194 b \u2208 s :=", "nl_statement_of_codex": "Let $G$ be a group and let $s$ be a subgroup of $G$. Then $b*a\\in s$ if and only if $b\\in s$."}
{"name": "finset.sum_card_bipartite_above_eq_sum_card_bipartite_below", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/double_counting.lean", "formal_statement": "theorem finset.sum_card_bipartite_above_eq_sum_card_bipartite_below\n\t{\u03b1 \u03b2 : Type*} (r : \u03b1 \u2192 \u03b2 \u2192 Prop) {s : finset \u03b1} {t : finset \u03b2}\n\t[\u03a0 (a : \u03b1) (b : \u03b2), decidable (r a b)] :\n\ts.sum (\u03bb (a : \u03b1), (finset.bipartite_above r t a).card) = t.sum (\u03bb (b : \u03b2), (finset.bipartite_below r s b).card) :=", "nl_statement_of_codex": "Let $r$ be a relation between two finite sets $S$ and $T$. Then the sum of the sizes of the sets $r(a)$ for $a\\in S$ is equal to the sum of the sizes of the sets $r^{-1}(b)$ for $b\\in T$."}
{"name": "monotone_mul_left_of_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem monotone_mul_left_of_nonneg {\u03b1 : Type u} [linear_ordered_semiring \u03b1]\n\t{a : \u03b1} (ha : 0 \u2264 a) :\n\tmonotone (\u03bb (x : \u03b1), a * x) :=", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring and let $a\\in R$. If $a\\geq 0$, then the function $x\\mapsto ax$ is monotone."}
{"name": "cardinal.mk_bUnion_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.mk_bUnion_le {\u03b9 \u03b1 : Type u} (A : \u03b9 \u2192 set \u03b1) (s : set \u03b9) :\n\tcardinal.mk (\u21a5\u22c3 (x : \u03b9) (H : x \u2208 s), A x) \u2264 cardinal.mk \u21a5s * \u2a06 (x : \u21a5s), cardinal.mk \u21a5(A x.val) :=", "nl_statement_of_codex": "Let $A$ be a family of sets indexed by $I$. Then the cardinality of the union of the sets in $A$ is less than or equal to the cardinality of $I$ times the supremum of the cardinalities of the sets in $A$."}
{"name": "monoid_with_zero_hom.coe_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem monoid_with_zero_hom.coe_comp {M N P : Type*} [mul_zero_one_class M]\n\t[mul_zero_one_class N] [mul_zero_one_class P] (g : N \u2192*\u2080 P) (f : M \u2192*\u2080 N) :\n\t\u21d1(g.comp f) = \u21d1g \u2218 \u21d1f :=", "nl_statement_of_codex": "Let $M, N, P$ be monoids with zero. Let $f:M\\to N$ and $g:N\\to P$ be monoid homomorphisms. Then $g\\circ f$ is a monoid homomorphism from $M$ to $P$."}
{"name": "discrete_quotient.of_le_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/discrete_quotient.lean", "formal_statement": "theorem discrete_quotient.of_le_comp {X : Type*} [topological_space X]\n\t{A B C : discrete_quotient X} (h1 : A \u2264 B) (h2 : B \u2264 C) :\n\tdiscrete_quotient.of_le _ = discrete_quotient.of_le h2 \u2218 discrete_quotient.of_le h1 :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A, B, C$ be discrete quotients of $X$. If $A\\leq B$ and $B\\leq C$, then $A\\leq C$."}
{"name": "polynomial.erase_lead_nat_degree_lt_or_erase_lead_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/erase_lead.lean", "formal_statement": "theorem polynomial.erase_lead_nat_degree_lt_or_erase_lead_eq_zero {R : Type*}\n\t[semiring R] (f : polynomial R) :\n\tf.erase_lead.nat_degree < f.nat_degree \u2228 f.erase_lead = 0 :=", "nl_statement_of_codex": "Let $f$ be a polynomial over a semiring $R$. Then either the degree of $f$ is strictly less than the degree of $f$ with the leading coefficient erased, or $f$ with the leading coefficient erased is zero."}
{"name": "complex.exists_root", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/polynomial.lean", "formal_statement": "theorem complex.exists_root {f : polynomial \u2102} (hf : 0 < f.degree) :\n\t\u2203 (z : \u2102), f.is_root z :=", "nl_statement_of_codex": "Let $f$ be a non-constant polynomial with complex coefficients. Then $f$ has a root."}
{"name": "nat.rfind_spec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/partrec.lean", "formal_statement": "theorem nat.rfind_spec {p : \u2115 \u2192. bool} {n : \u2115} (h : n \u2208 nat.rfind p) :\n\tbool.tt \u2208 p n :=", "nl_statement_of_codex": "If $n$ is in the range of the function $p$, then $p(n)$ is true."}
{"name": "sym2.lift_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sym/sym2.lean", "formal_statement": "theorem sym2.lift_mk {\u03b1 \u03b2 : Type*} (f : {f // \u2200 (a\u2081 a\u2082 : \u03b1), f a\u2081 a\u2082 = f a\u2082 a\u2081})\n\t(a\u2081 a\u2082 : \u03b1) :\n\t\u21d1sym2.lift f \u27e6(a\u2081, a\u2082)\u27e7 = \u2191f a\u2081 a\u2082 :=", "nl_statement_of_codex": "Let $f:A\\times A\\to B$ be a function such that $f(a,b)=f(b,a)$ for all $a,b\\in A$. Then the function $g:A\\to B$ defined by $g(a)=f(a,a)$ is symmetric."}
{"name": "nat.totient_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/totient.lean", "formal_statement": "theorem nat.totient_two :\n\t2.totient = 1 :=", "nl_statement_of_codex": "The totient of $2$ is $1$."}
{"name": "mv_polynomial.support_monomial", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.support_monomial {R : Type u} {\u03c3 : Type*} {a : R}\n\t{s : \u03c3 \u2192\u2080 \u2115} [comm_semiring R] [decidable (a = 0)] :\n\t(\u21d1(mv_polynomial.monomial s) a).support = ite (a = 0) \u2205 {s} :=", "nl_statement_of_codex": "The support of the monomial $a\\cdot x^s$ is $\\{s\\}$ if $a\\neq 0$ and is empty if $a=0$."}
{"name": "add_subgroup.coe_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.coe_zero {G : Type*} [add_group G] (H : add_subgroup G) :\n\t\u21910 = 0 :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $H$ be an additive subgroup of $G$. Then $0\\in H$."}
{"name": "list.pairwise.forall_of_forall_of_flip", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/pairwise.lean", "formal_statement": "theorem list.pairwise.forall_of_forall_of_flip {\u03b1 : Type*} {R : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t{l : list \u03b1} (h\u2081 : \u2200 (x : \u03b1), x \u2208 l \u2192 R x x) (h\u2082 : list.pairwise R l)\n\t(h\u2083 : list.pairwise (flip R) l) \u2983x : \u03b1\u2984 :\n\tx \u2208 l \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 l \u2192 R x y :=", "nl_statement_of_codex": "Let $R$ be a relation on a list $l$. If $R$ is reflexive and symmetric, then $R$ is transitive."}
{"name": "add_action.stabilizer_vadd_eq_stabilizer_map_conj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/basic.lean", "formal_statement": "theorem add_action.stabilizer_vadd_eq_stabilizer_map_conj {\u03b1 : Type u}\n\t{\u03b2 : Type v} [add_group \u03b1] [add_action \u03b1 \u03b2] (g : \u03b1) (x : \u03b2) :\n\tadd_action.stabilizer \u03b1 (g +\u1d65 x) = add_subgroup.map (add_equiv.to_add_monoid_hom (\u21d1add_aut.conj g)) (add_action.stabilizer \u03b1 x) :=", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then the stabilizer of $g+x$ is equal to the image of the stabilizer of $x$ under the map $h_g:G\\to G$ defined by $h_g(x)=gxg^{-1}$."}
{"name": "algebraic_geometry.is_reduced_of_is_affine_is_reduced", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/properties.lean", "formal_statement": "theorem algebraic_geometry.is_reduced_of_is_affine_is_reduced\n\t(X : algebraic_geometry.Scheme) [algebraic_geometry.is_affine X]\n\t[h : is_reduced \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op \u22a4))] :\n\talgebraic_geometry.is_reduced X :=", "nl_statement_of_codex": "Let $X$ be an affine scheme. If the structure sheaf of $X$ is reduced, then $X$ is reduced."}
{"name": "simple_graph.edge_density_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/density.lean", "formal_statement": "theorem simple_graph.edge_density_comm {\u03b1 : Type*} (G : simple_graph \u03b1)\n\t[decidable_rel G.adj] (s t : finset \u03b1) :\n\tG.edge_density s t = G.edge_density t s :=", "nl_statement_of_codex": "The edge density of a simple graph $G$ is symmetric."}
{"name": "category_theory.limits.diagram_of_cones.cone_points_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/fubini.lean", "formal_statement": "theorem category_theory.limits.diagram_of_cones.cone_points_map {J K : Type v}\n\t[category_theory.small_category J] [category_theory.small_category K]\n\t{C : Type u} [category_theory.category C] {F : J \u2964 K \u2964 C}\n\t(D : category_theory.limits.diagram_of_cones F) (j j' : J) (f : j \u27f6 j') :\n\tD.cone_points.map f = (D.map f).hom :=", "nl_statement_of_codex": "Let $F:J\\to K\\to C$ be a functor. Let $D$ be a diagram of cones for $F$. Then for any morphism $f:j\\to j'$ in $J$, the morphism $D.cone_points.map f$ is equal to the morphism $(D.map f).hom$."}
{"name": "alg_equiv.to_linear_equiv_of_linear_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.to_linear_equiv_of_linear_equiv {R : Type u} {A\u2081 : Type v}\n\t{A\u2082 : Type w} [comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081]\n\t[algebra R A\u2082] (l : A\u2081 \u2243\u2097[R] A\u2082)\n\t(map_mul : \u2200 (x y : A\u2081), \u21d1l (x * y) = \u21d1l x * \u21d1l y)\n\t(commutes : \u2200 (r : R), \u21d1l (\u21d1(algebra_map R A\u2081) r) = \u21d1(algebra_map R A\u2082) r) :\n\t(alg_equiv.of_linear_equiv l map_mul commutes).to_linear_equiv = l :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A_1$ and $A_2$ be $R$-algebras. Let $l:A_1\\to A_2$ be a linear map such that $l(x\\cdot y)=l(x)\\cdot l(y)$ and $l(r\\cdot x)=r\\cdot l(x)$ for all $x,y\\in A_1$ and $r\\in R$. Then the algebra isomorphism $l:A_1\\to A_2$ is the same as the linear map $l:A_1\\to A_2$."}
{"name": "finset.eq_univ_iff_forall", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem finset.eq_univ_iff_forall {\u03b1 : Type*} [fintype \u03b1] {s : finset \u03b1} :\n\ts = finset.univ \u2194 \u2200 (x : \u03b1), x \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a finite set. Then $s=\\{1,\\ldots,n\\}$ if and only if $s$ contains all elements of $\\{1,\\ldots,n\\}$."}
{"name": "Bipointed.swap_equiv_inverse_map_to_fun", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/Bipointed.lean", "formal_statement": "theorem Bipointed.swap_equiv_inverse_map_to_fun (X Y : Bipointed) (f : X \u27f6 Y)\n\t(\u1fb0 : \u21a5X) :\n\t(Bipointed.swap_equiv.inverse.map f).to_fun \u1fb0 = f.to_fun \u1fb0 :=", "nl_statement_of_codex": "Let $X$ and $Y$ be bipointed spaces and let $f:X\\to Y$ be a map. Then the inverse of the map $f$ is the same as the map $f$."}
{"name": "bernoulli'_eq_bernoulli", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/bernoulli.lean", "formal_statement": "theorem bernoulli'_eq_bernoulli (n : \u2115) :\n\tbernoulli' n = (-1) ^ n * bernoulli n :=", "nl_statement_of_codex": "The $n$-th Bernoulli number is equal to $(-1)^n$ times the $n$-th Bernoulli' number."}
{"name": "fin.succ_above_pred_above", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.succ_above_pred_above {n : \u2115} {p : fin n} {i : fin (n + 1)}\n\t(h : i \u2260 \u21d1fin.cast_succ p) :\n\t\u21d1((\u21d1fin.cast_succ p).succ_above) (p.pred_above i) = i :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $p$ be a finite number less than $n$. Let $i$ be a finite number less than $n+1$. If $i$ is not equal to $p+1$, then $p+1$ is less than $i$ if and only if $p$ is less than $i$."}
{"name": "finsupp.sum_of_support_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.sum_of_support_subset {\u03b1 M N : Type*} [has_zero M]\n\t[add_comm_monoid N] (f : \u03b1 \u2192\u2080 M) {s : finset \u03b1} (hs : f.support \u2286 s)\n\t(g : \u03b1 \u2192 M \u2192 N) (h : \u2200 (i : \u03b1), i \u2208 s \u2192 g i 0 = 0) :\n\tf.sum g = s.sum (\u03bb (x : \u03b1), g x (\u21d1f x)) :=", "nl_statement_of_codex": "Let $f:A\\to M$ be a finitely supported function. Let $s$ be a finite set such that $supp(f)\\subseteq s$. Let $g:A\\times M\\to N$ be a function such that $g(i,0)=0$ for all $i\\in s$. Then $\\sum_{a\\in A}g(a,f(a))=\\sum_{a\\in s}g(a,f(a))$."}
{"name": "zero_lt.lt_mul_of_lt_of_one_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas_zero_lt.lean", "formal_statement": "theorem zero_lt.lt_mul_of_lt_of_one_lt {\u03b1 : Type u} {a b c : \u03b1}\n\t[mul_one_class \u03b1] [has_zero \u03b1] [preorder \u03b1] [zero_lt.pos_mul_strict_mono \u03b1]\n\t(bc : b < c) (ha : 1 < a) (c0 : 0 < c) :\n\tb < c * a :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a preordered monoid with $1$. If $b<c$ and $1<a$, then $b<ca$."}
{"name": "real.sign_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/sign.lean", "formal_statement": "theorem real.sign_zero :\n\t0.sign = 0 :=", "nl_statement_of_codex": "The sign of $0$ is $0$."}
{"name": "isometry.embedding", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/isometry.lean", "formal_statement": "theorem isometry.embedding {\u03b1 : Type u} {\u03b2 : Type v} [emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : isometry f) :\n\tembedding f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be an isometry between metric spaces $X$ and $Y$. Then $f$ is an embedding."}
{"name": "nat.sub_eq_zero_of_le", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/lemmas.lean", "formal_statement": "theorem nat.sub_eq_zero_of_le {n m : \u2115} (h : n \u2264 m) :\n\tn - m = 0 :=", "nl_statement_of_codex": "If $n\\leq m$, then $n-m=0$."}
{"name": "cInf_image2_eq_cInf_cSup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/conditionally_complete_lattice.lean", "formal_statement": "theorem cInf_image2_eq_cInf_cSup {\u03b1 \u03b2 \u03b3 : Type*}\n\t[conditionally_complete_lattice \u03b1] [conditionally_complete_lattice \u03b2]\n\t[conditionally_complete_lattice \u03b3] {s : set \u03b1} {t : set \u03b2} {u : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n\t{l\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {l\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2}\n\t(h\u2081 : \u2200 (b : \u03b2), galois_connection (l\u2081 b) (function.swap u b))\n\t(h\u2082 : \u2200 (a : \u03b1), galois_connection (\u21d1order_dual.to_dual \u2218 l\u2082 a) (u a \u2218 \u21d1order_dual.of_dual)) :\n\ts.nonempty \u2192 bdd_below s \u2192 t.nonempty \u2192 bdd_above t \u2192 has_Inf.Inf (set.image2 u s t) = u (has_Inf.Inf s) (has_Sup.Sup t) :=", "nl_statement_of_codex": "Let $s$ and $t$ be nonempty sets of real numbers with lower and upper bounds, respectively. Let $u:s\\times t\\to\\mathbb{R}$ be a function. Let $l_1:t\\to\\mathbb{R}$ and $l_2:s\\to\\mathbb{R}$ be functions such that $l_1(b)$ is the infimum of $u(a,b)$ over $a\\in s$ and $l_2(a)$ is the supremum of $u(a,b)$ over $b\\in t$. Then the infimum of $u(a,b)"}
{"name": "has_strict_deriv_at.const_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_strict_deriv_at.const_smul {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c}\n\t{R : Type*} [semiring R] [module R F] [smul_comm_class \ud835\udd5c R F]\n\t[has_continuous_const_smul R F] ( : R) (hf : has_strict_deriv_at f f' x) :\n\thas_strict_deriv_at (\u03bb (y : \ud835\udd5c), c \u2022 f y) (c \u2022 f') x :=", "nl_statement_of_codex": "Let $f: \\mathbb{R}\\to \\mathbb{R}$ be a function with a strict derivative at $x$. Then the function $g(y)=cf(y)$ has a strict derivative at $x$."}
{"name": "sigma.Icc_mk_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sigma/interval.lean", "formal_statement": "theorem sigma.Icc_mk_mk {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [decidable_eq \u03b9]\n\t[\u03a0 (i : \u03b9), preorder (\u03b1 i)] [\u03a0 (i : \u03b9), locally_finite_order (\u03b1 i)] (i : \u03b9)\n\t(a b : \u03b1 i) :\n\tfinset.Icc \u27e8i, a\u27e9 \u27e8i, b\u27e9 = finset.map (function.embedding.sigma_mk i) (finset.Icc a b) :=", "nl_statement_of_codex": "Let $i$ be an index set and let $\\alpha$ be a family of preorders indexed by $i$. Then the interval $[(i,a),(i,b)]$ is equal to the set $\\{(i,x)\\mid a\\leq x\\leq b\\}$."}
{"name": "first_order.language.bounded_formula.map_term_rel_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/syntax.lean", "formal_statement": "theorem first_order.language.bounded_formula.map_term_rel_equiv_apply\n\t{L : first_order.language} {L' : first_order.language} {\u03b1 : Type u'}\n\t{\u03b2 : Type v'} (ft : \u03a0 (n : \u2115), L.term (\u03b1 \u2295 fin n) \u2243 L'.term (\u03b2 \u2295 fin n))\n\t(fr : \u03a0 (n : \u2115), L.relations n \u2243 L'.relations n) {n : \u2115}\n\t(\u1fb0 : L.bounded_formula \u03b1 n) :\n\t\u21d1(first_order.language.bounded_formula.map_term_rel_equiv ft fr) \u1fb0 = first_order.language.bounded_formula.map_term_rel (\u03bb (n : \u2115), \u21d1(ft n)) (\u03bb (n : \u2115), \u21d1(fr n)) (\u03bb (_x : \u2115), id) \u1fb0 :=", "nl_statement_of_codex": "Let $L$ and $L'$ be first-order languages, let $\\alpha$ and $\\beta$ be types, and let $f$ and $g$ be functions from $\\mathbb{N}$ to the set of equivalences between the sets of terms and relations of $L$ and $L'$ respectively. Then the equivalence between the sets of bounded formulas of $L$ and $L'$ induced by $f$ and $g$ is equal to the function that maps a bounded formula of $L$ to the bounded formula of $L'$ obtained by applying $f$ and $g$ to the terms and relations of the bounded formula."}
{"name": "exists_compact_superset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/subset_properties.lean", "formal_statement": "theorem exists_compact_superset {\u03b1 : Type u} [topological_space \u03b1]\n\t[locally_compact_space \u03b1] {K : set \u03b1} (hK : is_compact K) :\n\t\u2203 (K' : set \u03b1), is_compact K' \u2227 K \u2286 interior K' :=", "nl_statement_of_codex": "Let $K$ be a compact subset of a locally compact space $X$. Then there is a compact subset $K'$ of $X$ such that $K\\subset\\mathrm{int}(K')$."}
{"name": "category_theory.triangulated.rot_comp_inv_rot_inv_2", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/triangulated/rotate.lean", "formal_statement": "theorem category_theory.triangulated.rot_comp_inv_rot_inv_2 {C : Type u}\n\t[category_theory.category C] [category_theory.preadditive C]\n\t[category_theory.has_shift C \u2124]\n\t[\u2200 (n : \u2124), (category_theory.shift_functor C n).additive] :\n\tcategory_theory.triangulated.rot_comp_inv_rot.inv = category_theory.triangulated.rot_comp_inv_rot_inv :=", "nl_statement_of_codex": "Let $C$ be a triangulated category. Then the composition of the functors $\\Sigma^{-1}\\circ\\Sigma^{-1}$ and $\\Sigma\\circ\\Sigma$ is the identity functor."}
{"name": "mul_bit0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/lemmas.lean", "formal_statement": "theorem mul_bit0 {R : Type u\u2081} [non_unital_non_assoc_ring R] {n r : R} :\n\tr * bit0 n = 2 \u2022 (r * n) :=", "nl_statement_of_codex": "Let $R$ be a non-unital non-associative ring. Then $r\\cdot 2n=2(r\\cdot n)$."}
{"name": "ordinal.lift_id'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/basic.lean", "formal_statement": "theorem ordinal.lift_id' (a : ordinal) :\n\ta.lift = a :=", "nl_statement_of_codex": "The lift of an ordinal is the ordinal itself."}
{"name": "fintype.card_fun", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/card.lean", "formal_statement": "theorem fintype.card_fun {\u03b1 \u03b2 : Type*} [decidable_eq \u03b1] [fintype \u03b1] [fintype \u03b2] :\n\tfintype.card (\u03b1 \u2192 \u03b2) = fintype.card \u03b2 ^ fintype.card \u03b1 :=", "nl_statement_of_codex": "The cardinality of the set of functions from $A$ to $B$ is $|B|^{|A|}$."}
{"name": "set.bUnion_of_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.bUnion_of_singleton {\u03b1 : Type*} (s : set \u03b1) :\n\t(\u22c3 (x : \u03b1) (H : x \u2208 s), {x}) = s :=", "nl_statement_of_codex": "The union of the singleton sets $\\{x\\}$ for $x\\in s$ is $s$."}
{"name": "ne.bot_lt'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem ne.bot_lt' {\u03b1 : Type u} [partial_order \u03b1] [order_bot \u03b1] {a : \u03b1}\n\t(h : \u22a5 \u2260 a) :\n\t\u22a5 < a :=", "nl_statement_of_codex": "Let $\u03b1$ be a partially ordered set with a bottom element. If $a$ is not the bottom element, then $a$ is greater than the bottom element."}
{"name": "Top.presheaf.Sheaf_spaces_equiv_sheaf_sites_functor", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sheaves/sheaf_condition/sites.lean", "formal_statement": "theorem Top.presheaf.Sheaf_spaces_equiv_sheaf_sites_functor (C : Type u)\n\t[category_theory.category C] [category_theory.limits.has_products C] (X : Top) :\n\t(Top.presheaf.Sheaf_spaces_equiv_sheaf_sites C X).functor = Top.presheaf.Sheaf_sites_to_sheaf_spaces C X :=", "nl_statement_of_codex": "The functor from the category of sheaves on $X$ to the category of sheaves on $X$ is the same as the functor from the category of sheaves on $X$ to the category of sheaves on $X$."}
{"name": "category_theory.monoidal_closed.uncurry_curry", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/closed/monoidal.lean", "formal_statement": "theorem category_theory.monoidal_closed.uncurry_curry {C : Type u}\n\t[category_theory.category C] [category_theory.monoidal_category C] {A X Y : C}\n\t[category_theory.closed A] (f : A \u2297 X \u27f6 Y) :\n\tcategory_theory.monoidal_closed.uncurry (category_theory.monoidal_closed.curry f) = f :=", "nl_statement_of_codex": "Let $C$ be a monoidal category and let $A$ be a closed object in $C$. Then the uncurrying of the currying of a morphism $f:A\\otimes X\\to Y$ is equal to $f$."}
{"name": "real.sin_eq_sqrt_one_sub_cos_sq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem real.sin_eq_sqrt_one_sub_cos_sq {x : \u211d} (hl : 0 \u2264 x) (hu : x \u2264 real.pi) :\n\treal.sin x = real.sqrt (1 - real.cos x ^ 2) :=", "nl_statement_of_codex": "For $x\\in[0,\\pi]$, we have $\\sin(x)=\\sqrt{1-\\cos(x)^2}$."}
{"name": "affine_map.line_map_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_subspace.lean", "formal_statement": "theorem affine_map.line_map_mem {k V P : Type*} [ring k] [add_comm_group V]\n\t[module k V] [add_torsor V P] {Q : affine_subspace k P} {p\u2080 p\u2081 : P} ( : k)\n\t(h\u2080 : p\u2080 \u2208 Q) (h\u2081 : p\u2081 \u2208 Q) :\n\t\u21d1(affine_map.line_map p\u2080 p\u2081) c \u2208 Q :=", "nl_statement_of_codex": "Let $Q$ be an affine subspace of $P$. Let $p_0, p_1\\in Q$. Then $c\\cdot p_0+(1-c)\\cdot p_1\\in Q$ for all $c\\in\\mathbb{R}$."}
{"name": "list.chain_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/chain.lean", "formal_statement": "theorem list.chain_singleton {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1} :\n\tlist.chain R a [b] \u2194 R a b :=", "nl_statement_of_codex": "A list $[b]$ is a chain with respect to $R$ if and only if $R(a,b)$."}
{"name": "submodule.torsion_by_set_torsion_by_set_eq_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/torsion.lean", "formal_statement": "theorem submodule.torsion_by_set_torsion_by_set_eq_top {R M : Type*}\n\t[comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) :\n\tsubmodule.torsion_by_set R \u21a5(submodule.torsion_by_set R M s) s = \u22a4 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and $M$ be an $R$-module. Then the set of elements of $M$ that are annihilated by some element of $R$ is the same as the set of elements of $M$ that are annihilated by some element of $R$ that is a power of a prime."}
{"name": "subset_succ_chain", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/chain.lean", "formal_statement": "theorem subset_succ_chain {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : set \u03b1} :\n\ts \u2286 succ_chain r s :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $S$. Then $S$ is a subset of the successor chain of $r$."}
{"name": "equiv.forall\u2082_congr'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/basic.lean", "formal_statement": "theorem equiv.forall\u2082_congr' {\u03b1\u2081 : Sort ua1} {\u03b1\u2082 : Sort ua2} {\u03b2\u2081 : Sort ub1}\n\t{\u03b2\u2082 : Sort ub2} {p : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Prop} {q : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Prop} (e\u03b1 : \u03b1\u2081 \u2243 \u03b1\u2082)\n\t(e\u03b2 : \u03b2\u2081 \u2243 \u03b2\u2082)\n\t(h : \u2200 {x : \u03b1\u2082} {y : \u03b2\u2082}, p (\u21d1(e\u03b1.symm) x) (\u21d1(e\u03b2.symm) y) \u2194 q x y) :\n\t(\u2200 (x : \u03b1\u2081) (y : \u03b2\u2081), p x y) \u2194 \u2200 (x : \u03b1\u2082) (y : \u03b2\u2082), q x y :=", "nl_statement_of_codex": "Let $e_\\alpha$ and $e_\\beta$ be equivalences between types $A$ and $B$ and $C$ and $D$, respectively. Then the following are equivalent:\n\\begin{enumerate}\n\\item For all $a\\in A$ and $c\\in C$, $P(a,c)$ holds.\n\\item For all $b\\in B$ and $d\\in D$, $Q(b,d)$ holds.\n\\end{enumerate}\nwhere $P(a,c)$ is equivalent to $Q(b,d)$ for all $a\\in A$ and $c\\in C"}
{"name": "polynomial.continuous_within_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/polynomial.lean", "formal_statement": "theorem polynomial.continuous_within_at {R : Type*} [semiring R]\n\t[topological_space R] [topological_semiring R] (p : polynomial R) {s : set R}\n\t{a : R} :\n\tcontinuous_within_at (\u03bb (x : R), polynomial.eval x p) s a :=", "nl_statement_of_codex": "Let $R$ be a topological semiring. Then the function $f:\\mathbb{R}\\to R$ defined by $f(x)=p(x)$ is continuous at $a$ for any polynomial $p$."}
{"name": "fintype.linear_order.is_well_order_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem fintype.linear_order.is_well_order_lt {\u03b1 : Type*} [fintype \u03b1]\n\t[linear_order \u03b1] :\n\tis_well_order \u03b1 has_lt.lt :=", "nl_statement_of_codex": "Let $X$ be a finite linearly ordered set. Then $X$ is well-ordered by the strict order relation."}
{"name": "submonoid.exists_list_of_mem_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/membership.lean", "formal_statement": "theorem submonoid.exists_list_of_mem_closure {M : Type*} [monoid M] {s : set M}\n\t{x : M} (hx : x \u2208 submonoid.closure s) :\n\t\u2203 (l : list M) (hl : \u2200 (y : M), y \u2208 l \u2192 y \u2208 s), l.prod = x :=", "nl_statement_of_codex": "Let $M$ be a monoid and let $s$ be a subset of $M$. Let $x\\in M$. Then there is a list $l$ of elements of $s$ such that $x$ is the product of the elements of $l$."}
{"name": "pow_bit0_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/order.lean", "formal_statement": "theorem pow_bit0_nonneg {R : Type*} [linear_ordered_ring R] (a : R) (n : \u2115) :\n\t0 \u2264 a ^ bit0 n :=", "nl_statement_of_codex": "Let $R$ be a linear ordered ring. Then $a^n\\geq 0$ for all $a\\in R$ and $n\\in\\mathbb{N}$."}
{"name": "lie_equiv.injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/basic.lean", "formal_statement": "theorem lie_equiv.injective {R : Type u} {L\u2081 : Type v} {L\u2082 : Type w}\n\t[comm_ring R] [lie_ring L\u2081] [lie_ring L\u2082] [lie_algebra R L\u2081] [lie_algebra R L\u2082]\n\t(e : L\u2081 \u2243\u2097\u2045R\u2046 L\u2082) :\n\tfunction.injective \u21d1\u2191e :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $L_1$ and $L_2$ be Lie algebras over $R$. If $e:L_1\\to L_2$ is a Lie algebra isomorphism, then $e$ is injective."}
{"name": "multiset.map_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.map_singleton {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n\tmultiset.map f {a} = {f a} :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $a\\in A$. Then $f(\\{a\\})=\\{f(a)\\}$."}
{"name": "exists_pos_lt_subset_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem exists_pos_lt_subset_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t[proper_space \u03b1] {x : \u03b1} {r : \u211d} {s : set \u03b1} (hr : 0 < r) (hs : is_closed s)\n\t(h : s \u2286 metric.ball x r) :\n\t\u2203 (r' : \u211d) (H : r' \u2208 set.Ioo 0 r), s \u2286 metric.ball x r' :=", "nl_statement_of_codex": "Let $X$ be a proper pseudo-metric space and let $x\\in X$. Let $r>0$ and let $s$ be a closed subset of $X$ such that $s\\subset B(x,r)$. Then there is $r'\\in (0,r)$ such that $s\\subset B(x,r')$."}
{"name": "measurable_equiv.smul_to_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/measurable_equiv.lean", "formal_statement": "theorem measurable_equiv.smul_to_equiv {G \u03b1 : Type*} [measurable_space G]\n\t[measurable_space \u03b1] [group G] [mul_action G \u03b1] [has_measurable_smul G \u03b1]\n\t( : G) :\n\t(measurable_equiv.smul c).to_equiv = mul_action.to_perm c :=", "nl_statement_of_codex": "Let $G$ be a group acting on a measurable space $\\alpha$. Then the map $x\\mapsto c\\cdot x$ is a measurable permutation of $\\alpha$."}
{"name": "list.range_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/range.lean", "formal_statement": "theorem list.range_add (a b : \u2115) :\n\tlist.range (a + b) = list.range a ++ list.map (\u03bb (x : \u2115), a + x) (list.range b) :=", "nl_statement_of_codex": "The list of integers from $a$ to $a+b$ is the concatenation of the list of integers from $a$ to $a$ and the list of integers from $0$ to $b$."}
{"name": "finset.not_mem_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.not_mem_empty {\u03b1 : Type*} (a : \u03b1) :\n\ta \u2209 \u2205 :=", "nl_statement_of_codex": "$a$ is not an element of the empty set."}
{"name": "absolute_value.is_admissible.exists_partition", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/class_number/admissible_absolute_value.lean", "formal_statement": "theorem absolute_value.is_admissible.exists_partition {R : Type*}\n\t[euclidean_domain R] {abv : absolute_value R \u2124} {\u03b9 : Type*} [fintype \u03b9] {\u03b5 : \u211d}\n\t(h\u03b5 : 0 < \u03b5) {b : R} (hb : b \u2260 0) (A : \u03b9 \u2192 R) (h : abv.is_admissible) :\n\t\u2203 (t : \u03b9 \u2192 fin (h.card \u03b5)), \u2200 (i\u2080 i\u2081 : \u03b9), t i\u2080 = t i\u2081 \u2192 \u2191(\u21d1abv (A i\u2081 % b - A i\u2080 % b)) < \u21d1abv b \u2022 \u03b5 :=", "nl_statement_of_codex": "Let $R$ be a Euclidean domain, let $b\\in R$ be nonzero, and let $A:\\mathbb{N}\\to R$. Then there is a partition of $\\mathbb{N}$ into finitely many sets $S_1,\\ldots,S_n$ such that for all $i,j\\in\\mathbb{N}$ with $i\\neq j$ and $i,j\\in S_k$ for some $k$, we have $|A(j)\\bmod b-A(i)\\bmod b|<b\\epsilon$."}
{"name": "measure_theory.simple_func.integral_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/bochner.lean", "formal_statement": "theorem measure_theory.simple_func.integral_def {\u03b1 F : Type*} [normed_group F]\n\t[normed_space \u211d F] {m : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1)\n\t(f : measure_theory.simple_func \u03b1 F) :\n\tmeasure_theory.simple_func.integral \u03bc f = measure_theory.simple_func.set_to_simple_func (measure_theory.weighted_smul \u03bc) f :=", "nl_statement_of_codex": "Let $f$ be a simple function on a measurable space $(X,\\mathcal{A})$ and let $\\mu$ be a measure on $(X,\\mathcal{A})$. Then $\\int_X f\\,d\\mu=\\sum_{i=1}^n a_i\\mu(A_i)$ where $f=\\sum_{i=1}^n a_i\\chi_{A_i}$."}
{"name": "differentiable_within_at.congr_of_eventually_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem differentiable_within_at.congr_of_eventually_eq {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {f f\u2081 : E \u2192 F} {x : E}\n\t{s : set E} (h : differentiable_within_at \ud835\udd5c f s x)\n\t(h\u2081 : f\u2081 =\u1da0[nhds_within x s] f) (hx : f\u2081 x = f x) :\n\tdifferentiable_within_at \ud835\udd5c f\u2081 s x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f,f_1:E\\to F$ and let $x\\in E$. Suppose that $f$ is differentiable at $x$ and that $f_1$ is eventually equal to $f$ in a neighborhood of $x$. Then $f_1$ is differentiable at $x$."}
{"name": "Mon_.hom.one_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/Mon_.lean", "formal_statement": "theorem Mon_.hom.one_hom {C : Type u\u2081} [category_theory.category C]\n\t[category_theory.monoidal_category C] {M N : Mon_ C} (self : M.hom N) :\n\tM.one \u226b self.hom = N.one :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $M$ and $N$ be monoids in $C$. Let $f:M\\to N$ be a monoid homomorphism. Then $f(1_M)=1_N$."}
{"name": "linear_map.range_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_map.range_neg {R R\u2082 M M\u2082 : Type*} [semiring R] [ring R\u2082]\n\t[add_comm_monoid M] [add_comm_group M\u2082] [module R M] [module R\u2082 M\u2082]\n\t{\u03c4\u2081\u2082 : R \u2192+* R\u2082} [ring_hom_surjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n\t(-f).range = f.range :=", "nl_statement_of_codex": "Let $R$ and $R'$ be rings, $M$ and $M'$ be $R$-modules and $R'$-modules, respectively. Let $f:M\\to M'$ be a linear map. Then the range of $-f$ is equal to the range of $f$."}
{"name": "finsupp.map_range.add_monoid_hom_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.map_range.add_monoid_hom_id {\u03b1 M : Type*} [add_comm_monoid M] :\n\tfinsupp.map_range.add_monoid_hom (add_monoid_hom.id M) = add_monoid_hom.id (\u03b1 \u2192\u2080 M) :=", "nl_statement_of_codex": "The identity map on $M$ is a monoid homomorphism from $M$ to $M$."}
{"name": "nat.add_factorial_succ_le_factorial_add_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/factorial/basic.lean", "formal_statement": "theorem nat.add_factorial_succ_le_factorial_add_succ (i n : \u2115) :\n\ti + (n + 1).factorial \u2264 (i + (n + 1)).factorial :=", "nl_statement_of_codex": "For all $i,n\\in\\mathbb{N}$, we have $i+(n+1)!\\leq (i+n+1)!$."}
{"name": "submodule.liftq_span_singleton_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/quotient.lean", "formal_statement": "theorem submodule.liftq_span_singleton_apply {R M : Type*} [ring R]\n\t[add_comm_group M] [module R M] {R\u2082 M\u2082 : Type*} [ring R\u2082] [add_comm_group M\u2082]\n\t[module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} (x : M) (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h : \u21d1f x = 0)\n\t(y : M) :\n\t\u21d1(submodule.liftq_span_singleton x f h) (submodule.quotient.mk y) = \u21d1f y :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, $R_2$ a ring, $M_2$ an $R_2$-module, and $\\tau_{12}:R\\to R_2$ a ring homomorphism. Let $x\\in M$, $f:M\\to M_2$ a linear map, and $h:f(x)=0$. Let $y\\in M$. Then the image of $y$ under the map $M/\\langle x\\rangle\\to M_2$ induced by $f$ is $f(y)$."}
{"name": "set.is_unit_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.is_unit_iff {\u03b1 : Type*} [division_monoid \u03b1] {s : set \u03b1} :\n\tis_unit s \u2194 \u2203 (a : \u03b1), s = {a} \u2227 is_unit a :=", "nl_statement_of_codex": "Let $R$ be a division monoid. Then a subset $S$ of $R$ is a unit if and only if $S$ is a singleton set $\\{a\\}$ and $a$ is a unit."}
{"name": "add_subgroup.sup_add_subgroup_of_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.sup_add_subgroup_of_eq {G : Type*} [add_group G]\n\t{H K L : add_subgroup G} (hH : H \u2264 L) (hK : K \u2264 L) :\n\tH.add_subgroup_of L \u2294 K.add_subgroup_of L = (H \u2294 K).add_subgroup_of L :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $H, K, L$ be additive subgroups of $G$. If $H\\leq L$ and $K\\leq L$, then $H\\oplus_L K=H\\oplus K$."}
{"name": "is_closed_set_of_map_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/module/basic.lean", "formal_statement": "theorem is_closed_set_of_map_smul (M\u2081 M\u2082 : Type*) {R S : Type*}\n\t[topological_space M\u2082] [t2_space M\u2082] [semiring R] [semiring S]\n\t[add_comm_monoid M\u2081] [add_comm_monoid M\u2082] [module R M\u2081] [module S M\u2082]\n\t[has_continuous_const_smul S M\u2082] (\u03c3 : R \u2192+* S) :\n\tis_closed {f : M\u2081 \u2192 M\u2082 | \u2200 (c : R) (x : M\u2081), f (c \u2022 x) = \u21d1\u03c3 c \u2022 f x} :=", "nl_statement_of_codex": "Let $M_1$ and $M_2$ be topological spaces, $R$ and $S$ be semirings, and $\\sigma:R\\to S$ be a semiring homomorphism. Then the set of all functions $f:M_1\\to M_2$ such that $f(cx)=\\sigma(c)f(x)$ for all $c\\in R$ and $x\\in M_1$ is closed in the space of all functions $M_1\\to M_2$."}
{"name": "cau_seq.completion.of_rat_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/cau_seq_completion.lean", "formal_statement": "theorem cau_seq.completion.of_rat_neg {\u03b1 : Type*} [linear_ordered_field \u03b1]\n\t{\u03b2 : Type*} [comm_ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [is_absolute_value abv] (x : \u03b2) :\n\tcau_seq.completion.of_rat (-x) = -cau_seq.completion.of_rat x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $x\\in R$. Then $\\overline{-x}=-\\overline{x}$."}
{"name": "convex.subset_interior_image_homothety_of_one_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/topology.lean", "formal_statement": "theorem convex.subset_interior_image_homothety_of_one_lt {E : Type*}\n\t[add_comm_group E] [module \u211d E] [topological_space E] [topological_add_group E]\n\t[has_continuous_smul \u211d E] {s : set E} (hs : convex \u211d s) {x : E}\n\t(hx : x \u2208 interior s) (t : \u211d) (ht : 1 < t) :\n\ts \u2286 interior (\u21d1(affine_map.homothety x t) '' s) :=", "nl_statement_of_codex": "Let $E$ be a topological vector space. Let $s$ be a convex subset of $E$. Let $x\\in s$ and $t>1$. Then $s$ is contained in the interior of the image of $s$ under the homothety $x\\mapsto tx$."}
{"name": "real.sinh_lt_sinh", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem real.sinh_lt_sinh {x y : \u211d} :\n\treal.sinh x < real.sinh y \u2194 x < y :=", "nl_statement_of_codex": "For all $x,y\\in\\mathbb{R}$, $sinh(x)<sinh(y)$ if and only if $x<y$."}
{"name": "asymptotics.is_O_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_pi {\u03b1 F' : Type*} [semi_normed_group F'] {g' : \u03b1 \u2192 F'}\n\t{l : filter \u03b1} {\u03b9 : Type*} [fintype \u03b9] {E' : \u03b9 \u2192 Type*}\n\t[\u03a0 (i : \u03b9), normed_group (E' i)] {f : \u03b1 \u2192 \u03a0 (i : \u03b9), E' i} :\n\tf =O[l] g' \u2194 \u2200 (i : \u03b9), (\u03bb (x : \u03b1), f x i) =O[l] g' :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to F'$ be functions. Then $f=O(g)$ if and only if $f_i=O(g)$ for all $i\\in I$."}
{"name": "div_le_iff_le_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem div_le_iff_le_mul {\u03b1 : Type u} [group \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] {a b c : \u03b1} :\n\ta / c \u2264 b \u2194 a \u2264 b * c :=", "nl_statement_of_codex": "Let $G$ be a group with a left-invariant order. Then $a/c\\leq b$ if and only if $a\\leq bc$."}
{"name": "emetric.closed_ball_mem_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean", "formal_statement": "theorem emetric.closed_ball_mem_nhds {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t(x : \u03b1) {\u03b5 : ennreal} (\u03b50 : 0 < \u03b5) :\n\temetric.closed_ball x \u03b5 \u2208 nhds x :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x\\in X$. Then the closed ball $B_\\epsilon(x)$ is a neighborhood of $x$."}
{"name": "measure_theory.simple_func.exists_forall_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.simple_func.exists_forall_le {\u03b1 \u03b2 : Type*}\n\t[measurable_space \u03b1] [nonempty \u03b2] [preorder \u03b2] [is_directed \u03b2 has_le.le]\n\t(f : measure_theory.simple_func \u03b1 \u03b2) :\n\t\u2203 (C : \u03b2), \u2200 (x : \u03b1), \u21d1f x \u2264 C :=", "nl_statement_of_codex": "Let $f$ be a simple function from a measurable space $X$ to a directed set $Y$. Then there is a $y\\in Y$ such that $f(x)\\leq y$ for all $x\\in X$."}
{"name": "vector.mem_of_mem_tail", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/vector/mem.lean", "formal_statement": "theorem vector.mem_of_mem_tail {\u03b1 : Type*} {n : \u2115} (a : \u03b1) (v : vector \u03b1 n)\n\t(ha : a \u2208 v.tail.to_list) :\n\ta \u2208 v.to_list :=", "nl_statement_of_codex": "Let $v$ be a vector of length $n$ and let $a$ be an element of the tail of $v$. Then $a$ is an element of $v$."}
{"name": "filter.map_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.map_top {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) :\n\tfilter.map f \u22a4 = filter.principal (set.range f) :=", "nl_statement_of_codex": "The filter of sets $f(U)$ where $U$ is an open set is the filter of sets $V$ such that $V=f(U)$ for some open set $U$."}
{"name": "add_semiconj_by.add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/semiconj.lean", "formal_statement": "theorem add_semiconj_by.add_left {S : Type u} [add_semigroup S] {a b x y z : S}\n\t(ha : add_semiconj_by a y z) (hb : add_semiconj_by b x y) :\n\tadd_semiconj_by (a + b) x z :=", "nl_statement_of_codex": "Let $S$ be an additive semigroup. Let $a,b,x,y,z\\in S$. If $a+y=z$ and $b+x=y$, then $a+b+x=z$."}
{"name": "category_theory.limits.multiequalizer.condition_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/multiequalizer.lean", "formal_statement": "theorem category_theory.limits.multiequalizer.condition_assoc {C : Type u}\n\t[category_theory.category C] (I : category_theory.limits.multicospan_index C)\n\t[category_theory.limits.has_multiequalizer I] (b : I.R) {X' : C}\n\t(f' : I.right b \u27f6 X') :\n\tcategory_theory.limits.multiequalizer.\u03b9 I (I.fst_to b) \u226b I.fst b \u226b f' = category_theory.limits.multiequalizer.\u03b9 I (I.snd_to b) \u226b I.snd b \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category and let $I$ be a multicospan index in $C$. Let $b$ be an object of $I$ and let $f':I.right(b)\\to X'$ be a morphism. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\nI.left(b) \\arrow[r, "}
{"name": "alternating_map.coe_dom_dom_congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/alternating.lean", "formal_statement": "theorem alternating_map.coe_dom_dom_congr {R : Type*} [semiring R] {M : Type*}\n\t[add_comm_monoid M] [module R M] {N : Type*} [add_comm_monoid N] [module R N]\n\t{\u03b9 \u03b9' : Type*} [decidable_eq \u03b9] [decidable_eq \u03b9'] (f : alternating_map R M N \u03b9)\n\t(\u03c3 : \u03b9 \u2243 \u03b9') :\n\t\u2191(alternating_map.dom_dom_congr \u03c3 f) = multilinear_map.dom_dom_congr \u03c3 \u2191f :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $N$ be $R$-modules, and $\\iota$ and $\\iota'$ be types. Let $f:\\iota\\to\\iota'$ be an alternating map. Then the alternating map $f':\\iota\\to\\iota'$ defined by $f'(x)=f(x)$ is equal to $f$."}
{"name": "finset.inf_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.inf_image {\u03b1 \u03b2 \u03b3 : Type*} [semilattice_inf \u03b1] [order_top \u03b1]\n\t[decidable_eq \u03b2] (s : finset \u03b3) (f : \u03b3 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n\t(finset.image f s).inf g = s.inf (g \u2218 f) :=", "nl_statement_of_codex": "Let $s$ be a finite set, $f:s\\to\\beta$, and $g:\\beta\\to\\alpha$. Then $\\inf_{b\\in f(s)}g(b)=\\inf_{x\\in s}g(f(x))$."}
{"name": "codisjoint.symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem codisjoint.symm {\u03b1 : Type u} [semilattice_sup \u03b1] [order_top \u03b1] \u2983a b : \u03b1\u2984 :\n\tcodisjoint a b \u2192 codisjoint b a :=", "nl_statement_of_codex": "Let $a$ and $b$ be elements of a complete lattice. Then $a$ and $b$ are codisjoint if and only if $b$ and $a$ are codisjoint."}
{"name": "subspace.dual_lift_right_inverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/dual.lean", "formal_statement": "theorem subspace.dual_lift_right_inverse {K : Type u} {V : Type v} [field K]\n\t[add_comm_group V] [module K V] (W : subspace K V) :\n\tfunction.right_inverse \u21d1(W.dual_lift) \u21d1(submodule.dual_restrict W) :=", "nl_statement_of_codex": "Let $K$ be a field, $V$ a $K$-vector space, and $W$ a subspace of $V$. Then the dual lift of $W$ is a right inverse of the dual restriction of $W$."}
{"name": "submodule.prod_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/span.lean", "formal_statement": "theorem submodule.prod_top {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {M' : Type*} [add_comm_monoid M'] [module R M'] :\n\t\u22a4.prod \u22a4 = \u22a4 :=", "nl_statement_of_codex": "The product of two submodules of $M$ is a submodule of $M$."}
{"name": "tensor_product.direct_sum_lof_tmul_lof", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/direct_sum/tensor_product.lean", "formal_statement": "theorem tensor_product.direct_sum_lof_tmul_lof (R : Type*) [comm_ring R]\n\t(\u03b9\u2081 \u03b9\u2082 : Type*) [decidable_eq \u03b9\u2081] [decidable_eq \u03b9\u2082] (M\u2081 M\u2082 : \u03b9\u2082 \u2192 Type*)\n\t[\u03a0 (i\u2081 : \u03b9\u2081), add_comm_group (M\u2081 i\u2081)] [\u03a0 (i\u2082 : \u03b9\u2082), add_comm_group (M\u2082 i\u2082)]\n\t[\u03a0 (i\u2081 : \u03b9\u2081), module R (M\u2081 i\u2081)] [\u03a0 (i\u2082 : \u03b9\u2082), module R (M\u2082 i\u2082)] (i\u2081 : \u03b9\u2081)\n\t(m\u2081 : M\u2081 i\u2081) (i\u2082 : \u03b9\u2082) (m\u2082 : M\u2082 i\u2082) :\n\t\u21d1(tensor_product.direct_sum R \u03b9\u2081 \u03b9\u2082 M\u2081 M\u2082) (\u21d1(direct_sum.lof R \u03b9\u2081 M\u2081 i\u2081) m\u2081 \u2297\u209c[R] \u21d1(direct_sum.lof R \u03b9\u2082 M\u2082 i\u2082) m\u2082) = \u21d1(direct_sum.lof R (\u03b9\u2081 \u00d7 \u03b9\u2082) (\u03bb (i : \u03b9\u2081 \u00d7 \u03b9\u2082), tensor_product R (M\u2081 i.fst) (M\u2082 i.snd)) (i\u2081, i\u2082)) (m\u2081 \u2297\u209c[R] m\u2082) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $\\iota_1, \\iota_2$ be types, let $M_1, M_2$ be families of $R$-modules indexed by $\\iota_1, \\iota_2$, respectively. Let $i_1\\in \\iota_1$ and $m_1\\in M_1(i_1)$. Let $i_2\\in \\iota_2$ and $m_2\\in M_2(i_2)$. Then the following equality holds:\n$$\\left(\\left(\\bigoplus_{i_1\\in \\iota_1} M_"}
{"name": "real.rpow_def_of_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem real.rpow_def_of_pos {x : \u211d} (hx : 0 < x) (y : \u211d) :\n\tx ^ y = real.exp (real.log x * y) :=", "nl_statement_of_codex": "If $x>0$ and $y\\in\\mathbb{R}$, then $x^y=e^{y\\log x}$."}
{"name": "ennreal.to_nnreal_lt_to_nnreal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.to_nnreal_lt_to_nnreal {a b : ennreal} (ha : a \u2260 \u22a4) (hb : b \u2260 \u22a4) :\n\ta.to_nnreal < b.to_nnreal \u2194 a < b :=", "nl_statement_of_codex": "Let $a,b$ be extended nonnegative reals. Then $a<b$ if and only if $a.to\\_nnreal<b.to\\_nnreal$."}
{"name": "set.image2_subset_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.image2_subset_left {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1}\n\t{t t' : set \u03b2} (ht : t \u2286 t') :\n\tset.image2 f s t \u2286 set.image2 f s t' :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. If $B\\subset B'$, then $f(A\\times B)\\subset f(A\\times B')$."}
{"name": "category_theory.limits.cocone_right_op_of_cone_\u03b9", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.limits.cocone_right_op_of_cone_\u03b9 {J : Type u\u2081}\n\t[category_theory.category J] {C : Type u\u2083} [category_theory.category C]\n\t{F : J\u1d52\u1d56 \u2964 C} ( : category_theory.limits.cone F) :\n\t(category_theory.limits.cocone_right_op_of_cone c).\u03b9 = category_theory.nat_trans.right_op c.\u03c0 :=", "nl_statement_of_codex": "Let $F:J^{op}\\to C$ be a functor. Then the right adjoint of the cone $\\pi:F\\to\\lim F$ is the cocone $\\iota:\\lim F\\to F$."}
{"name": "exists_and_distrib_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem exists_and_distrib_left {\u03b1 : Sort u_1} {q : Prop} {p : \u03b1 \u2192 Prop} :\n\t(\u2203 (x : \u03b1), q \u2227 p x) \u2194 q \u2227 \u2203 (x : \u03b1), p x :=", "nl_statement_of_codex": "$\\exists x\\in\\alpha, q\\land p(x)$ if and only if $q\\land\\exists x\\in\\alpha, p(x)$."}
{"name": "convolution_exists_at_flip", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convolution.lean", "formal_statement": "theorem convolution_exists_at_flip {\ud835\udd5c G E E' F : Type*} [normed_group E]\n\t[normed_group E'] [normed_group F] {f : G \u2192 E} {g : G \u2192 E'} {x : G}\n\t[nondiscrete_normed_field \ud835\udd5c] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c E']\n\t[normed_space \ud835\udd5c F] {L : E \u2192L[\ud835\udd5c] E' \u2192L[\ud835\udd5c] F} [measurable_space G]\n\t{\u03bc : measure_theory.measure G} [add_comm_group G] [has_measurable_add\u2082 G]\n\t[has_measurable_neg G] [\u03bc.is_add_left_invariant] [\u03bc.is_neg_invariant] :\n\tconvolution_exists_at g f x L.flip \u03bc \u2194 convolution_exists_at f g x L \u03bc :=", "nl_statement_of_codex": "Let $G$ be a topological group, let $E$ and $E'$ be normed groups, let $F$ be a normed group, let $f:G\\to E$, let $g:G\\to E'$, let $x\\in G$, let $L:E\\times E'\\to F$ be a bilinear map, and let $\\mu$ be a measure on $G$. Then the convolution $L(f,g)$ exists at $x$ if and only if the convolution $L(g,f)$ exists at $x$."}
{"name": "finset.coe_vsub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/pointwise.lean", "formal_statement": "theorem finset.coe_vsub {\u03b1 \u03b2 : Type*} [decidable_eq \u03b1] [has_vsub \u03b1 \u03b2]\n\t(s t : finset \u03b2) :\n\t\u2191(s -\u1d65 t) = \u2191s -\u1d65 \u2191t :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets. Then the set of elements of $s$ that are not in $t$ is equal to the set of elements of $s$ that are not in $t$."}
{"name": "polynomial.monic.of_mul_monic_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/monic.lean", "formal_statement": "theorem polynomial.monic.of_mul_monic_left {R : Type u} [semiring R]\n\t{p q : polynomial R} (hp : p.monic) (hpq : (p * q).monic) :\n\tq.monic :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p, q$ be polynomials over $R$. If $p$ is monic and $pq$ is monic, then $q$ is monic."}
{"name": "multiset.nocomm_prod_map_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/noncomm_prod.lean", "formal_statement": "theorem multiset.nocomm_prod_map_aux {\u03b1 \u03b2 : Type*} [monoid \u03b1] [monoid \u03b2]\n\t(s : multiset \u03b1) (comm : \u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b1), y \u2208 s \u2192 commute x y)\n\t{F : Type*} [monoid_hom_class F \u03b1 \u03b2] (f : F) (x : \u03b2)\n\t(H : x \u2208 multiset.map \u21d1f s) (y : \u03b2) (H_1 : y \u2208 multiset.map \u21d1f s) :\n\tcommute x y :=", "nl_statement_of_codex": "Let $s$ be a multiset of a commutative monoid $\u03b1$ and let $f:\u03b1\\to \u03b2$ be a monoid homomorphism. Then $f$ is a commutative monoid homomorphism."}
{"name": "mul_le_mul_of_nonpos_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem mul_le_mul_of_nonpos_left {\u03b1 : Type u} [ordered_ring \u03b1] {a b c : \u03b1} :\n\tb \u2264 a \u2192 c \u2264 0 \u2192 c * a \u2264 c * b :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of an ordered ring. If $b\\leq a$ and $c\\leq 0$, then $c\\cdot a\\leq c\\cdot b$."}
{"name": "relator.bi_total.rel_forall", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/relator.lean", "formal_statement": "theorem relator.bi_total.rel_forall {\u03b1 : Type u\u2081} {\u03b2 : Type u\u2082}\n\t{R : \u03b1 \u2192 \u03b2 \u2192 Prop} (h : relator.bi_total R) :\n\t((R \u21d2 iff) \u21d2 iff) (\u03bb (p : \u03b1 \u2192 Prop), \u2200 (i : \u03b1), p i) (\u03bb (q : \u03b2 \u2192 Prop), \u2200 (i : \u03b2), q i) :=", "nl_statement_of_codex": "Let $R$ be a bi-total relation. Then the following are equivalent:\n(1) $R$ is a subrelation of the implication relation.\n(2) For all $p:\\alpha\\to\\beta$ and $q:\\beta\\to\\alpha$, if $p$ is true for all $\\alpha$ then $q$ is true for all $\\beta$."}
{"name": "simple_graph.subgraph.bot_verts", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/subgraph.lean", "formal_statement": "theorem simple_graph.subgraph.bot_verts {V : Type u} {G : simple_graph V} :\n\t\u22a5.verts = \u2205 :=", "nl_statement_of_codex": "The vertex set of the empty graph is empty."}
{"name": "discrete.add_monoidal_tensor_obj_as", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/discrete.lean", "formal_statement": "theorem discrete.add_monoidal_tensor_obj_as (M : Type u) [add_monoid M]\n\t(X Y : category_theory.discrete M) :\n\t(X \u2297 Y).as = X.as + Y.as :=", "nl_statement_of_codex": "Let $M$ be an additive monoid. Let $X$ and $Y$ be discrete categories over $M$. Then the underlying set of $X\\otimes Y$ is the sum of the underlying sets of $X$ and $Y$."}
{"name": "category_theory.over.iterated_slice_forward_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/over.lean", "formal_statement": "theorem category_theory.over.iterated_slice_forward_map {T : Type u\u2081}\n\t[category_theory.category T] {X : T} (f : category_theory.over X)\n\t(\u03b1 \u03b2 : category_theory.over f) (\u03ba : \u03b1 \u27f6 \u03b2) :\n\tf.iterated_slice_forward.map \u03ba = category_theory.over.hom_mk \u03ba.left.left _ :=", "nl_statement_of_codex": "Let $T$ be a category and let $X$ be an object of $T$. Let $f:Y\\to X$ be a morphism in $T$. Let $\\alpha,\\beta:Z\\to Y$ be morphisms in $T$ and let $\\kappa:\\alpha\\to\\beta$ be a morphism in $T$. Then the map $\\kappa$ induces a map $\\kappa':Z\\to Y$ such that $\\kappa'\\circ\\alpha=\\kappa\\circ\\beta$."}
{"name": "is_pi_system_Ioo_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/pi_system.lean", "formal_statement": "theorem is_pi_system_Ioo_mem {\u03b1 : Type*} [linear_order \u03b1] (s t : set \u03b1) :\n\tis_pi_system {S : set \u03b1 | \u2203 (l : \u03b1) (H : l \u2208 s) (u : \u03b1) (H : u \u2208 t) (h : l < u), set.Ioo l u = S} :=", "nl_statement_of_codex": "Let $s,t$ be subsets of a linear order $X$. Then the set of all intervals $[l,u]$ with $l\\in s$ and $u\\in t$ is a $\\pi$-system."}
{"name": "measure_theory.ae_eq_fun.integrable.sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l1_space.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.integrable.sub {\u03b1 \u03b2 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_group \u03b2]\n\t{f g : \u03b1 \u2192\u2098[\u03bc] \u03b2} (hf : f.integrable) (hg : g.integrable) :\n\t(f - g).integrable :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be measurable functions. If $f$ and $g$ are integrable, then $f-g$ is integrable."}
{"name": "measurable_neg_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem measurable_neg_iff {\u03b1 : Type*} {m : measurable_space \u03b1} {G : Type*}\n\t[add_group G] [measurable_space G] [has_measurable_neg G] {f : \u03b1 \u2192 G} :\n\tmeasurable (\u03bb (x : \u03b1), -f x) \u2194 measurable f :=", "nl_statement_of_codex": "Let $f:X\\to G$ be a measurable function. Then $-f$ is measurable if and only if $f$ is measurable."}
{"name": "Top.snd_open_embedding_of_left_open_embedding", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Top/limits.lean", "formal_statement": "theorem Top.snd_open_embedding_of_left_open_embedding {X Y S : Top} {f : X \u27f6 S}\n\t(H : open_embedding \u21d1f) (g : Y \u27f6 S) :\n\topen_embedding \u21d1category_theory.limits.pullback.snd :=", "nl_statement_of_codex": "Let $X, Y, S$ be topological spaces and let $f:X\\to S$ and $g:Y\\to S$ be continuous maps. If $f$ is an open embedding, then the second projection of the pullback of $f$ and $g$ is an open embedding."}
{"name": "measure_theory.ae_of_ae_restrict_of_ae_restrict_compl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.ae_of_ae_restrict_of_ae_restrict_compl {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (t : set \u03b1)\n\t{p : \u03b1 \u2192 Prop} (ht : \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict t, p x)\n\t(htc : \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict t\u1d9c, p x) :\n\t\u2200\u1d50 (x : \u03b1) \u2202\u03bc, p x :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $t\\subset X$ and let $p:X\\to\\{0,1\\}$ be a measurable function. If $p$ is $\\mu$-almost everywhere equal to $1$ on $t$ and $\\mu$-almost everywhere equal to $0$ on $t^c$, then $p$ is $\\mu$-almost everywhere equal to $1$ on $X$."}
{"name": "finset.mem_image\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/n_ary.lean", "formal_statement": "theorem finset.mem_image\u2082 {\u03b1 \u03b2 \u03b3 : Type*} [decidable_eq \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n\t{s : finset \u03b1} {t : finset \u03b2} { : \u03b3} :\n\tc \u2208 finset.image\u2082 f s t \u2194 \u2203 (a : \u03b1) (b : \u03b2), a \u2208 s \u2227 b \u2208 t \u2227 f a b = c :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. Then $c\\in f(A\\times B)$ if and only if there are $a\\in A$ and $b\\in B$ such that $f(a,b)=c$."}
{"name": "matrix.inv_eq_left_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/nonsingular_inverse.lean", "formal_statement": "theorem matrix.inv_eq_left_inv {n : Type u'} {\u03b1 : Type v} [fintype n]\n\t[decidable_eq n] [comm_ring \u03b1] {A B : matrix n n \u03b1} (h : B.mul A = 1) :\n\tA\u207b\u00b9 = B :=", "nl_statement_of_codex": "Let $A$ and $B$ be $n\\times n$ matrices over a commutative ring $R$ such that $AB=I$. Then $A^{-1}=B$."}
{"name": "nat.odd.of_mul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/parity.lean", "formal_statement": "theorem nat.odd.of_mul_right {m n : \u2115} (h : odd (m * n)) :\n\todd n :=", "nl_statement_of_codex": "If $m$ is odd and $n$ is even, then $m\\cdot n$ is even."}
{"name": "box_integral.prepartition.is_partition.le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/basic.lean", "formal_statement": "theorem box_integral.prepartition.is_partition.le_iff {\u03b9 : Type*}\n\t{I : box_integral.box \u03b9} {\u03c0\u2081 \u03c0\u2082 : box_integral.prepartition I}\n\t(h : \u03c0\u2082.is_partition) :\n\t\u03c0\u2081 \u2264 \u03c0\u2082 \u2194 \u2200 (J : box_integral.box \u03b9), J \u2208 \u03c0\u2081 \u2192 \u2200 (J' : box_integral.box \u03b9), J' \u2208 \u03c0\u2082 \u2192 (\u2191J \u2229 \u2191J').nonempty \u2192 J \u2264 J' :=", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $\\pi_1, \\pi_2$ be two partitions of $I$. Then $\\pi_1\\leq \\pi_2$ if and only if for each $J\\in \\pi_1$ and each $J'\\in \\pi_2$ such that $J\\cap J'\\neq \\emptyset$, we have $J\\leq J'$."}
{"name": "int.coe_nat_zero", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/basic.lean", "formal_statement": "theorem int.coe_nat_zero :\n\t\u21910 = 0 :=", "nl_statement_of_codex": "The integer $0$ is equal to the natural number $0$."}
{"name": "is_primitive_root.order_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/roots_of_unity.lean", "formal_statement": "theorem is_primitive_root.order_of {M : Type*} [comm_monoid M] (\u03b6 : M) :\n\tis_primitive_root \u03b6 (order_of \u03b6) :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid and let $\\zeta\\in M$. Then $\\zeta$ is a primitive root of $M$ of order $o(\\zeta)$."}
{"name": "measure_theory.complex_measure.equiv_signed_measure\u2097_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/complex.lean", "formal_statement": "theorem measure_theory.complex_measure.equiv_signed_measure\u2097_symm_apply\n\t{\u03b1 : Type*} {m : measurable_space \u03b1} {R : Type*} [semiring R] [module R \u211d]\n\t[has_continuous_const_smul R \u211d] [has_continuous_const_smul R \u2102]\n\t(\u1fb0 : measure_theory.signed_measure \u03b1 \u00d7 measure_theory.signed_measure \u03b1) :\n\t\u21d1(measure_theory.complex_measure.equiv_signed_measure\u2097.symm) \u1fb0 = measure_theory.complex_measure.equiv_signed_measure.inv_fun \u1fb0 :=", "nl_statement_of_codex": "Let $m$ be a measurable space and let $R$ be a semiring. Then the inverse of the equivalence between the complex measure and the signed measure is the inverse of the equivalence between the complex measure and the signed measure."}
{"name": "neq_of_not_iff", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/logic.lean", "formal_statement": "theorem neq_of_not_iff {a b : Prop} :\n\t\u00ac(a \u2194 b) \u2192 a \u2260 b :=", "nl_statement_of_codex": "If $a$ and $b$ are propositions and $a$ and $b$ are not equivalent, then $a$ and $b$ are not equal."}
{"name": "affine_map.right_vsub_line_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_map.lean", "formal_statement": "theorem affine_map.right_vsub_line_map {k V1 P1 : Type*} [ring k]\n\t[add_comm_group V1] [module k V1] [add_torsor V1 P1] (p\u2080 p\u2081 : P1) ( : k) :\n\tp\u2081 -\u1d65 \u21d1(affine_map.line_map p\u2080 p\u2081) c = (1 - c) \u2022 (p\u2081 -\u1d65 p\u2080) :=", "nl_statement_of_codex": "Let $k$ be a ring, $V$ a $k$-module, and $P$ an affine space over $V$. Let $p_0, p_1\\in P$ and $c\\in k$. Then $p_1-c\\cdot\\ell_{p_0,p_1}= (1-c)\\cdot(p_1-p_0)$."}
{"name": "hahn_series.single_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/hahn_series.lean", "formal_statement": "theorem hahn_series.single_ne_zero {\u0393 R : Type*} [partial_order \u0393] [has_zero R]\n\t{a : \u0393} {r : R} (h : r \u2260 0) :\n\t\u21d1(hahn_series.single a) r \u2260 0 :=", "nl_statement_of_codex": "Let $R$ be a ring with zero and let $a\\in\\Gamma$. Then the Hahn series $\\sum_{\\gamma\\in\\Gamma}r_\\gamma\\gamma$ is not zero if and only if $r_a\\neq 0$."}
{"name": "equiv.swap_mul_involutive", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/basic.lean", "formal_statement": "theorem equiv.swap_mul_involutive {\u03b1 : Type u} [decidable_eq \u03b1] (i j : \u03b1) :\n\tfunction.involutive (has_mul.mul (equiv.swap i j)) :=", "nl_statement_of_codex": "The multiplication map on the group of permutations of a set $X$ is an involution."}
{"name": "onote.fundamental_sequence_has_prop", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/notation.lean", "formal_statement": "theorem onote.fundamental_sequence_has_prop (o : onote) :\n\to.fundamental_sequence_prop o.fundamental_sequence :=", "nl_statement_of_codex": "Let $o$ be an ordinal. Then the fundamental sequence of $o$ has the fundamental sequence property."}
{"name": "emetric.mem_closed_ball_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean", "formal_statement": "theorem emetric.mem_closed_ball_self {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t{x : \u03b1} {\u03b5 : ennreal} :\n\tx \u2208 emetric.closed_ball x \u03b5 :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x\\in X$. Then $x$ is in the closed ball of radius $\\epsilon$ centered at $x$."}
{"name": "measure_theory.lintegral_lintegral_mul_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/prod.lean", "formal_statement": "theorem measure_theory.lintegral_lintegral_mul_inv {G : Type*}\n\t[measurable_space G] [group G] [has_measurable_mul\u2082 G]\n\t(\u03bc \u03bd : measure_theory.measure G) [measure_theory.sigma_finite \u03bd]\n\t[measure_theory.sigma_finite \u03bc] [has_measurable_inv G]\n\t[\u03bc.is_mul_left_invariant] [\u03bd.is_mul_left_invariant] (f : G \u2192 G \u2192 ennreal)\n\t(hf : ae_measurable (function.uncurry f) (\u03bc.prod \u03bd)) :\n\t\u222b\u207b (x : G), \u222b\u207b (y : G), f (y * x) x\u207b\u00b9 \u2202\u03bd \u2202\u03bc = \u222b\u207b (x : G), \u222b\u207b (y : G), f x y \u2202\u03bd \u2202\u03bc :=", "nl_statement_of_codex": "Let $G$ be a group and let $\\mu,\\nu$ be left-invariant measures on $G$. Let $f:G\\times G\\to [0,\\infty]$ be a measurable function. Then\n$$\\int_G\\int_G f(yx^{-1})d\\nu(y)d\\mu(x)=\\int_G\\int_G f(x,y)d\\nu(y)d\\mu(x).$$"}
{"name": "right.add_lt_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem right.add_lt_add {\u03b1 : Type*} [has_add \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] {a b c d : \u03b1}\n\t(h\u2081 : a < b) (h\u2082 : c < d) :\n\ta + c < b + d :=", "nl_statement_of_codex": "If $a<b$ and $c<d$, then $a+c<b+d$."}
{"name": "add_subsemigroup.mem_inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/basic.lean", "formal_statement": "theorem add_subsemigroup.mem_inf {M : Type*} [has_add M]\n\t{p p' : add_subsemigroup M} {x : M} :\n\tx \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p' :=", "nl_statement_of_codex": "Let $M$ be a set with an addition operation. Let $p, p'$ be subsemigroups of $M$. Then $x\\in p\\cap p'$ if and only if $x\\in p$ and $x\\in p'$."}
{"name": "projective_spectrum.zero_locus_bUnion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/projective_spectrum/topology.lean", "formal_statement": "theorem projective_spectrum.zero_locus_bUnion {R A : Type*} [comm_semiring R]\n\t[comm_ring A] [algebra R A] (\ud835\udc9c : \u2115 \u2192 submodule R A) [graded_algebra \ud835\udc9c]\n\t(s : set (set A)) :\n\tprojective_spectrum.zero_locus \ud835\udc9c (\u22c3 (s' : set A) (H : s' \u2208 s), s') = \u22c2 (s' : set A) (H : s' \u2208 s), projective_spectrum.zero_locus \ud835\udc9c s' :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a commutative ring, and $\ud835\udc9c$ a graded algebra over $R$. Then the zero locus of the union of a family of subsets of $A$ is the intersection of the zero loci of the subsets."}
{"name": "has_strict_fderiv_at.local_inverse_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/inverse.lean", "formal_statement": "theorem has_strict_fderiv_at.local_inverse_unique {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] [cs : complete_space E]\n\t{f : E \u2192 F} {f' : E \u2243L[\ud835\udd5c] F} {a : E} (hf : has_strict_fderiv_at f \u2191f' a)\n\t{g : F \u2192 E} (hg : \u2200\u1da0 (x : E) in nhds a, g (f x) = x) :\n\t\u2200\u1da0 (y : F) in nhds (f a), g y = has_strict_fderiv_at.local_inverse f f' a hf y :=", "nl_statement_of_codex": "Let $f:E\\to F$ be a function between normed spaces. Suppose that $f$ has a strict derivative $f'$ at $a\\in E$. Let $g:F\\to E$ be a function such that $g(f(x))=x$ for all $x$ in a neighborhood of $a$. Then $g(y)=f'^{-1}(y)$ for all $y$ in a neighborhood of $f(a)$."}
{"name": "monotone.quasilinear_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/quasiconvex.lean", "formal_statement": "theorem monotone.quasilinear_on {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c]\n\t[linear_ordered_add_comm_monoid E] [ordered_add_comm_monoid \u03b2] [module \ud835\udd5c E]\n\t[ordered_smul \ud835\udd5c E] {f : E \u2192 \u03b2} (hf : monotone f) :\n\tquasilinear_on \ud835\udd5c set.univ f :=", "nl_statement_of_codex": "Let $E$ be a linearly ordered abelian group and let $f:E\\to \\mathbb{R}$ be a monotone function. Then $f$ is quasilinear."}
{"name": "is_bot_to_dual_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/max.lean", "formal_statement": "theorem is_bot_to_dual_iff {\u03b1 : Type*} [has_le \u03b1] {a : \u03b1} :\n\tis_bot (\u21d1order_dual.to_dual a) \u2194 is_top a :=", "nl_statement_of_codex": "Let $\u03b1$ be a partially ordered set. Then $a$ is the top element of $\u03b1$ if and only if $\u21d1order_dual.to_dual a$ is the bottom element of $order_dual \u03b1$."}
{"name": "fin.coe_coe_of_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.coe_coe_of_lt {n a : \u2115} (h : a < n + 1) :\n\t\u2191\u2191a = a :=", "nl_statement_of_codex": "If $a<n+1$, then $a=\\overline{\\overline{a}}$."}
{"name": "lie_hom.congr_fun", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/basic.lean", "formal_statement": "theorem lie_hom.congr_fun {R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} [comm_ring R]\n\t[lie_ring L\u2081] [lie_algebra R L\u2081] [lie_ring L\u2082] [lie_algebra R L\u2082]\n\t{f g : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082} (h : f = g) (x : L\u2081) :\n\t\u21d1f x = \u21d1g x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $L_1$ and $L_2$ be Lie algebras over $R$, and let $f,g:L_1\\to L_2$ be Lie homomorphisms. If $f=g$, then $f(x)=g(x)$ for all $x\\in L_1$."}
{"name": "polynomial.eq_zero_of_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.eq_zero_of_eq_zero {R : Type u} [semiring R] (h : 0 = 1)\n\t(p : polynomial R) :\n\tp = 0 :=", "nl_statement_of_codex": "If $0=1$, then every polynomial is equal to $0$."}
{"name": "set.diff_diff_right_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.diff_diff_right_self {\u03b1 : Type u} (s t : set \u03b1) :\n\ts \\ (s \\ t) = s \u2229 t :=", "nl_statement_of_codex": "$S\\setminus (S\\setminus T)=S\\cap T$."}
{"name": "category_theory.limits.coprod.inr_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/binary_products.lean", "formal_statement": "theorem category_theory.limits.coprod.inr_map {C : Type u}\n\t[category_theory.category C] {W X Y Z : C}\n\t[category_theory.limits.has_binary_coproduct W X]\n\t[category_theory.limits.has_binary_coproduct Y Z] (f : W \u27f6 Y) (g : X \u27f6 Z) :\n\tcategory_theory.limits.coprod.inr \u226b category_theory.limits.coprod.map f g = g \u226b category_theory.limits.coprod.inr :=", "nl_statement_of_codex": "Let $C$ be a category. Let $W, X, Y, Z$ be objects of $C$. Suppose that $W\\oplus X$ and $Y\\oplus Z$ exist. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nW\\oplus X & \\xrightarrow{f\\oplus g} & Y\\oplus Z \\\\\n\\downarrow & & \\downarrow \\\\\nX & \\xrightarrow{g} & Z\n\\end{array}$$"}
{"name": "FinPartialOrder.iso.mk_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/category/FinPartialOrder.lean", "formal_statement": "theorem FinPartialOrder.iso.mk_hom {\u03b1 \u03b2 : FinPartialOrder} (e : \u21a5\u03b1 \u2243o \u21a5\u03b2) :\n\t(FinPartialOrder.iso.mk e).hom = \u2191e :=", "nl_statement_of_codex": "Let $\u03b1$ and $\u03b2$ be finite partial orders. Let $e:\u03b1\\to \u03b2$ be an order isomorphism. Then the induced isomorphism $FinPartialOrder.iso.mk e$ has the same underlying function as $e$."}
{"name": "ae_strongly_measurable_const_smul_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem ae_strongly_measurable_const_smul_iff {\u03b1 \u03b2 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {G : Type*} [group G] [mul_action G \u03b2]\n\t[has_continuous_const_smul G \u03b2] ( : G) :\n\tmeasure_theory.ae_strongly_measurable (\u03bb (x : \u03b1), c \u2022 f x) \u03bc \u2194 measure_theory.ae_strongly_measurable f \u03bc :=", "nl_statement_of_codex": "Let $G$ be a group acting continuously on a topological space $X$. Then a function $f:X\\to Y$ is strongly measurable if and only if $c\\cdot f$ is strongly measurable for all $c\\in G$."}
{"name": "int.eq_of_mul_eq_mul_right", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.eq_of_mul_eq_mul_right {a b c : \u2124} (ha : a \u2260 0) (h : b * a = c * a) :\n\tb = c :=", "nl_statement_of_codex": "If $a\\neq 0$ and $b\\cdot a=c\\cdot a$, then $b=c$."}
{"name": "smul_eq_iff_eq_inv_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/group.lean", "formal_statement": "theorem smul_eq_iff_eq_inv_smul {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1]\n\t[mul_action \u03b1 \u03b2] (g : \u03b1) {x y : \u03b2} :\n\tg \u2022 x = y \u2194 x = g\u207b\u00b9 \u2022 y :=", "nl_statement_of_codex": "Let $G$ be a group acting on a set $X$. Then $g\\cdot x=y$ if and only if $x=g^{-1}\\cdot y$."}
{"name": "set.countable.prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/countable.lean", "formal_statement": "theorem set.countable.prod {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2}\n\t(hs : s.countable) (ht : t.countable) :\n\t(s \u00d7\u02e2 t).countable :=", "nl_statement_of_codex": "If $S$ and $T$ are countable sets, then $S\\times T$ is countable."}
{"name": "psigma.skip_left_wf", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/sigma/lex.lean", "formal_statement": "theorem psigma.skip_left_wf (\u03b1 : Type u) {\u03b2 : Type v} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n\t(hb : well_founded s) :\n\twell_founded (psigma.skip_left \u03b1 s) :=", "nl_statement_of_codex": "Let $s$ be a well-founded relation on $\\beta$. Then the relation $s\\times\\alpha$ is well-founded."}
{"name": "ratfunc.num_denom_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/ratfunc.lean", "formal_statement": "theorem ratfunc.num_denom_div {K : Type u} [hfield : field K] (p : polynomial K)\n\t{q : polynomial K} (hq : q \u2260 0) :\n\t(\u21d1(algebra_map (polynomial K) (ratfunc K)) p / \u21d1(algebra_map (polynomial K) (ratfunc K)) q).num_denom = (\u21d1polynomial.C ((q / gcd_monoid.gcd p q).leading_coeff)\u207b\u00b9 * (p / gcd_monoid.gcd p q), \u21d1polynomial.C ((q / gcd_monoid.gcd p q).leading_coeff)\u207b\u00b9 * (q / gcd_monoid.gcd p q)) :=", "nl_statement_of_codex": "Let $K$ be a field and let $p, q\\in K[x]$ be polynomials. Then the numerator and denominator of the rational function $p/q$ are given by $p/\\gcd(p,q)$ and $q/\\gcd(p,q)$, respectively."}
{"name": "euclidean_space.pi_Lp_congr_left_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/pi_L2.lean", "formal_statement": "theorem euclidean_space.pi_Lp_congr_left_single {\u03b9 \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c]\n\t[fintype \u03b9] [decidable_eq \u03b9] {\u03b9' : Type*} [fintype \u03b9'] [decidable_eq \u03b9']\n\t(e : \u03b9' \u2243 \u03b9) (i' : \u03b9') :\n\t\u21d1(linear_isometry_equiv.pi_Lp_congr_left 2 \ud835\udd5c \ud835\udd5c e) (euclidean_space.single i' 1) = euclidean_space.single (\u21d1e i') 1 :=", "nl_statement_of_codex": "Let $e:I'\\to I$ be a bijection. Then the map $f:I'\\to I$ defined by $f(i')=e(i')$ is a linear isometry."}
{"name": "rat.cast_multiset_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/cast.lean", "formal_statement": "theorem rat.cast_multiset_prod {\u03b1 : Type*} [field \u03b1] [char_zero \u03b1]\n\t(s : multiset \u211a) :\n\t\u2191(s.prod) = (multiset.map coe s).prod :=", "nl_statement_of_codex": "The product of a multiset of rational numbers is equal to the product of the multiset of the corresponding elements of the field of rational numbers."}
{"name": "category_theory.is_subterminal_of_mono_terminal_from", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subterminal.lean", "formal_statement": "theorem category_theory.is_subterminal_of_mono_terminal_from {C : Type u\u2081}\n\t[category_theory.category C] {A : C} [category_theory.limits.has_terminal C]\n\t[category_theory.mono (category_theory.limits.terminal.from A)] :\n\tcategory_theory.is_subterminal A :=", "nl_statement_of_codex": "Let $C$ be a category with a terminal object $T$. Let $A$ be an object of $C$ such that the morphism $T\\to A$ is monic. Then $A$ is a subterminal object of $C$."}
{"name": "nnreal.coe_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/nnreal.lean", "formal_statement": "theorem nnreal.coe_two :\n\t\u21912 = 2 :=", "nl_statement_of_codex": "The natural number $2$ is equal to the non-negative real number $2$."}
{"name": "exists_unique_add_zsmul_mem_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/archimedean.lean", "formal_statement": "theorem exists_unique_add_zsmul_mem_Ico {\u03b1 : Type*}\n\t[linear_ordered_add_comm_group \u03b1] [archimedean \u03b1] {a : \u03b1} (ha : 0 < a)\n\t(b c : \u03b1) :\n\t\u2203! (m : \u2124), b + m \u2022 a \u2208 set.Ico c (c + a) :=", "nl_statement_of_codex": "Let $a$ be a positive real number and let $b, c$ be real numbers. Then there is a unique integer $m$ such that $b+ma\\in[c,c+a]$."}
{"name": "linear_map.prod_eq_sup_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/prod.lean", "formal_statement": "theorem linear_map.prod_eq_sup_map {R : Type u} {M : Type v} {M\u2082 : Type w}\n\t[semiring R] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M]\n\t[module R M\u2082] (p : submodule R M) (q : submodule R M\u2082) :\n\tp.prod q = submodule.map (linear_map.inl R M M\u2082) p \u2294 submodule.map (linear_map.inr R M M\u2082) q :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $M_2$ be $R$-modules. Then the product of the submodules $p$ and $q$ of $M$ and $M_2$ respectively is equal to the sum of the images of $p$ and $q$ under the canonical maps $M\\to M\\oplus M_2$ and $M_2\\to M\\oplus M_2$ respectively."}
{"name": "order_of_pos_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/order_of_element.lean", "formal_statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] :\n\t0 < order_of x \u2194 is_of_fin_order x :=", "nl_statement_of_codex": "Let $G$ be a monoid and let $x\\in G$. Then $x$ has finite order if and only if $0<\\mathrm{ord}(x)$."}
{"name": "lipschitz_with.list_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/lipschitz.lean", "formal_statement": "theorem lipschitz_with.list_prod {\u03b1 : Type u} {\u03b9 : Type x}\n\t[pseudo_emetric_space \u03b1] (f : \u03b9 \u2192 function.End \u03b1) (K : \u03b9 \u2192 nnreal)\n\t(h : \u2200 (i : \u03b9), lipschitz_with (K i) (f i)) (l : list \u03b9) :\n\tlipschitz_with (list.map K l).prod (list.map f l).prod :=", "nl_statement_of_codex": "Let $f_i:X\\to Y$ be a family of Lipschitz functions with Lipschitz constants $K_i$. Then the product of the functions $f_i$ is Lipschitz with Lipschitz constant $\\prod K_i$."}
{"name": "valuation.map_sum_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/valuation/basic.lean", "formal_statement": "theorem valuation.map_sum_lt {R \u0393\u2080 : Type*} [ring R]\n\t[linear_ordered_comm_monoid_with_zero \u0393\u2080] (v : valuation R \u0393\u2080) {\u03b9 : Type*}\n\t{s : finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n\t(hf : \u2200 (i : \u03b9), i \u2208 s \u2192 \u21d1v (f i) < g) :\n\t\u21d1v (s.sum (\u03bb (i : \u03b9), f i)) < g :=", "nl_statement_of_codex": "Let $R$ be a ring, let $\\Gamma_0$ be a linearly ordered commutative monoid with zero, and let $v$ be a valuation on $R$ with values in $\\Gamma_0$. Let $s$ be a finite set, let $f:s\\to R$, and let $g\\in\\Gamma_0$ with $g\\neq 0$. Suppose that $v(f(i))<g$ for all $i\\in s$. Then $v(\\sum_{i\\in s}f(i))<g$."}
{"name": "omega.coeffs.val_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/omega/coeffs.lean", "formal_statement": "theorem omega.coeffs.val_eq_zero {v : \u2115 \u2192 \u2124} {is : list \u2124} :\n\t(\u2200 (x : \u2124), x \u2208 is \u2192 x = 0) \u2192 omega.coeffs.val v is = 0 :=", "nl_statement_of_codex": "Let $v$ be a function from $\\mathbb{N}$ to $\\mathbb{Z}$ and let $is$ be a list of integers. If all elements of $is$ are zero, then $\\omega.coeffs.val(v, is)=0$."}
{"name": "measure_theory.ae_eq_fun.coe_fn_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ae_eq_fun.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.coe_fn_mul {\u03b1 \u03b3 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} [topological_space \u03b3] [has_mul \u03b3]\n\t[has_continuous_mul \u03b3] (f g : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n\t\u21d1(f * g) =\u1d50[\u03bc] \u21d1f * \u21d1g :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be measurable functions. Then $f\\cdot g$ is measurable and $(f\\cdot g)^*=f^*\\cdot g^*$."}
{"name": "finset.sum_eq_sum_Ico_succ_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/intervals.lean", "formal_statement": "theorem finset.sum_eq_sum_Ico_succ_bot {\u03b4 : Type*} [add_comm_monoid \u03b4] {a b : \u2115}\n\t(hab : a < b) (f : \u2115 \u2192 \u03b4) :\n\t(finset.Ico a b).sum (\u03bb (k : \u2115), f k) = f a + (finset.Ico (a + 1) b).sum (\u03bb (k : \u2115), f k) :=", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{N}$ with $a<b$. Then $\\sum_{k=a}^{b-1}f(k)=f(a)+\\sum_{k=a+1}^{b-1}f(k)$."}
{"name": "stream.tail_iterate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/stream/init.lean", "formal_statement": "theorem stream.tail_iterate {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) (a : \u03b1) :\n\t(stream.iterate f a).tail = stream.iterate f (f a) :=", "nl_statement_of_codex": "The tail of the stream $s_n=f(s_{n-1})$ is the stream $s_n=f(s_{n-1})$."}
{"name": "is_locally_constant.range_finite", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/locally_constant/basic.lean", "formal_statement": "theorem is_locally_constant.range_finite {X Y : Type*} [topological_space X]\n\t[compact_space X] {f : X \u2192 Y} (hf : is_locally_constant f) :\n\t(set.range f).finite :=", "nl_statement_of_codex": "Let $X$ be a compact topological space and let $f:X\\to Y$. If $f$ is locally constant, then the range of $f$ is finite."}
{"name": "part.coe_some", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.coe_some {\u03b1 : Type*} (a : \u03b1) :\n\t\u2191(option.some a) = part.some a :=", "nl_statement_of_codex": "The equivalence class of $a$ is the same as the equivalence class of $a$."}
{"name": "thickened_indicator_aux_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/thickened_indicator.lean", "formal_statement": "theorem thickened_indicator_aux_mono {\u03b1 : Type*} [pseudo_emetric_space \u03b1]\n\t{\u03b4\u2081 \u03b4\u2082 : \u211d} (hle : \u03b4\u2081 \u2264 \u03b4\u2082) (E : set \u03b1) :\n\tthickened_indicator_aux \u03b4\u2081 E \u2264 thickened_indicator_aux \u03b4\u2082 E :=", "nl_statement_of_codex": "Let $E$ be a subset of a pseudo-metric space $(X,d)$. Then the thickened indicator function $\\chi_{\\delta_1}(E)$ is less than or equal to the thickened indicator function $\\chi_{\\delta_2}(E)$."}
{"name": "tactic.ring.add_neg_eq_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/ring.lean", "formal_statement": "theorem tactic.ring.add_neg_eq_sub {\u03b1 : Type*} [add_group \u03b1] (a b : \u03b1) :\n\ta + -b = a - b :=", "nl_statement_of_codex": "For all $a,b\\in\\alpha$, $a+(-b)=a-b$."}
{"name": "polynomial.monomial_mem_lifts", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/lifts.lean", "formal_statement": "theorem polynomial.monomial_mem_lifts {R : Type u} [semiring R] {S : Type v}\n\t[semiring S] {f : R \u2192+* S} {s : S} (n : \u2115) (h : s \u2208 set.range \u21d1f) :\n\t\u21d1(polynomial.monomial n) s \u2208 polynomial.lifts f :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings and let $f:R\\to S$ be a semiring homomorphism. Then the monomial $x^n$ lifts to $S$."}
{"name": "finset.sum_erase_eq_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_erase_eq_sub {\u03b2 : Type u} {\u03b1 : Type v} {s : finset \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} [add_comm_group \u03b2] [decidable_eq \u03b1] {a : \u03b1} (h : a \u2208 s) :\n\t(s.erase a).sum (\u03bb (x : \u03b1), f x) = s.sum (\u03bb (x : \u03b1), f x) - f a :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\beta$ be a function. Then $\\sum_{x\\in s\\setminus\\{a\\}}f(x)=\\sum_{x\\in s}f(x)-f(a)$."}
{"name": "int.lxor_bit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.lxor_bit (a : bool) (m : \u2124) (b : bool) (n : \u2124) :\n\t(int.bit a m).lxor (int.bit b n) = int.bit (bxor a b) (m.lxor n) :=", "nl_statement_of_codex": "The bitwise exclusive or of two integers $m$ and $n$ is the integer whose $i$-th bit is the exclusive or of the $i$-th bits of $m$ and $n$."}
{"name": "multiplicity.multiplicity_add_of_gt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/multiplicity.lean", "formal_statement": "theorem multiplicity.multiplicity_add_of_gt {\u03b1 : Type*} [comm_ring \u03b1]\n\t[decidable_rel has_dvd.dvd] {p a b : \u03b1}\n\t(h : multiplicity p b < multiplicity p a) :\n\tmultiplicity p (a + b) = multiplicity p b :=", "nl_statement_of_codex": "Let $p$ be a prime element of a commutative ring $R$. If $p^k$ divides $a$ but not $b$, then $p^k$ divides $a+b$."}
{"name": "ordnode.valid'.glue_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.valid'.glue_aux {\u03b1 : Type*} [preorder \u03b1] {l r : ordnode \u03b1}\n\t{o\u2081 : with_bot \u03b1} {o\u2082 : with_top \u03b1} (hl : ordnode.valid' o\u2081 l o\u2082)\n\t(hr : ordnode.valid' o\u2081 r o\u2082)\n\t(sep : ordnode.all (\u03bb (x : \u03b1), ordnode.all (\u03bb (y : \u03b1), x < y) r) l)\n\t(bal : ordnode.balanced_sz l.size r.size) :\n\tordnode.valid' o\u2081 (l.glue r) o\u2082 \u2227 (l.glue r).size = l.size + r.size :=", "nl_statement_of_codex": "Let $l$ and $r$ be valid ordered nodes with $l$ less than $r$. Then $l$ and $r$ can be glued together to form a valid ordered node."}
{"name": "measure_theory.ae_cover_Ioc_of_Ioo", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/integral_eq_improper.lean", "formal_statement": "theorem measure_theory.ae_cover_Ioc_of_Ioo {\u03b1 \u03b9 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {l : filter \u03b9} [linear_order \u03b1]\n\t[topological_space \u03b1] [order_closed_topology \u03b1] [opens_measurable_space \u03b1]\n\t{a b : \u03b9 \u2192 \u03b1} {A B : \u03b1} [measure_theory.has_no_atoms \u03bc]\n\t(ha : filter.tendsto a l (nhds A)) (hb : filter.tendsto b l (nhds B)) :\n\tmeasure_theory.ae_cover (\u03bc.restrict (set.Ioc A B)) l (\u03bb (i : \u03b9), set.Ioo (a i) (b i)) :=", "nl_statement_of_codex": "Let $A, B$ be real numbers with $A<B$. Let $a, b:\\mathbb{N}\\to\\mathbb{R}$ be sequences such that $a_n\\to A$ and $b_n\\to B$. Then the measure of the set $\\{x\\in\\mathbb{R}: A<x<B\\}$ is equal to the limit of the measures of the sets $\\{x\\in\\mathbb{R}: a_n<x<b_n\\}$."}
{"name": "not.intro", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/logic.lean", "formal_statement": "theorem not.intro {a : Prop} (h : a \u2192 false) :\n\t\u00aca :=", "nl_statement_of_codex": "If $a$ is false, then $a$ is not true."}
{"name": "rat.mk_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/order.lean", "formal_statement": "theorem rat.mk_nonneg (a : \u2124) {b : \u2124} (h : 0 < b) :\n\t(rat.mk a b).nonneg \u2194 0 \u2264 a :=", "nl_statement_of_codex": "The rational number $a/b$ is nonnegative if and only if $a\\geq 0$."}
{"name": "list.revzip_sublists", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/perm.lean", "formal_statement": "theorem list.revzip_sublists {\u03b1 : Type uu} (l l\u2081 l\u2082 : list \u03b1) :\n\t(l\u2081, l\u2082) \u2208 l.sublists.revzip \u2192 l\u2081 ++ l\u2082 ~ l :=", "nl_statement_of_codex": "Let $l, l_1, l_2$ be lists. If $(l_1, l_2)$ is in the reverse zip of the sublists of $l$, then $l_1$ and $l_2$ concatenate to $l$."}
{"name": "first_order.language.elementary_substructure.Theory_model_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/elementary_maps.lean", "formal_statement": "theorem first_order.language.elementary_substructure.Theory_model_iff\n\t{L : first_order.language} {M : Type*} [L.Structure M]\n\t(S : L.elementary_substructure M) (T : L.Theory) :\n\t\u21a5S \u22a8 T \u2194 M \u22a8 T :=", "nl_statement_of_codex": "Let $L$ be a first-order language, $M$ a model of $L$, and $S$ an elementary substructure of $M$. Then $S$ is a model of $T$ if and only if $M$ is a model of $T$."}
{"name": "matrix.to_lin_transpose", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/dual.lean", "formal_statement": "theorem matrix.to_lin_transpose {K V\u2081 V\u2082 \u03b9\u2081 \u03b9\u2082 : Type*} [field K]\n\t[add_comm_group V\u2081] [module K V\u2081] [add_comm_group V\u2082] [module K V\u2082]\n\t[fintype \u03b9\u2081] [fintype \u03b9\u2082] [decidable_eq \u03b9\u2081] [decidable_eq \u03b9\u2082]\n\t{B\u2081 : basis \u03b9\u2081 K V\u2081} {B\u2082 : basis \u03b9\u2082 K V\u2082} (M : matrix \u03b9\u2081 \u03b9\u2082 K) :\n\t\u21d1(matrix.to_lin B\u2081.dual_basis B\u2082.dual_basis) M.transpose = \u21d1module.dual.transpose (\u21d1(matrix.to_lin B\u2082 B\u2081) M) :=", "nl_statement_of_codex": "Let $K$ be a field, $V_1$ and $V_2$ be $K$-vector spaces, $B_1$ and $B_2$ be bases of $V_1$ and $V_2$, respectively. Then the transpose of the matrix of the linear transformation $V_1\\to V_2$ with respect to $B_1$ and $B_2$ is the matrix of the linear transformation $V_2^*\\to V_1^*$ with respect to the dual bases of $B_1$ and $B_2$."}
{"name": "category_theory.splitting.comp_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/short_exact/preadditive.lean", "formal_statement": "theorem category_theory.splitting.comp_eq_zero {\ud835\udc9c : Type*}\n\t[category_theory.category \ud835\udc9c] {A B C : \ud835\udc9c} {f : A \u27f6 B} {g : B \u27f6 C}\n\t[category_theory.preadditive \ud835\udc9c]\n\t[category_theory.limits.has_binary_biproducts \ud835\udc9c]\n\t(h : category_theory.splitting f g) :\n\tf \u226b g = 0 :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be morphisms in a preadditive category with binary biproducts. If $f$ and $g$ split, then $f\\circ g=0$."}
{"name": "cont_diff_bump_of_inner.one_of_mem_closed_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/specific_functions.lean", "formal_statement": "theorem cont_diff_bump_of_inner.one_of_mem_closed_ball {E : Type*}\n\t[inner_product_space \u211d E] { : E} (f : cont_diff_bump_of_inner c) {x : E}\n\t(hx : x \u2208 metric.closed_ball c f.r) :\n\t\u21d1f x = 1 :=", "nl_statement_of_codex": "Let $E$ be an inner product space and let $f:E\\to\\mathbb{R}$ be a continuous function with compact support. Then $f(x)=1$ for all $x$ in the closed ball of radius $r$ centered at $c$."}
{"name": "nhds_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem nhds_swap {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] (a : \u03b1) (b : \u03b2) :\n\tnhds (a, b) = filter.map prod.swap (nhds (b, a)) :=", "nl_statement_of_codex": "The neighborhood filter of $(a,b)$ is equal to the image of the neighborhood filter of $(b,a)$ under the map $(x,y)\\mapsto (y,x)$."}
{"name": "finsupp.apply_add_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.apply_add_hom_apply {\u03b1 M : Type*} [add_zero_class M] (a : \u03b1)\n\t(g : \u03b1 \u2192\u2080 M) :\n\t\u21d1(finsupp.apply_add_hom a) g = \u21d1g a :=", "nl_statement_of_codex": "Let $g:\\alpha\\to M$ be a finitely supported function. Then the function $f:\\alpha\\to M$ defined by $f(x)=g(x+a)$ is also finitely supported and $\\sum_{x\\in\\alpha}f(x)=\\sum_{x\\in\\alpha}g(x+a)$."}
{"name": "ne.lt_of_le'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/basic.lean", "formal_statement": "theorem ne.lt_of_le' {\u03b1 : Type u} [partial_order \u03b1] {a b : \u03b1} :\n\tb \u2260 a \u2192 a \u2264 b \u2192 a < b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a partially ordered set. If $a\\leq b$ and $a\\neq b$, then $a<b$."}
{"name": "quaternion.mul_im_j", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion.mul_im_j {R : Type*} [comm_ring R] (a b : quaternion R) :\n\t(a * b).im_j = a.re * b.im_j - a.im_i * b.im_k + a.im_j * b.re + a.im_k * b.im_i :=", "nl_statement_of_codex": "The imaginary part of the product of two quaternions is given by the formula $a\\cdot b=a_0b_0-a_1b_1-a_2b_2-a_3b_3+a_1b_2+a_2b_1+a_3b_0+a_0b_3+a_2b_3+a_3b_2+a_1b_0+a_0b_1$."}
{"name": "mul_inv_lt_of_lt_mul\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/with_zero.lean", "formal_statement": "theorem mul_inv_lt_of_lt_mul\u2080 {\u03b1 : Type*} {x y z : \u03b1}\n\t[linear_ordered_comm_group_with_zero \u03b1] (h : x < y * z) :\n\tx * z\u207b\u00b9 < y :=", "nl_statement_of_codex": "Let $x,y,z$ be elements of a linearly ordered commutative group with zero. If $x<yz$, then $xz^{-1}<y$."}
{"name": "list.sublist_append_of_sublist_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.sublist_append_of_sublist_right {\u03b1 : Type u} {l l\u2081 l\u2082 : list \u03b1}\n\t(s : l <+ l\u2082) :\n\tl <+ l\u2081 ++ l\u2082 :=", "nl_statement_of_codex": "If $l$ is a sublist of $l_2$, then $l$ is a sublist of $l_1++l_2$."}
{"name": "submonoid.localization_map.eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.eq {M : Type*} [comm_monoid M]\n\t{S : submonoid M} {N : Type*} [comm_monoid N] (f : S.localization_map N)\n\t{a\u2081 b\u2081 : M} {a\u2082 b\u2082 : \u21a5S} :\n\tf.mk' a\u2081 a\u2082 = f.mk' b\u2081 b\u2082 \u2194 \u2203 (c : \u21a5S), a\u2081 * \u2191b\u2082 * \u2191c = b\u2081 * \u2191a\u2082 * \u2191c :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, and let $f:S\\to N$ be a map of monoids. Then $f(a)=f(b)$ if and only if there is an element $c\\in S$ such that $a\\cdot c=b\\cdot c$."}
{"name": "list.map_coe_fin_range", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/range.lean", "formal_statement": "theorem list.map_coe_fin_range (n : \u2115) :\n\tlist.map coe (list.fin_range n) = list.range n :=", "nl_statement_of_codex": "The list of natural numbers from $0$ to $n-1$ is the same as the list of finite ordinals from $0$ to $n-1$."}
{"name": "matrix.conj_transpose_row", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem matrix.conj_transpose_row {m : Type*} {\u03b1 : Type v} [has_star \u03b1]\n\t(v : m \u2192 \u03b1) :\n\t(matrix.row v).conj_transpose = matrix.col (has_star.star v) :=", "nl_statement_of_codex": "Let $v$ be a row vector. Then the conjugate transpose of $v$ is the column vector obtained by taking the conjugate of each entry of $v$."}
{"name": "real.arcsin_lt_iff_lt_sin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/inverse.lean", "formal_statement": "theorem real.arcsin_lt_iff_lt_sin {x y : \u211d} (hx : x \u2208 set.Icc (-1) 1)\n\t(hy : y \u2208 set.Icc (-(real.pi / 2)) (real.pi / 2)) :\n\treal.arcsin x < y \u2194 x < real.sin y :=", "nl_statement_of_codex": "Let $x, y\\in\\mathbb{R}$ such that $-1\\leq x\\leq 1$ and $-\\pi/2\\leq y\\leq \\pi/2$. Then $\\arcsin(x)<y$ if and only if $x<\\sin(y)$."}
{"name": "mul_action.of_quotient_stabilizer_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/quotient.lean", "formal_statement": "theorem mul_action.of_quotient_stabilizer_smul (\u03b1 : Type u) {\u03b2 : Type v}\n\t[group \u03b1] [mul_action \u03b1 \u03b2] (x : \u03b2) (g : \u03b1) (g' : \u03b1 \u29f8 mul_action.stabilizer \u03b1 x) :\n\tmul_action.of_quotient_stabilizer \u03b1 x (g \u2022 g') = g \u2022 mul_action.of_quotient_stabilizer \u03b1 x g' :=", "nl_statement_of_codex": "Let $G$ be a group acting on a set $X$. Let $x\\in X$ and let $g,g'\\in G$. Then $g\\cdot (g'\\cdot x)=g\\cdot (g\\cdot x)$."}
{"name": "set.not_mem_Ioc_of_gt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.not_mem_Ioc_of_gt {\u03b1 : Type*} [linear_order \u03b1] {a b c : \u03b1}\n\t(hb : b < c) :\n\tc \u2209 set.Ioc a b :=", "nl_statement_of_codex": "Let $a,b,c$ be real numbers such that $b<c$. Then $c$ is not in the interval $(a,b)$."}
{"name": "ideal.map_infi_comap_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.map_infi_comap_of_surjective {R : Type u} {S : Type v} {F : Type*}\n\t[semiring R] [semiring S] [rc : ring_hom_class F R S] (f : F) {\u03b9 : Sort u_3}\n\t(hf : function.surjective \u21d1f) (K : \u03b9 \u2192 ideal S) :\n\tideal.map f (\u2a05 (i : \u03b9), ideal.comap f (K i)) = infi K :=", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings and let $f:R\\to S$ be a surjective ring homomorphism. Then $f$ maps the intersection of the ideals $K_i$ to the intersection of the ideals $f(K_i)$."}
{"name": "nat.digits_def'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/digits.lean", "formal_statement": "theorem nat.digits_def' {b : \u2115} (h : 2 \u2264 b) {n : \u2115} (w : 0 < n) :\n\tb.digits n = n % b :: b.digits (n / b) :=", "nl_statement_of_codex": "Let $b$ be a natural number greater than $2$. Then the digits of $n$ in base $b$ are given by $n\\%b$ followed by the digits of $n/b$."}
{"name": "zero_lt.mul_le_mul_iff_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas_zero_lt.lean", "formal_statement": "theorem zero_lt.mul_le_mul_iff_right {\u03b1 : Type u} {a b c : \u03b1} [has_mul \u03b1]\n\t[has_zero \u03b1] [has_lt \u03b1] [has_le \u03b1] [zero_lt.mul_pos_mono \u03b1]\n\t[zero_lt.mul_pos_mono_rev \u03b1] (a0 : 0 < a) :\n\tb * a \u2264 c * a \u2194 b \u2264 c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a commutative ring with identity. If $a$ is positive, then $b\\leq c$ if and only if $ba\\leq ca$."}
{"name": "category_theory.limits.concrete.to_product_injective_of_is_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/concrete_category.lean", "formal_statement": "theorem category_theory.limits.concrete.to_product_injective_of_is_limit\n\t{C : Type u} [category_theory.category C] [category_theory.concrete_category C]\n\t{J : Type w} [category_theory.small_category J] (F : J \u2964 C)\n\t[category_theory.limits.preserves_limit F (category_theory.forget C)]\n\t{D : category_theory.limits.cone F} (hD : category_theory.limits.is_limit D) :\n\tfunction.injective (\u03bb (x : \u21a5(D.X)) (j : J), \u21d1(D.\u03c0.app j) x) :=", "nl_statement_of_codex": "Let $C$ be a concrete category and let $F:J\\to C$ be a functor. If $F$ has a limit, then the map $D.X\\to \\prod_{j\\in J}F(j)$ is injective."}
{"name": "bilin_form.smul_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/bilinear_form.lean", "formal_statement": "theorem bilin_form.smul_apply {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {\u03b1 : Type*} [monoid \u03b1] [distrib_mul_action \u03b1 R]\n\t[smul_comm_class \u03b1 R R] (a : \u03b1) (B : bilin_form R M) (x y : M) :\n\t\u21d1(a \u2022 B) x y = a \u2022 \u21d1B x y :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $\\alpha$ a monoid. Let $B$ be a bilinear form on $M$. Then for all $a\\in\\alpha$ and $x,y\\in M$, we have $(a\\cdot B)(x,y)=a\\cdot B(x,y)$."}
{"name": "nat.prime.multiplicity_choose_prime_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/multiplicity.lean", "formal_statement": "theorem nat.prime.multiplicity_choose_prime_pow {p n k : \u2115} (hp : nat.prime p)\n\t(hkn : k \u2264 p ^ n) (hk0 : 0 < k) :\n\tmultiplicity p ((p ^ n).choose k) + multiplicity p k = \u2191n :=", "nl_statement_of_codex": "Let $p$ be a prime and let $n, k$ be natural numbers such that $k\\leq p^n$. Then the multiplicity of $p$ in $\\binom{p^n}{k}$ is $n$."}
{"name": "submonoid.localization_map.symm_comp_of_mul_equiv_of_localizations_apply'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.symm_comp_of_mul_equiv_of_localizations_apply'\n\t{M : Type*} [comm_monoid M] {S : submonoid M} {N : Type*} [comm_monoid N]\n\t{P : Type*} [comm_monoid P] (f : S.localization_map N) {k : P \u2243* N} (x : M) :\n\t\u21d1k (\u21d1((f.of_mul_equiv_of_localizations k.symm).to_map) x) = \u21d1(f.to_map) x :=", "nl_statement_of_codex": "Let $M$ and $N$ be commutative monoids, let $S$ be a submonoid of $M$, and let $P$ be a commutative monoid. Let $f:S\\to N$ be a map of monoids. Let $k:P\\to N$ be an isomorphism of monoids. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nS & \\xrightarrow{f} & N \\\\\n\\downarrow & & \\downarrow \\\\\nM & \\xrightarrow{f} & P\n\\end{array}$$"}
{"name": "category_theory.sieve.pullback_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sieves.lean", "formal_statement": "theorem category_theory.sieve.pullback_id {C : Type u\u2081}\n\t[category_theory.category C] {X : C} {S : category_theory.sieve X} :\n\tcategory_theory.sieve.pullback (\ud835\udfd9 X) S = S :=", "nl_statement_of_codex": "The pullback of a sieve $S$ along the identity morphism $X\\to X$ is $S$."}
{"name": "add_subgroup.mem_map_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.mem_map_of_mem {G : Type*} [add_group G] {N : Type*}\n\t[add_group N] (f : G \u2192+ N) {K : add_subgroup G} {x : G} (hx : x \u2208 K) :\n\t\u21d1f x \u2208 add_subgroup.map f K :=", "nl_statement_of_codex": "Let $G$ and $N$ be abelian groups and let $f:G\\to N$ be a group homomorphism. Let $K$ be a subgroup of $G$. Then $f(K)$ is a subgroup of $N$."}
{"name": "has_deriv_at.lhopital_zero_nhds_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/lhopital.lean", "formal_statement": "theorem has_deriv_at.lhopital_zero_nhds_left {a : \u211d} {l : filter \u211d}\n\t{f f' g g' : \u211d \u2192 \u211d}\n\t(hff' : \u2200\u1da0 (x : \u211d) in nhds_within a (set.Iio a), has_deriv_at f (f' x) x)\n\t(hgg' : \u2200\u1da0 (x : \u211d) in nhds_within a (set.Iio a), has_deriv_at g (g' x) x)\n\t(hg' : \u2200\u1da0 (x : \u211d) in nhds_within a (set.Iio a), g' x \u2260 0)\n\t(hfa : filter.tendsto f (nhds_within a (set.Iio a)) (nhds 0))\n\t(hga : filter.tendsto g (nhds_within a (set.Iio a)) (nhds 0))\n\t(hdiv : filter.tendsto (\u03bb (x : \u211d), f' x / g' x) (nhds_within a (set.Iio a)) l) :\n\tfilter.tendsto (\u03bb (x : \u211d), f x / g x) (nhds_within a (set.Iio a)) l :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{R}\\to\\mathbb{R}$ be differentiable functions on $(a,\\infty)$ such that $f(x)\\to 0$ and $g(x)\\to 0$ as $x\\to a^+$. Suppose that $g'(x)\\neq 0$ for all $x\\in (a,\\infty)$. If $\\frac{f'(x)}{g'(x)}\\to l$ as $x\\to a^+$, then $\\frac{f(x)}{g(x)}\\to l$ as $x\\to a^+$."}
{"name": "function.partial_inv_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.partial_inv_left {\u03b1 : Type*} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2}\n\t(I : function.injective f) (x : \u03b1) :\n\tfunction.partial_inv f (f x) = option.some x :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $f$ has a left inverse."}
{"name": "measure_theory.pdf.ae_lt_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/density.lean", "formal_statement": "theorem measure_theory.pdf.ae_lt_top {\u03b1 E : Type*} [measurable_space E]\n\t{m : measurable_space \u03b1} {\u2119 : measure_theory.measure \u03b1}\n\t[measure_theory.is_finite_measure \u00ab\u2119\u00bb] {\u03bc : measure_theory.measure E}\n\t{X : \u03b1 \u2192 E} :\n\t\u2200\u1d50 (x : E) \u2202\u03bc, measure_theory.pdf X \u00ab\u2119\u00bb \u03bc x < \u22a4 :=", "nl_statement_of_codex": "Let $X$ be a random variable with finite measure $\\mathbb{P}$ and probability density function $\\mu$. Then $\\mu(x)<\\infty$ for almost all $x\\in E$."}
{"name": "set.add_mem_centralizer", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/centralizer.lean", "formal_statement": "theorem set.add_mem_centralizer {M : Type*} {S : set M} {a b : M} [distrib M]\n\t(ha : a \u2208 S.centralizer) (hb : b \u2208 S.centralizer) :\n\ta + b \u2208 S.centralizer :=", "nl_statement_of_codex": "Let $M$ be a distributive monoid and let $S$ be a subset of $M$. If $a,b\\in S.centralizer$, then $a+b\\in S.centralizer$."}
{"name": "list.cyclic_permutations_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/rotate.lean", "formal_statement": "theorem list.cyclic_permutations_nil {\u03b1 : Type u} :\n\tlist.nil.cyclic_permutations = [list.nil] :=", "nl_statement_of_codex": "The cyclic permutations of the empty list are the empty list."}
{"name": "category_theory.limits.\u03b9_colimit_limit_to_limit_colimit_\u03c0_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/colimit_limit.lean", "formal_statement": "theorem category_theory.limits.\u03b9_colimit_limit_to_limit_colimit_\u03c0_assoc\n\t{J K : Type v} [category_theory.small_category J]\n\t[category_theory.small_category K] {C : Type u} [category_theory.category C]\n\t(F : J \u00d7 K \u2964 C) [category_theory.limits.has_limits_of_shape J C]\n\t[category_theory.limits.has_colimits_of_shape K C] (j : J) (k : K) {X' : C}\n\t(f' : (category_theory.curry.obj F \u22d9 category_theory.limits.colim).obj j \u27f6 X') :\n\tcategory_theory.limits.colimit.\u03b9 (category_theory.curry.obj (category_theory.prod.swap K J \u22d9 F) \u22d9 category_theory.limits.lim) k \u226b category_theory.limits.colimit_limit_to_limit_colimit F \u226b category_theory.limits.limit.\u03c0 (category_theory.curry.obj F \u22d9 category_theory.limits.colim) j \u226b f' = category_theory.limits.limit.\u03c0 ((category_theory.curry.obj (category_theory.prod.swap K J \u22d9 F)).obj k) j \u226b category_theory.limits.colimit.\u03b9 ((category_theory.curry.obj F).obj j) k \u226b f' :=", "nl_statement_of_codex": "Let $F:J\\times K\\to C$ be a functor. Then the following diagram commutes:\n\\begin{equation*}\n\\begin{tikzcd}\n\\lim_{j\\in J} \\colim_{k\\in K} F(j,k) \\arrow[r, "}
{"name": "nat.mkpair_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/pairing.lean", "formal_statement": "theorem nat.mkpair_equiv_apply :\n\t\u21d1nat.mkpair_equiv = function.uncurry nat.mkpair :=", "nl_statement_of_codex": "The function $\\langle\\cdot,\\cdot\\rangle:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$ is equal to the function $(x,y)\\mapsto x+y^2$."}
{"name": "lie_submodule.subset_lie_span", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/submodule.lean", "formal_statement": "theorem lie_submodule.subset_lie_span {R : Type u} {L : Type v} {M : Type w}\n\t[comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M]\n\t[lie_ring_module L M] [lie_module R L M] {s : set M} :\n\ts \u2286 \u2191(lie_submodule.lie_span R L s) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a $R$-module. Then the set of all Lie submodules of $M$ is a subset of the set of all Lie submodules of $M$."}
{"name": "zmod.int_cast_zmod_cast", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/zmod/basic.lean", "formal_statement": "theorem zmod.int_cast_zmod_cast {n : \u2115} (a : zmod n) :\n\t\u2191\u2191a = a :=", "nl_statement_of_codex": "The map $a\\mapsto \\overline{a}$ is the identity map on $\\mathbb{Z}/n\\mathbb{Z}$."}
{"name": "set.multiset_prod_mem_multiset_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.multiset_prod_mem_multiset_prod {\u03b1 \u03b9 : Type*} [comm_monoid \u03b1]\n\t(t : multiset \u03b9) (f : \u03b9 \u2192 set \u03b1) (g : \u03b9 \u2192 \u03b1)\n\t(hg : \u2200 (i : \u03b9), i \u2208 t \u2192 g i \u2208 f i) :\n\t(multiset.map g t).prod \u2208 (multiset.map f t).prod :=", "nl_statement_of_codex": "Let $t$ be a multiset of elements of a type $\\iota$, let $f:\\iota\\to\\mathcal{P}(A)$ and let $g:\\iota\\to A$ be functions. Suppose that $g(i)\\in f(i)$ for all $i\\in t$. Then $\\prod_{i\\in t}g(i)\\in\\prod_{i\\in t}f(i)$."}
{"name": "simple_graph.walk.support_reverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.support_reverse {V : Type u} {G : simple_graph V}\n\t{u v : V} (p : G.walk u v) :\n\tp.reverse.support = p.support.reverse :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $p$ be a walk in $G$ from $u$ to $v$. Then the support of $p$ is the reverse of the support of $p^{-1}$."}
{"name": "metric.bounded.measure_lt_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem metric.bounded.measure_lt_top {\u03b1 : Type*} {m0 : measurable_space \u03b1}\n\t[pseudo_metric_space \u03b1] [proper_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t[measure_theory.is_finite_measure_on_compacts \u03bc] \u2983s : set \u03b1\u2984\n\t(hs : metric.bounded s) :\n\t\u21d1\u03bc s < \u22a4 :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $\\mu$ be a finite measure on $X$. If $s\\subset X$ is bounded, then $\\mu(s)<\\infty$."}
{"name": "normed_group_hom.comp_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/hom.lean", "formal_statement": "theorem normed_group_hom.comp_apply {V\u2081 V\u2082 V\u2083 : Type*} [semi_normed_group V\u2081]\n\t[semi_normed_group V\u2082] [semi_normed_group V\u2083] (g : normed_group_hom V\u2082 V\u2083)\n\t(f : normed_group_hom V\u2081 V\u2082) (\u1fb0 : V\u2081) :\n\t\u21d1(g.comp f) \u1fb0 = \u21d1g (\u21d1f \u1fb0) :=", "nl_statement_of_codex": "Let $V_1, V_2, V_3$ be semi-normed groups and let $f:V_1\\to V_2$ and $g:V_2\\to V_3$ be normed group homomorphisms. Then $g\\circ f:V_1\\to V_3$ is a normed group homomorphism and $(g\\circ f)(x)=g(f(x))$ for all $x\\in V_1$."}
{"name": "smul_ite", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/defs.lean", "formal_statement": "theorem smul_ite {M \u03b1 : Type*} [has_smul M \u03b1] (p : Prop) [decidable p] (a : M)\n\t(b\u2081 b\u2082 : \u03b1) :\n\ta \u2022 ite p b\u2081 b\u2082 = ite p (a \u2022 b\u2081) (a \u2022 b\u2082) :=", "nl_statement_of_codex": "Let $M$ be a monoid and let $a\\in M$. Then $a\\cdot \\mathrm{ite}(p,b_1,b_2)=\\mathrm{ite}(p,a\\cdot b_1,a\\cdot b_2)$."}
{"name": "category_theory.comonad.id_\u03b5", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/basic.lean", "formal_statement": "theorem category_theory.comonad.id_\u03b5 (C : Type u\u2081) [category_theory.category C] :\n\t(category_theory.comonad.id C).\u03b5 = \ud835\udfd9 (\ud835\udfed C) :=", "nl_statement_of_codex": "The counit of the identity comonad on a category $C$ is the identity morphism."}
{"name": "turing.partrec_to_TM2.code_supp_tail", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/tm_to_partrec.lean", "formal_statement": "theorem turing.partrec_to_TM2.code_supp_tail (k : turing.partrec_to_TM2.cont') :\n\tturing.partrec_to_TM2.code_supp turing.to_partrec.code.tail k = turing.partrec_to_TM2.tr_stmts\u2081 (turing.partrec_to_TM2.tr_normal turing.to_partrec.code.tail k) \u222a turing.partrec_to_TM2.cont_supp k :=", "nl_statement_of_codex": "Let $k$ be a Turing machine. Then the support of the code of the tail of $k$ is equal to the union of the support of the code of the tail of $k$ and the support of $k$."}
{"name": "minpoly.subsingleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/minpoly.lean", "formal_statement": "theorem minpoly.subsingleton (A : Type*) {B : Type*} [comm_ring A] [ring B]\n\t[algebra A B] (x : B) [subsingleton B] :\n\tminpoly A x = 1 :=", "nl_statement_of_codex": "Let $A$ be a commutative ring, $B$ a ring, and $x\\in B$. If $B$ is a singleton, then the minimal polynomial of $x$ over $A$ is $1$."}
{"name": "monoid_hom.coprod_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/prod.lean", "formal_statement": "theorem monoid_hom.coprod_unique {M N P : Type*} [mul_one_class M]\n\t[mul_one_class N] [comm_monoid P] (f : M \u00d7 N \u2192* P) :\n\t(f.comp (monoid_hom.inl M N)).coprod (f.comp (monoid_hom.inr M N)) = f :=", "nl_statement_of_codex": "Let $M, N, P$ be monoids. Let $f:M\\times N\\to P$ be a monoid homomorphism. Then $f$ is the coproduct of the monoid homomorphisms $f_1:M\\to P$ and $f_2:N\\to P$ defined by $f_1(m)=f(m,1)$ and $f_2(n)=f(1,n)$."}
{"name": "list.indexes_values_eq_filter_enum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/indexes.lean", "formal_statement": "theorem list.indexes_values_eq_filter_enum {\u03b1 : Type u} (p : \u03b1 \u2192 Prop)\n\t[decidable_pred p] (as : list \u03b1) :\n\tlist.indexes_values p as = list.filter (p \u2218 prod.snd) as.enum :=", "nl_statement_of_codex": "Let $p$ be a predicate on a type $\u03b1$. Let $as$ be a list of elements of $\u03b1$. Then the list of indexes of elements of $as$ satisfying $p$ is equal to the list of elements of $as$ satisfying $p$."}
{"name": "is_group_hom.injective_iff_trivial_ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_group_hom.injective_iff_trivial_ker {G H : Type*} [group G] [group H]\n\t{f : G \u2192 H} (hf : is_group_hom f) :\n\tfunction.injective f \u2194 is_group_hom.ker f = is_subgroup.trivial G :=", "nl_statement_of_codex": "Let $G$ and $H$ be groups and let $f:G\\to H$ be a group homomorphism. Then $f$ is injective if and only if $\\ker f$ is the trivial subgroup of $G$."}
{"name": "option.eq_some_iff_get_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/option/basic.lean", "formal_statement": "theorem option.eq_some_iff_get_eq {\u03b1 : Type*} {o : option \u03b1} {a : \u03b1} :\n\to = option.some a \u2194 \u2203 (h : \u21a5(o.is_some)), option.get h = a :=", "nl_statement_of_codex": "Let $o$ be an option of type $\\alpha$. Then $o=\\mathrm{some}(a)$ if and only if there is a proof that $o$ is some and the value of $o$ is $a$."}
{"name": "computable.pred", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/partrec.lean", "formal_statement": "theorem computable.pred :\n\tcomputable nat.pred :=", "nl_statement_of_codex": "The predecessor function is computable."}
{"name": "set.indicator_smul_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/indicator_function.lean", "formal_statement": "theorem set.indicator_smul_apply {\u03b1 M A : Type*} [add_monoid A] [monoid M]\n\t[distrib_mul_action M A] (s : set \u03b1) (r : \u03b1 \u2192 M) (f : \u03b1 \u2192 A) (x : \u03b1) :\n\ts.indicator (\u03bb (x : \u03b1), r x \u2022 f x) x = r x \u2022 s.indicator f x :=", "nl_statement_of_codex": "Let $M$ be a monoid, $A$ be an abelian monoid, and $M$ act on $A$ by monoid homomorphisms. Let $s$ be a subset of $\u03b1$, $r$ be a function from $\u03b1$ to $M$, and $f$ be a function from $\u03b1$ to $A$. Then the indicator function of $s$ applied to the function $x\\mapsto r(x)f(x)$ is equal to the product of the indicator function of $s$ applied to $f$ and $r$."}
{"name": "frontier_closed_ball'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/basic.lean", "formal_statement": "theorem frontier_closed_ball' {E : Type*} [normed_group E] [normed_space \u211d E]\n\t[nontrivial E] (x : E) (r : \u211d) :\n\tfrontier (metric.closed_ball x r) = metric.sphere x r :=", "nl_statement_of_codex": "The boundary of the closed ball of radius $r$ centered at $x$ is the sphere of radius $r$ centered at $x$."}
{"name": "hahn_series.of_power_series_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/hahn_series.lean", "formal_statement": "theorem hahn_series.of_power_series_injective {\u0393 R : Type*} [semiring R]\n\t[ordered_semiring \u0393] [nontrivial \u0393] :\n\tfunction.injective \u21d1(hahn_series.of_power_series \u0393 R) :=", "nl_statement_of_codex": "The map from power series to Hahn series is injective."}
{"name": "primrec\u2082.left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/primrec.lean", "formal_statement": "theorem primrec\u2082.left {\u03b1 \u03b2 : Type*} [primcodable \u03b1] [primcodable \u03b2] :\n\tprimrec\u2082 (\u03bb (a : \u03b1) (b : \u03b2), a) :=", "nl_statement_of_codex": "The function $f:\\alpha\\times\\beta\\to\\alpha$ defined by $f(a,b)=a$ is primitive recursive."}
{"name": "multiset.filter_union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.filter_union {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t[decidable_eq \u03b1] (s t : multiset \u03b1) :\n\tmultiset.filter p (s \u222a t) = multiset.filter p s \u222a multiset.filter p t :=", "nl_statement_of_codex": "Let $p$ be a predicate on a type $\u03b1$ and let $s$ and $t$ be multisets of $\u03b1$. Then the multiset of elements of $s$ and $t$ that satisfy $p$ is the union of the multisets of elements of $s$ and $t$ that satisfy $p$."}
{"name": "nat.prime.dvd_choose_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/choose/dvd.lean", "formal_statement": "theorem nat.prime.dvd_choose_add {p a b : \u2115} (hap : a < p) (hbp : b < p)\n\t(h : p \u2264 a + b) (hp : nat.prime p) :\n\tp \u2223 (a + b).choose a :=", "nl_statement_of_codex": "Let $p$ be a prime number and let $a,b$ be natural numbers such that $a<p$ and $b<p$. If $p\\leq a+b$, then $p$ divides $\\binom{a+b}{a}$."}
{"name": "set.mul_indicator_apply_ne_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/indicator_function.lean", "formal_statement": "theorem set.mul_indicator_apply_ne_one {\u03b1 M : Type*} [has_one M] {s : set \u03b1}\n\t{f : \u03b1 \u2192 M} {a : \u03b1} :\n\ts.mul_indicator f a \u2260 1 \u2194 a \u2208 s \u2229 function.mul_support f :=", "nl_statement_of_codex": "Let $M$ be a monoid with identity $1$. Let $s$ be a set and let $f:s\\to M$. Then $s.mul_indicator f(a)\\neq 1$ if and only if $a\\in s\\cap supp(f)$."}
{"name": "int_smul_eq_zsmul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/basic.lean", "formal_statement": "theorem int_smul_eq_zsmul {M : Type*} [add_comm_group M] (h : module \u2124 M)\n\t(n : \u2124) (x : M) :\n\tn \u2022 x = n \u2022 x :=", "nl_statement_of_codex": "Let $M$ be an abelian group and let $n$ be an integer. Then $n\\cdot x=n\\cdot x$."}
{"name": "truncated_witt_vector.ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/truncated.lean", "formal_statement": "theorem truncated_witt_vector.ext_iff {p n : \u2115} {R : Type*}\n\t{x y : truncated_witt_vector p n R} :\n\tx = y \u2194 \u2200 (i : fin n), truncated_witt_vector.coeff i x = truncated_witt_vector.coeff i y :=", "nl_statement_of_codex": "Two truncated Witt vectors $x, y$ are equal if and only if their coefficients are equal."}
{"name": "fderiv_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem fderiv_snd {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {p : E \u00d7 F} :\n\tfderiv \ud835\udd5c prod.snd p = continuous_linear_map.snd \ud835\udd5c E F :=", "nl_statement_of_codex": "The derivative of the projection map $p\\mapsto p_2$ is the linear map $p\\mapsto p_2$."}
{"name": "order_hom.gfp_induction", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/fixed_points.lean", "formal_statement": "theorem order_hom.gfp_induction {\u03b1 : Type u} [complete_lattice \u03b1] (f : \u03b1 \u2192o \u03b1)\n\t{p : \u03b1 \u2192 Prop} (step : \u2200 (a : \u03b1), p a \u2192 \u21d1order_hom.gfp f \u2264 a \u2192 p (\u21d1f a))\n\t(hInf : \u2200 (s : set \u03b1), (\u2200 (a : \u03b1), a \u2208 s \u2192 p a) \u2192 p (has_Inf.Inf s)) :\n\tp (\u21d1order_hom.gfp f) :=", "nl_statement_of_codex": "Let $f:A\\to A$ be a monotone function on a complete lattice $A$. Suppose that $p$ is a property of elements of $A$ such that $p(a)$ implies $p(f(a))$ for all $a\\in A$ and that $p(a)$ holds for all $a\\in A$ such that $a\\leq \\inf_{a\\in A}f(a)$. Then $p(\\inf_{a\\in A}f(a))$ holds."}
{"name": "measure_theory.is_stopping_time.measurable_set_inter_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/stopping.lean", "formal_statement": "theorem measure_theory.is_stopping_time.measurable_set_inter_le_iff\n\t{\u03b1 \u03b9 : Type*} {m : measurable_space \u03b1} [linear_order \u03b9]\n\t{f : measure_theory.filtration \u03b9 m} {\u03c4 \u03c0 : \u03b1 \u2192 \u03b9} [topological_space \u03b9]\n\t[topological_space.second_countable_topology \u03b9] [order_topology \u03b9]\n\t[measurable_space \u03b9] [borel_space \u03b9] (h\u03c4 : measure_theory.is_stopping_time f \u03c4)\n\t(h\u03c0 : measure_theory.is_stopping_time f \u03c0) (s : set \u03b1) :\n\tmeasurable_set (s \u2229 {x : \u03b1 | \u03c4 x \u2264 \u03c0 x}) \u2194 measurable_set (s \u2229 {x : \u03b1 | \u03c4 x \u2264 \u03c0 x}) :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\tau,\\pi:X\\to\\mathbb{R}$ be stopping times. Then the set $\\{x\\in X\\mid \\tau(x)\\leq\\pi(x)\\}$ is measurable."}
{"name": "set.nonempty_Ioi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.nonempty_Ioi {\u03b1 : Type*} [preorder \u03b1] {a : \u03b1} [no_max_order \u03b1] :\n\t(set.Ioi a).nonempty :=", "nl_statement_of_codex": "The set $\\{x\\in\\alpha\\mid x<a\\}$ is nonempty."}
{"name": "free_monoid.map_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/free_monoid.lean", "formal_statement": "theorem free_monoid.map_comp {\u03b1 \u03b2 \u03b3 : Type*} (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) :\n\tfree_monoid.map (g \u2218 f) = (free_monoid.map g).comp (free_monoid.map f) :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be functions. Then the map $g\\circ f:A\\to C$ is equal to the composition of the maps $g:B^*\\to C^*$ and $f:A^*\\to B^*$."}
{"name": "subring.subset_pointwise_smul_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/pointwise.lean", "formal_statement": "theorem subring.subset_pointwise_smul_iff {M R : Type*} [group M] [ring R]\n\t[mul_semiring_action M R] {a : M} {S T : subring R} :\n\tS \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T :=", "nl_statement_of_codex": "Let $M$ be a group, $R$ be a ring, and $M$ act on $R$ by ring automorphisms. Let $S$ and $T$ be subrings of $R$. Then $S\\leq a\\cdot T$ if and only if $a^{-1}\\cdot S\\leq T$."}
{"name": "list.filter_append", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/list/lemmas.lean", "formal_statement": "theorem list.filter_append {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} [h : decidable_pred p]\n\t(l\u2081 l\u2082 : list \u03b1) :\n\tlist.filter p (l\u2081 ++ l\u2082) = list.filter p l\u2081 ++ list.filter p l\u2082 :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a type $\u03b1$. Then the filter of $p$ on the concatenation of two lists $l_1$ and $l_2$ is the concatenation of the filters of $p$ on $l_1$ and $l_2$."}
{"name": "option.orelse_eq_none'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/option/basic.lean", "formal_statement": "theorem option.orelse_eq_none' {\u03b1 : Type*} (o o' : option \u03b1) :\n\to.orelse o' = option.none \u2194 o = option.none \u2227 o' = option.none :=", "nl_statement_of_codex": "Let $o, o'$ be options. Then $o\\vee o'=\\bot$ if and only if $o=\\bot$ and $o'=\\bot$."}
{"name": "mul_hom.mul_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem mul_hom.mul_apply {M N : Type*} {mM : has_mul M} {mN : comm_semigroup N}\n\t(f g : M \u2192\u2099* N) (x : M) :\n\t\u21d1(f * g) x = \u21d1f x * \u21d1g x :=", "nl_statement_of_codex": "Let $M$ and $N$ be types with multiplication. Let $f,g:M\\to N$ be multiplicative functions. Then $(f\\cdot g)(x)=f(x)\\cdot g(x)$."}
{"name": "cont_diff_within_at_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff_within_at_id {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {n : with_top \u2115} {s : set E}\n\t{x : E} :\n\tcont_diff_within_at \ud835\udd5c n id s x :=", "nl_statement_of_codex": "The identity function is continuously differentiable on any set."}
{"name": "category_theory.limits.biproduct.lift_desc_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.biproduct.lift_desc_assoc {C : Type u}\n\t[category_theory.category C] [category_theory.preadditive C] {J : Type}\n\t[fintype J] {f : J \u2192 C} [category_theory.limits.has_biproduct f] {T U : C}\n\t{g : \u03a0 (j : J), T \u27f6 f j} {h : \u03a0 (j : J), f j \u27f6 U} {X' : C} (f' : U \u27f6 X') :\n\tcategory_theory.limits.biproduct.lift g \u226b category_theory.limits.biproduct.desc h \u226b f' = finset.univ.sum (\u03bb (j : J), g j \u226b h j) \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category with finite products and coproducts. Let $f:J\\to C$ be a functor. Let $T, U, X'$ be objects of $C$ and let $g:T\\to f(j)$ and $h:f(j)\\to U$ be morphisms. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\nT \\arrow[r, "}
{"name": "gaussian_int.to_complex_div_re", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/gaussian_int.lean", "formal_statement": "theorem gaussian_int.to_complex_div_re (x y : gaussian_int) :\n\t\u2191(x / y).re = \u2191(round (\u2191x / \u2191y).re) :=", "nl_statement_of_codex": "The real part of the quotient of two Gaussian integers is equal to the rounded real part of the quotient of the corresponding complex numbers."}
{"name": "cardinal.is_strong_limit_aleph_0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/cofinality.lean", "formal_statement": "theorem cardinal.is_strong_limit_aleph_0 :\n\tcardinal.aleph_0.is_strong_limit :=", "nl_statement_of_codex": "$\\aleph_0$ is a strong limit cardinal."}
{"name": "comap_norm_nhds_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem comap_norm_nhds_zero {E : Type*} [semi_normed_group E] :\n\tfilter.comap has_norm.norm (nhds 0) = nhds 0 :=", "nl_statement_of_codex": "The filter of neighborhoods of $0$ in a semi-normed group is equal to the filter of neighborhoods of $0$ in the normed group obtained by taking the norm."}
{"name": "mv_polynomial.fin_succ_equiv_coeff_coeff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/equiv.lean", "formal_statement": "theorem mv_polynomial.fin_succ_equiv_coeff_coeff {R : Type u} [comm_semiring R]\n\t{n : \u2115} (m : fin n \u2192\u2080 \u2115) (f : mv_polynomial (fin (n + 1)) R) (i : \u2115) :\n\tmv_polynomial.coeff m ((\u21d1(mv_polynomial.fin_succ_equiv R n) f).coeff i) = mv_polynomial.coeff (finsupp.cons i m) f :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $n$ a natural number, $m$ a finite support function from $\\{0,\\ldots,n-1\\}$ to $\\mathbb{N}$, $f$ a multivariate polynomial over $R$ in $n+1$ variables, and $i$ a natural number. Then the coefficient of $x_i$ in the polynomial $(\\mathrm{fin\\_succ\\_equiv} R n)f$ is equal to the coefficient of $x_0^{m(0)}\\cdots x_{n-1}^{m(n-1)}$ in $f$."}
{"name": "finset.coe_union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.coe_union {\u03b1 : Type*} [decidable_eq \u03b1] (s\u2081 s\u2082 : finset \u03b1) :\n\t\u2191(s\u2081 \u222a s\u2082) = \u2191s\u2081 \u222a \u2191s\u2082 :=", "nl_statement_of_codex": "The union of two finite sets is the union of their underlying sets."}
{"name": "algebra.bit0_smul_bit0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem algebra.bit0_smul_bit0 {R : Type u} {A : Type w} [comm_semiring R]\n\t[semiring A] [algebra R A] {r : R} {a : A} :\n\tbit0 r \u2022 bit0 a = r \u2022 bit0 (bit0 a) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ be a semiring, and $R$ be an algebra over $A$. Then $2r\\cdot 2a=r\\cdot 2(2a)$."}
{"name": "summable_star_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean", "formal_statement": "theorem summable_star_iff {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1]\n\t[topological_space \u03b1] {f : \u03b2 \u2192 \u03b1} [star_add_monoid \u03b1] [has_continuous_star \u03b1] :\n\tsummable (\u03bb (b : \u03b2), has_star.star (f b)) \u2194 summable f :=", "nl_statement_of_codex": "Let $f:\\beta\\to\\alpha$ be a function. Then $f$ is summable if and only if $f^*$ is summable."}
{"name": "finset.Ioo_eq_empty_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/locally_finite.lean", "formal_statement": "theorem finset.Ioo_eq_empty_iff {\u03b1 : Type*} [preorder \u03b1]\n\t[locally_finite_order \u03b1] {a b : \u03b1} [densely_ordered \u03b1] :\n\tfinset.Ioo a b = \u2205 \u2194 \u00aca < b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a densely ordered set. Then the interval $(a,b)$ is empty if and only if $a\\geq b$."}
{"name": "dfinsupp.comap_domain_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.comap_domain_add {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v}\n\t[dec : decidable_eq \u03b9] {\u03ba : Type*} [\u03a0 (i : \u03b9), add_zero_class (\u03b2 i)]\n\t(h : \u03ba \u2192 \u03b9) (hh : function.injective h) (f g : \u03a0\u2080 (i : \u03b9), \u03b2 i) :\n\tdfinsupp.comap_domain h hh (f + g) = dfinsupp.comap_domain h hh f + dfinsupp.comap_domain h hh g :=", "nl_statement_of_codex": "Let $h: \\kappa \\to \\iota$ be an injective function. Then the map $f\\mapsto f\\circ h$ is a homomorphism of additive groups from the set of functions $\\iota\\to \\beta$ to the set of functions $\\kappa\\to \\beta$."}
{"name": "add_cancel_comm_monoid.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/ext.lean", "formal_statement": "theorem add_cancel_comm_monoid.ext {M : Type*}\n\t\u2983m\u2081 m\u2082 : add_cancel_comm_monoid M\u2984\n\t(h_mul : add_cancel_comm_monoid.add = add_cancel_comm_monoid.add) :\n\tm\u2081 = m\u2082 :=", "nl_statement_of_codex": "Let $M$ be an additive commutative monoid. Then two structures $m_1, m_2$ on $M$ are equal if and only if the addition operations are equal."}
{"name": "linear_map.lsum_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/pi.lean", "formal_statement": "theorem linear_map.lsum_symm_apply (R : Type u) {M : Type v} {\u03b9 : Type x}\n\t[semiring R] (\u03c6 : \u03b9 \u2192 Type i) [\u03a0 (i : \u03b9), add_comm_monoid (\u03c6 i)]\n\t[\u03a0 (i : \u03b9), module R (\u03c6 i)] (S : Type*) [add_comm_monoid M] [module R M]\n\t[fintype \u03b9] [decidable_eq \u03b9] [semiring S] [module S M] [smul_comm_class R S M]\n\t(f : (\u03a0 (i : \u03b9), \u03c6 i) \u2192\u2097[R] M) (i : \u03b9) :\n\t\u21d1((linear_map.lsum R \u03c6 S).symm) f i = f.comp (linear_map.single i) :=", "nl_statement_of_codex": "Let $R$ be a semiring, let $M$ be an $R$-module, let $\\phi$ be a family of $R$-modules, let $S$ be a semiring, let $f:\\prod_{i\\in I}\\phi_i\\to M$ be a linear map, and let $i\\in I$. Then the $i$-th component of the linear map $f\\circ\\prod_{i\\in I}\\phi_i\\to M$ is equal to $f\\circ\\phi_i$."}
{"name": "measure_theory.measure.finite_spanning_sets_in.disjointed_set_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.finite_spanning_sets_in.disjointed_set_eq\n\t{\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t(S : \u03bc.finite_spanning_sets_in {s : set \u03b1 | measurable_set s}) :\n\tS.disjointed.set = disjointed S.set :=", "nl_statement_of_codex": "Let $S$ be a finite spanning set of measurable sets. Then the disjoint union of the sets in $S$ is equal to the disjoint union of the sets in $S$."}
{"name": "mv_polynomial.support_monomial_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.support_monomial_subset {R : Type u} {\u03c3 : Type*} {a : R}\n\t{s : \u03c3 \u2192\u2080 \u2115} [comm_semiring R] :\n\t(\u21d1(mv_polynomial.monomial s) a).support \u2286 {s} :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $a\\in R$, and let $s$ be a monomial. Then the support of $a\\cdot s$ is $\\{s\\}$."}
{"name": "set.disjoint_Union\u2082_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.disjoint_Union\u2082_right {\u03b1 : Type*} {\u03b9 : Sort u_4} {\u03ba : \u03b9 \u2192 Sort u_7}\n\t{s : set \u03b1} {t : \u03a0 (i : \u03b9), \u03ba i \u2192 set \u03b1} :\n\tdisjoint s (\u22c3 (i : \u03b9) (j : \u03ba i), t i j) \u2194 \u2200 (i : \u03b9) (j : \u03ba i), disjoint s (t i j) :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $s$ and $\\bigcup_{i,j} t_{ij}$ are disjoint if and only if $s$ and $t_{ij}$ are disjoint for all $i,j$."}
{"name": "real.cont_diff_sin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem real.cont_diff_sin {n : with_top \u2115} :\n\tcont_diff \u211d n real.sin :=", "nl_statement_of_codex": "The $n$-th derivative of the sine function is continuous."}
{"name": "finset.subtype_Ico_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/locally_finite.lean", "formal_statement": "theorem finset.subtype_Ico_eq {\u03b1 : Type*} [preorder \u03b1] (p : \u03b1 \u2192 Prop)\n\t[decidable_pred p] [locally_finite_order \u03b1] (a b : subtype p) :\n\tfinset.Ico a b = finset.subtype p (finset.Ico \u2191a \u2191b) :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a preorder $\u03b1$. Let $a,b$ be elements of the subtype $p$. Then the interval $[a,b]$ is equal to the subtype of $p$ of the interval $[a,b]$."}
{"name": "finset.nat.sigma_antidiagonal_equiv_prod_symm_apply_fst", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/nat_antidiagonal.lean", "formal_statement": "theorem finset.nat.sigma_antidiagonal_equiv_prod_symm_apply_fst (x : \u2115 \u00d7 \u2115) :\n\t(\u21d1(finset.nat.sigma_antidiagonal_equiv_prod.symm) x).fst = x.fst + x.snd :=", "nl_statement_of_codex": "Let $x=(i,j)\\in\\mathbb{N}\\times\\mathbb{N}$. Then the first coordinate of the image of $x$ under the inverse of the bijection $\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$ given by $(i,j)\\mapsto i+j$ is $i+j$."}
{"name": "finprod_cond_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finprod_cond_nonneg {\u03b1 R : Type*} [ordered_comm_semiring R]\n\t{p : \u03b1 \u2192 Prop} {f : \u03b1 \u2192 R} (hf : \u2200 (x : \u03b1), p x \u2192 0 \u2264 f x) :\n\t0 \u2264 finprod (\u03bb (x : \u03b1), finprod (\u03bb (h : p x), f x)) :=", "nl_statement_of_codex": "Let $R$ be an ordered commutative semiring and let $f:A\\to R$ be a function. If $f(x)\\geq 0$ for all $x\\in A$, then $\\prod_{x\\in A}f(x)\\geq 0$."}
{"name": "finprod_dmem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finprod_dmem {\u03b1 M : Type*} [comm_monoid M] {s : set \u03b1}\n\t[decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)] (f : \u03a0 (a : \u03b1), a \u2208 s \u2192 M) :\n\tfinprod (\u03bb (a : \u03b1), finprod (\u03bb (h : a \u2208 s), f a h)) = finprod (\u03bb (a : \u03b1), finprod (\u03bb (h : a \u2208 s), dite (a \u2208 s) (\u03bb (h' : a \u2208 s), f a h') (\u03bb (h' : a \u2209 s), 1))) :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid. Let $s$ be a set and let $f:s\\to M$. Then $\\prod_{a\\in s}f(a)=\\prod_{a\\in s}f(a)$."}
{"name": "category_theory.monoidal_category.left_unitor_tensor_inv_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/coherence_lemmas.lean", "formal_statement": "theorem category_theory.monoidal_category.left_unitor_tensor_inv_assoc\n\t{C : Type*} [category_theory.category C] [category_theory.monoidal_category C]\n\t(X Y : C) {X' : C} (f' : \ud835\udfd9_ C \u2297 X \u2297 Y \u27f6 X') :\n\t(\u03bb_ (X \u2297 Y)).inv \u226b f' = ((\u03bb_ X).inv \u2297 \ud835\udfd9 Y) \u226b (\u03b1_ (\ud835\udfd9_ C) X Y).hom \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X, Y, X'$ be objects of $C$ and let $f':(I\\otimes X\\otimes Y)\\to X'$ be a morphism. Then $(\\lambda_{X\\otimes Y})^{-1}\\circ f'=(\\lambda_X^{-1}\\otimes I_Y)\\circ \\alpha_{I,X,Y}\\circ f'$."}
{"name": "smooth_bump_covering.comp_embedding_pi_tangent_mfderiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/whitney_embedding.lean", "formal_statement": "theorem smooth_bump_covering.comp_embedding_pi_tangent_mfderiv {\u03b9 : Type u\u03b9}\n\t{E : Type uE} [normed_group E] [normed_space \u211d E] [finite_dimensional \u211d E]\n\t{H : Type uH} [topological_space H] {I : model_with_corners \u211d E H}\n\t{M : Type uM} [topological_space M] [charted_space H M]\n\t[smooth_manifold_with_corners I M] [t2_space M] [fintype \u03b9] {s : set M}\n\t(f : smooth_bump_covering \u03b9 I M s) (x : M) (hx : x \u2208 s) :\n\t((continuous_linear_map.fst \u211d E \u211d).comp (continuous_linear_map.proj (f.ind x hx))).comp (mfderiv I (model_with_corners_self \u211d (\u03b9 \u2192 E \u00d7 \u211d)) \u21d1(f.embedding_pi_tangent) x) = mfderiv I I \u21d1(charted_space.chart_at H (f.c (f.ind x hx))) x :=", "nl_statement_of_codex": "Let $M$ be a smooth manifold with corners, let $s$ be a subset of $M$, and let $f$ be a smooth bump covering of $s$. Let $x$ be a point in $s$. Then the derivative of the map $f$ at $x$ is equal to the derivative of the chart map at $x$."}
{"name": "continuous_linear_map.norm_id_of_nontrivial_seminorm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.norm_id_of_nontrivial_seminorm {\ud835\udd5c E : Type*}\n\t[semi_normed_group E] [nondiscrete_normed_field \ud835\udd5c] [normed_space \ud835\udd5c E]\n\t(h : \u2203 (x : E), \u2225x\u2225 \u2260 0) :\n\t\u2225continuous_linear_map.id \ud835\udd5c E\u2225 = 1 :=", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$. If $E$ is nontrivial, then the norm of the identity map on $E$ is $1$."}
{"name": "asymptotics.is_equivalent.is_O_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotic_equivalent.lean", "formal_statement": "theorem asymptotics.is_equivalent.is_O_symm {\u03b1 \u03b2 : Type*} [normed_group \u03b2]\n\t{u v : \u03b1 \u2192 \u03b2} {l : filter \u03b1} (h : asymptotics.is_equivalent l u v) :\n\tv =O[l] u :=", "nl_statement_of_codex": "Let $u,v:\\alpha\\to\\beta$ be functions. If $u$ is asymptotically equivalent to $v$, then $v$ is asymptotically equivalent to $u$."}
{"name": "list.one_le_prod_of_one_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/big_operators.lean", "formal_statement": "theorem list.one_le_prod_of_one_le {M : Type*} [monoid M] [preorder M]\n\t[covariant_class M M has_mul.mul has_le.le] {l : list M}\n\t(hl\u2081 : \u2200 (x : M), x \u2208 l \u2192 1 \u2264 x) :\n\t1 \u2264 l.prod :=", "nl_statement_of_codex": "Let $M$ be a monoid with a preorder. Let $l$ be a list of elements of $M$. If $1\\leq x$ for all $x\\in l$, then $1\\leq \\prod_{x\\in l} x$."}
{"name": "list.partition_eq_filter_filter", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/list/lemmas.lean", "formal_statement": "theorem list.partition_eq_filter_filter {\u03b1 : Type u} (p : \u03b1 \u2192 Prop)\n\t[decidable_pred p] (l : list \u03b1) :\n\tlist.partition p l = (list.filter p l, list.filter (not \u2218 p) l) :=", "nl_statement_of_codex": "The partition of a list $l$ with respect to a predicate $p$ is equal to the pair of lists consisting of the elements of $l$ satisfying $p$ and the elements of $l$ not satisfying $p$."}
{"name": "has_dvd.dvd.mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/divisibility.lean", "formal_statement": "theorem has_dvd.dvd.mul_left {\u03b1 : Type*} [comm_semigroup \u03b1] {a b : \u03b1}\n\t(h : a \u2223 b) ( : \u03b1) :\n\ta \u2223 c * b :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a commutative semigroup. If $a$ divides $b$, then $a$ divides $c\\cdot b$."}
{"name": "finset.mk_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.mk_zero {\u03b1 : Type*} :\n\t{val := 0, nodup := _} = \u2205 :=", "nl_statement_of_codex": "The finite set $\\{0\\}$ is empty."}
{"name": "le_nhds_Lim", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem le_nhds_Lim {\u03b1 : Type u} [topological_space \u03b1] {f : filter \u03b1}\n\t(h : \u2203 (a : \u03b1), f \u2264 nhds a) :\n\tf \u2264 nhds (Lim f) :=", "nl_statement_of_codex": "Let $f$ be a filter on a topological space $X$. If $f$ converges to some point $a\\in X$, then $f$ converges to the limit of $f$."}
{"name": "filter.coclosed_compact_eq_cocompact", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/separation.lean", "formal_statement": "theorem filter.coclosed_compact_eq_cocompact {\u03b1 : Type u} [topological_space \u03b1]\n\t[t2_space \u03b1] :\n\tfilter.coclosed_compact \u03b1 = filter.cocompact \u03b1 :=", "nl_statement_of_codex": "In a Hausdorff space, the compact sets are the same as the cocompact sets."}
{"name": "measure_theory.measure_add_right_null", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/prod.lean", "formal_statement": "theorem measure_theory.measure_add_right_null {G : Type*} [measurable_space G]\n\t[add_group G] [has_measurable_add\u2082 G] (\u03bc : measure_theory.measure G)\n\t[measure_theory.sigma_finite \u03bc] {E : set G} [has_measurable_neg G]\n\t[\u03bc.is_add_left_invariant] (y : G) :\n\t\u21d1\u03bc ((\u03bb (x : G), x + y) \u207b\u00b9' E) = 0 \u2194 \u21d1\u03bc E = 0 :=", "nl_statement_of_codex": "Let $G$ be a measurable space with a $\\sigma$-finite measure $\\mu$. Let $E$ be a measurable subset of $G$. Then $\\mu(E+y)=0$ if and only if $\\mu(E)=0$."}
{"name": "zmod.pow_totient", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/finite/basic.lean", "formal_statement": "theorem zmod.pow_totient {n : \u2115} [fact (0 < n)] (x : (zmod n)\u02e3) :\n\tx ^ n.totient = 1 :=", "nl_statement_of_codex": "Let $n$ be a positive integer. Then $x^{\\varphi(n)}=1$ for all $x\\in(\\mathbb{Z}/n\\mathbb{Z})^*$."}
{"name": "continuous_of_linear_of_bound\u209b\u2097", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_of_linear_of_bound\u209b\u2097 {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [semi_normed_group E]\n\t[semi_normed_group F] [normed_field \ud835\udd5c] [normed_field \ud835\udd5c\u2082] [normed_space \ud835\udd5c E]\n\t[normed_space \ud835\udd5c\u2082 F] {\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} {f : E \u2192 F}\n\t(h_add : \u2200 (x y : E), f (x + y) = f x + f y)\n\t(h_smul : \u2200 (c : \ud835\udd5c) (x : E), f (c \u2022 x) = \u21d1\u03c3 c \u2022 f x) {C : \u211d}\n\t(h_bound : \u2200 (x : E), \u2225f x\u2225 \u2264 C * \u2225x\u2225) :\n\tcontinuous f :=", "nl_statement_of_codex": "Let $E$ and $F$ be semi-normed groups, let $\\sigma: \\mathbb{K}\\to \\mathbb{K}'$ be a field homomorphism, and let $f:E\\to F$ be a linear map. If $f$ is bounded, then $f$ is continuous."}
{"name": "int.neg_succ_of_nat_inj_iff", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/basic.lean", "formal_statement": "theorem int.neg_succ_of_nat_inj_iff {m n : \u2115} :\n\t-[1+ m] = -[1+ n] \u2194 m = n :=", "nl_statement_of_codex": "$-1-m=-1-n$ if and only if $m=n$."}
{"name": "clifford_algebra.foldl_prod_map_\u03b9", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/clifford_algebra/fold.lean", "formal_statement": "theorem clifford_algebra.foldl_prod_map_\u03b9 {R M N : Type*} [comm_ring R]\n\t[add_comm_group M] [add_comm_group N] [module R M] [module R N]\n\t(Q : quadratic_form R M) (l : list M) (f : M \u2192\u2097[R] N \u2192\u2097[R] N)\n\t(hf : \u2200 (m : M) (x : N), \u21d1(\u21d1f m) (\u21d1(\u21d1f m) x) = \u21d1Q m \u2022 x) (n : N) :\n\t\u21d1(\u21d1(clifford_algebra.foldl Q f hf) n) (list.map \u21d1(clifford_algebra.\u03b9 Q) l).prod = list.foldl (\u03bb (m : N) (n : M), \u21d1(\u21d1f n) m) n l :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ and $N$ be $R$-modules, $Q$ be a quadratic form on $M$, $l$ be a list of elements of $M$, $f:M\\to\\mathrm{End}_R(N)$ be a linear map, and $n$ be an element of $N$. Suppose that $f$ is a Clifford algebra homomorphism. Then $\\mathrm{Cl}(Q,f)(n)\\left(\\prod_{m\\in l}\\iota_Q(m)\\right)=\\sum_{m\\in l}f(m)(n)$."}
{"name": "is_unit.continuous_on_const_smul_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/const_mul_action.lean", "formal_statement": "theorem is_unit.continuous_on_const_smul_iff {M \u03b1 \u03b2 : Type*} [monoid M]\n\t[topological_space \u03b1] [mul_action M \u03b1] [has_continuous_const_smul M \u03b1]\n\t[topological_space \u03b2] {f : \u03b2 \u2192 \u03b1} { : M} {s : set \u03b2} (hc : is_unit c) :\n\tcontinuous_on (\u03bb (x : \u03b2), c \u2022 f x) s \u2194 continuous_on f s :=", "nl_statement_of_codex": "Let $M$ be a monoid, let $\u03b1$ and $\u03b2$ be topological spaces, and let $f:\u03b2\\to \u03b1$ be a function. Then $f$ is continuous if and only if $cf$ is continuous for all $c\\in M$."}
{"name": "equiv.perm.cycle_induction_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/basic.lean", "formal_statement": "theorem equiv.perm.cycle_induction_on {\u03b2 : Type*} [fintype \u03b2]\n\t(P : equiv.perm \u03b2 \u2192 Prop) (\u03c3 : equiv.perm \u03b2) (base_one : P 1)\n\t(base_cycles : \u2200 (\u03c3 : equiv.perm \u03b2), \u03c3.is_cycle \u2192 P \u03c3)\n\t(induction_disjoint : \u2200 (\u03c3 \u03c4 : equiv.perm \u03b2), \u03c3.disjoint \u03c4 \u2192 \u03c3.is_cycle \u2192 P \u03c3 \u2192 P \u03c4 \u2192 P (\u03c3 * \u03c4)) :\n\tP \u03c3 :=", "nl_statement_of_codex": "Let $P$ be a property of permutations of a finite set $X$. Suppose that $P$ holds for the identity permutation, for all cycles, and for the product of two permutations $\\sigma$ and $\\tau$ such that $\\sigma$ and $\\tau$ are disjoint and $\\sigma$ is a cycle. Then $P$ holds for all permutations of $X$."}
{"name": "is_open_map.nhds_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/maps.lean", "formal_statement": "theorem is_open_map.nhds_le {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : is_open_map f) (a : \u03b1) :\n\tnhds (f a) \u2264 filter.map f (nhds a) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be an open map. Then for each $x\\in X$, the filter $\\mathcal{N}(f(x))$ is finer than the filter $\\mathcal{N}(x)$."}
{"name": "rbnode.find_balance2_node_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rbtree/insert.lean", "formal_statement": "theorem rbnode.find_balance2_node_lt {\u03b1 : Type u} (lt : \u03b1 \u2192 \u03b1 \u2192 Prop)\n\t[is_strict_weak_order \u03b1 lt] [decidable_rel lt] {s t : rbnode \u03b1} {x y : \u03b1}\n\t{lo hi : option \u03b1} (h : lt x y)\n\t(ht : rbnode.is_searchable lt t (option.some y) hi)\n\t(hs : rbnode.is_searchable lt s lo (option.some y))\n\t(hne : t \u2260 rbnode.leaf . \"ins_ne_leaf_tac\") :\n\trbnode.find lt (t.balance2_node y s) x = rbnode.find lt s x :=", "nl_statement_of_codex": "Let $t$ and $s$ be red-black trees with $t$ having a black root and $s$ having a red root. Let $x$ and $y$ be elements of the tree. If $x<y$, then the result of inserting $x$ into the tree $t$ is the same as the result of inserting $x$ into the tree $s$."}
{"name": "filter.germ.const_abs", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/filter_product.lean", "formal_statement": "theorem filter.germ.const_abs {\u03b1 : Type u} {\u03b2 : Type v} {\u03c6 : ultrafilter \u03b1}\n\t[linear_ordered_add_comm_group \u03b2] (x : \u03b2) :\n\t\u2191|x| = |\u2191x| :=", "nl_statement_of_codex": "Let $x$ be an element of a linear ordered additive commutative group $G$. Then the germ of $|x|$ is equal to the absolute value of the germ of $x$."}
{"name": "category_theory.prod_id_fst", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/products/basic.lean", "formal_statement": "theorem category_theory.prod_id_fst (C : Type u\u2081) [category_theory.category C]\n\t(D : Type u\u2082) [category_theory.category D] (X : C \u00d7 D) :\n\t(\ud835\udfd9 X).fst = \ud835\udfd9 X.fst :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories. Let $X$ be an object of $C\\times D$. Then the first component of the identity morphism of $X$ is the identity morphism of the first component of $X$."}
{"name": "mul_action.orbit_zpowers_equiv_symm_apply'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/zmod/quotient.lean", "formal_statement": "theorem mul_action.orbit_zpowers_equiv_symm_apply' {\u03b1 \u03b2 : Type*} [group \u03b1]\n\t(a : \u03b1) [mul_action \u03b1 \u03b2] (b : \u03b2) (k : \u2124) :\n\t\u21d1((mul_action.orbit_zpowers_equiv a b).symm) \u2191k = \u27e8a, _\u27e9 ^ k \u2022 \u27e8b, _\u27e9 :=", "nl_statement_of_codex": "Let $G$ be a group, $X$ a $G$-set, $a\\in G$, and $x\\in X$. Then the $G$-orbit of $x$ is equal to the set of elements of the form $a^kx$ for $k\\in\\mathbb{Z}$."}
{"name": "linear_isometry.congr_fun", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem linear_isometry.congr_fun {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082]\n\t{\u03c3\u2081\u2082 : R \u2192+* R\u2082} [semi_normed_group E] [semi_normed_group E\u2082] [module R E]\n\t[module R\u2082 E\u2082] {f g : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} (h : f = g) (x : E) :\n\t\u21d1f x = \u21d1g x :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $E$ and $E'$ be semi-normed groups, and let $f,g:E\\to E'$ be linear isometries. If $f=g$, then $f(x)=g(x)$ for all $x\\in E$."}
{"name": "category_theory.is_subterminal.def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subterminal.lean", "formal_statement": "theorem category_theory.is_subterminal.def {C : Type u\u2081}\n\t[category_theory.category C] {A : C} :\n\tcategory_theory.is_subterminal A \u2194 \u2200 \u2983Z : C\u2984 (f g : Z \u27f6 A), f = g :=", "nl_statement_of_codex": "An object $A$ in a category $C$ is subterminal if and only if for any object $Z$ in $C$, any two morphisms $f,g:Z\\to A$ are equal."}
{"name": "mul_opposite.map_op_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/constructions.lean", "formal_statement": "theorem mul_opposite.map_op_nhds {M : Type*} [topological_space M] (x : M) :\n\tfilter.map mul_opposite.op (nhds x) = nhds (mul_opposite.op x) :=", "nl_statement_of_codex": "The filter of neighborhoods of $x$ is equal to the filter of neighborhoods of $-x$."}
{"name": "con.con_gen_idem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/congruence.lean", "formal_statement": "theorem con.con_gen_idem {M : Type*} [has_mul M] (r : M \u2192 M \u2192 Prop) :\n\tcon_gen \u21d1(con_gen r) = con_gen r :=", "nl_statement_of_codex": "The congruence generated by the congruence generated by $r$ is the same as the congruence generated by $r$."}
{"name": "ideal.comap_le_comap_iff_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.comap_le_comap_iff_of_surjective {R : Type u} {S : Type v}\n\t{F : Type*} [ring R] [ring S] [ring_hom_class F R S] (f : F)\n\t(hf : function.surjective \u21d1f) (I J : ideal S) :\n\tideal.comap f I \u2264 ideal.comap f J \u2194 I \u2264 J :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f:R\\to S$ be a surjective ring homomorphism. Then the ideals $I$ and $J$ of $S$ satisfy $f^{-1}(I)\\subset f^{-1}(J)$ if and only if $I\\subset J$."}
{"name": "tropical.trop_order_iso_coe_fn", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/tropical/basic.lean", "formal_statement": "theorem tropical.trop_order_iso_coe_fn {R : Type u} [preorder R] :\n\t\u21d1tropical.trop_order_iso = tropical.trop :=", "nl_statement_of_codex": "The map $\\trop:R\\to\\mathbb{R}$ is an order isomorphism."}
{"name": "turing.partrec_to_TM2.tr_normal_respects", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/tm_to_partrec.lean", "formal_statement": "theorem turing.partrec_to_TM2.tr_normal_respects ( : turing.to_partrec.code)\n\t(k : turing.to_partrec.cont) (v : list \u2115) (s : option turing.partrec_to_TM2.\u0393') :\n\t\u2203 (b\u2082 : turing.partrec_to_TM2.cfg'), turing.partrec_to_TM2.tr_cfg (turing.to_partrec.step_normal c k v) b\u2082 \u2227 turing.reaches\u2081 (turing.TM2.step turing.partrec_to_TM2.tr) {l := option.some (turing.partrec_to_TM2.tr_normal c (turing.partrec_to_TM2.tr_cont k)), var := s, stk := turing.partrec_to_TM2.K'.elim (turing.partrec_to_TM2.tr_list v) list.nil list.nil (turing.partrec_to_TM2.tr_cont_stack k)} b\u2082 :=", "nl_statement_of_codex": "Let $c$ be a code, $k$ be a continuation, $v$ be a list of natural numbers, and $s$ be an option of $\\Gamma'$. Then there is a configuration $b_2$ such that $b_2$ is reachable from the configuration $c, k, v, s$."}
{"name": "order.iso_of_countable_dense", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/countable_dense_linear_order.lean", "formal_statement": "theorem order.iso_of_countable_dense (\u03b1 \u03b2 : Type*) [linear_order \u03b1]\n\t[linear_order \u03b2] [encodable \u03b1] [densely_ordered \u03b1] [no_min_order \u03b1]\n\t[no_max_order \u03b1] [nonempty \u03b1] [encodable \u03b2] [densely_ordered \u03b2]\n\t[no_min_order \u03b2] [no_max_order \u03b2] [nonempty \u03b2] :\n\tnonempty (\u03b1 \u2243o \u03b2) :=", "nl_statement_of_codex": "If $\\alpha$ and $\\beta$ are countable dense linear orders without endpoints, then $\\alpha$ and $\\beta$ are order-isomorphic."}
{"name": "zsqrtd.nonneg_muld", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.nonneg_muld {d : \u2115} {a : \u2124\u221a\u2191d} (ha : a.nonneg) :\n\t(zsqrtd.sqrtd * a).nonneg :=", "nl_statement_of_codex": "Let $d$ be a positive integer and let $a$ be a nonnegative element of $\\mathbb{Z}\\sqrt{d}$. Then $a\\sqrt{d}$ is nonnegative."}
{"name": "int.to_nat_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.to_nat_one :\n\t1.to_nat = 1 :=", "nl_statement_of_codex": "The natural number $1$ is equal to the integer $1$."}
{"name": "list.count_map_of_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/count.lean", "formal_statement": "theorem list.count_map_of_injective {\u03b1 \u03b2 : Type*} [decidable_eq \u03b1]\n\t[decidable_eq \u03b2] (l : list \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : function.injective f) (x : \u03b1) :\n\tlist.count (f x) (list.map f l) = list.count x l :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then for any list $l$ of elements of $A$, the number of occurrences of $x$ in $l$ is equal to the number of occurrences of $f(x)$ in $f(l)$."}
{"name": "W_type.nat_\u03b1_equiv_punit_sum_punit_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/W/constructions.lean", "formal_statement": "theorem W_type.nat_\u03b1_equiv_punit_sum_punit_symm_apply (b : punit \u2295 punit) :\n\t\u21d1(W_type.nat_\u03b1_equiv_punit_sum_punit.symm) b = W_type.nat_\u03b1_equiv_punit_sum_punit._match_2 b :=", "nl_statement_of_codex": "The inverse of the isomorphism $W_type.nat_\u03b1_equiv_punit_sum_punit$ is given by $W_type.nat_\u03b1_equiv_punit_sum_punit._match_2$."}
{"name": "with_top.zero_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid.lean", "formal_statement": "theorem with_top.zero_eq_coe {\u03b1 : Type u} [has_zero \u03b1] {a : \u03b1} :\n\t0 = \u2191a \u2194 a = 0 :=", "nl_statement_of_codex": "Let $\u03b1$ be a type with a zero element. Then $0=\\top$ if and only if $a=0$."}
{"name": "sbtw_irrefl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/circular.lean", "formal_statement": "theorem sbtw_irrefl {\u03b1 : Type*} [circular_preorder \u03b1] (a : \u03b1) :\n\t\u00achas_sbtw.sbtw a a a :=", "nl_statement_of_codex": "Let $a$ be an element of a circular preorder. Then $a$ is not sandwiched between itself."}
{"name": "sym2.eq_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sym/sym2.lean", "formal_statement": "theorem sym2.eq_iff {\u03b1 : Type*} {x y z w : \u03b1} :\n\t\u27e6(x, y)\u27e7 = \u27e6(z, w)\u27e7 \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z :=", "nl_statement_of_codex": "Two ordered pairs $(x,y)$ and $(z,w)$ are equal if and only if $x=z$ and $y=w$ or $x=w$ and $y=z$."}
{"name": "cycle.to_multiset_eq_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/cycle.lean", "formal_statement": "theorem cycle.to_multiset_eq_nil {\u03b1 : Type*} {s : cycle \u03b1} :\n\ts.to_multiset = 0 \u2194 s = cycle.nil :=", "nl_statement_of_codex": "A cycle $s$ is the empty cycle if and only if $s$ is the zero multiset."}
{"name": "order_hom.fst_comp_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/basic.lean", "formal_statement": "theorem order_hom.fst_comp_prod {\u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t[preorder \u03b3] (f : \u03b1 \u2192o \u03b2) (g : \u03b1 \u2192o \u03b3) :\n\torder_hom.fst.comp (f.prod g) = f :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:A\\to C$ be order homomorphisms. Then the order homomorphism $f\\times g:A\\to B\\times C$ satisfies $(f\\times g)(a)=(f(a),g(a))$."}
{"name": "algebra.mul_sub_algebra_map_commutes", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem algebra.mul_sub_algebra_map_commutes {R : Type u} {A : Type w}\n\t[comm_semiring R] [ring A] [algebra R A] (x : A) (r : R) :\n\tx * (x - \u21d1(algebra_map R A) r) = (x - \u21d1(algebra_map R A) r) * x :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a ring, and $R\\to A$ an algebra map. Then for all $x\\in A$ and $r\\in R$, we have $x(x-r)=x(x-r)$."}
{"name": "category_theory.lax_braided_functor.map_CommMon_obj_to_Mon_", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/CommMon_.lean", "formal_statement": "theorem category_theory.lax_braided_functor.map_CommMon_obj_to_Mon_\n\t{C : Type u\u2081} [category_theory.category C]\n\t[category_theory.monoidal_category C] [category_theory.braided_category C]\n\t{D : Type u\u2082} [category_theory.category D]\n\t[category_theory.monoidal_category D] [category_theory.braided_category D]\n\t(F : category_theory.lax_braided_functor C D) (A : CommMon_ C) :\n\t(F.map_CommMon.obj A).to_Mon_ = F.to_lax_monoidal_functor.map_Mon.obj A.to_Mon_ :=", "nl_statement_of_codex": "Let $C$ and $D$ be braided monoidal categories. Let $F:C\\to D$ be a braided functor. Let $A$ be a commutative monoid in $C$. Then $F(A)$ is a monoid in $D$ and $F(A)$ is the same as $F(A)$ as a monoid."}
{"name": "set.singleton_add_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.singleton_add_singleton {\u03b1 : Type*} [has_add \u03b1] {a b : \u03b1} :\n\t{a} + {b} = {a + b} :=", "nl_statement_of_codex": "Let $A$ be a set with an addition operation. Then $\\{a\\}+\\{b\\}=\\{a+b\\}$."}
{"name": "ordinal.sup_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.sup_le_iff {\u03b9 : Type*} {f : \u03b9 \u2192 ordinal} {a : ordinal} :\n\tordinal.sup f \u2264 a \u2194 \u2200 (i : \u03b9), f i \u2264 a :=", "nl_statement_of_codex": "Let $f:\\iota\\to\\mathrm{Ord}$ be a function. Then $\\sup f\\leq a$ if and only if $f(i)\\leq a$ for all $i\\in\\iota$."}
{"name": "bornology.cobounded_eq_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bornology/basic.lean", "formal_statement": "theorem bornology.cobounded_eq_bot (\u03b1 : Type*) [bornology \u03b1] [bounded_space \u03b1] :\n\tbornology.cobounded \u03b1 = \u22a5 :=", "nl_statement_of_codex": "The cobounded bornology on a bounded space is the trivial bornology."}
{"name": "order.embedding_from_countable_to_dense", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/countable_dense_linear_order.lean", "formal_statement": "theorem order.embedding_from_countable_to_dense (\u03b1 \u03b2 : Type*) [linear_order \u03b1]\n\t[linear_order \u03b2] [encodable \u03b1] [densely_ordered \u03b2] [nontrivial \u03b2] :\n\tnonempty (\u03b1 \u21aao \u03b2) :=", "nl_statement_of_codex": "Let $\\alpha$ and $\\beta$ be linear orders. If $\\alpha$ is countable and $\\beta$ is dense and nontrivial, then there is an order embedding from $\\alpha$ to $\\beta$."}
{"name": "mv_polynomial.expand_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/expand.lean", "formal_statement": "theorem mv_polynomial.expand_one {\u03c3 R : Type*} [comm_semiring R] :\n\tmv_polynomial.expand 1 = alg_hom.id R (mv_polynomial \u03c3 R) :=", "nl_statement_of_codex": "The polynomial $1$ is the identity element of the ring of polynomials."}
{"name": "homotopy_category.quotient_obj_as", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/homotopy_category.lean", "formal_statement": "theorem homotopy_category.quotient_obj_as {\u03b9 : Type*} {V : Type u}\n\t[category_theory.category V] [category_theory.preadditive V]\n\t{ : complex_shape \u03b9} (C : homological_complex V c) :\n\t((homotopy_category.quotient V c).obj C).as = C :=", "nl_statement_of_codex": "Let $C$ be a homological complex. Then the underlying complex of the quotient object of $C$ in the homotopy category is $C$."}
{"name": "units.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/units.lean", "formal_statement": "theorem units.ext {\u03b1 : Type u} [monoid \u03b1] :\n\tfunction.injective coe :=", "nl_statement_of_codex": "The map $x\\mapsto x^{-1}$ is injective on the group of units of a monoid."}
{"name": "measure_theory.mem_\u2112p.sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/lp_space.lean", "formal_statement": "theorem measure_theory.mem_\u2112p.sub {\u03b1 E : Type*} {m0 : measurable_space \u03b1}\n\t{p : ennreal} {\u03bc : measure_theory.measure \u03b1} [normed_group E] {f g : \u03b1 \u2192 E}\n\t(hf : measure_theory.mem_\u2112p f p \u03bc) (hg : measure_theory.mem_\u2112p g p \u03bc) :\n\tmeasure_theory.mem_\u2112p (f - g) p \u03bc :=", "nl_statement_of_codex": "Let $E$ be a normed group, let $p$ be an extended non-negative real number, let $\\mu$ be a measure on a measurable space $\\alpha$, and let $f,g:\\alpha\\to E$. If $f$ and $g$ are in $L^p(\\mu)$, then $f-g$ is in $L^p(\\mu)$."}
{"name": "lipschitz_on_with.norm_sub_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem lipschitz_on_with.norm_sub_le {E F : Type*} [semi_normed_group E]\n\t[semi_normed_group F] {f : E \u2192 F} {C : nnreal} {s : set E}\n\t(h : lipschitz_on_with C f s) {x y : E} (x_in : x \u2208 s) (y_in : y \u2208 s) :\n\t\u2225f x - f y\u2225 \u2264 \u2191C * \u2225x - y\u2225 :=", "nl_statement_of_codex": "Let $E$ and $F$ be semi-normed groups, let $f:E\\to F$ be a function, let $C$ be a non-negative real number, and let $s$ be a subset of $E$. Suppose that $f$ is $C$-Lipschitz on $s$. Then for all $x,y\\in s$, we have $\\|f(x)-f(y)\\|\\leq C\\|x-y\\|$."}
{"name": "category_theory.limits.\u03c0_comp_cokernel_iso_of_eq_hom_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/kernels.lean", "formal_statement": "theorem category_theory.limits.\u03c0_comp_cokernel_iso_of_eq_hom_assoc {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C} {f g : X \u27f6 Y} [category_theory.limits.has_cokernel f]\n\t[category_theory.limits.has_cokernel g] (h : f = g) {X' : C}\n\t(f' : category_theory.limits.cokernel g \u27f6 X') :\n\tcategory_theory.limits.cokernel.\u03c0 f \u226b (category_theory.limits.cokernel_iso_of_eq h).hom \u226b f' = category_theory.limits.cokernel.\u03c0 g \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $X, Y, X'$ be objects of $C$ and let $f, g:X\\to Y$ be morphisms. Suppose that $f=g$. Then the cokernel of $f$ is isomorphic to the cokernel of $g$."}
{"name": "linear_equiv.to_add_equiv_to_int_linear_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/equiv.lean", "formal_statement": "theorem linear_equiv.to_add_equiv_to_int_linear_equiv {M M\u2082 : Type*}\n\t[add_comm_group M] [add_comm_group M\u2082] (e : M \u2243\u2097[\u2124] M\u2082) :\n\te.to_add_equiv.to_int_linear_equiv = e :=", "nl_statement_of_codex": "Let $M$ and $M_2$ be abelian groups. If $e:M\\to M_2$ is a linear equivalence, then $e$ is an integer linear equivalence."}
{"name": "simplex_category.small_category_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_topology/simplex_category.lean", "formal_statement": "theorem simplex_category.small_category_hom (n m : simplex_category) :\n\t(n \u27f6 m) = n.hom m :=", "nl_statement_of_codex": "The set of morphisms from $n$ to $m$ in the simplex category is equal to $n.hom(m)$."}
{"name": "finset.image_eq_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.image_eq_empty {\u03b1 \u03b2 : Type*} [decidable_eq \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t{s : finset \u03b1} :\n\tfinset.image f s = \u2205 \u2194 s = \u2205 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $S$ be a finite set. Then $f(S)=\\emptyset$ if and only if $S=\\emptyset$."}
{"name": "hyperreal.coe_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.coe_mul (x y : \u211d) :\n\t\u2191(x * y) = \u2191x * \u2191y :=", "nl_statement_of_codex": "The hyperreal number $x\\cdot y$ is equal to the hyperreal number $x$ times the hyperreal number $y$."}
{"name": "box_integral.prepartition.is_partition_split_center", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/subbox_induction.lean", "formal_statement": "theorem box_integral.prepartition.is_partition_split_center {\u03b9 : Type*}\n\t[fintype \u03b9] (I : box_integral.box \u03b9) :\n\t(box_integral.prepartition.split_center I).is_partition :=", "nl_statement_of_codex": "The split center of a box is a partition."}
{"name": "local_equiv.eq_on_source.trans'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/local_equiv.lean", "formal_statement": "theorem local_equiv.eq_on_source.trans' {\u03b1 \u03b2 \u03b3 : Type*} {e e' : local_equiv \u03b1 \u03b2}\n\t{f f' : local_equiv \u03b2 \u03b3} (he : e \u2248 e') (hf : f \u2248 f') :\n\te.trans f \u2248 e'.trans f' :=", "nl_statement_of_codex": "Let $e:U\\to V$ and $f:V\\to W$ be local homeomorphisms. Then $f\\circ e$ is a local homeomorphism if and only if $f\\circ e$ is a local homeomorphism."}
{"name": "filter.tendsto_at_top_at_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.tendsto_at_top_at_bot {\u03b1 \u03b2 : Type*} [nonempty \u03b1]\n\t[semilattice_sup \u03b1] [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\tfilter.tendsto f filter.at_top filter.at_bot \u2194 \u2200 (b : \u03b2), \u2203 (i : \u03b1), \u2200 (a : \u03b1), i \u2264 a \u2192 f a \u2264 b :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function from a nonempty poset $A$ to a poset $B$. Then $f$ tends to $-\\infty$ at $\\infty$ if and only if for each $b\\in B$ there is an $i\\in A$ such that $f(a)\\leq b$ for all $a\\geq i$."}
{"name": "ring_topology.ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/ring.lean", "formal_statement": "theorem ring_topology.ext_iff {\u03b1 : Type u} {_inst_1 : ring \u03b1}\n\t(x y : ring_topology \u03b1) :\n\tx = y \u2194 x.to_topological_space = y.to_topological_space :=", "nl_statement_of_codex": "Let $R$ be a ring. Then two ring topologies on $R$ are equal if and only if the corresponding topological spaces are equal."}
{"name": "isometry.diam_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/isometry.lean", "formal_statement": "theorem isometry.diam_image {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1]\n\t[pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : isometry f) (s : set \u03b1) :\n\tmetric.diam (f '' s) = metric.diam s :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be an isometry. Then the diameter of $f(A)$ is equal to the diameter of $A$."}
{"name": "exp_char_one_iff_char_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/char_p/exp_char.lean", "formal_statement": "theorem exp_char_one_iff_char_zero (R : Type u) [semiring R] [nontrivial R]\n\t(p q : \u2115) [char_p R p] [exp_char R q] :\n\tq = 1 \u2194 p = 0 :=", "nl_statement_of_codex": "Let $R$ be a nontrivial semiring of characteristic $p$ and exponent $q$. Then $q=1$ if and only if $p=0$."}
{"name": "function.is_fixed_pt.map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/fixed_points/basic.lean", "formal_statement": "theorem function.is_fixed_pt.map {\u03b1 : Type u} {\u03b2 : Type v} {fa : \u03b1 \u2192 \u03b1}\n\t{fb : \u03b2 \u2192 \u03b2} {x : \u03b1} (hx : function.is_fixed_pt fa x) {g : \u03b1 \u2192 \u03b2}\n\t(h : function.semiconj g fa fb) :\n\tfunction.is_fixed_pt fb (g x) :=", "nl_statement_of_codex": "Let $f:X\\to X$ and $g:Y\\to Y$ be functions. Let $h:X\\to Y$ be a function such that $h\\circ f=g\\circ h$. If $x\\in X$ is a fixed point of $f$, then $h(x)$ is a fixed point of $g$."}
{"name": "imp_false", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem imp_false {a : Prop} :\n\ta \u2192 false \u2194 \u00aca :=", "nl_statement_of_codex": "$a\\to false$ is equivalent to $\\lnot a$."}
{"name": "complete_lattice.is_sup_closed_compact.is_Sup_finite_compact", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/compactly_generated.lean", "formal_statement": "theorem complete_lattice.is_sup_closed_compact.is_Sup_finite_compact (\u03b1 : Type*)\n\t[complete_lattice \u03b1] :\n\tcomplete_lattice.is_sup_closed_compact \u03b1 \u2192 complete_lattice.is_Sup_finite_compact \u03b1 :=", "nl_statement_of_codex": "Let $L$ be a complete lattice. If $L$ is sup-closed and compact, then $L$ is finite-compact."}
{"name": "metric.mem_closed_ball'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.mem_closed_ball' {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x y : \u03b1}\n\t{\u03b5 : \u211d} :\n\ty \u2208 metric.closed_ball x \u03b5 \u2194 has_dist.dist x y \u2264 \u03b5 :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x,y\\in X$. Then $y\\in \\overline{B}(x,\\epsilon)$ if and only if $d(x,y)\\leq \\epsilon$."}
{"name": "list.is_rotated.eqv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/rotate.lean", "formal_statement": "theorem list.is_rotated.eqv {\u03b1 : Type u} :\n\tequivalence list.is_rotated :=", "nl_statement_of_codex": "The relation of being a rotation is an equivalence relation on lists."}
{"name": "add_subgroup.eq_bot_iff_forall", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.eq_bot_iff_forall {G : Type*} [add_group G]\n\t(H : add_subgroup G) :\n\tH = \u22a5 \u2194 \u2200 (x : G), x \u2208 H \u2192 x = 0 :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $H$ be a subgroup of $G$. Then $H=\\{0\\}$ if and only if $H$ contains only the zero element."}
{"name": "nat.dvd_of_digits_sub_of_digits", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/digits.lean", "formal_statement": "theorem nat.dvd_of_digits_sub_of_digits {\u03b1 : Type*} [comm_ring \u03b1] {a b k : \u03b1}\n\t(h : k \u2223 a - b) (L : list \u2115) :\n\tk \u2223 nat.of_digits a L - nat.of_digits b L :=", "nl_statement_of_codex": "Let $a,b,k\\in\\mathbb{Z}$ and let $L$ be a list of natural numbers. If $k$ divides $a-b$, then $k$ divides $a-b$."}
{"name": "quaternion.zero_re", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion.zero_re {R : Type*} [comm_ring R] :\n\t0.re = 0 :=", "nl_statement_of_codex": "The real part of the zero quaternion is zero."}
{"name": "zsqrtd.nonneg_antisymm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.nonneg_antisymm {d : \u2115} [dnsq : zsqrtd.nonsquare d] {a : \u2124\u221a\u2191d} :\n\ta.nonneg \u2192 (-a).nonneg \u2192 a = 0 :=", "nl_statement_of_codex": "Let $d$ be a non-square integer. If $a$ is a square root of $d$, then $a$ is non-negative if and only if $-a$ is non-negative."}
{"name": "span_gram_schmidt_Iic", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/gram_schmidt_ortho.lean", "formal_statement": "theorem span_gram_schmidt_Iic (\ud835\udd5c : Type*) {E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] {\u03b9 : Type*} [linear_order \u03b9]\n\t[locally_finite_order_bot \u03b9] [is_well_order \u03b9 has_lt.lt] (f : \u03b9 \u2192 E) ( : \u03b9) :\n\tsubmodule.span \ud835\udd5c (gram_schmidt \ud835\udd5c f '' set.Iic c) = submodule.span \ud835\udd5c (f '' set.Iic c) :=", "nl_statement_of_codex": "Let $E$ be a complex inner product space. Let $f:I\\to E$ be a function, where $I$ is a well-ordered set. Then the span of the Gram-Schmidt orthogonalization of $f$ restricted to $I_c$ is equal to the span of $f$ restricted to $I_c$."}
{"name": "basis.algebra_map_coeffs_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/algebra_tower.lean", "formal_statement": "theorem basis.algebra_map_coeffs_apply {R : Type u} (A : Type w) {\u03b9 M : Type*}\n\t[comm_semiring R] [semiring A] [add_comm_monoid M] [algebra R A] [module A M]\n\t[module R M] [is_scalar_tower R A M] (b : basis \u03b9 R M)\n\t(h : function.bijective \u21d1(algebra_map R A)) (i : \u03b9) :\n\t\u21d1(basis.algebra_map_coeffs A b h) i = \u21d1b i :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a semiring, $M$ an $R$-module, and $b$ a basis of $M$. Then the coefficients of the basis $b$ with respect to the basis $b$ are the identity map."}
{"name": "lower_set.compl_sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/upper_lower.lean", "formal_statement": "theorem lower_set.compl_sup {\u03b1 : Type*} [has_le \u03b1] (s t : lower_set \u03b1) :\n\t(s \u2294 t).compl = s.compl \u2294 t.compl :=", "nl_statement_of_codex": "Let $s$ and $t$ be lower sets. Then the complement of $s\\cup t$ is equal to the union of the complements of $s$ and $t$."}
{"name": "mul_aut.one_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/aut.lean", "formal_statement": "theorem mul_aut.one_apply (M : Type*) [has_mul M] (m : M) :\n\t\u21d11 m = m :=", "nl_statement_of_codex": "The identity automorphism of a group $G$ is the identity function on $G$."}
{"name": "category_theory.endofunctor.coalgebra.functor_of_nat_trans_id_hom_app_f", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/endofunctor/algebra.lean", "formal_statement": "theorem category_theory.endofunctor.coalgebra.functor_of_nat_trans_id_hom_app_f\n\t{C : Type u} [category_theory.category C] {F : C \u2964 C}\n\t(X : category_theory.endofunctor.coalgebra F) :\n\t(category_theory.endofunctor.coalgebra.functor_of_nat_trans_id.hom.app X).f = (category_theory.iso.refl ((category_theory.endofunctor.coalgebra.functor_of_nat_trans (\ud835\udfd9 F)).obj X).V).hom :=", "nl_statement_of_codex": "Let $C$ be a category and let $F:C\\to C$ be an endofunctor. Let $X$ be a coalgebra for $F$. Then the morphism $X\\to F(X)$ is the identity morphism."}
{"name": "simple_graph.dart_edge_fiber_card", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/degree_sum.lean", "formal_statement": "theorem simple_graph.dart_edge_fiber_card {V : Type u} (G : simple_graph V)\n\t[fintype V] [decidable_rel G.adj] [decidable_eq V] (e : sym2 V)\n\t(h : e \u2208 G.edge_set) :\n\t(finset.filter (\u03bb (d : G.dart), d.edge = e) finset.univ).card = 2 :=", "nl_statement_of_codex": "Let $G$ be a simple graph. Then the number of darts in $G$ with edge $e$ is $2$."}
{"name": "smul_lt_smul_iff_of_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/smul.lean", "formal_statement": "theorem smul_lt_smul_iff_of_pos {R M : Type*} [ordered_semiring R]\n\t[ordered_add_comm_monoid M] [smul_with_zero R M] [ordered_smul R M] {a b : M}\n\t{ : R} (hc : 0 < c) :\n\tc \u2022 a < c \u2022 b \u2194 a < b :=", "nl_statement_of_codex": "Let $R$ be an ordered semiring, $M$ an ordered additive commutative monoid, and $c\\in R$. Then $c\\cdot a<c\\cdot b$ if and only if $a<b$."}
{"name": "list.argmax_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/min_max.lean", "formal_statement": "theorem list.argmax_nil {\u03b1 \u03b2 : Type*} [preorder \u03b2] [decidable_rel has_lt.lt]\n\t(f : \u03b1 \u2192 \u03b2) :\n\tlist.argmax f list.nil = option.none :=", "nl_statement_of_codex": "The maximum of the empty list is undefined."}
{"name": "path_connected_subset_basis", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/path_connected.lean", "formal_statement": "theorem path_connected_subset_basis {X : Type*} [topological_space X] {x : X}\n\t[loc_path_connected_space X] {U : set X} (h : is_open U) (hx : x \u2208 U) :\n\t(nhds x).has_basis (\u03bb (s : set X), s \u2208 nhds x \u2227 is_path_connected s \u2227 s \u2286 U) id :=", "nl_statement_of_codex": "Let $X$ be a locally path-connected topological space and let $U$ be an open subset of $X$. Then the set of all path-connected subsets of $U$ is a basis for the topology of $X$ at $x$."}
{"name": "alist.perm_insert", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/alist.lean", "formal_statement": "theorem alist.perm_insert {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {a : \u03b1}\n\t{b : \u03b2 a} {s\u2081 s\u2082 : alist \u03b2} (p : s\u2081.entries ~ s\u2082.entries) :\n\t(alist.insert a b s\u2081).entries ~ (alist.insert a b s\u2082).entries :=", "nl_statement_of_codex": "Let $s_1$ and $s_2$ be alists. If $s_1$ and $s_2$ have the same entries, then $s_1$ and $s_2$ have the same entries after inserting an element."}
{"name": "sdiff_le_sdiff_of_sup_le_sup_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/boolean_algebra.lean", "formal_statement": "theorem sdiff_le_sdiff_of_sup_le_sup_right {\u03b1 : Type u} {x y z : \u03b1}\n\t[generalized_boolean_algebra \u03b1] (h : x \u2294 z \u2264 y \u2294 z) :\n\tx \\ z \u2264 y \\ z :=", "nl_statement_of_codex": "Let $x,y,z$ be elements of a generalized boolean algebra. If $x\\vee z\\leq y\\vee z$, then $x\\setminus z\\leq y\\setminus z$."}
{"name": "measure_theory.fin_meas_additive.add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/set_to_l1.lean", "formal_statement": "theorem measure_theory.fin_meas_additive.add {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {\u03b2 : Type*}\n\t[add_comm_monoid \u03b2] {T T' : set \u03b1 \u2192 \u03b2}\n\t(hT : measure_theory.fin_meas_additive \u03bc T)\n\t(hT' : measure_theory.fin_meas_additive \u03bc T') :\n\tmeasure_theory.fin_meas_additive \u03bc (T + T') :=", "nl_statement_of_codex": "Let $(X,\\mathcal{A},\\mu)$ be a measure space and let $T,T':X\\to\\mathbb{R}$ be additive functions. Then $T+T'$ is additive."}
{"name": "commute.cast_int_mul_cast_int_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/lemmas.lean", "formal_statement": "theorem commute.cast_int_mul_cast_int_mul {R : Type u\u2081} [ring R] {a b : R}\n\t(h : commute a b) (m n : \u2124) :\n\tcommute (\u2191m * a) (\u2191n * b) :=", "nl_statement_of_codex": "Let $R$ be a ring and let $a,b\\in R$. If $a$ and $b$ commute, then $ma$ and $nb$ commute for all $m,n\\in\\mathbb{Z}$."}
{"name": "set.Ico_union_Ici", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Ico_union_Ici {\u03b1 : Type*} [linear_order \u03b1] {a b c : \u03b1}\n\t(h : c \u2264 linear_order.max a b) :\n\tset.Ico a b \u222a set.Ici c = set.Ici (linear_order.min a c) :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order. If $c\\leq \\max(a,b)$, then $[a,b]\\cup [c,\\infty)=[\\min(a,c),\\infty)$."}
{"name": "algebra.algebra_map_of_subring_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem algebra.algebra_map_of_subring_apply {R : Type*} [comm_ring R]\n\t(S : subring R) (x : \u21a5S) :\n\t\u21d1(algebra_map \u21a5S R) x = \u2191x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $S$ be a subring of $R$. Then the algebra map $S\\to R$ is the inclusion map."}
{"name": "or_eq_of_eq", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/cc_lemmas.lean", "formal_statement": "theorem or_eq_of_eq {a b : Prop} (h : a = b) :\n\t(a \u2228 b) = a :=", "nl_statement_of_codex": "If $a=b$, then $a\\lor b$ is equivalent to $a$."}
{"name": "measure_theory.measure.supr_restrict_spanning_sets", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.supr_restrict_spanning_sets {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1}\n\t[measure_theory.sigma_finite \u03bc] (hs : measurable_set s) :\n\t(\u2a06 (i : \u2115), \u21d1(\u03bc.restrict (measure_theory.spanning_sets \u03bc i)) s) = \u21d1\u03bc s :=", "nl_statement_of_codex": "Let $\\mu$ be a $\\sigma$-finite measure on a measurable space $(X,\\mathcal{A})$. Then for any measurable set $A\\in\\mathcal{A}$, we have $\\mu(A)=\\sup_{n\\in\\mathbb{N}}\\mu(A\\cap E_n)$, where $\\{E_n\\}_{n\\in\\mathbb{N}}$ is a sequence of measurable sets such that $\\mu(E_n)<\\infty$ for all $n\\in\\mathbb{N}$ and $\\bigcup_{n\\in\\mathbb{N}}E_n=X$."}
{"name": "add_submonoid.localization_map.map_add_units", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem add_submonoid.localization_map.map_add_units {M : Type*}\n\t[add_comm_monoid M] {S : add_submonoid M} {N : Type*} [add_comm_monoid N]\n\t(f : S.localization_map N) (y : \u21a5S) :\n\tis_add_unit (\u21d1(f.to_map) \u2191y) :=", "nl_statement_of_codex": "Let $M$ be an additive commutative monoid, let $S$ be an additive submonoid of $M$, let $N$ be an additive commutative monoid, and let $f:S\\to N$ be a map such that $f(x+y)=f(x)+f(y)$ for all $x,y\\in S$. Then $f(y)$ is an additive unit in $N$ for all $y\\in S$."}
{"name": "measure_theory.lintegral_mul_const''", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.lintegral_mul_const'' {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (r : ennreal)\n\t{f : \u03b1 \u2192 ennreal} (hf : ae_measurable f \u03bc) :\n\t\u222b\u207b (a : \u03b1), f a * r \u2202\u03bc = \u222b\u207b (a : \u03b1), f a \u2202\u03bc * r :=", "nl_statement_of_codex": "Let $f$ be a measurable function from a measure space $(X,\\mathcal{A},\\mu)$ to $[0,\\infty]$. Then $\\int_X f(x)r\\,d\\mu=\\int_X f(x)\\,d\\mu\\cdot r$ for all $r\\in[0,\\infty]$."}
{"name": "basis.prod_repr_inl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basis.lean", "formal_statement": "theorem basis.prod_repr_inl {\u03b9 \u03b9' R M M' : Type*} [semiring R]\n\t[add_comm_monoid M] [module R M] [add_comm_monoid M'] [module R M']\n\t(b : basis \u03b9 R M) (b' : basis \u03b9' R M') (x : M \u00d7 M') (i : \u03b9) :\n\t\u21d1(\u21d1((b.prod b').repr) x) (sum.inl i) = \u21d1(\u21d1(b.repr) x.fst) i :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $M'$ be $R$-modules. Let $b$ and $b'$ be bases of $M$ and $M'$, respectively. Then the representation of $(x,y)\\in M\\times M'$ with respect to the basis $b\\times b'$ is given by $(\\sum_{i\\in I}a_i\\cdot b_i,\\sum_{j\\in J}a'_j\\cdot b'_j)$ where $a_i\\in R$ and $a'_j\\in R$."}
{"name": "num.of_nat'_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem num.of_nat'_eq (n : \u2115) :\n\tnum.of_nat' n = \u2191n :=", "nl_statement_of_codex": "The function $num.of_nat':\\mathbb{N}\\to\\mathbb{N}$ is the identity function."}
{"name": "order.exists_between_finsets", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/countable_dense_linear_order.lean", "formal_statement": "theorem order.exists_between_finsets {\u03b1 : Type*} [linear_order \u03b1]\n\t[densely_ordered \u03b1] [no_min_order \u03b1] [no_max_order \u03b1] [nonem : nonempty \u03b1]\n\t(lo hi : finset \u03b1) (lo_lt_hi : \u2200 (x : \u03b1), x \u2208 lo \u2192 \u2200 (y : \u03b1), y \u2208 hi \u2192 x < y) :\n\t\u2203 (m : \u03b1), (\u2200 (x : \u03b1), x \u2208 lo \u2192 x < m) \u2227 \u2200 (y : \u03b1), y \u2208 hi \u2192 m < y :=", "nl_statement_of_codex": "Let $X$ be a densely ordered set with no minimum and no maximum. Let $A$ and $B$ be finite subsets of $X$ such that $A<B$. Then there is an element $m\\in X$ such that $A<m<B$."}
{"name": "polynomial.forall_iff_forall_finsupp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.forall_iff_forall_finsupp {R : Type u} [semiring R]\n\t(P : polynomial R \u2192 Prop) :\n\t(\u2200 (p : polynomial R), P p) \u2194 \u2200 (q : add_monoid_algebra R \u2115), P {to_finsupp := q} :=", "nl_statement_of_codex": "Let $R$ be a semiring. Then a property $P$ holds for all polynomials if and only if it holds for all finitely supported functions from $\\mathbb{N}$ to $R$."}
{"name": "lattice_ordered_comm_group.m_le_iff_pos_le_neg_ge", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/lattice_group.lean", "formal_statement": "theorem lattice_ordered_comm_group.m_le_iff_pos_le_neg_ge {\u03b1 : Type u}\n\t[lattice \u03b1] [comm_group \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_le.le]\n\t(a b : \u03b1) :\n\ta \u2264 b \u2194 a\u207a \u2264 b\u207a \u2227 b\u207b \u2264 a\u207b :=", "nl_statement_of_codex": "Let $a, b$ be elements of a lattice-ordered commutative group. Then $a\\leq b$ if and only if $a^+\\leq b^+$ and $b^-\\leq a^-$."}
{"name": "no_max_order.upper_bounds_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem no_max_order.upper_bounds_univ {\u03b1 : Type u} [preorder \u03b1]\n\t[no_max_order \u03b1] :\n\tupper_bounds set.univ = \u2205 :=", "nl_statement_of_codex": "If $\\alpha$ is a preorder with no maximal element, then the set of upper bounds of $\\alpha$ is empty."}
{"name": "free_group.eqv_gen_step_iff_join_red", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/free_group.lean", "formal_statement": "theorem free_group.eqv_gen_step_iff_join_red {\u03b1 : Type u}\n\t{L\u2081 L\u2082 : list (\u03b1 \u00d7 bool)} :\n\teqv_gen free_group.red.step L\u2081 L\u2082 \u2194 relation.join free_group.red L\u2081 L\u2082 :=", "nl_statement_of_codex": "Let $L_1$ and $L_2$ be lists of pairs of elements of $\\alpha$ and booleans. Then $L_1$ and $L_2$ are equivalent under the reduction relation if and only if $L_1$ and $L_2$ are joinable under the reduction relation."}
{"name": "complex.of_real_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/basic.lean", "formal_statement": "theorem complex.of_real_eq_coe (r : \u211d) :\n\t\u21d1complex.of_real r = \u2191r :=", "nl_statement_of_codex": "The complex number $r+0i$ is equal to the real number $r$."}
{"name": "finset.nonempty.of_image\u2082_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/n_ary.lean", "formal_statement": "theorem finset.nonempty.of_image\u2082_left {\u03b1 \u03b2 \u03b3 : Type*} [decidable_eq \u03b3]\n\t{f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : finset \u03b1} {t : finset \u03b2}\n\t(h : (finset.image\u2082 f s t).nonempty) :\n\ts.nonempty :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. If $f(A\\times B)$ is nonempty, then $A$ is nonempty."}
{"name": "continuous_at.continuous_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_on.lean", "formal_statement": "theorem continuous_at.continuous_on {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}\n\t(hcont : \u2200 (x : \u03b1), x \u2208 s \u2192 continuous_at f x) :\n\tcontinuous_on f s :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f$ is continuous at each point of $X$, then $f$ is continuous on $X$."}
{"name": "finsupp.single_left_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.single_left_inj {\u03b1 M : Type*} [has_zero M] {a a' : \u03b1} {b : M}\n\t(h : b \u2260 0) :\n\tfinsupp.single a b = finsupp.single a' b \u2194 a = a' :=", "nl_statement_of_codex": "Let $M$ be a monoid with zero. Let $a, a'\\in\\alpha$ and $b\\in M$. Then $a=a'$ if and only if $\\{a\\mapsto b\\}=\\{a'\\mapsto b\\}$."}
{"name": "mem_omega_limit_singleton_iff_map_cluster_point", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/omega_limit.lean", "formal_statement": "theorem mem_omega_limit_singleton_iff_map_cluster_point {\u03c4 \u03b1 \u03b2 : Type*}\n\t[topological_space \u03b2] (f : filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (x : \u03b1) (y : \u03b2) :\n\ty \u2208 omega_limit f \u03d5 {x} \u2194 map_cluster_pt y f (\u03bb (t : \u03c4), \u03d5 t x) :=", "nl_statement_of_codex": "Let $f:\\tau\\to\\alpha\\to\\beta$ be a function and let $x\\in\\alpha$. Then $y\\in\\omega\\text{-}\\lim_{t\\to f} \\{x\\}$ if and only if $y$ is a cluster point of the sequence $(\\phi_t(x))_{t\\in\\tau}$."}
{"name": "function.injective.prod_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/prod/basic.lean", "formal_statement": "theorem function.injective.prod_map {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4}\n\t(hf : function.injective f) (hg : function.injective g) :\n\tfunction.injective (prod.map f g) :=", "nl_statement_of_codex": "Let $f:A\\to C$ and $g:B\\to D$ be injective functions. Then the function $f\\times g:A\\times B\\to C\\times D$ is injective."}
{"name": "set.add_centralizer_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/centralizer.lean", "formal_statement": "theorem set.add_centralizer_subset {M : Type*} {S T : set M} [has_add M]\n\t(h : S \u2286 T) :\n\tT.add_centralizer \u2286 S.add_centralizer :=", "nl_statement_of_codex": "Let $M$ be a set with an addition operation. Let $S$ and $T$ be subsets of $M$. If $S\\subset T$, then $T$'s additive centralizer is contained in $S$'s additive centralizer."}
{"name": "local_homeomorph.trans_source", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/local_homeomorph.lean", "formal_statement": "theorem local_homeomorph.trans_source {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [topological_space \u03b3] (e : local_homeomorph \u03b1 \u03b2)\n\t(e' : local_homeomorph \u03b2 \u03b3) :\n\t(e.trans e').to_local_equiv.source = e.to_local_equiv.source \u2229 \u21d1e \u207b\u00b9' e'.to_local_equiv.source :=", "nl_statement_of_codex": "Let $e:X\\to Y$ and $e':Y\\to Z$ be local homeomorphisms. Then the source of the local homeomorphism $e'\\circ e:X\\to Z$ is the intersection of the source of $e$ and the preimage of the source of $e'$ under $e$."}
{"name": "pnat.mk_le_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pnat/basic.lean", "formal_statement": "theorem pnat.mk_le_mk (n k : \u2115) (hn : 0 < n) (hk : 0 < k) :\n\t\u27e8n, hn\u27e9 \u2264 \u27e8k, hk\u27e9 \u2194 n \u2264 k :=", "nl_statement_of_codex": "Let $n, k$ be positive integers. Then $n\\le k$ if and only if $\u27e8n, hn\u27e9\\le \u27e8k, hk\u27e9$."}
{"name": "mvqpf.fix.ind_rec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/qpf/multivariate/constructions/fix.lean", "formal_statement": "theorem mvqpf.fix.ind_rec {n : \u2115} {F : typevec (n + 1) \u2192 Type u} [mvfunctor F]\n\t[q : mvqpf F] {\u03b1 : typevec n} {\u03b2 : Type u} (g\u2081 g\u2082 : mvqpf.fix F \u03b1 \u2192 \u03b2)\n\t(h : \u2200 (x : F (\u03b1 ::: mvqpf.fix F \u03b1)), mvfunctor.map (typevec.id ::: g\u2081) x = mvfunctor.map (typevec.id ::: g\u2082) x \u2192 g\u2081 (mvqpf.fix.mk x) = g\u2082 (mvqpf.fix.mk x))\n\t(x : mvqpf.fix F \u03b1) :\n\tg\u2081 x = g\u2082 x :=", "nl_statement_of_codex": "Let $F$ be a multivariate functor and let $q$ be a multivariate quasi-polynomial functor. Let $g_1, g_2:F\\to\\beta$ be two functions. Suppose that for all $x\\in F$, $g_1(x)=g_2(x)$. Then $g_1=g_2$."}
{"name": "fderiv_within_mem_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem fderiv_within_mem_iff {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {t : set E} {s : set (E \u2192L[\ud835\udd5c] F)} {x : E} :\n\tfderiv_within \ud835\udd5c f t x \u2208 s \u2194 differentiable_within_at \ud835\udd5c f t x \u2227 fderiv_within \ud835\udd5c f t x \u2208 s \u2228 \u00acdifferentiable_within_at \ud835\udd5c f t x \u2227 0 \u2208 s :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over $\\mathbb{K}$ and let $f:E\\to F$. Let $t$ be a subset of $E$ and let $s$ be a subset of $E\\to F$. Then $f'(x)$ is in $s$ if and only if $f$ is differentiable at $x$ and $f'(x)$ is in $s$ or $f$ is not differentiable at $x$ and $0$ is in $s$."}
{"name": "lipschitz_with.mk_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/lipschitz.lean", "formal_statement": "theorem lipschitz_with.mk_one {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1]\n\t[pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(h : \u2200 (x y : \u03b1), has_dist.dist (f x) (f y) \u2264 has_dist.dist x y) :\n\tlipschitz_with 1 f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between pseudo-metric spaces. If $f$ is $1$-Lipschitz, then $f$ is Lipschitz."}
{"name": "monoid_algebra.op_ring_equiv_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/monoid_algebra/basic.lean", "formal_statement": "theorem monoid_algebra.op_ring_equiv_symm_apply {k : Type u\u2081} {G : Type u\u2082}\n\t[semiring k] [monoid G] (\u1fb0 : G\u1d50\u1d52\u1d56 \u2192\u2080 k\u1d50\u1d52\u1d56) :\n\t\u21d1(monoid_algebra.op_ring_equiv.symm) \u1fb0 = mul_opposite.op (finsupp.map_range mul_opposite.unop _ (finsupp.equiv_map_domain mul_opposite.op_equiv.symm \u1fb0)) :=", "nl_statement_of_codex": "Let $k$ be a semiring and $G$ be a monoid. Let $\\alpha:G\\to k$ be a function. Then $\\alpha$ is a ring homomorphism if and only if $\\alpha$ is a monoid homomorphism."}
{"name": "multiset.induction_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.induction_on {\u03b1 : Type*} {p : multiset \u03b1 \u2192 Prop}\n\t(s : multiset \u03b1) (h\u2081 : p 0)\n\t(h\u2082 : \u2200 \u2983a : \u03b1\u2984 {s : multiset \u03b1}, p s \u2192 p (a ::\u2098 s)) :\n\tp s :=", "nl_statement_of_codex": "Let $s$ be a multiset. Then $s$ is a multiset with no elements or $s$ is a multiset with one element or $s$ is a multiset with two elements or $s$ is a multiset with three elements or $s$ is a multiset with four elements or $s$ is a multiset with five elements or $s$ is a multiset with six elements or $s$ is a multiset with seven elements or $s$ is a multiset with eight elements or $s$ is a multiset with nine elements or $s$ is a multiset with ten elements or $s$ is a mult"}
{"name": "category_theory.free_monoidal_category.mk_\u03c1_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/free/basic.lean", "formal_statement": "theorem category_theory.free_monoidal_category.mk_\u03c1_inv {C : Type u}\n\t{X : category_theory.free_monoidal_category C} :\n\t\u27e6category_theory.free_monoidal_category.hom.\u03c1_inv X\u27e7 = (\u03c1_ X).inv :=", "nl_statement_of_codex": "The inverse of the map $\\rho_X$ is the map $\\rho_X^{-1}$."}
{"name": "add_action.vadd_orbit_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/basic.lean", "formal_statement": "theorem add_action.vadd_orbit_subset {\u03b1 : Type u} {\u03b2 : Type v} [add_monoid \u03b1]\n\t[add_action \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) :\n\ta +\u1d65 add_action.orbit \u03b1 b \u2286 add_action.orbit \u03b1 b :=", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then for all $g\\in G$ and $x\\in X$, $g+x\\in X$."}
{"name": "subgroup.independent_of_coprime_order", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/noncomm_pi_coprod.lean", "formal_statement": "theorem subgroup.independent_of_coprime_order {G : Type*} [group G] {\u03b9 : Type*}\n\t[hfin : fintype \u03b9] {H : \u03b9 \u2192 subgroup G}\n\t(hcomm : \u2200 (i j : \u03b9), i \u2260 j \u2192 \u2200 (x y : G), x \u2208 H i \u2192 y \u2208 H j \u2192 commute x y)\n\t[\u03a0 (i : \u03b9), fintype \u21a5(H i)]\n\t(hcoprime : \u2200 (i j : \u03b9), i \u2260 j \u2192 (fintype.card \u21a5(H i)).coprime (fintype.card \u21a5(H j))) :\n\tcomplete_lattice.independent H :=", "nl_statement_of_codex": "Let $G$ be a group and let $\\{H_i\\}_{i\\in I}$ be a family of subgroups of $G$ such that $H_i$ and $H_j$ commute for all $i\\neq j$. If the orders of the subgroups $H_i$ are pairwise coprime, then the family $\\{H_i\\}_{i\\in I}$ is independent."}
{"name": "fin.last_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.last_val (n : \u2115) :\n\t(fin.last n).val = n :=", "nl_statement_of_codex": "The value of the last element of $\\mathbb{N}$ is $n$."}
{"name": "is_locally_constant.iff_continuous_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/locally_constant/basic.lean", "formal_statement": "theorem is_locally_constant.iff_continuous_bot {X Y : Type*}\n\t[topological_space X] (f : X \u2192 Y) :\n\tis_locally_constant f \u2194 continuous f :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $f:X\\to Y$. Then $f$ is locally constant if and only if $f$ is continuous."}
{"name": "diff_cont_on_cl.differentiable_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/diff_on_int_cont.lean", "formal_statement": "theorem diff_cont_on_cl.differentiable_at {\ud835\udd5c E F : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] [normed_group E] [normed_group F]\n\t[normed_space \ud835\udd5c E] [normed_space \ud835\udd5c F] {f : E \u2192 F} {s : set E} {x : E}\n\t(h : diff_cont_on_cl \ud835\udd5c f s) (hs : is_open s) (hx : x \u2208 s) :\n\tdifferentiable_at \ud835\udd5c f x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $\\mathbb{K}$. Let $f:E\\to F$ be a function and let $s$ be an open subset of $E$. If $f$ is differentiable on the closure of $s$, then $f$ is differentiable at each point of $s$."}
{"name": "has_strict_fderiv_at_exp_zero_of_radius_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/exponential.lean", "formal_statement": "theorem has_strict_fderiv_at_exp_zero_of_radius_pos {\ud835\udd42 \ud835\udd38 : Type*}\n\t[nondiscrete_normed_field \ud835\udd42] [normed_ring \ud835\udd38] [normed_algebra \ud835\udd42 \ud835\udd38]\n\t[complete_space \ud835\udd38] (h : 0 < (exp_series \ud835\udd42 \ud835\udd38).radius) :\n\thas_strict_fderiv_at (exp \ud835\udd42) 1 0 :=", "nl_statement_of_codex": "If the radius of convergence of the exponential series is positive, then the exponential function is differentiable at $0$."}
{"name": "fin_sum_equiv_of_finset_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/sort.lean", "formal_statement": "theorem fin_sum_equiv_of_finset_inr {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1]\n\t[linear_order \u03b1] {m n : \u2115} {s : finset \u03b1} (hm : s.card = m) (hn : s\u1d9c.card = n)\n\t(i : fin n) :\n\t\u21d1(fin_sum_equiv_of_finset hm hn) (sum.inr i) = \u21d1(s\u1d9c.order_emb_of_fin hn) i :=", "nl_statement_of_codex": "Let $s$ be a finite set with $|s|=m$ and $|s^c|=n$. Then the map $f:s\\sqcup s^c\\to \\{0,\\ldots,m+n-1\\}$ defined by $f(x)=\\begin{cases}\n\\text{the position of $x$ in the list $s$} & \\text{if $x\\in s$}\\\\\n\\text{the position of $x$ in the list $s^c$} & \\text{if $x\\in s^c$}\n\\end{cases}$ is a bijection."}
{"name": "is_top_of_dual_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/max.lean", "formal_statement": "theorem is_top_of_dual_iff {\u03b1 : Type*} [has_le \u03b1] {a : \u03b1\u1d52\u1d48} :\n\tis_top (\u21d1order_dual.of_dual a) \u2194 is_bot a :=", "nl_statement_of_codex": "Let $a$ be an element of the dual of a poset $P$. Then $a$ is a bottom element of $P$ if and only if the order dual of $a$ is a top element of $P^\\circ$."}
{"name": "affine_equiv.coe_to_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_equiv.lean", "formal_statement": "theorem affine_equiv.coe_to_equiv {k P\u2081 P\u2082 V\u2081 V\u2082 : Type*} [ring k]\n\t[add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081] [add_comm_group V\u2082]\n\t[module k V\u2082] [add_torsor V\u2082 P\u2082] (e : P\u2081 \u2243\u1d43[k] P\u2082) :\n\t\u21d1(e.to_equiv) = \u21d1e :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ and $V_2$ be $k$-modules, and $P_1$ and $P_2$ be $k$-affine spaces. Let $e:P_1\\to P_2$ be an affine map. Then the underlying map of $e$ is the same as the underlying map of $e$."}
{"name": "int.sub_pos_of_lt", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.sub_pos_of_lt {a b : \u2124} (h : b < a) :\n\t0 < a - b :=", "nl_statement_of_codex": "If $b<a$, then $0<a-b$."}
{"name": "add_subsemigroup.range_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem add_subsemigroup.range_subtype {M : Type*} [has_add M]\n\t(s : add_subsemigroup M) :\n\t(add_mem_class.subtype s).srange = s :=", "nl_statement_of_codex": "Let $M$ be a set with an addition operation. Let $s$ be a subsemigroup of $M$. Then the range of the subtype of $s$ is $s$."}
{"name": "category_theory.subobject.finset_inf_arrow_factors", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/lattice.lean", "formal_statement": "theorem category_theory.subobject.finset_inf_arrow_factors {C : Type u\u2081}\n\t[category_theory.category C] [category_theory.limits.has_pullbacks C]\n\t{I : Type*} {B : C} (s : finset I) (P : I \u2192 category_theory.subobject B)\n\t(i : I) (m : i \u2208 s) :\n\t(P i).factors (s.inf P).arrow :=", "nl_statement_of_codex": "Let $C$ be a category with pullbacks. Let $B$ be an object of $C$. Let $I$ be a set. Let $s$ be a finite subset of $I$. Let $P:I\\to \\mathrm{Sub}(B)$ be a function. Let $i$ be an element of $I$. Let $m$ be an element of $s$. Then the arrow $P(i)\\to \\bigcap_{j\\in s}P(j)$ factors through the arrow $P(i)\\to \\bigcap_{j\\in s}P(j)$."}
{"name": "int.succ_neg_nat_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.succ_neg_nat_succ (n : \u2115) :\n\t(-\u2191(n.succ)).succ = -\u2191n :=", "nl_statement_of_codex": "$-n-1=-n$ for all $n\\in\\mathbb{N}$."}
{"name": "continuous_within_at_of_not_mem_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_on.lean", "formal_statement": "theorem continuous_within_at_of_not_mem_closure {\u03b1 \u03b2 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {x : \u03b1} :\n\tx \u2209 closure s \u2192 continuous_within_at f s x :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $f:X\\to Y$. Let $s\\subset X$ and let $x\\in X$. If $x\\notin \\overline{s}$, then $f$ is continuous at $x$ on $s$."}
{"name": "list.nth_succ_scanl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.nth_succ_scanl {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2} {b : \u03b2}\n\t{l : list \u03b1} {i : \u2115} :\n\t(list.scanl f b l).nth (i + 1) = ((list.scanl f b l).nth i).bind (\u03bb (x : \u03b2), option.map (\u03bb (y : \u03b1), f x y) (l.nth i)) :=", "nl_statement_of_codex": "Let $f:B\\times A\\to B$ and $b\\in B$. Then for any list $l$ of elements of $A$ and any $i\\in\\mathbb{N}$, the $(i+1)$-th element of the list $scanl(f,b,l)$ is equal to $f(x,y)$, where $x$ is the $i$-th element of $scanl(f,b,l)$ and $y$ is the $i$-th element of $l$."}
{"name": "real.log_nonpos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/log/basic.lean", "formal_statement": "theorem real.log_nonpos {x : \u211d} (hx : 0 \u2264 x) (h'x : x \u2264 1) :\n\treal.log x \u2264 0 :=", "nl_statement_of_codex": "If $0\\leq x\\leq 1$, then $\\log(x)\\leq 0$."}
{"name": "num.land_to_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem num.land_to_nat (m n : num) :\n\t\u2191(m.land n) = \u2191m.land \u2191n :=", "nl_statement_of_codex": "The bitwise and of two numerals $m$ and $n$ is equal to the bitwise and of the numerals $m$ and $n$."}
{"name": "nnnorm_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem nnnorm_zero {E : Type*} [semi_normed_group E] :\n\t\u22250\u2225\u208a = 0 :=", "nl_statement_of_codex": "The semi-norm of the zero element of a semi-normed group is zero."}
{"name": "category_theory.sheaf.le_finest_topology", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/canonical.lean", "formal_statement": "theorem category_theory.sheaf.le_finest_topology {C : Type u}\n\t[category_theory.category C] (Ps : set (C\u1d52\u1d56 \u2964 Type v))\n\t(J : category_theory.grothendieck_topology C)\n\t(hJ : \u2200 (P : C\u1d52\u1d56 \u2964 Type v), P \u2208 Ps \u2192 category_theory.presieve.is_sheaf J P) :\n\tJ \u2264 category_theory.sheaf.finest_topology Ps :=", "nl_statement_of_codex": "Let $C$ be a category and let $Ps$ be a set of presheaves on $C$. Let $J$ be a Grothendieck topology on $C$. If each presheaf in $Ps$ is a sheaf for $J$, then $J$ is finer than the finest topology on $C$ for which each presheaf in $Ps$ is a sheaf."}
{"name": "is_closed.is_G\u03b4", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/G_delta.lean", "formal_statement": "theorem is_closed.is_G\u03b4 {\u03b1 : Type*} [uniform_space \u03b1]\n\t[(uniformity \u03b1).is_countably_generated] {s : set \u03b1} (hs : is_closed s) :\n\tis_G\u03b4 s :=", "nl_statement_of_codex": "Let $X$ be a uniform space. If $X$ is countably generated, then every closed set is a $G_\\delta$ set."}
{"name": "measure_theory.integrable.neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l1_space.lean", "formal_statement": "theorem measure_theory.integrable.neg {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [normed_group \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : measure_theory.integrable f \u03bc) :\n\tmeasure_theory.integrable (-f) \u03bc :=", "nl_statement_of_codex": "Let $f$ be a measurable function from a measurable space $X$ to a normed group $G$. Then $-f$ is integrable."}
{"name": "card_finset_fin_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem card_finset_fin_le {n : \u2115} (s : finset (fin n)) :\n\ts.card \u2264 n :=", "nl_statement_of_codex": "The cardinality of a finite set of natural numbers is less than or equal to the maximum element of the set."}
{"name": "dfinsupp.sum_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.sum_apply {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} {\u03b9\u2081 : Type u\u2081}\n\t[decidable_eq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [\u03a0 (i\u2081 : \u03b9\u2081), has_zero (\u03b2\u2081 i\u2081)]\n\t[\u03a0 (i : \u03b9\u2081) (x : \u03b2\u2081 i), decidable (x \u2260 0)] [\u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)]\n\t{f : \u03a0\u2080 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081} {g : \u03a0 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081 \u2192 (\u03a0\u2080 (i : \u03b9), \u03b2 i)} {i\u2082 : \u03b9} :\n\t\u21d1(f.sum g) i\u2082 = f.sum (\u03bb (i\u2081 : \u03b9\u2081) (b : \u03b2\u2081 i\u2081), \u21d1(g i\u2081 b) i\u2082) :=", "nl_statement_of_codex": "Let $f$ be a finitely supported function from $\\mathbb{N}$ to $\\mathbb{N}$ and let $g$ be a function from $\\mathbb{N}$ to the set of finitely supported functions from $\\mathbb{N}$ to $\\mathbb{N}$. Then the sum of $f$ and $g$ is equal to the sum of $f$ and the function $h$ defined by $h(n)=g(n)(m)$."}
{"name": "laurent_series.coe_algebra_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/laurent_series.lean", "formal_statement": "theorem laurent_series.coe_algebra_map {R : Type u} [comm_semiring R] :\n\t\u21d1(algebra_map (power_series R) (laurent_series R)) = \u21d1(hahn_series.of_power_series \u2124 R) :=", "nl_statement_of_codex": "The map from power series to Laurent series is the same as the map from power series to Hahn series."}
{"name": "alg_hom.commutes", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_hom.commutes {R : Type u} {A : Type v} {B : Type w}\n\t[comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B]\n\t(\u03c6 : A \u2192\u2090[R] B) (r : R) :\n\t\u21d1\u03c6 (\u21d1(algebra_map R A) r) = \u21d1(algebra_map R B) r :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be $R$-algebras. Let $\\phi:A\\to B$ be an $R$-algebra homomorphism. Then $\\phi(r)=r$ for all $r\\in R$."}
{"name": "equiv.forall_congr'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/basic.lean", "formal_statement": "theorem equiv.forall_congr' {\u03b1 : Sort u} {\u03b2 : Sort v} {p : \u03b1 \u2192 Prop}\n\t{q : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2) (h : \u2200 {x : \u03b2}, p (\u21d1(f.symm) x) \u2194 q x) :\n\t(\u2200 (x : \u03b1), p x) \u2194 \u2200 (y : \u03b2), q y :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a bijection. Then $\\forall x\\in A, P(x)$ is equivalent to $\\forall y\\in B, P(f^{-1}(y))$."}
{"name": "galois_connection.monotone_u", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/galois_connection.lean", "formal_statement": "theorem galois_connection.monotone_u {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : galois_connection l u) :\n\tmonotone u :=", "nl_statement_of_codex": "Let $l$ and $u$ be a Galois connection between two preordered sets. Then $u$ is monotone."}
{"name": "prod.swap_covby_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/cover.lean", "formal_statement": "theorem prod.swap_covby_swap {\u03b1 \u03b2 : Type*} [partial_order \u03b1] [partial_order \u03b2]\n\t{x y : \u03b1 \u00d7 \u03b2} :\n\tx.swap \u22d6 y.swap \u2194 x \u22d6 y :=", "nl_statement_of_codex": "Let $x,y$ be elements of $\\alpha\\times\\beta$. Then $x\\prec y$ if and only if $(x_2,x_1)\\prec (y_2,y_1)$."}
{"name": "measure_theory.null_measurable_set_to_measurable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/null_measurable.lean", "formal_statement": "theorem measure_theory.null_measurable_set_to_measurable {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} :\n\tmeasure_theory.null_measurable_set (measure_theory.to_measurable \u03bc s) \u03bc :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Then the set $s\\subset X$ is measurable."}
{"name": "finprod_congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finprod_congr {M : Type*} {\u03b1 : Sort u_4} [comm_monoid M] {f g : \u03b1 \u2192 M}\n\t(h : \u2200 (x : \u03b1), f x = g x) :\n\tfinprod f = finprod g :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid and let $f,g:\\alpha\\to M$. If $f(x)=g(x)$ for all $x\\in\\alpha$, then $\\prod_{x\\in\\alpha}f(x)=\\prod_{x\\in\\alpha}g(x)$."}
{"name": "finset.nonempty_coe_sort", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.nonempty_coe_sort {\u03b1 : Type*} {s : finset \u03b1} :\n\tnonempty \u21a5s \u2194 s.nonempty :=", "nl_statement_of_codex": "A finite set $S$ is nonempty if and only if the set of its elements is nonempty."}
{"name": "stieltjes_function.length_subadditive_Icc_Ioo", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/stieltjes.lean", "formal_statement": "theorem stieltjes_function.length_subadditive_Icc_Ioo (f : stieltjes_function)\n\t{a b : \u211d} {c d : \u2115 \u2192 \u211d} (ss : set.Icc a b \u2286 \u22c3 (i : \u2115), set.Ioo (c i) (d i)) :\n\tennreal.of_real (\u21d1f b - \u21d1f a) \u2264 \u2211' (i : \u2115), ennreal.of_real (\u21d1f (d i) - \u21d1f (c i)) :=", "nl_statement_of_codex": "Let $f$ be a Stieltjes function. Let $a,b\\in\\mathbb{R}$ and let $c,d:\\mathbb{N}\\to\\mathbb{R}$. If $[a,b]\\subseteq\\bigcup_{i\\in\\mathbb{N}}(c(i),d(i))$, then $f(b)-f(a)\\leq\\sum_{i\\in\\mathbb{N}}(f(d(i))-f(c(i)))$."}
{"name": "list.scanr_aux_cons", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.scanr_aux_cons {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2)\n\t(a : \u03b1) (l : list \u03b1) :\n\tlist.scanr_aux f b (a :: l) = (list.foldr f b (a :: l), list.scanr f b l) :=", "nl_statement_of_codex": "Let $f:A\\times B\\to B$ and $b\\in B$. Then the scanr function of $f$ and $b$ on the list $a_1,\\ldots,a_n$ is equal to the pair $(f(a_1,\\ldots,f(a_n,b)),f(a_n,\\ldots,f(a_1,b)))$."}
{"name": "isometric.coe_add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem isometric.coe_add_left {E : Type*} [semi_normed_group E] (x : E) :\n\t\u21d1(isometric.add_left x) = has_add.add x :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group. Then the map $x\\mapsto x+a$ is an isometry for any $a\\in E$."}
{"name": "function.fixed_points_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/fixed_points/basic.lean", "formal_statement": "theorem function.fixed_points_id {\u03b1 : Type u} :\n\tfunction.fixed_points id = set.univ :=", "nl_statement_of_codex": "The fixed points of the identity function on a set $X$ are all the elements of $X$."}
{"name": "zsmul_le_zsmul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/lemmas.lean", "formal_statement": "theorem zsmul_le_zsmul {\u03b1 : Type*} [ordered_add_comm_group \u03b1] {m n : \u2124} {a : \u03b1}\n\t(ha : 0 \u2264 a) (h : m \u2264 n) :\n\tm \u2022 a \u2264 n \u2022 a :=", "nl_statement_of_codex": "Let $a$ be a nonnegative element of an ordered abelian group. Then $m\\cdot a\\leq n\\cdot a$ for all integers $m\\leq n$."}
{"name": "ae_measurable.sub'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem ae_measurable.sub' {G \u03b1 : Type*} [measurable_space G] [has_sub G]\n\t{m : measurable_space \u03b1} {f g : \u03b1 \u2192 G} {\u03bc : measure_theory.measure \u03b1}\n\t[has_measurable_sub\u2082 G] (hf : ae_measurable f \u03bc) (hg : ae_measurable g \u03bc) :\n\tae_measurable (f - g) \u03bc :=", "nl_statement_of_codex": "Let $G$ be a measurable space and let $f,g:\\alpha\\to G$ be a.e. measurable functions. Then $f-g$ is a.e. measurable."}
{"name": "category_theory.limits.binary_biproduct.bicone_inl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.binary_biproduct.bicone_inl {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C} [category_theory.limits.has_binary_biproduct X Y] :\n\t(category_theory.limits.binary_biproduct.bicone X Y).inl = category_theory.limits.biprod.inl :=", "nl_statement_of_codex": "The left inclusion map of the biproduct of $X$ and $Y$ is the left inclusion map of the biproduct cone of $X$ and $Y$."}
{"name": "pgame.fuzzy_iff_game_fuzzy", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/basic.lean", "formal_statement": "theorem pgame.fuzzy_iff_game_fuzzy {x y : pgame} :\n\tx.fuzzy y \u2194 game.fuzzy \u27e6x\u27e7 \u27e6y\u27e7 :=", "nl_statement_of_codex": "Let $x$ and $y$ be partial games. Then $x$ is fuzzy to $y$ if and only if the game $x$ is fuzzy to the game $y$."}
{"name": "affine_equiv.trans_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_equiv.lean", "formal_statement": "theorem affine_equiv.trans_assoc {k P\u2081 P\u2082 P\u2083 P\u2084 V\u2081 V\u2082 V\u2083 V\u2084 : Type*} [ring k]\n\t[add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081] [add_comm_group V\u2082]\n\t[module k V\u2082] [add_torsor V\u2082 P\u2082] [add_comm_group V\u2083] [module k V\u2083]\n\t[add_torsor V\u2083 P\u2083] [add_comm_group V\u2084] [module k V\u2084] [add_torsor V\u2084 P\u2084]\n\t(e\u2081 : P\u2081 \u2243\u1d43[k] P\u2082) (e\u2082 : P\u2082 \u2243\u1d43[k] P\u2083) (e\u2083 : P\u2083 \u2243\u1d43[k] P\u2084) :\n\t(e\u2081.trans e\u2082).trans e\u2083 = e\u2081.trans (e\u2082.trans e\u2083) :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1, V_2, V_3, V_4$ be $k$-modules, and $P_1, P_2, P_3, P_4$ be $k$-torsors. Let $e_1:P_1\\to P_2$, $e_2:P_2\\to P_3$, and $e_3:P_3\\to P_4$ be affine equivalences. Then $(e_1\\circ e_2)\\circ e_3 = e_1\\circ (e_2\\circ e_3)$."}
{"name": "category_theory.limits.has_limits_of_shape_of_equivalence", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/has_limits.lean", "formal_statement": "theorem category_theory.limits.has_limits_of_shape_of_equivalence {J : Type u\u2081}\n\t[category_theory.category J] {C : Type u} [category_theory.category C]\n\t{J' : Type u\u2082} [category_theory.category J'] (e : J \u224c J')\n\t[category_theory.limits.has_limits_of_shape J C] :\n\tcategory_theory.limits.has_limits_of_shape J' C :=", "nl_statement_of_codex": "If $J$ and $J'$ are equivalent categories and $J$ has limits of shape $C$, then $J'$ has limits of shape $C$."}
{"name": "set.subset_preimage_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.subset_preimage_image {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2)\n\t(s : set \u03b1) :\n\ts \u2286 f \u207b\u00b9' (f '' s) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function and let $A\\subset X$. Then $A\\subset f^{-1}(f(A))$."}
{"name": "asymptotics.is_o.add_is_O", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_o.add_is_O {\u03b1 F E' : Type*} [has_norm F]\n\t[semi_normed_group E'] {g : \u03b1 \u2192 F} {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'}\n\t(h\u2081 : f\u2081 =o[l] g) (h\u2082 : f\u2082 =O[l] g) :\n\t(\u03bb (x : \u03b1), f\u2081 x + f\u2082 x) =O[l] g :=", "nl_statement_of_codex": "Let $f_1, f_2, g:\\alpha\\to E'$ be functions. If $f_1=o(g)$ and $f_2=O(g)$, then $f_1+f_2=O(g)$."}
{"name": "order_iso.tendsto_at_top_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem order_iso.tendsto_at_top_iff {\u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t{l : filter \u03b3} {f : \u03b3 \u2192 \u03b1} (e : \u03b1 \u2243o \u03b2) :\n\tfilter.tendsto (\u03bb (x : \u03b3), \u21d1e (f x)) l filter.at_top \u2194 filter.tendsto f l filter.at_top :=", "nl_statement_of_codex": "Let $f:\\gamma\\to\\alpha$ be a function. Then $f$ tends to $\\infty$ if and only if $e\\circ f$ tends to $\\infty$."}
{"name": "sym2.rel.trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sym/sym2.lean", "formal_statement": "theorem sym2.rel.trans {\u03b1 : Type*} {x y z : \u03b1 \u00d7 \u03b1} (a : sym2.rel \u03b1 x y)\n\t(b : sym2.rel \u03b1 y z) :\n\tsym2.rel \u03b1 x z :=", "nl_statement_of_codex": "Let $x,y,z$ be elements of $A\\times A$. If $(x,y)$ and $(y,z)$ are in the symmetric relation on $A\\times A$, then $(x,z)$ is in the symmetric relation on $A\\times A$."}
{"name": "list.modify_nth_tail_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.modify_nth_tail_id {\u03b1 : Type u} (n : \u2115) (l : list \u03b1) :\n\tlist.modify_nth_tail id n l = l :=", "nl_statement_of_codex": "The list obtained by modifying the $n$-th tail of a list $l$ by the identity function is $l$."}
{"name": "monotone.add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem monotone.add {\u03b1 \u03b2 : Type*} [has_add \u03b1] [preorder \u03b1] [preorder \u03b2]\n\t{f g : \u03b2 \u2192 \u03b1} [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (hf : monotone f)\n\t(hg : monotone g) :\n\tmonotone (\u03bb (x : \u03b2), f x + g x) :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be monotone functions. Then $f+g:X\\to Y$ is monotone."}
{"name": "category_theory.unmop_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/opposite.lean", "formal_statement": "theorem category_theory.unmop_id {C : Type u\u2081} [category_theory.category C]\n\t{X : C\u1d39\u1d52\u1d56} :\n\t(\ud835\udfd9 X).unmop = \ud835\udfd9 (category_theory.monoidal_opposite.unmop X) :=", "nl_statement_of_codex": "The identity morphism of the monoidal opposite of an object $X$ is the monoidal opposite of the identity morphism of $X$."}
{"name": "filter.tendsto_at_bot_at_bot_of_monotone'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.tendsto_at_bot_at_bot_of_monotone' {\u03b9 \u03b1 : Type*} [preorder \u03b9]\n\t[linear_order \u03b1] {u : \u03b9 \u2192 \u03b1} (h : monotone u) (H : \u00acbdd_below (set.range u)) :\n\tfilter.tendsto u filter.at_bot filter.at_bot :=", "nl_statement_of_codex": "Let $u:\\mathbb{N}\\to\\mathbb{R}$ be a monotone function. If $u$ is not bounded below, then $u$ tends to $-\\infty$."}
{"name": "subfield.mem_inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/subfield.lean", "formal_statement": "theorem subfield.mem_inf {K : Type u} [field K] {p p' : subfield K} {x : K} :\n\tx \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p' :=", "nl_statement_of_codex": "Let $K$ be a field and let $p, p'$ be subfields of $K$. Then $x\\in p\\cap p'$ if and only if $x\\in p$ and $x\\in p'$."}
{"name": "algebraic_geometry.PresheafedSpace.glue_data.snd_inv_app_t_app_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/presheafed_space/gluing.lean", "formal_statement": "theorem algebraic_geometry.PresheafedSpace.glue_data.snd_inv_app_t_app_assoc\n\t{C : Type u} [category_theory.category C]\n\t(D : algebraic_geometry.PresheafedSpace.glue_data C) (i j k : D.to_glue_data.J)\n\t(U : topological_space.opens \u21a5((category_theory.limits.pullback (D.to_glue_data.f i j) (D.to_glue_data.f i k)).carrier))\n\t{X' : C}\n\t(f' : ((D.to_glue_data.t k i).base _* (D.to_glue_data.V (k, i)).presheaf).obj (opposite.op (_.open_functor.obj U)) \u27f6 X') :\n\t_.inv_app U \u226b (D.to_glue_data.t k i).c.app (opposite.op (_.open_functor.obj U)) \u226b f' = (D.to_glue_data.t' k i j).c.app (opposite.op U) \u226b _.inv_app (opposite.unop ((topological_space.opens.map (D.to_glue_data.t' k i j).base).op.obj (opposite.op U))) \u226b (D.to_glue_data.V (k, i)).presheaf.map (category_theory.eq_to_hom _) \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, $D$ a glue data, $i, j, k$ elements of $D.to_glue_data.J$, $U$ an open subset of the pullback of $D.to_glue_data.f i j$ and $D.to_glue_data.f i k$, $X'$ an object of $C$, and $f'$ a morphism from the pullback of $D.to_glue_data.t k i$ and $D.to_glue_data.V (k, i)$ to $X'$. Then the following diagram commutes."}
{"name": "antitone.map_bdd_above", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem antitone.map_bdd_above {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : antitone f) {s : set \u03b1} :\n\tbdd_above s \u2192 bdd_below (f '' s) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an antitone function. If $A$ is bounded above, then $B$ is bounded below."}
{"name": "ideal.prime_iff_is_prime", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/dedekind_domain/ideal.lean", "formal_statement": "theorem ideal.prime_iff_is_prime {A : Type*} [comm_ring A] [is_domain A]\n\t[is_dedekind_domain A] {P : ideal A} (hP : P \u2260 \u22a5) :\n\tprime P \u2194 P.is_prime :=", "nl_statement_of_codex": "Let $A$ be a Dedekind domain. Then an ideal $P$ of $A$ is prime if and only if $P$ is a prime ideal."}
{"name": "NFA.to_\u03b5_NFA_\u03b5_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/epsilon_NFA.lean", "formal_statement": "theorem NFA.to_\u03b5_NFA_\u03b5_closure {\u03b1 : Type u} {\u03c3 : Type v} (M : NFA \u03b1 \u03c3)\n\t(S : set \u03c3) :\n\tM.to_\u03b5_NFA.\u03b5_closure S = S :=", "nl_statement_of_codex": "Let $M$ be an NFA and let $S$ be a set of states of $M$. Then the $\\epsilon$-closure of $S$ in $M$ is equal to $S$."}
{"name": "forall_true_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem forall_true_iff {\u03b1 : Sort u_1} :\n\t\u03b1 \u2192 true \u2194 true :=", "nl_statement_of_codex": "For any type $\u03b1$, the statement '$\\forall x:\u03b1, true$' is equivalent to the statement '$true$'."}
{"name": "monoid.is_torsion.torsion_eq_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/torsion.lean", "formal_statement": "theorem monoid.is_torsion.torsion_eq_top {G : Type*} [comm_monoid G]\n\t(tG : monoid.is_torsion G) :\n\tcomm_monoid.torsion G = \u22a4 :=", "nl_statement_of_codex": "If $G$ is a commutative monoid with torsion, then the torsion submonoid of $G$ is the whole of $G$."}
{"name": "first_order.language.Theory.Model.reduct_carrier", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/bundled.lean", "formal_statement": "theorem first_order.language.Theory.Model.reduct_carrier\n\t{L : first_order.language} {T : L.Theory} {L' : first_order.language}\n\t(\u03c6 : L \u2192\u1d38 L') (M : (\u03c6.on_Theory T).Model) :\n\t\u21a5(first_order.language.Theory.Model.reduct \u03c6 M) = \u21a5M :=", "nl_statement_of_codex": "Let $L$ be a first-order language, $T$ a theory in $L$, $L'$ a first-order language, and $\\varphi:L\\to L'$ a morphism of languages. Let $M$ be a model of $T$. Then the carrier of the reduct of $M$ to $L'$ is the same as the carrier of $M$."}
{"name": "real.cos_sub_two_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem real.cos_sub_two_pi (x : \u211d) :\n\treal.cos (x - 2 * real.pi) = real.cos x :=", "nl_statement_of_codex": "$\\cos(x-2\\pi)=\\cos(x)$."}
{"name": "measure_theory.L1.simple_func.set_to_L1s_clm_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/set_to_l1.lean", "formal_statement": "theorem measure_theory.L1.simple_func.set_to_L1s_clm_nonneg {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {G' G'' : Type*}\n\t[normed_lattice_add_comm_group G''] [normed_space \u211d G'']\n\t[normed_lattice_add_comm_group G'] [normed_space \u211d G']\n\t{T : set \u03b1 \u2192 (G' \u2192L[\u211d] G'')} {C : \u211d}\n\t(hT : measure_theory.dominated_fin_meas_additive \u03bc T C)\n\t(hT_nonneg : \u2200 (s : set \u03b1), measurable_set s \u2192 \u21d1\u03bc s < \u22a4 \u2192 \u2200 (x : G'), 0 \u2264 x \u2192 0 \u2264 \u21d1(T s) x)\n\t{f : \u21a5(measure_theory.Lp.simple_func G' 1 \u03bc)} (hf : 0 \u2264 f) :\n\t0 \u2264 \u21d1(measure_theory.L1.simple_func.set_to_L1s_clm \u03b1 G' \u03bc hT) f :=", "nl_statement_of_codex": "Let $T:2^X\\to L^1(X,\\mu)$ be a finitely additive set function. Suppose that $T$ is dominated by a constant $C$ and that $T$ is nonnegative. Let $f\\in L^1(X,\\mu)$ be nonnegative. Then the function $f\\mapsto \\int_X T(E)f\\,d\\mu$ is nonnegative."}
{"name": "ordnode.bounded.weak_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.bounded.weak_left {\u03b1 : Type*} [preorder \u03b1] {t : ordnode \u03b1}\n\t{o\u2081 : with_bot \u03b1} {o\u2082 : with_top \u03b1} :\n\tt.bounded o\u2081 o\u2082 \u2192 t.bounded \u22a5 o\u2082 :=", "nl_statement_of_codex": "Let $t$ be an ordnode. If $t$ is bounded above and below, then $t$ is bounded above."}
{"name": "setoid.is_partition.pairwise_disjoint", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/setoid/partition.lean", "formal_statement": "theorem setoid.is_partition.pairwise_disjoint {\u03b1 : Type*} { : set (set \u03b1)}\n\t(hc : setoid.is_partition c) :\n\tc.pairwise_disjoint id :=", "nl_statement_of_codex": "Let $c$ be a partition of a set $X$. Then the sets in $c$ are pairwise disjoint."}
{"name": "add_add_sub_cancel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem add_add_sub_cancel {G : Type*} [add_comm_group G] (a b c : G) :\n\ta + c + (b - c) = a + b :=", "nl_statement_of_codex": "Let $G$ be an abelian group. Then $a+c+(b-c)=a+b$ for all $a,b,c\\in G$."}
{"name": "cardinal.bit0_le_bit1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/ordinal.lean", "formal_statement": "theorem cardinal.bit0_le_bit1 {a b : cardinal} :\n\tbit0 a \u2264 bit1 b \u2194 a \u2264 b :=", "nl_statement_of_codex": "$2^a\\leq 2^{2b}$ if and only if $a\\leq b$."}
{"name": "tactic.ring_exp.mul_pf_c_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/ring_exp.lean", "formal_statement": "theorem tactic.ring_exp.mul_pf_c_prod {\u03b1 : Type u} [comm_semiring \u03b1]\n\t{ps qqs q qs pqs : \u03b1} :\n\tqqs = q * qs \u2192 ps * qs = pqs \u2192 ps * qqs = q * pqs :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring. Let $p, q, qs, ps, pqs, qqs$ be elements of $R$. If $qqs=q\\cdot qs$ and $ps\\cdot qs=pqs$, then $ps\\cdot qqs=q\\cdot pqs$."}
{"name": "first_order.language.Theory.exists_large_model_of_infinite_model", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/satisfiability.lean", "formal_statement": "theorem first_order.language.Theory.exists_large_model_of_infinite_model\n\t{L : first_order.language} (T : L.Theory) (\u03ba : cardinal) (M : Type w')\n\t[L.Structure M] [M \u22a8 T] [infinite M] :\n\t\u2203 (N : T.Model), \u03ba.lift \u2264 cardinal.mk \u21a5N :=", "nl_statement_of_codex": "Let $T$ be a first-order theory in a language $L$ and let $M$ be an infinite model of $T$. Then there is a model $N$ of $T$ such that $|N|\\geq |M|$."}
{"name": "filter.eventually_Sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.eventually_Sup {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} {fs : set (filter \u03b1)} :\n\t(\u2200\u1da0 (x : \u03b1) in has_Sup.Sup fs, p x) \u2194 \u2200 (f : filter \u03b1), f \u2208 fs \u2192 (\u2200\u1da0 (x : \u03b1) in f, p x) :=", "nl_statement_of_codex": "Let $p$ be a property of elements of a set $X$. Then the following are equivalent:\n(1) For every $x\\in X$, $p(x)$ holds.\n(2) For every filter $f$ on $X$, if $f$ is a member of a set $F$ of filters on $X$, then $p(x)$ holds for every $x\\in f$."}
{"name": "representation.average_map_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/representation_theory/invariants.lean", "formal_statement": "theorem representation.average_map_id {k G V : Type*} [comm_semiring k]\n\t[group G] [add_comm_monoid V] [module k V] (\u03c1 : representation k G V)\n\t[fintype G] [invertible \u2191(fintype.card G)] (v : V) (hv : v \u2208 \u03c1.invariants) :\n\t\u21d1(\u03c1.average_map) v = v :=", "nl_statement_of_codex": "Let $G$ be a finite group and let $V$ be a $G$-module. Then the average map $\\overline{\\rho}$ is the identity on the invariant subspace $V^G$."}
{"name": "box_integral.box.split_upper_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/split.lean", "formal_statement": "theorem box_integral.box.split_upper_le {\u03b9 : Type*} {I : box_integral.box \u03b9}\n\t{i : \u03b9} {x : \u211d} :\n\tI.split_upper i x \u2264 \u2191I :=", "nl_statement_of_codex": "Let $I$ be a box integral. Then the upper sum of $I$ is greater than or equal to the upper sum of the box integral obtained by splitting $I$ at $i$."}
{"name": "vector_span_range_eq_span_range_vsub_right_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_subspace.lean", "formal_statement": "theorem vector_span_range_eq_span_range_vsub_right_ne (k : Type*) {V P : Type*}\n\t[ring k] [add_comm_group V] [module k V] [add_torsor V P] {\u03b9 : Type*}\n\t(p : \u03b9 \u2192 P) (i\u2080 : \u03b9) :\n\tvector_span k (set.range p) = submodule.span k (set.range (\u03bb (i : {x // x \u2260 i\u2080}), p \u2191i -\u1d65 p i\u2080)) :=", "nl_statement_of_codex": "Let $V$ be a $k$-module and let $P$ be an $V$-torsor. Let $p:\\mathbb{I}\\to P$ be a function. Then the vector span of the range of $p$ is equal to the vector span of the range of the function $i\\mapsto p(i)-p(i_0)$."}
{"name": "matrix.block_diag_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/block.lean", "formal_statement": "theorem matrix.block_diag_add {m n o \u03b1 : Type*2} [add_zero_class \u03b1]\n\t(M N : matrix (m \u00d7 o) (n \u00d7 o) \u03b1) :\n\t(M + N).block_diag = M.block_diag + N.block_diag :=", "nl_statement_of_codex": "Let $M$ and $N$ be matrices of size $m\\times n$ and $m\\times o$ respectively. Then the block diagonal of $M+N$ is the sum of the block diagonals of $M$ and $N$."}
{"name": "submodule.fg_restrict_scalars", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem submodule.fg_restrict_scalars {R S M : Type*} [comm_semiring R]\n\t[semiring S] [algebra R S] [add_comm_group M] [module S M] [module R M]\n\t[is_scalar_tower R S M] (N : submodule S M) (hfin : N.fg)\n\t(h : function.surjective \u21d1(algebra_map R S)) :\n\t(submodule.restrict_scalars R N).fg :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $S$ a semiring, $M$ an $S$-module, and $N$ a submodule of $M$. Suppose that $N$ is finitely generated and that the map $R\\to S$ is surjective. Then the submodule of $M$ generated by $N$ as an $R$-module is finitely generated."}
{"name": "add_monoid.closure.is_add_submonoid", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/submonoid.lean", "formal_statement": "theorem add_monoid.closure.is_add_submonoid {M : Type*} [add_monoid M]\n\t(s : set M) :\n\tis_add_submonoid (add_monoid.closure s) :=", "nl_statement_of_codex": "The closure of a subset $S$ of an additive monoid $M$ is an additive submonoid of $M$."}
{"name": "multiset.nodup.le_dedup_iff_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/dedup.lean", "formal_statement": "theorem multiset.nodup.le_dedup_iff_le {\u03b1 : Type*} [decidable_eq \u03b1]\n\t{s t : multiset \u03b1} (hno : s.nodup) :\n\ts \u2264 t.dedup \u2194 s \u2264 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be multisets. If $s$ has no duplicates, then $s\\leq t$ if and only if $s\\leq t$ with duplicates removed."}
{"name": "measure_theory.simple_func.const_mul_lintegral", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.simple_func.const_mul_lintegral {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t(f : measure_theory.simple_func \u03b1 ennreal) (x : ennreal) :\n\t(measure_theory.simple_func.const \u03b1 x * f).lintegral \u03bc = x * f.lintegral \u03bc :=", "nl_statement_of_codex": "Let $f$ be a simple function on a measurable space $(X,\\mathcal{A})$ and let $\\mu$ be a measure on $(X,\\mathcal{A})$. Then $\\int_X xf\\,d\\mu=x\\int_X f\\,d\\mu$."}
{"name": "int.le_of_add_le_add_left", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.le_of_add_le_add_left {a b c : \u2124} (h : a + b \u2264 a + c) :\n\tb \u2264 c :=", "nl_statement_of_codex": "If $a+b\\leq a+c$, then $b\\leq c$."}
{"name": "seminorm_family.basis_sets_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/with_seminorms.lean", "formal_statement": "theorem seminorm_family.basis_sets_neg {\ud835\udd5c E \u03b9 : Type*} [normed_field \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] (p : seminorm_family \ud835\udd5c E \u03b9) (U : set E)\n\t(hU' : U \u2208 p.basis_sets) :\n\t\u2203 (V : set E) (H : V \u2208 p.basis_sets), V \u2286 (\u03bb (x : E), -x) \u207b\u00b9' U :=", "nl_statement_of_codex": "Let $p$ be a seminorm family on $E$ and let $U$ be a basis set for $p$. Then there is a basis set $V$ for $p$ such that $V\\subset -U$."}
{"name": "mv_polynomial.bind\u2081_bind\u2081", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/monad.lean", "formal_statement": "theorem mv_polynomial.bind\u2081_bind\u2081 {\u03c3 \u03c4 R : Type*} [comm_semiring R] {\u03c5 : Type*}\n\t(f : \u03c3 \u2192 mv_polynomial \u03c4 R) (g : \u03c4 \u2192 mv_polynomial \u03c5 R) (\u03c6 : mv_polynomial \u03c3 R) :\n\t\u21d1(mv_polynomial.bind\u2081 g) (\u21d1(mv_polynomial.bind\u2081 f) \u03c6) = \u21d1(mv_polynomial.bind\u2081 (\u03bb (i : \u03c3), \u21d1(mv_polynomial.bind\u2081 g) (f i))) \u03c6 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $\\sigma, \\tau, \\upsilon$ be types, let $f:\\sigma\\to \\mathbb{Z}[\\tau]$, let $g:\\tau\\to \\mathbb{Z}[\\upsilon]$, and let $\\phi\\in \\mathbb{Z}[\\sigma]$. Then $(g\\circ f)\\circ \\phi = (g\\circ f)\\circ \\phi$."}
{"name": "category_theory.monad.id_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/basic.lean", "formal_statement": "theorem category_theory.monad.id_coe (C : Type u\u2081) [category_theory.category C] :\n\t\u2191(category_theory.monad.id C) = \ud835\udfed C :=", "nl_statement_of_codex": "The identity monad on a category $C$ is the identity functor on $C$."}
{"name": "asymptotics.is_O_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_zero {\u03b1 F E' : Type*} [has_norm F]\n\t[semi_normed_group E'] (g : \u03b1 \u2192 F) (l : filter \u03b1) :\n\t(\u03bb (x : \u03b1), 0) =O[l] g :=", "nl_statement_of_codex": "Let $g:\\alpha\\to F$ be a function. Then $0=O(g)$."}
{"name": "category_theory.limits.biprod.inr_cokernel_cofork_\u03c0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.biprod.inr_cokernel_cofork_\u03c0 {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t(X Y : C) [category_theory.limits.has_binary_biproduct X Y] :\n\tcategory_theory.limits.cofork.\u03c0 (category_theory.limits.biprod.inr_cokernel_cofork X Y) = category_theory.limits.biprod.fst :=", "nl_statement_of_codex": "The projection of the cokernel of the morphism $X\\oplus Y\\to Y$ is the first projection $X\\oplus Y\\to X$."}
{"name": "pochhammer_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/pochhammer.lean", "formal_statement": "theorem pochhammer_map {S : Type u} [semiring S] {T : Type v} [semiring T]\n\t(f : S \u2192+* T) (n : \u2115) :\n\tpolynomial.map f (pochhammer S n) = pochhammer T n :=", "nl_statement_of_codex": "Let $f:S\\to T$ be a semiring homomorphism. Then $f$ maps the pochhammer polynomial $p_n(x)$ to the pochhammer polynomial $p_n(f(x))$."}
{"name": "matrix.det_update_row_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/determinant.lean", "formal_statement": "theorem matrix.det_update_row_add {n : Type*} [decidable_eq n] [fintype n]\n\t{R : Type v} [comm_ring R] (M : matrix n n R) (j : n) (u v : n \u2192 R) :\n\t(M.update_row j (u + v)).det = (M.update_row j u).det + (M.update_row j v).det :=", "nl_statement_of_codex": "Let $M$ be an $n\\times n$ matrix over a commutative ring $R$. Let $u,v:n\\to R$ be functions. Then $\\det(M+u+v)=\\det(M+u)+\\det(M+v)$."}
{"name": "int.cInf_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/order.lean", "formal_statement": "theorem int.cInf_mem {s : set \u2124} (h1 : s.nonempty) (h2 : bdd_below s) :\n\thas_Inf.Inf s \u2208 s :=", "nl_statement_of_codex": "The infimum of a nonempty set $S$ of integers is an element of $S$."}
{"name": "cont_diff_bump.tsupport_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/specific_functions.lean", "formal_statement": "theorem cont_diff_bump.tsupport_eq {E : Type*} [normed_group E]\n\t[normed_space \u211d E] [finite_dimensional \u211d E] { : E} (f : cont_diff_bump c) :\n\ttsupport \u21d1f = euclidean.closed_ball c f.to_cont_diff_bump_of_inner.R :=", "nl_statement_of_codex": "Let $E$ be a finite dimensional normed space over $\\mathbb{R}$. Let $f$ be a bump function with center $c$. Then the support of $f$ is the closed ball of radius $f.to_cont_diff_bump_of_inner.R$ centered at $c$."}
{"name": "norm_exp_series_div_summable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/exponential.lean", "formal_statement": "theorem norm_exp_series_div_summable (\ud835\udd42 : Type*) {\ud835\udd38 : Type*} [is_R_or_C \ud835\udd42]\n\t[normed_division_ring \ud835\udd38] [normed_algebra \ud835\udd42 \ud835\udd38] (x : \ud835\udd38) :\n\tsummable (\u03bb (n : \u2115), \u2225x ^ n / \u2191(n.factorial)\u2225) :=", "nl_statement_of_codex": "The series $\\sum_{n=0}^\\infty \\frac{x^n}{n!}$ is absolutely convergent."}
{"name": "quaternion_algebra.equiv_prod_symm_apply_im_i", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion_algebra.equiv_prod_symm_apply_im_i {R : Type*} (c\u2081 c\u2082 : R)\n\t(a : R \u00d7 R \u00d7 R \u00d7 R) :\n\t(\u21d1((quaternion_algebra.equiv_prod c\u2081 c\u2082).symm) a).im_i = a.snd.fst :=", "nl_statement_of_codex": "Let $R$ be a ring and let $c_1, c_2\\in R$. Then the imaginary part of the quaternion algebra $A=\\{a_0+a_1i+a_2j+a_3k\\mid a_0, a_1, a_2, a_3\\in R\\}$ with $i^2=c_1$, $j^2=c_2$, $ij=-ji$ is equal to the second component of the second component of the tuple $(a_0, a_1, a_2, a_3)$."}
{"name": "bornology.is_vonN_bounded_covers", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/bounded.lean", "formal_statement": "theorem bornology.is_vonN_bounded_covers {\ud835\udd5c E : Type*} [normed_field \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] [topological_space E] [has_continuous_smul \ud835\udd5c E] :\n\t\u22c3\u2080 set_of (bornology.is_vonN_bounded \ud835\udd5c) = set.univ :=", "nl_statement_of_codex": "The union of all von Neumann bounded sets is the whole space."}
{"name": "ring_hom_inv_pair.symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/comp_typeclasses.lean", "formal_statement": "theorem ring_hom_inv_pair.symm {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082]\n\t(\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082) (\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081) [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] :\n\tring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082 :=", "nl_statement_of_codex": "Let $R_1$ and $R_2$ be semirings and let $\\sigma_{12}:R_1\\to R_2$ and $\\sigma_{21}:R_2\\to R_1$ be ring homomorphisms. If $\\sigma_{12}$ is a bijection and $\\sigma_{21}$ is its inverse, then $\\sigma_{21}$ is a bijection and $\\sigma_{12}$ is its inverse."}
{"name": "ideal.map_eq_bot_iff_le_ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.map_eq_bot_iff_le_ker {R S F : Type*} [semiring R] [semiring S]\n\t[rc : ring_hom_class F R S] {I : ideal R} (f : F) :\n\tideal.map f I = \u22a5 \u2194 I \u2264 ring_hom.ker f :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings and let $f:R\\to S$ be a ring homomorphism. Then $f(I)=\\{0\\}$ if and only if $I\\subseteq \\ker f$."}
{"name": "monoid_with_zero_hom.with_top_map_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem monoid_with_zero_hom.with_top_map_apply {R S : Type*}\n\t[mul_zero_one_class R] [decidable_eq R] [nontrivial R] [mul_zero_one_class S]\n\t[decidable_eq S] [nontrivial S] (f : R \u2192*\u2080 S) (hf : function.injective \u21d1f) :\n\t\u21d1(f.with_top_map hf) = with_top.map \u21d1f :=", "nl_statement_of_codex": "Let $R$ and $S$ be nontrivial commutative rings with identity. Let $f:R\\to S$ be a monoid homomorphism. Then the map $f$ induces a monoid homomorphism $f:R\\cup\\{\\infty\\}\\to S\\cup\\{\\infty\\}$."}
{"name": "measurable_set_preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_set_preimage {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2}\n\t{m : measurable_space \u03b1} {m\u03b2 : measurable_space \u03b2} {t : set \u03b2}\n\t(hf : measurable f) (ht : measurable_set t) :\n\tmeasurable_set (f \u207b\u00b9' t) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a measurable function between measurable spaces $X$ and $Y$. Then the preimage of a measurable set $A\\subset Y$ is measurable."}
{"name": "list.pw_filter_sublist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/pairwise.lean", "formal_statement": "theorem list.pw_filter_sublist {\u03b1 : Type*} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [decidable_rel R]\n\t(l : list \u03b1) :\n\tlist.pw_filter R l <+ l :=", "nl_statement_of_codex": "The list of pairs of elements of a list $l$ that are related by $R$ is a sublist of $l$."}
{"name": "power_basis.lift_equiv_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_basis.lean", "formal_statement": "theorem power_basis.lift_equiv_apply_coe {S : Type*} [comm_ring S] {A : Type*}\n\t[comm_ring A] [algebra A S] {S' : Type*} [comm_ring S'] [algebra A S']\n\t[is_domain A] (pb : power_basis A S) (f : S \u2192\u2090[A] S') :\n\t\u2191(\u21d1(pb.lift_equiv) f) = \u21d1f pb.gen :=", "nl_statement_of_codex": "Let $A$ be a domain and let $S$ and $S'$ be $A$-algebras. Let $pb$ be a power basis of $S$ and let $f:S\\to S'$ be an $A$-algebra homomorphism. Then the power basis of $S'$ obtained by lifting $pb$ to $S'$ via $f$ is the same as the power basis of $S'$ obtained by applying $f$ to the power basis $pb$ of $S$."}
{"name": "nat.bodd_mul", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/bitwise.lean", "formal_statement": "theorem nat.bodd_mul (m n : \u2115) :\n\t(m * n).bodd = m.bodd && n.bodd :=", "nl_statement_of_codex": "The product of two odd numbers is odd."}
{"name": "polynomial.as_sum_range", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.as_sum_range {R : Type u} [semiring R] (p : polynomial R) :\n\tp = (finset.range (p.nat_degree + 1)).sum (\u03bb (i : \u2115), \u21d1(polynomial.monomial i) (p.coeff i)) :=", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$. Then $p$ is equal to the sum of its monomials."}
{"name": "category_theory.monad.algebra_functor_of_monad_hom_obj_a", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/algebra.lean", "formal_statement": "theorem category_theory.monad.algebra_functor_of_monad_hom_obj_a {C : Type u\u2081}\n\t[category_theory.category C] {T\u2081 T\u2082 : category_theory.monad C} (h : T\u2082 \u27f6 T\u2081)\n\t(A : T\u2081.algebra) :\n\t((category_theory.monad.algebra_functor_of_monad_hom h).obj A).a = h.to_nat_trans.app A.A \u226b A.a :=", "nl_statement_of_codex": "Let $T_1$ and $T_2$ be monads on a category $C$ and let $h:T_2\\to T_1$ be a monad homomorphism. Let $A$ be an algebra for $T_1$. Then the algebra structure of the object $h^*A$ of the category of $T_2$-algebras is given by the composite $h^*A\\xrightarrow{h^*A.a}T_2A\\xrightarrow{T_2A.a}A$."}
{"name": "is_algebraic_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/algebraic.lean", "formal_statement": "theorem is_algebraic_one {R : Type u} {A : Type v} [comm_ring R] [ring A]\n\t[algebra R A] [nontrivial R] :\n\tis_algebraic R 1 :=", "nl_statement_of_codex": "Let $R$ be a nontrivial commutative ring and let $A$ be an $R$-algebra. Then $1\\in A$ is algebraic over $R$."}
{"name": "has_deriv_within_at.neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_within_at.neg {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c}\n\t{s : set \ud835\udd5c} (h : has_deriv_within_at f f' s x) :\n\thas_deriv_within_at (\u03bb (x : \ud835\udd5c), -f x) (-f') s x :=", "nl_statement_of_codex": "Let $f:U\\to\\mathbb{R}^n$ be differentiable at $x\\in U$. Then $-f$ is differentiable at $x$ and $(-f)'(x)=-f'(x)$."}
{"name": "typevec.drop_fun_from_append1_drop_last", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/typevec.lean", "formal_statement": "theorem typevec.drop_fun_from_append1_drop_last {n : \u2115} {\u03b1 : typevec (n + 1)} :\n\ttypevec.drop_fun typevec.from_append1_drop_last = typevec.id :=", "nl_statement_of_codex": "The function $f:\\mathbb{N}^{n+1}\\to\\mathbb{N}^n$ defined by $f(x_1,\\ldots,x_{n+1})=(x_1,\\ldots,x_n)$ is the identity function."}
{"name": "pgame.domineering.card_of_mem_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/domineering.lean", "formal_statement": "theorem pgame.domineering.card_of_mem_right {b : pgame.domineering.board}\n\t{m : \u2124 \u00d7 \u2124} (h : m \u2208 pgame.domineering.right b) :\n\t2 \u2264 finset.card b :=", "nl_statement_of_codex": "If $m$ is a move in the right player's strategy in the game of domineering, then the board has at least two squares."}
{"name": "liouville_with.int_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/liouville/liouville_with.lean", "formal_statement": "theorem liouville_with.int_mul {p x : \u211d} {m : \u2124} (h : liouville_with p x)\n\t(hm : m \u2260 0) :\n\tliouville_with p (\u2191m * x) :=", "nl_statement_of_codex": "If $x$ is a Liouville number with respect to $p$, then $mx$ is a Liouville number with respect to $p$ for any nonzero integer $m$."}
{"name": "finset.empty_product", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/prod.lean", "formal_statement": "theorem finset.empty_product {\u03b1 \u03b2 : Type*} (t : finset \u03b2) :\n\t\u2205.product t = \u2205 :=", "nl_statement_of_codex": "The product of the empty set with any set is the empty set."}
{"name": "computation.lift_rel_aux.ret_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.lift_rel_aux.ret_right {\u03b1 : Type u} {\u03b2 : Type v}\n\t(R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : computation \u03b1 \u2192 computation \u03b2 \u2192 Prop) (b : \u03b2)\n\t(ca : computation \u03b1) :\n\tcomputation.lift_rel_aux R C ca.destruct (sum.inl b) \u2194 \u2203 {a : \u03b1}, a \u2208 ca \u2227 R a b :=", "nl_statement_of_codex": "Let $R$ be a relation on $\u03b1$ and $\u03b2$. Let $C$ be a relation on computations of $\u03b1$ and $\u03b2$. Let $b$ be an element of $\u03b2$ and let $ca$ be a computation of $\u03b1$. Then $ca$ is related to $b$ by $C$ if and only if there is an element $a$ of $ca$ such that $a$ is related to $b$ by $R$."}
{"name": "is_open_set_of_nat_le_rank", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/finite_dimension.lean", "formal_statement": "theorem is_open_set_of_nat_le_rank {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type v} [normed_group E] [normed_space \ud835\udd5c E] {F : Type w} [normed_group F]\n\t[normed_space \ud835\udd5c F] [complete_space \ud835\udd5c] (n : \u2115) :\n\tis_open {f : E \u2192L[\ud835\udd5c] F | \u2191n \u2264 rank \u2191f} :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Then the set of linear maps $f:E\\to F$ with rank at most $n$ is open."}
{"name": "metric.bounded.exists_norm_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/pointwise.lean", "formal_statement": "theorem metric.bounded.exists_norm_le {E : Type*} [semi_normed_group E]\n\t{s : set E} :\n\tmetric.bounded s \u2192 (\u2203 (R : \u211d), \u2200 (x : E), x \u2208 s \u2192 \u2225x\u2225 \u2264 R) :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $s$ be a bounded subset of $E$. Then there is a real number $R$ such that $\\|x\\|\\leq R$ for all $x\\in s$."}
{"name": "bernstein_polynomial.map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/bernstein.lean", "formal_statement": "theorem bernstein_polynomial.map {R : Type*} [comm_ring R] {S : Type*}\n\t[comm_ring S] (f : R \u2192+* S) (n \u03bd : \u2115) :\n\tpolynomial.map f (bernstein_polynomial R n \u03bd) = bernstein_polynomial S n \u03bd :=", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings and let $f:R\\to S$ be a ring homomorphism. Then $f$ maps the Bernstein polynomial $B_n^\\nu$ to the Bernstein polynomial $B_n^\\nu$."}
{"name": "equiv.Pi_congr_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/basic.lean", "formal_statement": "theorem equiv.Pi_congr_symm_apply {\u03b1 : Sort u} {\u03b2 : Sort v} {W : \u03b1 \u2192 Sort w}\n\t{Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u03a0 (a : \u03b1), W a \u2243 Z (\u21d1h\u2081 a))\n\t(f : \u03a0 (b : \u03b2), Z b) :\n\t\u21d1((h\u2081.Pi_congr h\u2082).symm) f = \u03bb (a : \u03b1), \u21d1((h\u2082 a).symm) (f (\u21d1h\u2081 a)) :=", "nl_statement_of_codex": "Let $h_1:A\\to B$ and $h_2:W\\to Z$ be two bijections. Then the bijection $h_1\\times h_2:A\\times W\\to B\\times Z$ is the inverse of the bijection $h_1\\times h_2:B\\times Z\\to A\\times W$."}
{"name": "filter.map_inf_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.map_inf_le {\u03b1 : Type u} {\u03b2 : Type v} {f g : filter \u03b1} {m : \u03b1 \u2192 \u03b2} :\n\tfilter.map m (f \u2293 g) \u2264 filter.map m f \u2293 filter.map m g :=", "nl_statement_of_codex": "Let $f$ and $g$ be filters on a set $X$ and let $m:X\\to Y$ be a function. Then $m(f\\cap g)\\subseteq m(f)\\cap m(g)$."}
{"name": "linear_isometry_equiv.map_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem linear_isometry_equiv.map_zero {R R\u2082 E E\u2082 : Type*} [semiring R]\n\t[semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n\t[ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [semi_normed_group E] [semi_normed_group E\u2082]\n\t[module R E] [module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\t\u21d1e 0 = 0 :=", "nl_statement_of_codex": "Let $E$ and $E'$ be semi-normed groups over a semiring $R$ and let $e:E\\to E'$ be a linear isometry. Then $e(0)=0$."}
{"name": "measure_theory.vector_measure.of_disjoint_Union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/vector_measure.lean", "formal_statement": "theorem measure_theory.vector_measure.of_disjoint_Union {\u03b1 \u03b2 : Type*}\n\t{m : measurable_space \u03b1} {M : Type*} [add_comm_monoid M] [topological_space M]\n\t[t2_space M] {v : measure_theory.vector_measure \u03b1 M} [encodable \u03b2]\n\t{f : \u03b2 \u2192 set \u03b1} (hf\u2081 : \u2200 (i : \u03b2), measurable_set (f i))\n\t(hf\u2082 : pairwise (disjoint on f)) :\n\t\u21d1v (\u22c3 (i : \u03b2), f i) = \u2211' (i : \u03b2), \u21d1v (f i) :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $M$ be a topological space. Let $v$ be a vector measure on $X$ with values in $M$. Let $f:I\\to \\mathcal{P}(X)$ be a family of measurable sets such that the sets $f(i)$ are pairwise disjoint. Then $v(\\bigcup_{i\\in I}f(i))=\\sum_{i\\in I}v(f(i))$."}
{"name": "category_theory.limits.cones.equivalence_of_reindexing_unit_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.limits.cones.equivalence_of_reindexing_unit_iso\n\t{J : Type u\u2081} [category_theory.category J] {K : Type u\u2082}\n\t[category_theory.category K] {C : Type u\u2083} [category_theory.category C]\n\t{F : J \u2964 C} {G : K \u2964 C} (e : K \u224c J) (\u03b1 : e.functor \u22d9 F \u2245 G) :\n\t(category_theory.limits.cones.equivalence_of_reindexing e \u03b1).unit_iso = category_theory.nat_iso.of_components (\u03bb (s : category_theory.limits.cone F), category_theory.limits.cones.ext (category_theory.iso.refl s.X) _) _ \u226a\u226b category_theory.iso_whisker_left (category_theory.limits.cones.whiskering e.functor) (category_theory.iso_whisker_right (category_theory.nat_iso.of_components (\u03bb (s : category_theory.limits.cone (e.functor \u22d9 F)), category_theory.limits.cones.ext (category_theory.iso.refl s.X) _) _) (category_theory.limits.cones.whiskering e.inverse \u22d9 category_theory.limits.cones.postcompose (e.inv_fun_id_assoc F).hom)) :=", "nl_statement_of_codex": "Let $J, K, C$ be categories and let $F:J\\to C$ and $G:K\\to C$ be functors. Let $e:K\\to J$ be an equivalence of categories. Let $\\alpha:e\\circ F\\to G$ be a natural isomorphism. Then the unit isomorphism of the equivalence of cones induced by $e$ is the composition of the following natural isomorphisms:\n\\begin{enumerate}\n\\item The natural isomorphism of functors $e\\circ F\\to G$ induced by $\\alpha$.\n\\item The natural isomorphism of functors $e\\circ F\\to e\\"}
{"name": "real.supr_mul_of_nonpos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/pointwise.lean", "formal_statement": "theorem real.supr_mul_of_nonpos {\u03b9 : Sort u_1} {r : \u211d} (ha : r \u2264 0) (f : \u03b9 \u2192 \u211d) :\n\t(\u2a06 (i : \u03b9), f i) * r = \u2a05 (i : \u03b9), f i * r :=", "nl_statement_of_codex": "Let $f:\\mathbb{R}\\to\\mathbb{R}$ be a function. Then $\\sup_{x\\in\\mathbb{R}}f(x)\\cdot r=\\inf_{x\\in\\mathbb{R}}f(x)\\cdot r$ for all $r\\leq 0$."}
{"name": "simple_graph.walk.is_trail.rotate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.is_trail.rotate {V : Type u} {G : simple_graph V}\n\t[decidable_eq V] {u v : V} { : G.walk v v} (hc : c.is_trail)\n\t(h : u \u2208 c.support) :\n\t(c.rotate h).is_trail :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $c$ be a trail in $G$. Let $u$ be a vertex in the support of $c$. Then the walk $c$ rotated at $u$ is a trail."}
{"name": "category_theory.limits.bicone_\u03b9_\u03c0_self_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.bicone_\u03b9_\u03c0_self_assoc {J : Type w} {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{F : J \u2192 C} (B : category_theory.limits.bicone F) (j : J) {X' : C}\n\t(f' : F j \u27f6 X') :\n\tB.\u03b9 j \u226b B.\u03c0 j \u226b f' = f' :=", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor and let $B$ be a bicone for $F$. Then for any $j\\in J$ and any morphism $f':F(j)\\to X'$, we have $B_{\\iota}(j)\\circ B_{\\pi}(j)\\circ f'=f'$."}
{"name": "list.to_finset_reverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem list.to_finset_reverse {\u03b1 : Type*} [decidable_eq \u03b1] {l : list \u03b1} :\n\tl.reverse.to_finset = l.to_finset :=", "nl_statement_of_codex": "The finite set corresponding to the reverse of a list is the same as the finite set corresponding to the list."}
{"name": "list.prev_cons_cons_eq'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/cycle.lean", "formal_statement": "theorem list.prev_cons_cons_eq' {\u03b1 : Type*} [decidable_eq \u03b1] (l : list \u03b1)\n\t(x y z : \u03b1) (h : x \u2208 y :: z :: l) (hx : x = y) :\n\t(y :: z :: l).prev x h = (z :: l).last _ :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b1$ with decidable equality. Let $x,y,z$ be elements of $\u03b1$. If $x=y$ and $x$ is in the list $y::z::l$, then the last element of the list $z::l$ is the previous element of $x$ in the list $y::z::l$."}
{"name": "category_theory.mono_over.pullback_obj_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/mono_over.lean", "formal_statement": "theorem category_theory.mono_over.pullback_obj_left {C : Type u\u2081}\n\t[category_theory.category C] {X Y : C} [category_theory.limits.has_pullbacks C]\n\t(f : X \u27f6 Y) (g : category_theory.mono_over Y) :\n\t\u2191((category_theory.mono_over.pullback f).obj g) = category_theory.limits.pullback g.arrow f :=", "nl_statement_of_codex": "Let $C$ be a category with pullbacks. Let $f:X\\to Y$ and $g:Z\\to Y$ be morphisms in $C$. Then the pullback of $f$ and $g$ is the pullback of $g$ and $f$."}
{"name": "alg_equiv.smul_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.smul_def {R : Type u} {A\u2081 : Type v} [comm_semiring R]\n\t[semiring A\u2081] [algebra R A\u2081] (f : A\u2081 \u2243\u2090[R] A\u2081) (a : A\u2081) :\n\tf \u2022 a = \u21d1f a :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $A_1$ be a semiring, and let $f:A_1\\to A_1$ be an $R$-algebra isomorphism. Then $f(ra)=rf(a)$ for all $r\\in R$ and $a\\in A_1$."}
{"name": "set_pi_mem_nhds_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem set_pi_mem_nhds_iff {\u03b9 \u03b1 : \u03b9 \u2192 Type*}\n\t[\u03a0 (i : \u03b9), topological_space (\u03b1 i)] {I : set \u03b9} (hI : I.finite)\n\t{s : \u03a0 (i : \u03b9), set (\u03b1 i)} (a : \u03a0 (i : \u03b9), \u03b1 i) :\n\tI.pi s \u2208 nhds a \u2194 \u2200 (i : \u03b9), i \u2208 I \u2192 s i \u2208 nhds (a i) :=", "nl_statement_of_codex": "Let $I$ be a finite set and let $s_i$ be a subset of $X_i$ for each $i\\in I$. Then $s_i$ is a neighborhood of $a_i$ for each $i\\in I$ if and only if $\\prod_{i\\in I}s_i$ is a neighborhood of $\\prod_{i\\in I}a_i$."}
{"name": "category_theory.hom_orthogonal.matrix_decomposition_linear_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/preadditive/hom_orthogonal.lean", "formal_statement": "theorem category_theory.hom_orthogonal.matrix_decomposition_linear_equiv_apply\n\t{C : Type u} [category_theory.category C] {\u03b9 : Type*} {s : \u03b9 \u2192 C}\n\t[category_theory.preadditive C]\n\t[category_theory.limits.has_finite_biproducts C] {R : Type*} [semiring R]\n\t[category_theory.linear R C] (o : category_theory.hom_orthogonal s)\n\t{\u03b1 \u03b2 : Type} [fintype \u03b1] [fintype \u03b2] {f : \u03b1 \u2192 \u03b9} {g : \u03b2 \u2192 \u03b9}\n\t(\u1fb0 : (\u2a01 \u03bb (a : \u03b1), s (f a)) \u27f6 \u2a01 \u03bb (b : \u03b2), s (g b)) (i : \u03b9) :\n\t\u21d1(o.matrix_decomposition_linear_equiv) \u1fb0 i = o.matrix_decomposition_add_equiv.to_fun \u1fb0 i :=", "nl_statement_of_codex": "Let $C$ be a category with finite biproducts. Let $s:\\mathbb{N}\\to C$ be a sequence of objects in $C$. Let $R$ be a semiring and let $C$ be a linear category over $R$. Let $o$ be a hom-orthogonal sequence of objects in $C$. Let $f,g:\\mathbb{N}\\to\\mathbb{N}$ be functions. Let $\\alpha,\\beta$ be finite sets. Let $\\alpha\\to\\beta$ be a morphism in $C$. Then the matrix of the morphism $\\alpha\\to\\beta$ with respect to the decomposition of $o$ is equal"}
{"name": "pgame.lf.le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/surreal/basic.lean", "formal_statement": "theorem pgame.lf.le {x y : pgame} (h : x.lf y) (ox : x.numeric) (oy : y.numeric) :\n\tx \u2264 y :=", "nl_statement_of_codex": "Let $x$ and $y$ be two positional games. If $x$ is less than or equal to $y$ in the lexicographic order, then $x$ is less than or equal to $y$ in the usual order."}
{"name": "module.free.rank_lt_aleph_0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/free_module/finite/rank.lean", "formal_statement": "theorem module.free.rank_lt_aleph_0 (R : Type u) (M : Type v) [ring R]\n\t[strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M]\n\t[module.finite R M] :\n\tmodule.rank R M < cardinal.aleph_0 :=", "nl_statement_of_codex": "Let $R$ be a ring with strong rank condition and let $M$ be a finitely generated free $R$-module. Then the rank of $M$ is less than $\\aleph_0$."}
{"name": "group_cohomology.resolution.to_tensor_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/representation_theory/group_cohomology_resolution.lean", "formal_statement": "theorem group_cohomology.resolution.to_tensor_single {k G : Type u}\n\t[comm_ring k] {n : \u2115} [group G] (f : fin (n + 1) \u2192 G) (m : k) :\n\t\u21d1((group_cohomology.resolution.to_tensor k G n).hom) (finsupp.single f m) = finsupp.single (f 0) m \u2297\u209c[k] finsupp.single (\u03bb (i : fin n), (f \u2191i)\u207b\u00b9 * f i.succ) 1 :=", "nl_statement_of_codex": "Let $G$ be a group and let $k$ be a commutative ring. Let $n$ be a natural number. Let $f: \\{0,\\ldots,n\\}\\to G$ be a function. Let $m$ be an element of $k$. Then the image of the element $f\\otimes m$ of the tensor product $k[G^{n+1}]\\otimes_k k$ under the homomorphism $k[G^{n+1}]\\otimes_k k\\to k[G]\\otimes_k k[G^n]$ is the element $f(0)\\otimes m\\otimes"}
{"name": "monotone.tendsto_nhds_within_Iio", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem monotone.tendsto_nhds_within_Iio {\u03b2 : Type v}\n\t[conditionally_complete_linear_order \u03b2] [topological_space \u03b2]\n\t[order_topology \u03b2] {\u03b1 : Type*} [linear_order \u03b1] [topological_space \u03b1]\n\t[order_topology \u03b1] {f : \u03b1 \u2192 \u03b2} (Mf : monotone f) (x : \u03b1) :\n\tfilter.tendsto f (nhds_within x (set.Iio x)) (nhds (has_Sup.Sup (f '' set.Iio x))) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a monotone function between two linearly ordered sets $X$ and $Y$. Then $f$ tends to $\\sup f(X)$ on the right."}
{"name": "ordinal.div_nonempty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.div_nonempty {a b : ordinal} (h : b \u2260 0) :\n\t{o : ordinal | a < b * order.succ o}.nonempty :=", "nl_statement_of_codex": "Let $a$ and $b$ be ordinals. If $b\\neq 0$, then there is an ordinal $o$ such that $a<b\\cdot\\mathrm{succ}(o)$."}
{"name": "nat.le_mod_add_mod_of_dvd_add_of_not_dvd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/modeq.lean", "formal_statement": "theorem nat.le_mod_add_mod_of_dvd_add_of_not_dvd {a b c : \u2115} (h : c \u2223 a + b)\n\t(ha : \u00acc \u2223 a) :\n\tc \u2264 a % c + b % c :=", "nl_statement_of_codex": "Let $a,b,c$ be natural numbers. If $c$ divides $a+b$ and $c$ does not divide $a$, then $c\\leq a\\mod c+b\\mod c$."}
{"name": "monotone_on.monovary_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monovary.lean", "formal_statement": "theorem monotone_on.monovary_on {\u03b9 \u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2} {s : set \u03b9} [linear_order \u03b9] (hf : monotone_on f s)\n\t(hg : monotone_on g s) :\n\tmonovary_on f g s :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be monotone functions. Then $f$ is monovary on $g$."}
{"name": "nat.sum_div_divisors", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/divisors.lean", "formal_statement": "theorem nat.sum_div_divisors {\u03b1 : Type*} [add_comm_monoid \u03b1] (n : \u2115) (f : \u2115 \u2192 \u03b1) :\n\tn.divisors.sum (\u03bb (d : \u2115), f (n / d)) = n.divisors.sum f :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\alpha$ be a function. Then $\\sum_{d\\mid n}f(n/d)=\\sum_{d\\mid n}f(d)$."}
{"name": "int.le_add_of_neg_le_sub_left", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.le_add_of_neg_le_sub_left {a b c : \u2124} (h : -a \u2264 b - c) :\n\tc \u2264 a + b :=", "nl_statement_of_codex": "Let $a,b,c$ be integers. If $-a\\leq b-c$, then $c\\leq a+b$."}
{"name": "finset.inf_bUnion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.inf_bUnion {\u03b1 \u03b2 \u03b3 : Type*} [semilattice_inf \u03b1] [order_top \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} [decidable_eq \u03b2] (s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b2) :\n\t(s.bUnion t).inf f = s.inf (\u03bb (x : \u03b3), (t x).inf f) :=", "nl_statement_of_codex": "Let $f:B\\to A$ be a function. Let $S$ be a finite set and let $T:S\\to \\mathcal{P}(B)$ be a function. Then $\\inf_{b\\in \\bigcup_{s\\in S}T(s)}f(b)=\\inf_{s\\in S}\\inf_{b\\in T(s)}f(b)$."}
{"name": "metric.continuous_inf_nndist_pt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean", "formal_statement": "theorem metric.continuous_inf_nndist_pt {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t(s : set \u03b1) :\n\tcontinuous (\u03bb (x : \u03b1), metric.inf_nndist x s) :=", "nl_statement_of_codex": "The function $f:X\\to\\mathbb{R}$ defined by $f(x)=\\inf\\{d(x,y):y\\in S\\}$ is continuous."}
{"name": "is_lub_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem is_lub_pi {\u03b1 : Type u} {\u03c0 : \u03b1 \u2192 Type*} [\u03a0 (a : \u03b1), preorder (\u03c0 a)]\n\t{s : set (\u03a0 (a : \u03b1), \u03c0 a)} {f : \u03a0 (a : \u03b1), \u03c0 a} :\n\tis_lub s f \u2194 \u2200 (a : \u03b1), is_lub (function.eval a '' s) (f a) :=", "nl_statement_of_codex": "Let $\\pi$ be a family of preorders indexed by a set $\\alpha$. Let $s$ be a set of functions from $\\alpha$ to $\\pi$ and let $f$ be a function from $\\alpha$ to $\\pi$. Then $f$ is the least upper bound of $s$ if and only if $f(a)$ is the least upper bound of $\\{g(a):g\\in s\\}$ for each $a\\in\\alpha$."}
{"name": "enorm.map_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/enorm.lean", "formal_statement": "theorem enorm.map_smul {\ud835\udd5c V : Type*} [normed_field \ud835\udd5c] [add_comm_group V]\n\t[module \ud835\udd5c V] (e : enorm \ud835\udd5c V) ( : \ud835\udd5c) (x : V) :\n\t\u21d1e (c \u2022 x) = \u2191\u2225c\u2225\u208a * \u21d1e x :=", "nl_statement_of_codex": "Let $V$ be a normed vector space over a normed field $K$. Then for all $c\\in K$ and $x\\in V$, we have $\\|cx\\|=\\|c\\|\\|x\\|$."}
{"name": "le_add_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid.lean", "formal_statement": "theorem le_add_self {\u03b1 : Type u} [canonically_ordered_add_monoid \u03b1] {a b : \u03b1} :\n\ta \u2264 b + a :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with unity. Then for all $a,b\\in R$, $a\\leq b+a$."}
{"name": "add_action.mem_stabilizer_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/basic.lean", "formal_statement": "theorem add_action.mem_stabilizer_iff {\u03b1 : Type u} {\u03b2 : Type v} [add_group \u03b1]\n\t[add_action \u03b1 \u03b2] {b : \u03b2} {a : \u03b1} :\n\ta \u2208 add_action.stabilizer \u03b1 b \u2194 a +\u1d65 b = b :=", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then $a\\in G$ stabilizes $x\\in X$ if and only if $a+x=x$."}
{"name": "finset.mem_inv_smul_finset_iff\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/pointwise.lean", "formal_statement": "theorem finset.mem_inv_smul_finset_iff\u2080 {\u03b1 \u03b2 : Type*} [decidable_eq \u03b2]\n\t[group_with_zero \u03b1] [mul_action \u03b1 \u03b2] {s : finset \u03b2} {a : \u03b1} {b : \u03b2}\n\t(ha : a \u2260 0) :\n\tb \u2208 a\u207b\u00b9 \u2022 s \u2194 a \u2022 b \u2208 s :=", "nl_statement_of_codex": "Let $G$ be a group with zero and let $G$ act on a set $X$. Let $s\\subset X$ and let $a\\in G$ be nonzero. Then $b\\in a^{-1}s$ if and only if $ab\\in s$."}
{"name": "parser.eof_eq_done", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/buffer/parser/basic.lean", "formal_statement": "theorem parser.eof_eq_done {cb : char_buffer} {n n' : \u2115} {u : unit} :\n\tparser.eof cb n = parse_result.done n' u \u2194 n = n' \u2227 buffer.size cb \u2264 n :=", "nl_statement_of_codex": "Let $cb$ be a character buffer and let $n$ be a natural number. Then the parser $eof$ returns $done$ with the same natural number $n$ if and only if the size of $cb$ is less than or equal to $n$."}
{"name": "Top.pullback_iso_prod_subtype_inv_fst_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Top/limits.lean", "formal_statement": "theorem Top.pullback_iso_prod_subtype_inv_fst_apply {X Y Z : Top} (f : X \u27f6 Z)\n\t(g : Y \u27f6 Z) (x : {p // \u21d1f p.fst = \u21d1g p.snd}) :\n\t\u21d1category_theory.limits.pullback.fst (\u21d1((Top.pullback_iso_prod_subtype f g).inv) x) = \u2191x.fst :=", "nl_statement_of_codex": "Let $f:X\\to Z$ and $g:Y\\to Z$ be continuous maps. Then the inverse of the isomorphism between the pullback of $f$ and $g$ and the subtype of $X\\times Y$ consisting of pairs $(x,y)$ such that $f(x)=g(y)$ is given by $(x,y)\\mapsto (x,y)$."}
{"name": "sub_eq_add_zero_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem sub_eq_add_zero_sub {G : Type*} [sub_neg_monoid G] (a b : G) :\n\ta - b = a + (0 - b) :=", "nl_statement_of_codex": "Let $G$ be a sub-negation monoid. Then for all $a,b\\in G$, $a-b=a+(0-b)$."}
{"name": "function.is_periodic_pt.minimal_period_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/periodic_pts.lean", "formal_statement": "theorem function.is_periodic_pt.minimal_period_pos {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1}\n\t{x : \u03b1} {n : \u2115} (hn : 0 < n) (hx : function.is_periodic_pt f n x) :\n\t0 < function.minimal_period f x :=", "nl_statement_of_codex": "Let $f:X\\to X$ be a function and let $x\\in X$. If $f$ is periodic at $x$ with period $n>0$, then the minimal period of $f$ at $x$ is positive."}
{"name": "category_theory.shift_add_hom_comp_eq_to_hom\u2081", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/shift.lean", "formal_statement": "theorem category_theory.shift_add_hom_comp_eq_to_hom\u2081 {C : Type u} {A : Type*}\n\t[category_theory.category C] [add_monoid A] [category_theory.has_shift C A]\n\t(X : C) (i i' j : A) (h : i = i') :\n\t(category_theory.shift_add X i j).hom \u226b category_theory.eq_to_hom _ = category_theory.eq_to_hom _ \u226b (category_theory.shift_add X i' j).hom :=", "nl_statement_of_codex": "Let $C$ be a category, $A$ an additive monoid, and $X$ an object of $C$. Then for any $i,i',j\\in A$ with $i=i'$, the morphism $(i+j)\\to X$ is equal to the composition of the morphism $i\\to X$ with the morphism $i\\to i'$."}
{"name": "box_integral.integral_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/basic.lean", "formal_statement": "theorem box_integral.integral_zero {\u03b9 : Type u} {E : Type v} {F : Type w}\n\t[normed_group E] [normed_space \u211d E] [normed_group F] [normed_space \u211d F]\n\t{I : box_integral.box \u03b9} [fintype \u03b9] {l : box_integral.integration_params}\n\t{vol : box_integral.box_additive_map \u03b9 (E \u2192L[\u211d] F) \u22a4} :\n\tbox_integral.integral I l (\u03bb (_x : \u03b9 \u2192 \u211d), 0) vol = 0 :=", "nl_statement_of_codex": "The integral of the zero function is zero."}
{"name": "algebraic_geometry.is_affine_open.prime_ideal_of_generic_point", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/function_field.lean", "formal_statement": "theorem algebraic_geometry.is_affine_open.prime_ideal_of_generic_point\n\t{X : algebraic_geometry.Scheme} [algebraic_geometry.is_integral X]\n\t{U : topological_space.opens \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)}\n\t(hU : algebraic_geometry.is_affine_open U) [h : nonempty \u21a5U] :\n\thU.prime_ideal_of \u27e8generic_point \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier) _, _\u27e9 = generic_point \u21a5((algebraic_geometry.Scheme.Spec.obj (opposite.op (X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.presheaf.obj (opposite.op U)))).to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier) :=", "nl_statement_of_codex": "Let $X$ be an integral scheme and let $U$ be an affine open subset of $X$. Then the prime ideal of the generic point of $U$ is the generic point of the spectrum of the ring of functions on $U$."}
{"name": "monoid_hom.mrange_restrict_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem monoid_hom.mrange_restrict_surjective {M N : Type*} [mul_one_class M]\n\t[mul_one_class N] (f : M \u2192* N) :\n\tfunction.surjective \u21d1(f.mrange_restrict) :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity. Let $f:M\\to N$ be a monoid homomorphism. Then the restriction of $f$ to the set of elements of $M$ with multiplicative inverse in $N$ is surjective."}
{"name": "with_one.cases_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/with_one.lean", "formal_statement": "theorem with_one.cases_on {\u03b1 : Type u} {P : with_one \u03b1 \u2192 Prop} (x : with_one \u03b1) :\n\tP 1 \u2192 (\u2200 (a : \u03b1), P \u2191a) \u2192 P x :=", "nl_statement_of_codex": "Let $P$ be a property of elements of the type $1+\\alpha$. Then $P$ holds for $1$ and for $a+1$ if and only if $P$ holds for $a$."}
{"name": "ideal.comap_ne_bot_of_algebraic_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/over.lean", "formal_statement": "theorem ideal.comap_ne_bot_of_algebraic_mem {R : Type*} [comm_ring R]\n\t{S : Type*} [comm_ring S] {I : ideal S} [algebra R S] [is_domain S] {x : S}\n\t(x_ne_zero : x \u2260 0) (x_mem : x \u2208 I) (hx : is_algebraic R x) :\n\tideal.comap (algebra_map R S) I \u2260 \u22a5 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $S$ be a commutative domain, and let $I$ be an ideal of $S$. Suppose that $S$ is an $R$-algebra and that $x\\in I$ is algebraic over $R$. Then the ideal $I$ is not mapped to the zero ideal under the map $S\\to S\\otimes_R S$."}
{"name": "fin.mk_lt_of_lt_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.mk_lt_of_lt_coe {n : \u2115} {b : fin n} {a : \u2115} (h : a < \u2191b) :\n\t\u27e8a, _\u27e9 < b :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $b$ be an element of $\\mathrm{fin}(n)$. Let $a$ be a natural number such that $a<b$. Then $\\langle a, _\\rangle<b$."}
{"name": "box_integral.box.is_some_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/box/basic.lean", "formal_statement": "theorem box_integral.box.is_some_iff {\u03b9 : Type*}\n\t{I : with_bot (box_integral.box \u03b9)} :\n\t\u21a5(option.is_some I) \u2194 \u2191I.nonempty :=", "nl_statement_of_codex": "The box integral $I$ is nonempty if and only if $I$ is not the bottom element."}
{"name": "algebra.discr_zero_of_not_linear_independent", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/discriminant.lean", "formal_statement": "theorem algebra.discr_zero_of_not_linear_independent (A : Type u) {B : Type v}\n\t{\u03b9 : Type w} [comm_ring A] [comm_ring B] [algebra A B] [fintype \u03b9]\n\t[is_domain A] {b : \u03b9 \u2192 B} (hli : \u00aclinear_independent A b) :\n\talgebra.discr A b = 0 :=", "nl_statement_of_codex": "Let $A$ be a commutative ring, $B$ be an $A$-algebra, and $b:\\{1,\\ldots,n\\}\\to B$ be a finite sequence of elements of $B$. If $b$ is not linearly independent over $A$, then the discriminant of $b$ is zero."}
{"name": "finset.max'_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.max'_mem {\u03b1 : Type*} [linear_order \u03b1] (s : finset \u03b1)\n\t(H : s.nonempty) :\n\ts.max' H \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a nonempty finite set of elements of a linear order. Then the maximum element of $s$ is an element of $s$."}
{"name": "int.coe_nat_nonpos_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.coe_nat_nonpos_iff {n : \u2115} :\n\t\u2191n \u2264 0 \u2194 n = 0 :=", "nl_statement_of_codex": "For any natural number $n$, $n\\leq 0$ if and only if $n=0$."}
{"name": "turing.partrec_to_TM2.K'.elim_update_stack", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/tm_to_partrec.lean", "formal_statement": "theorem turing.partrec_to_TM2.K'.elim_update_stack\n\t{a b c d d' : list turing.partrec_to_TM2.\u0393'} :\n\tfunction.update (turing.partrec_to_TM2.K'.elim a b c d) turing.partrec_to_TM2.K'.stack d' = turing.partrec_to_TM2.K'.elim a b c d' :=", "nl_statement_of_codex": "The function $K'_{\\text{elim}}$ is defined by the following equations:\n\\begin{align*}\nK'_{\\text{elim}}(a,b,c,d) &= (a,b,c,d)\\\\\nK'_{\\text{elim}}(a,b,c,d)_{\\text{stack}} &= d\n\\end{align*}"}
{"name": "subring.pointwise_smul_subset_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/pointwise.lean", "formal_statement": "theorem subring.pointwise_smul_subset_iff {M R : Type*} [group M] [ring R]\n\t[mul_semiring_action M R] {a : M} {S T : subring R} :\n\ta \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T :=", "nl_statement_of_codex": "Let $M$ be a group, $R$ a ring, and $M$ act on $R$ by ring automorphisms. Let $S$ and $T$ be subrings of $R$. Then $a\\cdot S\\subset T$ if and only if $S\\subset a^{-1}\\cdot T$."}
{"name": "chain_complex.truncate_augment_hom_f", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/augment.lean", "formal_statement": "theorem chain_complex.truncate_augment_hom_f {V : Type u}\n\t[category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t(C : chain_complex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0) (i : \u2115) :\n\t(C.truncate_augment f w).hom.f i = \ud835\udfd9 (C.X i) :=", "nl_statement_of_codex": "Let $C$ be a chain complex in a category $V$ with zero morphisms. Let $X$ be an object of $V$ and let $f:C_0\\to X$ be a morphism. Let $w$ be a morphism such that $d_1\\circ f=0$. Then the morphism $f$ is the $i$-th morphism of the chain complex $C\\to X$."}
{"name": "category_theory.zigzag_equivalence", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/is_connected.lean", "formal_statement": "theorem category_theory.zigzag_equivalence {J : Type u\u2081}\n\t[category_theory.category J] :\n\tequivalence category_theory.zigzag :=", "nl_statement_of_codex": "The category of zigzags is equivalent to the category of categories."}
{"name": "topological_space.opens.map_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Top/opens.lean", "formal_statement": "theorem topological_space.opens.map_eq {X Y : Top} (f g : X \u27f6 Y) (h : f = g) :\n\ttopological_space.opens.map f = topological_space.opens.map g :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $f,g:X\\to Y$. Then the map $f$ and $g$ induce the same map on the collection of open sets."}
{"name": "simple_graph.walk.edges_take_until_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.edges_take_until_subset {V : Type u}\n\t{G : simple_graph V} [decidable_eq V] {u v w : V} (p : G.walk v w)\n\t(h : u \u2208 p.support) :\n\t(p.take_until u h).edges \u2286 p.edges :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $u,v,w$ be vertices of $G$. Let $p$ be a walk from $v$ to $w$. If $u$ is a vertex of $p$, then the edges of the walk from $v$ to $u$ are a subset of the edges of $p$."}
{"name": "fin.zero_ne_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.zero_ne_one {n : \u2115} :\n\t0 \u2260 1 :=", "nl_statement_of_codex": "$0\\neq 1$."}
{"name": "real.continuous_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/real.lean", "formal_statement": "theorem real.continuous_inv :\n\tcontinuous (\u03bb (a : {r // r \u2260 0}), (a.val)\u207b\u00b9) :=", "nl_statement_of_codex": "The function $f:\\mathbb{R}\\setminus\\{0\\}\\to\\mathbb{R}$ defined by $f(x)=x^{-1}$ is continuous."}
{"name": "pmf.to_outer_measure_uniform_of_finset_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/probability_mass_function/constructions.lean", "formal_statement": "theorem pmf.to_outer_measure_uniform_of_finset_apply {\u03b1 : Type*} {s : finset \u03b1}\n\t(hs : s.nonempty) (t : set \u03b1) :\n\t\u21d1((pmf.uniform_of_finset s hs).to_outer_measure) t = \u2191((finset.filter (\u03bb (_x : \u03b1), _x \u2208 t) s).card) / \u2191(s.card) :=", "nl_statement_of_codex": "Let $s$ be a nonempty finite set and let $t$ be a subset of $s$. Then the outer measure of $t$ with respect to the uniform distribution on $s$ is equal to the ratio of the number of elements of $t$ in $s$ to the number of elements of $s$."}
{"name": "measure_theory.measure_preserving.exists_mem_image_mem_of_volume_lt_mul_volume", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/ergodic/measure_preserving.lean", "formal_statement": "theorem measure_theory.measure_preserving.exists_mem_image_mem_of_volume_lt_mul_volume\n\t{\u03b1 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 \u03b1}\n\t{s : set \u03b1} (hf : measure_theory.measure_preserving f \u03bc \u03bc)\n\t(hs : measurable_set s) {n : \u2115} (hvol : \u21d1\u03bc set.univ < \u2191n * \u21d1\u03bc s) :\n\t\u2203 (x : \u03b1) (H : x \u2208 s) (m : \u2115) (H : m \u2208 set.Ioo 0 n), f^[m] x \u2208 s :=", "nl_statement_of_codex": "Let $f:X\\to X$ be a measure-preserving map on a measure space $(X,\\mathcal{A},\\mu)$. Let $s\\in\\mathcal{A}$ be a measurable set. If $\\mu(X)<n\\mu(s)$, then there exists $x\\in s$ and $m\\in\\{1,\\ldots,n\\}$ such that $f^m(x)\\in s$."}
{"name": "tsub_le_tsub_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem tsub_le_tsub_left {\u03b1 : Type*} [preorder \u03b1] [add_comm_semigroup \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1}\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] (h : a \u2264 b) ( : \u03b1) :\n\tc - b \u2264 c - a :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a preordered additive commutative semigroup with subtraction. If $a\\leq b$, then $c-b\\leq c-a$."}
{"name": "measure_theory.outer_measure.comap_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.comap_top {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n\t\u21d1(measure_theory.outer_measure.comap f) \u22a4 = \u22a4 :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function. Then $\\overline{f^{-1}}(\\mathbb{Y})=\\mathbb{X}$."}
{"name": "subsemigroup.map_surjective_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem subsemigroup.map_surjective_of_surjective {M N : Type*} [has_mul M]\n\t[has_mul N] {f : M \u2192\u2099* N} (hf : function.surjective \u21d1f) :\n\tfunction.surjective (subsemigroup.map f) :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids and let $f:M\\to N$ be a surjective monoid homomorphism. Then the induced map $f:M\\to N$ is surjective."}
{"name": "cardinal.is_limit.ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/cofinality.lean", "formal_statement": "theorem cardinal.is_limit.ne_zero { : cardinal} (h : c.is_limit) :\n\tc \u2260 0 :=", "nl_statement_of_codex": "If $c$ is a limit cardinal, then $c\\neq 0$."}
{"name": "bool.to_bool_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bool/basic.lean", "formal_statement": "theorem bool.to_bool_eq {p q : Prop} [decidable p] [decidable q] :\n\tdecidable.to_bool p = decidable.to_bool q \u2194 (p \u2194 q) :=", "nl_statement_of_codex": "The boolean values of two decidable propositions $p$ and $q$ are equal if and only if $p$ and $q$ are equivalent."}
{"name": "bind_ext_congr", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/control/lawful.lean", "formal_statement": "theorem bind_ext_congr {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type v} [has_bind m]\n\t{x : m \u03b1} {f g : \u03b1 \u2192 m \u03b2} :\n\t(\u2200 (a : \u03b1), f a = g a) \u2192 x >>= f = x >>= g :=", "nl_statement_of_codex": "Let $m$ be a monad and let $x:m\\alpha$. If $f,g:\\alpha\\to m\\beta$ are such that $f(a)=g(a)$ for all $a\\in\\alpha$, then $x\\bind f=x\\bind g$."}
{"name": "Class.fval_ex", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/zfc.lean", "formal_statement": "theorem Class.fval_ex (F A : Class) :\n\tF\u2032A \u2208 Class.univ :=", "nl_statement_of_codex": "The class $F\u2032A$ is a member of the class $Class.univ$."}
{"name": "set.nonempty_Icc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.nonempty_Icc {\u03b1 : Type*} [preorder \u03b1] {a b : \u03b1} :\n\t(set.Icc a b).nonempty \u2194 a \u2264 b :=", "nl_statement_of_codex": "The interval $[a,b]$ is nonempty if and only if $a\\leq b$."}
{"name": "category_theory.limits.cokernel.condition_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/concrete_category/elementwise.lean", "formal_statement": "theorem category_theory.limits.cokernel.condition_apply {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C} (f : X \u27f6 Y) [category_theory.limits.has_cokernel f]\n\t[I : category_theory.concrete_category C] (x : \u21a5X) :\n\t\u21d1(category_theory.limits.cokernel.\u03c0 f) (\u21d1f x) = \u21d10 x :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $f:X\\to Y$ be a morphism in $C$ with cokernel $\\pi:Y\\to Z$. Then $\\pi(f(x))=0(x)$ for all $x\\in X$."}
{"name": "is_max_filter.bicomp_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/extr.lean", "formal_statement": "theorem is_max_filter.bicomp_mono {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}\n\t{\u03b4 : Type x} [preorder \u03b2] [preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {l : filter \u03b1} {a : \u03b1}\n\t[preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4} (hop : (has_le.le \u21d2 has_le.le \u21d2 has_le.le) op op)\n\t(hf : is_max_filter f l a) {g : \u03b1 \u2192 \u03b3} (hg : is_max_filter g l a) :\n\tis_max_filter (\u03bb (x : \u03b1), op (f x) (g x)) l a :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions such that $f$ is a maximal filter and $g$ is a maximal filter. Then the function $h:\\alpha\\to\\beta$ defined by $h(x)=f(x)\\vee g(x)$ is a maximal filter."}
{"name": "is_R_or_C.norm_re_le_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/is_R_or_C.lean", "formal_statement": "theorem is_R_or_C.norm_re_le_norm {K : Type*} [is_R_or_C K] (z : K) :\n\t\u2225\u21d1is_R_or_C.re z\u2225 \u2264 \u2225z\u2225 :=", "nl_statement_of_codex": "The real part of a complex number has norm less than or equal to the norm of the complex number."}
{"name": "matrix.conj_transpose_nat_cast_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem matrix.conj_transpose_nat_cast_smul {m n R : Type*} {\u03b1 : Type v}\n\t[semiring R] [add_comm_monoid \u03b1] [star_add_monoid \u03b1] [module R \u03b1] ( : \u2115)\n\t(M : matrix m n \u03b1) :\n\t(\u2191c \u2022 M).conj_transpose = \u2191c \u2022 M.conj_transpose :=", "nl_statement_of_codex": "Let $M$ be an $m\\times n$ matrix with entries in a semiring $R$. Then $(cM)^T=cM^T$."}
{"name": "category_theory.over.mk_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/over.lean", "formal_statement": "theorem category_theory.over.mk_left {T : Type u\u2081} [category_theory.category T]\n\t{X Y : T} (f : Y \u27f6 X) :\n\t(category_theory.over.mk f).left = Y :=", "nl_statement_of_codex": "Let $T$ be a category and let $X, Y$ be objects of $T$. Then the left object of the over category $T/X$ is $Y$."}
{"name": "nat.log_eq_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/log.lean", "formal_statement": "theorem nat.log_eq_zero_iff {b n : \u2115} :\n\tnat.log b n = 0 \u2194 n < b \u2228 b \u2264 1 :=", "nl_statement_of_codex": "$\\log_b n=0$ if and only if $n<b$ or $b\\leq 1$."}
{"name": "polynomial.coeff_mem_frange", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/basic.lean", "formal_statement": "theorem polynomial.coeff_mem_frange {R : Type u} [semiring R] (p : polynomial R)\n\t(n : \u2115) (h : p.coeff n \u2260 0) :\n\tp.coeff n \u2208 p.frange :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. If the coefficient of $p$ at $n$ is nonzero, then it is in the range of $p$."}
{"name": "set.singleton_prod_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/prod.lean", "formal_statement": "theorem set.singleton_prod_singleton {\u03b1 \u03b2 : Type*} {a : \u03b1} {b : \u03b2} :\n\t{a} \u00d7\u02e2 {b} = {(a, b)} :=", "nl_statement_of_codex": "The product of two singleton sets is a singleton set."}
{"name": "disjoint_symm_diff_inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/symm_diff.lean", "formal_statement": "theorem disjoint_symm_diff_inf {\u03b1 : Type*} [generalized_boolean_algebra \u03b1]\n\t(a b : \u03b1) :\n\tdisjoint (a \u2206 b) (a \u2293 b) :=", "nl_statement_of_codex": "Let $A$ be a generalized boolean algebra. Then $A\\Delta B$ and $A\\cap B$ are disjoint."}
{"name": "finset.prod_Ioc_succ_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/intervals.lean", "formal_statement": "theorem finset.prod_Ioc_succ_top {\u03b2 : Type v} [comm_monoid \u03b2] {a b : \u2115}\n\t(hab : a \u2264 b) (f : \u2115 \u2192 \u03b2) :\n\t(finset.Ioc a (b + 1)).prod (\u03bb (k : \u2115), f k) = (finset.Ioc a b).prod (\u03bb (k : \u2115), f k) * f (b + 1) :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\beta$ be a function. Then $\\prod_{k=a}^{b+1}f(k)=\\prod_{k=a}^bf(k)\\cdot f(b+1)$."}
{"name": "rbmap.eq_none_of_to_value_eq_none", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rbmap/default.lean", "formal_statement": "theorem rbmap.eq_none_of_to_value_eq_none {\u03b1 : Type u} {\u03b2 : Type v}\n\t{e : option (\u03b1 \u00d7 \u03b2)} :\n\trbmap.to_value e = option.none \u2192 e = option.none :=", "nl_statement_of_codex": "Let $e$ be an option of a pair of types. If the value of $e$ is none, then $e$ is none."}
{"name": "quaternion_algebra.conj_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion_algebra.conj_neg {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R}\n\t(a : quaternion_algebra R c\u2081 c\u2082) :\n\t\u21d1quaternion_algebra.conj (-a) = -\u21d1quaternion_algebra.conj a :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $c_1, c_2\\in R$. Let $a$ be an element of the quaternion algebra $R[i,j:i^2=c_1,j^2=c_2,ij=-ji]$. Then the conjugate of $-a$ is $-\\overline{a}$."}
{"name": "category_theory.functor.map_zero_object_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/preserves/shapes/zero.lean", "formal_statement": "theorem category_theory.functor.map_zero_object_hom {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t[category_theory.limits.has_zero_object C]\n\t[category_theory.limits.has_zero_object D]\n\t[category_theory.limits.has_zero_morphisms C]\n\t[category_theory.limits.has_zero_morphisms D] (F : C \u2964 D)\n\t[F.preserves_zero_morphisms] :\n\tF.map_zero_object.hom = 0 :=", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor between categories $C$ and $D$ with zero objects. If $F$ preserves zero morphisms, then $F$ maps the zero object of $C$ to the zero object of $D$."}
{"name": "is_R_or_C.of_real_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/is_R_or_C.lean", "formal_statement": "theorem is_R_or_C.of_real_smul {K : Type*} [is_R_or_C K] (r x : \u211d) :\n\tr \u2022 \u2191x = \u2191r * \u2191x :=", "nl_statement_of_codex": "If $K$ is either $\\mathbb{R}$ or $\\mathbb{C}$, then $r\\cdot x=r\\cdot x$ for all $r\\in\\mathbb{R}$ and $x\\in K$."}
{"name": "category_theory.prod_id_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/products/basic.lean", "formal_statement": "theorem category_theory.prod_id_snd (C : Type u\u2081) [category_theory.category C]\n\t(D : Type u\u2082) [category_theory.category D] (X : C \u00d7 D) :\n\t(\ud835\udfd9 X).snd = \ud835\udfd9 X.snd :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories. Then the identity morphism on $X\\in C\\times D$ is the product of the identity morphisms on $X$ and $X.snd$."}
{"name": "add_subgroup.zmultiples_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.zmultiples_subset {G : Type*} [add_group G] {a : G}\n\t{K : add_subgroup G} (h : a \u2208 K) :\n\tadd_subgroup.zmultiples a \u2264 K :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $K$ be a subgroup of $G$. Let $a\\in K$. Then the subgroup generated by $a$ is contained in $K$."}
{"name": "lie_ideal.mem_comap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/submodule.lean", "formal_statement": "theorem lie_ideal.mem_comap {R : Type u} {L : Type v} {L' : Type w\u2082}\n\t[comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L']\n\t{f : L \u2192\u2097\u2045R\u2046 L'} {J : lie_ideal R L'} {x : L} :\n\tx \u2208 lie_ideal.comap f J \u2194 \u21d1f x \u2208 J :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ and $L'$ be Lie rings over $R$, and $f:L\\to L'$ be a Lie algebra homomorphism. Then $x\\in L$ is in the preimage of a Lie ideal $J$ of $L'$ under $f$ if and only if $f(x)\\in J$."}
{"name": "presented_group.to_group.of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/presented_group.lean", "formal_statement": "theorem presented_group.to_group.of {\u03b1 G : Type} [group G] {f : \u03b1 \u2192 G}\n\t{rels : set (free_group \u03b1)}\n\t(h : \u2200 (r : free_group \u03b1), r \u2208 rels \u2192 \u21d1(\u21d1free_group.lift f) r = 1) {x : \u03b1} :\n\t\u21d1(presented_group.to_group h) (presented_group.of x) = f x :=", "nl_statement_of_codex": "Let $G$ be a group and let $f:A\\to G$ be a function. Let $R$ be a set of relations on $A$. Then the map $f$ induces a homomorphism from the quotient group $A/R$ to $G$."}
{"name": "nat.multichoose_one_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/choose/basic.lean", "formal_statement": "theorem nat.multichoose_one_right (n : \u2115) :\n\tn.multichoose 1 = n :=", "nl_statement_of_codex": "$\\binom{n}{1}=n$."}
{"name": "multiset.noncomm_prod_eq_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/noncomm_prod.lean", "formal_statement": "theorem multiset.noncomm_prod_eq_prod {\u03b1 : Type*} [comm_monoid \u03b1]\n\t(s : multiset \u03b1) :\n\ts.noncomm_prod _ = s.prod :=", "nl_statement_of_codex": "The noncommutative product of a multiset $s$ is equal to the product of $s$."}
{"name": "composition_series.equivalent.snoc_snoc_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/jordan_holder.lean", "formal_statement": "theorem composition_series.equivalent.snoc_snoc_swap {X : Type u} [lattice X]\n\t[jordan_holder_lattice X] {s : composition_series X} {x\u2081 x\u2082 y\u2081 y\u2082 : X}\n\t{hsat\u2081 : jordan_holder_lattice.is_maximal s.top x\u2081}\n\t{hsat\u2082 : jordan_holder_lattice.is_maximal s.top x\u2082}\n\t{hsaty\u2081 : jordan_holder_lattice.is_maximal (s.snoc x\u2081 hsat\u2081).top y\u2081}\n\t{hsaty\u2082 : jordan_holder_lattice.is_maximal (s.snoc x\u2082 hsat\u2082).top y\u2082}\n\t(hr\u2081 : jordan_holder_lattice.iso (s.top, x\u2081) (x\u2082, y\u2082))\n\t(hr\u2082 : jordan_holder_lattice.iso (x\u2081, y\u2081) (s.top, x\u2082)) :\n\t((s.snoc x\u2081 hsat\u2081).snoc y\u2081 hsaty\u2081).equivalent ((s.snoc x\u2082 hsat\u2082).snoc y\u2082 hsaty\u2082) :=", "nl_statement_of_codex": "Let $X$ be a lattice with a Jordan-Holder series $s$. Let $x_1, x_2, y_1, y_2\\in X$ be such that $x_1, x_2$ are maximal in $s$ and $y_1, y_2$ are maximal in $s\\cup\\{x_1\\}$ and $s\\cup\\{x_2\\}$, respectively. Suppose that there are isomorphisms $r_1:(s, x_1)\\to (x_2, y_2)$ and $r_2:(x_1, y_1)\\to (s, x_2)$."}
{"name": "algebraic_closure.step.is_integral", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/is_alg_closed/algebraic_closure.lean", "formal_statement": "theorem algebraic_closure.step.is_integral (k : Type u) [field k] (n : \u2115)\n\t(z : algebraic_closure.step k n) :\n\tis_integral k z :=", "nl_statement_of_codex": "Let $k$ be a field and let $n$ be a natural number. Then every element of the algebraic closure of $k$ in the algebraic closure of $k$ in $\\mathbb{C}$ is integral over $k$."}
{"name": "nat.nth_count_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/nth.lean", "formal_statement": "theorem nat.nth_count_le (p : \u2115 \u2192 Prop) [decidable_pred p]\n\t(hp : (set_of p).infinite) (n : \u2115) :\n\tn \u2264 nat.nth p (nat.count p n) :=", "nl_statement_of_codex": "Let $p$ be a predicate on $\\mathbb{N}$ such that the set of $n$ satisfying $p(n)$ is infinite. Then for each $n\\in\\mathbb{N}$, $n$ is less than or equal to the $n$th element of the set of $n$ satisfying $p(n)$."}
{"name": "list.nodup_sublists_len", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/nodup.lean", "formal_statement": "theorem list.nodup_sublists_len {\u03b1 : Type u} {l : list \u03b1} (n : \u2115) (h : l.nodup) :\n\t(list.sublists_len n l).nodup :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b1$. Then the list of all sublists of $l$ of length $n$ has no duplicates."}
{"name": "eq_zero_iff_eq_zero_of_add_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem eq_zero_iff_eq_zero_of_add_eq_zero {M : Type u} [add_zero_class M]\n\t{a b : M} (h : a + b = 0) :\n\ta = 0 \u2194 b = 0 :=", "nl_statement_of_codex": "Let $M$ be an additive monoid with zero. Let $a, b\\in M$. If $a+b=0$, then $a=0$ if and only if $b=0$."}
{"name": "geom_sum_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/geom_sum.lean", "formal_statement": "theorem geom_sum_eq {\u03b1 : Type u} [division_ring \u03b1] {x : \u03b1} (h : x \u2260 1) (n : \u2115) :\n\t(finset.range n).sum (\u03bb (i : \u2115), x ^ i) = (x ^ n - 1) / (x - 1) :=", "nl_statement_of_codex": "Let $x$ be a non-unit in a division ring $R$. Then $\\sum_{i=0}^n x^i = \\frac{x^n-1}{x-1}$."}
{"name": "list.is_rotated.cyclic_permutations", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/rotate.lean", "formal_statement": "theorem list.is_rotated.cyclic_permutations {\u03b1 : Type u} {l l' : list \u03b1}\n\t(h : l ~r l') :\n\tl.cyclic_permutations ~r l'.cyclic_permutations :=", "nl_statement_of_codex": "If $l$ is a rotation of $l'$, then the cyclic permutations of $l$ are a rotation of the cyclic permutations of $l'$."}
{"name": "lower_adjoint.mem_closed_iff_closure_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/closure.lean", "formal_statement": "theorem lower_adjoint.mem_closed_iff_closure_le {\u03b1 \u03b2 : Type*} [partial_order \u03b1]\n\t[partial_order \u03b2] {u : \u03b2 \u2192 \u03b1} (l : lower_adjoint u) (x : \u03b1) :\n\tx \u2208 l.closed \u2194 u (\u21d1l x) \u2264 x :=", "nl_statement_of_codex": "Let $u:B\\to A$ be a lower adjoint. Then $x\\in A$ is in the closure of $u$ if and only if $u^*(x)\\leq x$."}
{"name": "category_theory.concrete_category.has_coe_to_fun_Type", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/concrete_category/basic.lean", "formal_statement": "theorem category_theory.concrete_category.has_coe_to_fun_Type {X Y : Type u}\n\t(f : X \u27f6 Y) :\n\t\u21d1f = f :=", "nl_statement_of_codex": "Let $X$ and $Y$ be types. Then the morphism $f:X\\to Y$ is equal to its underlying function."}
{"name": "int.sub_nat_nat_of_sub_eq_succ", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/basic.lean", "formal_statement": "theorem int.sub_nat_nat_of_sub_eq_succ {m n k : \u2115} (h : n - m = k.succ) :\n\tint.sub_nat_nat m n = -[1+ k] :=", "nl_statement_of_codex": "Let $m,n,k$ be natural numbers. If $n-m=k+1$, then $m-n=-(k+1)$."}
{"name": "real.angle.coe_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/angle.lean", "formal_statement": "theorem real.angle.coe_neg (x : \u211d) :\n\t\u2191-x = -\u2191x :=", "nl_statement_of_codex": "The angle of $-x$ is the negative of the angle of $x$."}
{"name": "algebra.self_mem_elemental_algebra", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/algebra.lean", "formal_statement": "theorem algebra.self_mem_elemental_algebra (R : Type*) [comm_ring R]\n\t{A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A]\n\t(x : A) :\n\tx \u2208 algebra.elemental_algebra R x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $A$ be an $R$-algebra. Then $x\\in A$ is in the elemental algebra of $x$."}
{"name": "is_path_connected.exists_path_through_family", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/path_connected.lean", "formal_statement": "theorem is_path_connected.exists_path_through_family {X : Type*}\n\t[topological_space X] {n : \u2115} {s : set X} (h : is_path_connected s)\n\t(p : fin (n + 1) \u2192 X) (hp : \u2200 (i : fin (n + 1)), p i \u2208 s) :\n\t\u2203 (\u03b3 : path (p 0) (p \u2191n)), set.range \u21d1\u03b3 \u2286 s \u2227 \u2200 (i : fin (n + 1)), p i \u2208 set.range \u21d1\u03b3 :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $s$ be a path-connected subset of $X$. Let $p_0,\\ldots,p_n$ be points in $s$. Then there is a path $\\gamma$ from $p_0$ to $p_n$ such that $\\gamma$ is contained in $s$ and $p_0,\\ldots,p_n$ are in the range of $\\gamma$."}
{"name": "filter.mem_prod_principal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.mem_prod_principal {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1}\n\t{s : set (\u03b1 \u00d7 \u03b2)} {t : set \u03b2} :\n\ts \u2208 f.prod (filter.principal t) \u2194 {a : \u03b1 | \u2200 (b : \u03b2), b \u2208 t \u2192 (a, b) \u2208 s} \u2208 f :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $A$ and let $t$ be a subset of a set $B$. Then $f\\times\\{t\\}$ is the filter on $A\\times B$ consisting of all sets $s$ such that $\\{a\\in A\\mid \\forall b\\in t, (a,b)\\in s\\}$ is in $f$."}
{"name": "int.sub_one_lt_of_le", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.sub_one_lt_of_le {a b : \u2124} (H : a \u2264 b) :\n\ta - 1 < b :=", "nl_statement_of_codex": "If $a\\leq b$, then $a-1<b$."}
{"name": "filter.smul_filter_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.smul_filter_bot {\u03b1 \u03b2 : Type*} [has_smul \u03b1 \u03b2] {a : \u03b1} :\n\ta \u2022 \u22a5 = \u22a5 :=", "nl_statement_of_codex": "Let $R$ be a ring and let $a\\in R$. Then $a\\cdot\\bot=\\bot$."}
{"name": "polynomial.erase_lead_support_card_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/erase_lead.lean", "formal_statement": "theorem polynomial.erase_lead_support_card_lt {R : Type*} [semiring R]\n\t{f : polynomial R} (h : f \u2260 0) :\n\tf.erase_lead.support.card < f.support.card :=", "nl_statement_of_codex": "Let $f$ be a nonzero polynomial. Then the number of nonzero coefficients of $f$ is strictly less than the number of nonzero coefficients of $f$ with the leading coefficient removed."}
{"name": "measure_theory.integrable_on_iff_integable_of_support_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/integrable_on.lean", "formal_statement": "theorem measure_theory.integrable_on_iff_integable_of_support_subset\n\t{\u03b1 E : Type*} [measurable_space \u03b1] [normed_group E]\n\t{\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 E} {s : set \u03b1}\n\t(h1s : function.support f \u2286 s) (h2s : measurable_set s) :\n\tmeasure_theory.integrable_on f s \u03bc \u2194 measure_theory.integrable f \u03bc :=", "nl_statement_of_codex": "Let $f:X\\to E$ be a function with support contained in a measurable set $s$. Then $f$ is integrable on $s$ if and only if $f$ is integrable."}
{"name": "nonneg.inv_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/nonneg.lean", "formal_statement": "theorem nonneg.inv_mk {\u03b1 : Type*} [linear_ordered_field \u03b1] {x : \u03b1} (hx : 0 \u2264 x) :\n\t\u27e8x, hx\u27e9\u207b\u00b9 = \u27e8x\u207b\u00b9, _\u27e9 :=", "nl_statement_of_codex": "If $x\\geq 0$, then $(x)^{-1}=(x^{-1})$."}
{"name": "subring.coe_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/basic.lean", "formal_statement": "theorem subring.coe_add {R : Type u} [ring R] (s : subring R) (x y : \u21a5s) :\n\t\u2191(x + y) = \u2191x + \u2191y :=", "nl_statement_of_codex": "Let $R$ be a ring and let $s$ be a subring of $R$. Then the map $s\\to R$ is a ring homomorphism."}
{"name": "convex_halfspace_im_gt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/complex.lean", "formal_statement": "theorem convex_halfspace_im_gt (r : \u211d) :\n\tconvex \u211d {c : \u2102 | r < c.im} :=", "nl_statement_of_codex": "The set of complex numbers with imaginary part greater than $r$ is convex."}
{"name": "CommRing.free_map_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Ring/adjunctions.lean", "formal_statement": "theorem CommRing.free_map_coe {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} :\n\t\u21d1(CommRing.free.map f) = \u21d1(mv_polynomial.rename f) :=", "nl_statement_of_codex": "The map $f:R\\to S$ induces a map $f^*:S[x]\\to R[x]$ given by $f^*(p(x))=p(f(x))$."}
{"name": "int.add_le_add", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.add_le_add {a b c d : \u2124} (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) :\n\ta + c \u2264 b + d :=", "nl_statement_of_codex": "If $a\\leq b$ and $c\\leq d$, then $a+c\\leq b+d$."}
{"name": "category_theory.limits.types.coequalizer_preimage_image_eq_of_preimage_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/types.lean", "formal_statement": "theorem category_theory.limits.types.coequalizer_preimage_image_eq_of_preimage_eq\n\t{X Y Z : Type u} (f g : X \u27f6 Y) (\u03c0 : Y \u27f6 Z) (e : f \u226b \u03c0 = g \u226b \u03c0)\n\t(h : category_theory.limits.is_colimit (category_theory.limits.cofork.of_\u03c0 \u03c0 e))\n\t(U : set Y) (H : f \u207b\u00b9' U = g \u207b\u00b9' U) :\n\t\u03c0 \u207b\u00b9' (\u03c0 '' U) = U :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ and $\\pi:Y\\to Z$ be morphisms of types. Suppose that $\\pi$ is the coequalizer of $f$ and $g$. Let $U$ be a subset of $Y$ such that $f^{-1}(U)=g^{-1}(U)$. Then $\\pi^{-1}(\\pi(U))=U$."}
{"name": "bundle.coe_snd_map_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bundle.lean", "formal_statement": "theorem bundle.coe_snd_map_apply {B E : B \u2192 Type*}\n\t[\u03a0 (x : B), add_comm_monoid (E x)] (x : B) (v w : E x) :\n\t\u2191(v + w).snd = \u2191v.snd + \u2191w.snd :=", "nl_statement_of_codex": "Let $B$ be a set and let $E$ be a function from $B$ to the set of abelian monoids. Let $x\\in B$ and let $v,w\\in E(x)$. Then $(v+w).snd=v.snd+w.snd$."}
{"name": "measure_theory.measure.map_apply_of_ae_measurable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.map_apply_of_ae_measurable {\u03b1 \u03b2 : Type*}\n\t{m0 : measurable_space \u03b1} [measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} (hf : ae_measurable f \u03bc) {s : set \u03b2} (hs : measurable_set s) :\n\t\u21d1(measure_theory.measure.map f \u03bc) s = \u21d1\u03bc (f \u207b\u00b9' s) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a measurable function between measurable spaces $X$ and $Y$. Then the pushforward measure $f_*\\mu$ is given by $f_*\\mu(A)=\\mu(f^{-1}(A))$ for all measurable sets $A\\subset Y$."}
{"name": "left_div_gcd_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/euclidean_domain.lean", "formal_statement": "theorem left_div_gcd_ne_zero {R : Type*} [euclidean_domain R] [gcd_monoid R]\n\t{p q : R} (hp : p \u2260 0) :\n\tp / gcd_monoid.gcd p q \u2260 0 :=", "nl_statement_of_codex": "Let $R$ be a Euclidean domain. If $p$ is nonzero, then $p/\\gcd(p,q)$ is nonzero."}
{"name": "has_deriv_within_at.div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_within_at.div {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{x : \ud835\udd5c} {s : set \ud835\udd5c} {\ud835\udd5c' : Type*} [nondiscrete_normed_field \ud835\udd5c']\n\t[normed_algebra \ud835\udd5c \ud835\udd5c'] {c d : \ud835\udd5c \u2192 \ud835\udd5c'} {c' d' : \ud835\udd5c'}\n\t(hc : has_deriv_within_at c c' s x) (hd : has_deriv_within_at d d' s x)\n\t(hx : d x \u2260 0) :\n\thas_deriv_within_at (\u03bb (y : \ud835\udd5c), c y / d y) ((c' * d x - c x * d') / d x ^ 2) s x :=", "nl_statement_of_codex": "Let $c,d:U\\to\\mathbb{R}$ be differentiable at $x\\in U$. Then $c/d$ is differentiable at $x$ and $(c/d)'(x)=(c'(x)d(x)-c(x)d'(x))/(d(x))^2$."}
{"name": "monoid_hom.fst_comp_inl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/prod.lean", "formal_statement": "theorem monoid_hom.fst_comp_inl {M N : Type*} [mul_one_class M]\n\t[mul_one_class N] :\n\t(monoid_hom.fst M N).comp (monoid_hom.inl M N) = monoid_hom.id M :=", "nl_statement_of_codex": "The composition of the inclusion map $M\\to M\\times N$ with the projection map $M\\times N\\to M$ is the identity map on $M$."}
{"name": "matrix.block_diagonal'_apply_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/block.lean", "formal_statement": "theorem matrix.block_diagonal'_apply_ne {o m' n' \u03b1 : Type*2} [decidable_eq o]\n\t[has_zero \u03b1] (M : \u03a0 (i : o), matrix (m' i) (n' i) \u03b1) {k k' : o} (i : m' k)\n\t(j : n' k') (h : k \u2260 k') :\n\tmatrix.block_diagonal' M \u27e8k, i\u27e9 \u27e8k', j\u27e9 = 0 :=", "nl_statement_of_codex": "Let $M$ be a block diagonal matrix with blocks $M_1,\\ldots,M_n$. Then the $(i,j)$-entry of $M$ is $0$ if $i$ and $j$ are in different blocks."}
{"name": "filter.map_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.map_one {F \u03b1 \u03b2 : Type*} [has_one \u03b1] [has_one \u03b2]\n\t[one_hom_class F \u03b1 \u03b2] (\u03c6 : F) :\n\tfilter.map \u21d1\u03c6 1 = 1 :=", "nl_statement_of_codex": "Let $F$ be a functor from $\\mathbf{Set}$ to $\\mathbf{Set}$. Let $\\phi:F\\to F$ be a natural transformation. Then $\\phi_1(1)=1$."}
{"name": "encodable.encode_sigma_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/encodable/basic.lean", "formal_statement": "theorem encodable.encode_sigma_val {\u03b1 \u03b3 : \u03b1 \u2192 Type*} [encodable \u03b1]\n\t[\u03a0 (a : \u03b1), encodable (\u03b3 a)] (a : \u03b1) (b : \u03b3 a) :\n\tencodable.encode \u27e8a, b\u27e9 = nat.mkpair (encodable.encode a) (encodable.encode b) :=", "nl_statement_of_codex": "The encoding of a pair $(a,b)$ is the pair of the encodings of $a$ and $b$."}
{"name": "submonoid.localization_map.mul_equiv_of_localizations_right_inv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.mul_equiv_of_localizations_right_inv_apply\n\t{M : Type*} [comm_monoid M] {S : submonoid M} {N : Type*} [comm_monoid N]\n\t{P : Type*} [comm_monoid P] (f : S.localization_map N)\n\t{k : S.localization_map P} {x : M} :\n\t\u21d1((f.of_mul_equiv_of_localizations (f.mul_equiv_of_localizations k)).to_map) x = \u21d1(k.to_map) x :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, let $P$ be a commutative monoid, let $f:S\\to N$ be a localization map, let $k:S\\to P$ be a localization map, and let $x\\in M$. Then $f(k(x))=k(x)$."}
{"name": "linear_map.to_matrix'_algebra_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/to_lin.lean", "formal_statement": "theorem linear_map.to_matrix'_algebra_map {R : Type*} [comm_semiring R]\n\t{n : Type*} [fintype n] [decidable_eq n] (x : R) :\n\t\u21d1linear_map.to_matrix' (\u21d1(algebra_map R (module.End R (n \u2192 R))) x) = \u21d1(matrix.scalar n) x :=", "nl_statement_of_codex": "The matrix of the linear map $x\\cdot\\mathrm{id}$ is the scalar matrix $x\\cdot\\mathrm{id}$."}
{"name": "strict_mono.le_iff_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem strict_mono.le_iff_le {\u03b1 : Type u} {\u03b2 : Type v} [linear_order \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : strict_mono f) {a b : \u03b1} :\n\tf a \u2264 f b \u2194 a \u2264 b :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a strict monotone function. Then $f(a)\\leq f(b)$ if and only if $a\\leq b$."}
{"name": "measure_theory.adapted.smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/stopping.lean", "formal_statement": "theorem measure_theory.adapted.smul {\u03b1 \u03b2 \u03b9 : Type*} {m : measurable_space \u03b1}\n\t[topological_space \u03b2] [preorder \u03b9] {u : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n\t{f : measure_theory.filtration \u03b9 m} [has_smul \u211d \u03b2] [has_continuous_smul \u211d \u03b2]\n\t( : \u211d) (hu : measure_theory.adapted f u) :\n\tmeasure_theory.adapted f (c \u2022 u) :=", "nl_statement_of_codex": "Let $u$ be an adapted process. Then $cu$ is also an adapted process."}
{"name": "is_strong_antichain.flip", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/antichain.lean", "formal_statement": "theorem is_strong_antichain.flip {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : set \u03b1}\n\t[is_symm \u03b1 r] (hs : is_strong_antichain r s) :\n\tis_strong_antichain (flip r) s :=", "nl_statement_of_codex": "Let $r$ be a symmetric relation on a set $A$. If $S$ is a strong antichain for $r$, then $S$ is a strong antichain for the relation $r^{-1}$."}
{"name": "witt_vector.verschiebung_shift", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/domain.lean", "formal_statement": "theorem witt_vector.verschiebung_shift {p : \u2115} {R : Type*}\n\t[hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) (k : \u2115)\n\t(h : \u2200 (i : \u2115), i < k + 1 \u2192 x.coeff i = 0) :\n\t\u21d1witt_vector.verschiebung (x.shift k.succ) = x.shift k :=", "nl_statement_of_codex": "Let $p$ be a prime number, let $R$ be a commutative ring, and let $x$ be a Witt vector over $R$. Then the Verschiebung of the shift of $x$ is the shift of $x$."}
{"name": "composition.index_exists", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/composition.lean", "formal_statement": "theorem composition.index_exists {n : \u2115} ( : composition n) {j : \u2115} (h : j < n) :\n\t\u2203 (i : \u2115), j < c.size_up_to i.succ \u2227 i < c.length :=", "nl_statement_of_codex": "Let $c$ be a composition of $n$. Then for each $j<n$ there is an $i$ such that $j<c_1+\\cdots+c_i$ and $i<\\ell(c)$."}
{"name": "antitone.dual_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem antitone.dual_left {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} :\n\tantitone f \u2192 monotone (f \u2218 \u21d1order_dual.of_dual) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function between preordered sets. If $f$ is antitone, then $f$ is monotone when viewed as a function from $A$ to $B^\\text{op}$."}
{"name": "real.sqrt_sq_eq_abs", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/sqrt.lean", "formal_statement": "theorem real.sqrt_sq_eq_abs (x : \u211d) :\n\treal.sqrt (x ^ 2) = |x| :=", "nl_statement_of_codex": "$\\sqrt{x^2}=|x|$ for all $x\\in\\mathbb{R}$."}
{"name": "valued.cauchy_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/valuation.lean", "formal_statement": "theorem valued.cauchy_iff {R : Type u} [ring R] {\u0393\u2080 : Type v}\n\t[linear_ordered_comm_group_with_zero \u0393\u2080] [valued R \u0393\u2080] {F : filter R} :\n\tcauchy F \u2194 F.ne_bot \u2227 \u2200 (\u03b3 : \u0393\u2080\u02e3), \u2203 (M : set R) (H : M \u2208 F), \u2200 (x : R), x \u2208 M \u2192 \u2200 (y : R), y \u2208 M \u2192 \u21d1valued.v (y - x) < \u2191\u03b3 :=", "nl_statement_of_codex": "Let $R$ be a ring and let $\\Gamma_0$ be a linearly ordered commutative group with zero. Let $F$ be a filter on $R$. Then $F$ is Cauchy if and only if $F$ is non-empty and for each $\\gamma\\in\\Gamma_0$ there is a set $M\\in F$ such that for all $x,y\\in M$, $v(y-x)<\\gamma$."}
{"name": "measure_theory.L2.inner_indicator_const_Lp_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l2_space.lean", "formal_statement": "theorem measure_theory.L2.inner_indicator_const_Lp_one {\u03b1 \ud835\udd5c : Type*}\n\t[is_R_or_C \ud835\udd5c] [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1}\n\t(hs : measurable_set s) (h\u03bcs : \u21d1\u03bc s \u2260 \u22a4) (f : \u21a5(measure_theory.Lp \ud835\udd5c 2 \u03bc)) :\n\thas_inner.inner (measure_theory.indicator_const_Lp 2 hs h\u03bcs 1) f = \u222b (x : \u03b1) in s, \u21d1f x \u2202\u03bc :=", "nl_statement_of_codex": "Let $s$ be a measurable set with finite measure. Then the inner product of the indicator function of $s$ with any $L^2$ function is equal to the integral of the $L^2$ function over $s$."}
{"name": "function.injective_of_partial_inv_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.injective_of_partial_inv_right {\u03b1 : Type*} {\u03b2 : Sort u_2}\n\t{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 option \u03b1} (H : function.is_partial_inv f g) (x y : \u03b2)\n\t(b : \u03b1) (h\u2081 : b \u2208 g x) (h\u2082 : b \u2208 g y) :\n\tx = y :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to A$ be functions. If $g$ is a partial inverse of $f$, then $f$ is injective."}
{"name": "nnreal.coe_max", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/nnreal.lean", "formal_statement": "theorem nnreal.coe_max (x y : nnreal) :\n\t\u2191(linear_order.max x y) = linear_order.max \u2191x \u2191y :=", "nl_statement_of_codex": "The map $x\\mapsto \\lvert x\\rvert$ is order-preserving."}
{"name": "matrix.mul_kronecker_tmul_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/kronecker.lean", "formal_statement": "theorem matrix.mul_kronecker_tmul_mul (R : Type*) {\u03b1 \u03b2 l m n l' m' n' : Type*6}\n\t[comm_semiring R] [semiring \u03b1] [semiring \u03b2] [algebra R \u03b1] [algebra R \u03b2]\n\t[fintype m] [fintype m'] (A : matrix l m \u03b1) (B : matrix m n \u03b1)\n\t(A' : matrix l' m' \u03b2) (B' : matrix m' n' \u03b2) :\n\tmatrix.kronecker_map (tensor_product.tmul R) (A.mul B) (A'.mul B') = (matrix.kronecker_map (\u03bb (_x : \u03b1) (_y : \u03b2), _x \u2297\u209c[R] _y) A A').mul (matrix.kronecker_map (\u03bb (_x : \u03b1) (_y : \u03b2), _x \u2297\u209c[R] _y) B B') :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $A$ and $B$ be matrices over a $R$-algebra $\u03b1$, and let $A'$ and $B'$ be matrices over a $R$-algebra $\u03b2$. Then the Kronecker product of $A\\cdot B$ and $A'\\cdot B'$ is equal to the product of the Kronecker products of $A$ and $A'$ and of $B$ and $B'$."}
{"name": "submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/nakayama.lean", "formal_statement": "theorem submodule.smul_sup_eq_smul_sup_of_le_smul_of_le_jacobson {R M : Type*}\n\t[comm_ring R] [add_comm_group M] [module R M] {I J : ideal R}\n\t{N N' : submodule R M} (hN' : N'.fg) (hIJ : I \u2264 J.jacobson)\n\t(hNN : N \u2294 N' \u2264 N \u2294 I \u2022 N') :\n\tN \u2294 I \u2022 N' = N \u2294 J \u2022 N' :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ an $R$-module, $I$ and $J$ ideals of $R$, and $N$ and $N'$ submodules of $M$. If $N'$ is finitely generated, $I\\subseteq J^{-1}$, and $N\\oplus N'\\subseteq N\\oplus IN'$, then $N\\oplus IN'=N\\oplus JN'$."}
{"name": "zpow_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_with_zero/power.lean", "formal_statement": "theorem zpow_ne_zero {G\u2080 : Type*} [group_with_zero G\u2080] {x : G\u2080} (n : \u2124) :\n\tx \u2260 0 \u2192 x ^ n \u2260 0 :=", "nl_statement_of_codex": "Let $G$ be a group with zero element. Let $x\\in G$ and $n\\in\\mathbb{Z}$. If $x\\neq 0$, then $x^n\\neq 0$."}
{"name": "measure_theory.L1.simple_func.set_to_L1s_mono_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/set_to_l1.lean", "formal_statement": "theorem measure_theory.L1.simple_func.set_to_L1s_mono_left {\u03b1 E : Type*}\n\t[normed_group E] [normed_space \u211d E] {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {G'' : Type*}\n\t[normed_lattice_add_comm_group G''] [normed_space \u211d G'']\n\t{T T' : set \u03b1 \u2192 (E \u2192L[\u211d] G'')}\n\t(hTT' : \u2200 (s : set \u03b1) (x : E), \u21d1(T s) x \u2264 \u21d1(T' s) x)\n\t(f : \u21a5(measure_theory.Lp.simple_func E 1 \u03bc)) :\n\tmeasure_theory.L1.simple_func.set_to_L1s T f \u2264 measure_theory.L1.simple_func.set_to_L1s T' f :=", "nl_statement_of_codex": "Let $E$ be a normed group, $G''$ a normed lattice group, $T,T': \\mathcal{P}(E)\\to \\mathcal{P}(G'')$ and $f:\\mathcal{P}(E)\\to \\mathbb{R}$. If $T(s)(x)\\leq T'(s)(x)$ for all $s\\in \\mathcal{P}(E)$ and $x\\in E$, then $T(f)\\leq T'(f)$."}
{"name": "first_order.language.hom.to_fun_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/basic.lean", "formal_statement": "theorem first_order.language.hom.to_fun_eq_coe {L : first_order.language}\n\t{M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] {f : L.hom M N} :\n\tf.to_fun = \u21d1f :=", "nl_statement_of_codex": "Let $L$ be a first-order language, let $M$ and $N$ be $L$-structures, and let $f:M\\to N$ be an $L$-homomorphism. Then $f$ is equal to the function $f:M\\to N$."}
{"name": "real.strict_anti_on_log", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/log/basic.lean", "formal_statement": "theorem real.strict_anti_on_log :\n\tstrict_anti_on real.log (set.Iio 0) :=", "nl_statement_of_codex": "The logarithm function is strictly anti-monotone on the interval $(0,\\infty)$."}
{"name": "matrix.sum_cramer_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/adjugate.lean", "formal_statement": "theorem matrix.sum_cramer_apply {n : Type u} [decidable_eq n] [fintype n]\n\t{\u03b1 : Type v} [comm_ring \u03b1] (A : matrix n n \u03b1) {\u03b2 : Type*} (s : finset \u03b2)\n\t(f : n \u2192 \u03b2 \u2192 \u03b1) (i : n) :\n\ts.sum (\u03bb (x : \u03b2), \u21d1(A.cramer) (\u03bb (j : n), f j x) i) = \u21d1(A.cramer) (\u03bb (j : n), s.sum (\u03bb (x : \u03b2), f j x)) i :=", "nl_statement_of_codex": "Let $A$ be an $n\\times n$ matrix over a commutative ring $R$. Let $s$ be a finite set and let $f:n\\times s\\to R$. Then for each $i\\in n$, the $i$-th entry of the vector $A^{-1}(s\\sum_{x\\in s}f(x))$ is equal to $\\sum_{x\\in s}(A^{-1}f(x))_i$."}
{"name": "add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/char_zero/quotient.lean", "formal_statement": "theorem add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div {R : Type*}\n\t[division_ring R] [char_zero R] {p r : R} {z : \u2124} (hz : z \u2260 0) :\n\tz \u2022 r \u2208 add_subgroup.zmultiples p \u2194 \u2203 (k : fin z.nat_abs), r - \u2191k \u2022 (p / \u2191z) \u2208 add_subgroup.zmultiples p :=", "nl_statement_of_codex": "Let $R$ be a division ring of characteristic zero. Let $p, r\\in R$ and $z\\in\\mathbb{Z}$. Then $zr\\in zR$ if and only if there exists $k\\in\\mathbb{Z}$ such that $r-kp/z\\in zR$."}
{"name": "add_submonoid.subsingleton_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/basic.lean", "formal_statement": "theorem add_submonoid.subsingleton_iff {M : Type*} [add_zero_class M] :\n\tsubsingleton (add_submonoid M) \u2194 subsingleton M :=", "nl_statement_of_codex": "The additive submonoid of a type $M$ is a singleton if and only if $M$ is a singleton."}
{"name": "hamming.nnnorm_eq_hamming_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/information_theory/hamming.lean", "formal_statement": "theorem hamming.nnnorm_eq_hamming_norm {\u03b9 \u03b2 : \u03b9 \u2192 Type*} [fintype \u03b9]\n\t[\u03a0 (i : \u03b9), decidable_eq (\u03b2 i)] [\u03a0 (i : \u03b9), add_comm_group (\u03b2 i)]\n\t(x : hamming \u03b2) :\n\t\u2225x\u2225\u208a = \u2191(hamming_norm (\u21d1hamming.of_hamming x)) :=", "nl_statement_of_codex": "The Hamming norm of a Hamming sequence is equal to the Hamming norm of the corresponding Hamming sequence."}
{"name": "int.even_mul_succ_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/parity.lean", "formal_statement": "theorem int.even_mul_succ_self (n : \u2124) :\n\teven (n * (n + 1)) :=", "nl_statement_of_codex": "For any integer $n$, $n(n+1)$ is even."}
{"name": "quotient.lift_on'_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/quot.lean", "formal_statement": "theorem quotient.lift_on'_mk {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} [setoid \u03b1] (x : \u03b1)\n\t(f : \u03b1 \u2192 \u03b2) (h : \u2200 (a b : \u03b1), setoid.r a b \u2192 f a = f b) :\n\t\u27e6x\u27e7.lift_on' f h = f x :=", "nl_statement_of_codex": "Let $R$ be a setoid and let $f:R\\to S$ be a function. Then $f$ induces a function $f':R/\\sim\\to S$ by $f'([x])=f(x)$. This function is well-defined."}
{"name": "real.sinh_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/exponential.lean", "formal_statement": "theorem real.sinh_eq (x : \u211d) :\n\treal.sinh x = (real.exp x - real.exp (-x)) / 2 :=", "nl_statement_of_codex": "The hyperbolic sine of $x$ is equal to $(e^x-e^{-x})/2$."}
{"name": "part.sdiff_get_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.sdiff_get_eq {\u03b1 : Type*} [has_sdiff \u03b1] (a b : part \u03b1)\n\t(hab : (a \\ b).dom) :\n\t(a \\ b).get hab = a.get _ \\ b.get _ :=", "nl_statement_of_codex": "Let $A$ and $B$ be partitions of a set $X$. Then $(A\\setminus B)(x)=A(x)\\setminus B(x)$ for all $x\\in X$."}
{"name": "cardinal.mk_finsupp_of_fintype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.mk_finsupp_of_fintype (\u03b1 \u03b2 : Type u) [fintype \u03b1] [has_zero \u03b2] :\n\tcardinal.mk (\u03b1 \u2192\u2080 \u03b2) = cardinal.mk \u03b2 ^ fintype.card \u03b1 :=", "nl_statement_of_codex": "The cardinality of the set of finitely supported functions from $A$ to $B$ is the cardinality of $B$ raised to the cardinality of $A$."}
{"name": "bundle.sigma_mk_eq_total_space_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bundle.lean", "formal_statement": "theorem bundle.sigma_mk_eq_total_space_mk {B E : B \u2192 Type*} {x : B} {y : E x} :\n\t\u27e8x, y\u27e9 = bundle.total_space_mk x y :=", "nl_statement_of_codex": "Let $B$ be a set and let $E$ be a family of sets indexed by $B$. Then the element $(x,y)$ of the product $\\prod_{b\\in B}E_b$ is equal to the element $((x,y),y)$ of the total space of the bundle $E$."}
{"name": "category_theory.coalgebra_equiv_over_inverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/products.lean", "formal_statement": "theorem category_theory.coalgebra_equiv_over_inverse {C : Type u}\n\t[category_theory.category C] (X : C)\n\t[category_theory.limits.has_binary_products C] :\n\t(category_theory.coalgebra_equiv_over X).inverse = category_theory.over_to_coalgebra X :=", "nl_statement_of_codex": "The inverse of the equivalence between coalgebras over $X$ and $X$-coalgebras is the functor from $X$-coalgebras to coalgebras over $X$."}
{"name": "is_Lprojection.mul_compl_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/M_structure.lean", "formal_statement": "theorem is_Lprojection.mul_compl_self {X : Type*} [normed_group X] {M : Type}\n\t[ring M] [module M X] {P : {P // is_Lprojection X P}} :\n\t\u2191P * \u2191P\u1d9c = 0 :=", "nl_statement_of_codex": "Let $X$ be a normed group and let $M$ be a module over a ring $R$. Let $P$ be an $L$-projection on $X$. Then $P\\cdot P^\\perp=0$."}
{"name": "bitvec.add_lsb_div_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bitvec/basic.lean", "formal_statement": "theorem bitvec.add_lsb_div_two {x : \u2115} {b : bool} :\n\tbitvec.add_lsb x b / 2 = x :=", "nl_statement_of_codex": "The function $x\\mapsto x/2$ is the inverse of the function $x\\mapsto x+1$."}
{"name": "finset.singleton_product_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/prod.lean", "formal_statement": "theorem finset.singleton_product_singleton {\u03b1 \u03b2 : Type*} {a : \u03b1} {b : \u03b2} :\n\t{a}.product {b} = {(a, b)} :=", "nl_statement_of_codex": "The product of a singleton set and a singleton set is the singleton set containing the pair of the two elements."}
{"name": "algebra.finite_type.equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/finiteness.lean", "formal_statement": "theorem algebra.finite_type.equiv {R A B : Type*} [comm_ring R] [comm_ring A]\n\t[algebra R A] [comm_ring B] [algebra R B] (hRA : algebra.finite_type R A)\n\t(e : A \u2243\u2090[R] B) :\n\talgebra.finite_type R B :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $A$ and $B$ be $R$-algebras. If $A$ is a finite type $R$-algebra, then $B$ is a finite type $R$-algebra."}
{"name": "polynomial.erase_lead_nat_degree_le_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/erase_lead.lean", "formal_statement": "theorem polynomial.erase_lead_nat_degree_le_aux {R : Type*} [semiring R]\n\t{f : polynomial R} :\n\tf.erase_lead.nat_degree \u2264 f.nat_degree :=", "nl_statement_of_codex": "The degree of the polynomial $f$ is at least the degree of the polynomial $f$ with the leading coefficient erased."}
{"name": "matrix.invertible_equiv_det_invertible_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/nonsingular_inverse.lean", "formal_statement": "theorem matrix.invertible_equiv_det_invertible_symm_apply {n : Type u'}\n\t{\u03b1 : Type v} [fintype n] [decidable_eq n] [comm_ring \u03b1] (A : matrix n n \u03b1)\n\t[invertible A.det] :\n\t\u21d1(A.invertible_equiv_det_invertible.symm) _inst_4 = A.invertible_of_det_invertible :=", "nl_statement_of_codex": "Let $A$ be an $n\\times n$ matrix over a commutative ring $R$ such that $\\det(A)$ is invertible in $R$. Then $A$ is invertible and $A^{-1}=\\det(A)^{-1}A^T$."}
{"name": "affine_map.smul_linear", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_map.lean", "formal_statement": "theorem affine_map.smul_linear {k V1 P1 V2 : Type*} [ring k] [add_comm_group V1]\n\t[module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] {R : Type*0}\n\t[monoid R] [distrib_mul_action R V2] [smul_comm_class k R V2] (t : R)\n\t(f : P1 \u2192\u1d43[k] V2) :\n\t(t \u2022 f).linear = t \u2022 f.linear :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ and $V_2$ be $k$-modules, $P_1$ be an affine space over $V_1$, and $R$ be a monoid. Let $f:P_1\\to V_2$ be an affine map. Then $t\\cdot f$ is linear if and only if $f$ is linear."}
{"name": "order.ideal.is_proper.top_not_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/ideal.lean", "formal_statement": "theorem order.ideal.is_proper.top_not_mem {P : Type*} [has_le P] [order_top P]\n\t{I : order.ideal P} (hI : I.is_proper) :\n\t\u22a4 \u2209 I :=", "nl_statement_of_codex": "Let $P$ be a partially ordered set with a top element. Let $I$ be a proper ideal of $P$. Then the top element is not in $I$."}
{"name": "category_theory.monoidal_category.right_unitor_nat_iso_hom_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/category.lean", "formal_statement": "theorem category_theory.monoidal_category.right_unitor_nat_iso_hom_app\n\t(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]\n\t(X : C) :\n\t(category_theory.monoidal_category.right_unitor_nat_iso C).hom.app X = (\u03c1_ X).hom :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Then the natural isomorphism $\\rho_X:X\\otimes I\\to X$ is given by the homomorphism $\\rho_X:X\\otimes I\\to X$."}
{"name": "matrix.transpose_col", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem matrix.transpose_col {m : Type*} {\u03b1 : Type v} (v : m \u2192 \u03b1) :\n\t(matrix.col v).transpose = matrix.row v :=", "nl_statement_of_codex": "The transpose of a column vector is a row vector."}
{"name": "continuous_iff_coinduced_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order.lean", "formal_statement": "theorem continuous_iff_coinduced_le {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}\n\t{t\u2081 : topological_space \u03b1} {t\u2082 : topological_space \u03b2} :\n\tcontinuous f \u2194 topological_space.coinduced f t\u2081 \u2264 t\u2082 :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Then $f$ is continuous if and only if the coinduced topology on $X$ is finer than the topology on $Y$."}
{"name": "uniform_space.completion.extension_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/completion.lean", "formal_statement": "theorem uniform_space.completion.extension_map {\u03b1 : Type*} [uniform_space \u03b1]\n\t{\u03b2 : Type*} [uniform_space \u03b2] {\u03b3 : Type*} [uniform_space \u03b3] [complete_space \u03b3]\n\t[separated_space \u03b3] {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} (hf : uniform_continuous f)\n\t(hg : uniform_continuous g) :\n\tuniform_space.completion.extension f \u2218 uniform_space.completion.map g = uniform_space.completion.extension (f \u2218 g) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ and $g:X\\to Z$ be uniformly continuous maps. Then the map $f\\circ g:X\\to Y$ is uniformly continuous."}
{"name": "mem_rees_algebra_iff_support", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/rees_algebra.lean", "formal_statement": "theorem mem_rees_algebra_iff_support {R : Type u} [comm_ring R] (I : ideal R)\n\t(f : polynomial R) :\n\tf \u2208 rees_algebra I \u2194 \u2200 (i : \u2115), i \u2208 f.support \u2192 f.coeff i \u2208 I ^ i :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $I$ be an ideal of $R$. Then $f\\in R[It]$ if and only if $f_i\\in I^i$ for all $i\\in\\mathbb{N}$."}
{"name": "is_submonoid.preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/submonoid.lean", "formal_statement": "theorem is_submonoid.preimage {M : Type*} [monoid M] {N : Type*} [monoid N]\n\t{f : M \u2192 N} (hf : is_monoid_hom f) {s : set N} (hs : is_submonoid s) :\n\tis_submonoid (f \u207b\u00b9' s) :=", "nl_statement_of_codex": "Let $f:M\\to N$ be a monoid homomorphism. Let $s$ be a submonoid of $N$. Then $f^{-1}(s)$ is a submonoid of $M$."}
{"name": "finite_dimensional_of_dim_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean", "formal_statement": "theorem finite_dimensional_of_dim_eq_one {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V] (h : module.rank K V = 1) :\n\tfinite_dimensional K V :=", "nl_statement_of_codex": "Let $K$ be a division ring and $V$ a $K$-module. If $\\dim_K V=1$, then $V$ is finite dimensional."}
{"name": "finite_field.forall_pow_eq_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/finite/basic.lean", "formal_statement": "theorem finite_field.forall_pow_eq_one_iff (K : Type*) [field K] [fintype K]\n\t(i : \u2115) :\n\t(\u2200 (x : K\u02e3), x ^ i = 1) \u2194 fintype.card K - 1 \u2223 i :=", "nl_statement_of_codex": "Let $K$ be a finite field. Then $i$ is a multiple of $|K|-1$ if and only if every element of $K$ has order dividing $i$."}
{"name": "units.coe_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/units.lean", "formal_statement": "theorem units.coe_smul {G M : Type*} [group G] [monoid M] [mul_action G M]\n\t[smul_comm_class G M M] [is_scalar_tower G M M] (g : G) (m : M\u02e3) :\n\t\u2191(g \u2022 m) = g \u2022 \u2191m :=", "nl_statement_of_codex": "Let $G$ be a group acting on a monoid $M$ by monoid homomorphisms. Then the action of $G$ on $M$ induces an action of $G$ on the group of units of $M$."}
{"name": "list.singleton_sublist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.singleton_sublist {\u03b1 : Type u} {a : \u03b1} {l : list \u03b1} :\n\t[a] <+ l \u2194 a \u2208 l :=", "nl_statement_of_codex": "A list $[a]$ is a sublist of $l$ if and only if $a$ is an element of $l$."}
{"name": "linear_map.exists_right_inverse_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basis.lean", "formal_statement": "theorem linear_map.exists_right_inverse_of_surjective {K : Type*} {V : Type u}\n\t{V' : Type*} [field K] [add_comm_group V] [add_comm_group V'] [module K V]\n\t[module K V'] (f : V \u2192\u2097[K] V') (hf_surj : f.range = \u22a4) :\n\t\u2203 (g : V' \u2192\u2097[K] V), f.comp g = linear_map.id :=", "nl_statement_of_codex": "Let $K$ be a field, $V$ and $V'$ be $K$-vector spaces. Let $f:V\\to V'$ be a linear map. If $f$ is surjective, then there exists a linear map $g:V'\\to V$ such that $f\\circ g=\\mathrm{id}_{V'}$."}
{"name": "category_theory.cartesian_closed.curry_natural_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/closed/cartesian.lean", "formal_statement": "theorem category_theory.cartesian_closed.curry_natural_right {C : Type u}\n\t[category_theory.category C] {A X Y Y' : C}\n\t[category_theory.limits.has_finite_products C]\n\t[category_theory.exponentiable A] (f : A \u2a2f X \u27f6 Y) (g : Y \u27f6 Y') :\n\tcategory_theory.cartesian_closed.curry (f \u226b g) = category_theory.cartesian_closed.curry f \u226b (category_theory.exp A).map g :=", "nl_statement_of_codex": "Let $C$ be a category with finite products and exponentiable objects. Let $A, X, Y, Y'$ be objects of $C$ and let $f:A\\times X\\to Y$ and $g:Y\\to Y'$ be morphisms in $C$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nA\\times X & \\xrightarrow{f} & Y \\\\\n\\downarrow & & \\downarrow \\\\\nA & \\xrightarrow{g} & Y'\n\\end{array}$$"}
{"name": "polynomial.coe_norm_unit_of_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/field_division.lean", "formal_statement": "theorem polynomial.coe_norm_unit_of_ne_zero {R : Type u} [field R]\n\t{p : polynomial R} (hp : p \u2260 0) :\n\t\u2191(normalization_monoid.norm_unit p) = \u21d1polynomial.C (p.leading_coeff)\u207b\u00b9 :=", "nl_statement_of_codex": "Let $R$ be a field and let $p$ be a nonzero polynomial over $R$. Then the leading coefficient of $p$ is a unit in $R$."}
{"name": "metric.closed_ball_disjoint_closed_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.closed_ball_disjoint_closed_ball {\u03b1 : Type u}\n\t[pseudo_metric_space \u03b1] {x y : \u03b1} {\u03b4 \u03b5 : \u211d} (h : \u03b4 + \u03b5 < has_dist.dist x y) :\n\tdisjoint (metric.closed_ball x \u03b4) (metric.closed_ball y \u03b5) :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x,y\\in X$. If $\\delta+\\epsilon<d(x,y)$, then the closed balls $B(x,\\delta)$ and $B(y,\\epsilon)$ are disjoint."}
{"name": "continuous_linear_map.op_norm_lmul_apply_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.op_norm_lmul_apply_le (\ud835\udd5c : Type*)\n\t[nondiscrete_normed_field \ud835\udd5c] (\ud835\udd5c' : Type*1) [normed_ring \ud835\udd5c']\n\t[normed_algebra \ud835\udd5c \ud835\udd5c'] (x : \ud835\udd5c') :\n\t\u2225\u21d1(continuous_linear_map.lmul \ud835\udd5c \ud835\udd5c') x\u2225 \u2264 \u2225x\u2225 :=", "nl_statement_of_codex": "Let $K$ be a nondiscrete normed field and let $R$ be a normed ring. Then the norm of the linear map $K\\to K\\otimes_\\mathbb{Z}R$ given by $k\\mapsto k\\otimes x$ is bounded by the norm of $x$."}
{"name": "complex.deriv_sin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem complex.deriv_sin :\n\tderiv complex.sin = complex.cos :=", "nl_statement_of_codex": "The derivative of the sine function is the cosine function."}
{"name": "is_compact.exists_open_superset_measure_lt_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem is_compact.exists_open_superset_measure_lt_top {\u03b1 : Type*}\n\t[topological_space \u03b1] [measurable_space \u03b1] {s : set \u03b1} (h : is_compact s)\n\t(\u03bc : measure_theory.measure \u03b1) [measure_theory.is_locally_finite_measure \u03bc] :\n\t\u2203 (U : set \u03b1) (H : U \u2287 s), is_open U \u2227 \u21d1\u03bc U < \u22a4 :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $\\mu$ be a locally finite measure on $X$. Let $K$ be a compact subset of $X$. Then there is an open set $U$ containing $K$ such that $\\mu(U)<\\infty$."}
{"name": "algebraic_geometry.structure_sheaf.stalk_to_fiber_ring_hom_germ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.structure_sheaf.stalk_to_fiber_ring_hom_germ\n\t(R : Type u) [comm_ring R]\n\t(U : topological_space.opens \u21a5(algebraic_geometry.prime_spectrum.Top R))\n\t(x : \u21a5U)\n\t(s : \u21a5((algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op U))) :\n\t\u21d1(algebraic_geometry.structure_sheaf.stalk_to_fiber_ring_hom R \u2191x) (\u21d1((algebraic_geometry.Spec.structure_sheaf R).val.germ x) s) = s.val x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring. Let $U$ be an open subset of $\\operatorname{Spec}(R)$ and let $x\\in U$. Let $s$ be a section of the structure sheaf of $\\operatorname{Spec}(R)$ over $U$. Then the germ of $s$ at $x$ is equal to the image of $s$ under the stalk-to-fiber ring homomorphism at $x$."}
{"name": "cauchy_iff'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean", "formal_statement": "theorem cauchy_iff' {\u03b1 : Type u} [uniform_space \u03b1] {f : filter \u03b1} :\n\tcauchy f \u2194 f.ne_bot \u2227 \u2200 (s : set (\u03b1 \u00d7 \u03b1)), s \u2208 uniformity \u03b1 \u2192 (\u2203 (t : set \u03b1) (H : t \u2208 f), \u2200 (x : \u03b1), x \u2208 t \u2192 \u2200 (y : \u03b1), y \u2208 t \u2192 (x, y) \u2208 s) :=", "nl_statement_of_codex": "A filter $f$ on a uniform space $X$ is Cauchy if and only if $f$ is nonempty and for every entourage $U$ of $X$, there is a set $V\\in f$ such that for all $x,y\\in V$, $(x,y)\\in U$."}
{"name": "two_pointing.snd_ne_fst", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/two_pointing.lean", "formal_statement": "theorem two_pointing.snd_ne_fst {\u03b1 : Type*} (p : two_pointing \u03b1) :\n\tp.to_prod.snd \u2260 p.to_prod.fst :=", "nl_statement_of_codex": "Let $p$ be a two-pointing of a set $X$. Then the second element of $p$ is not equal to the first element of $p$."}
{"name": "div_le_div_iff'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem div_le_div_iff' {\u03b1 : Type u} [comm_group \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] {a b c d : \u03b1} :\n\ta / b \u2264 c / d \u2194 a * d \u2264 c * b :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a commutative group. Then $a/b\\leq c/d$ if and only if $ad\\leq cb$."}
{"name": "continuous_on_of_uniform_approx_of_continuous_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/uniform_convergence.lean", "formal_statement": "theorem continuous_on_of_uniform_approx_of_continuous_on {\u03b1 \u03b2 : Type*}\n\t[uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} [topological_space \u03b1]\n\t(L : \u2200 (u : set (\u03b2 \u00d7 \u03b2)), u \u2208 uniformity \u03b2 \u2192 (\u2203 (F : \u03b1 \u2192 \u03b2), continuous_on F s \u2227 \u2200 (y : \u03b1), y \u2208 s \u2192 (f y, F y) \u2208 u)) :\n\tcontinuous_on f s :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function from a topological space $X$ to a uniform space $Y$. Suppose that for each entourage $U$ of $Y$ there is a continuous function $F:X\\to Y$ such that $F(x)$ is close to $f(x)$ for all $x\\in X$. Then $f$ is continuous."}
{"name": "submonoid_class.one_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem submonoid_class.one_def {M : Type*} [mul_one_class M] {A : Type*}\n\t[set_like A M] [hA : submonoid_class A M] (S' : A) :\n\t1 = \u27e81, _\u27e9 :=", "nl_statement_of_codex": "Let $M$ be a monoid with identity $1$ and let $A$ be a submonoid of $M$. Then $1=\\langle 1\\rangle$."}
{"name": "real.smooth_transition.continuous", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/specific_functions.lean", "formal_statement": "theorem real.smooth_transition.continuous :\n\tcontinuous real.smooth_transition :=", "nl_statement_of_codex": "The function $f(x)=\\begin{cases} 0 & x\\leq 0 \\\\ x & 0\\leq x\\leq 1 \\\\ 1 & x\\geq 1 \\end{cases}$ is continuous."}
{"name": "parser.bounded.guard_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/buffer/parser/basic.lean", "formal_statement": "theorem parser.bounded.guard_iff {p : Prop} [decidable p] :\n\t(guard p).bounded \u2194 \u00acp :=", "nl_statement_of_codex": "The parser `guard p` is bounded if and only if $p$ is false."}
{"name": "category_theory.representable_of_nat_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/yoneda.lean", "formal_statement": "theorem category_theory.representable_of_nat_iso {C : Type u\u2081}\n\t[category_theory.category C] (F : C\u1d52\u1d56 \u2964 Type v\u2081) {G : C\u1d52\u1d56 \u2964 Type v\u2081}\n\t(i : F \u2245 G) [F.representable] :\n\tG.representable :=", "nl_statement_of_codex": "Let $F$ and $G$ be functors from the opposite category of $C$ to the category of types. If $F$ is representable and $F$ and $G$ are naturally isomorphic, then $G$ is representable."}
{"name": "int.to_nat_sub", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/basic.lean", "formal_statement": "theorem int.to_nat_sub (m n : \u2115) :\n\t(\u2191m - \u2191n).to_nat = m - n :=", "nl_statement_of_codex": "The natural number $m-n$ is equal to the natural number obtained by converting the integer $m-n$ to a natural number."}
{"name": "sigma_finsupp_equiv_dfinsupp_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/to_dfinsupp.lean", "formal_statement": "theorem sigma_finsupp_equiv_dfinsupp_single {\u03b9 \u03b7 N : Type*} [has_zero N]\n\t(a : \u03a3 (i : \u03b9), \u03b7 i) (n : N) :\n\t\u21d1sigma_finsupp_equiv_dfinsupp (finsupp.single a n) = dfinsupp.single a.fst (finsupp.single a.snd n) :=", "nl_statement_of_codex": "Let $N$ be a commutative monoid with zero. Let $a=(i,j)$ be an element of $\\Sigma_{i\\in I}J_i$. Then $\\Sigma_{i\\in I}J_i$ is isomorphic to $I\\times\\Sigma_{i\\in I}J_i$."}
{"name": "differentiable.cexp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/exp_deriv.lean", "formal_statement": "theorem differentiable.cexp {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_algebra \ud835\udd5c \u2102] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{f : E \u2192 \u2102} (hc : differentiable \ud835\udd5c f) :\n\tdifferentiable \ud835\udd5c (\u03bb (x : E), complex.exp (f x)) :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $f:E\\to\\mathbb{C}$. If $f$ is differentiable, then $e^f$ is differentiable."}
{"name": "prod.swap_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/prod.lean", "formal_statement": "theorem prod.swap_zero {M N : Type*} [has_zero M] [has_zero N] :\n\t0.swap = 0 :=", "nl_statement_of_codex": "The swap of the zero element of a product of two types with zero is the zero element of the product."}
{"name": "array.to_list_nth_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/array/lemmas.lean", "formal_statement": "theorem array.to_list_nth_le {n : \u2115} {\u03b1 : Type u} {a : array n \u03b1} (i : \u2115)\n\t(h : i < n) (h' : i < a.to_list.length) :\n\ta.to_list.nth_le i h' = a.read \u27e8i, h\u27e9 :=", "nl_statement_of_codex": "Let $a$ be an array of length $n$ and let $i$ be an integer such that $0\\leq i<n$. Then the $i$-th element of the list $a.to\\_list$ is equal to $a[i]$."}
{"name": "parser.success_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/buffer/parser/basic.lean", "formal_statement": "theorem parser.success_iff {\u03b1 : Type} (p : parser \u03b1) (cb : char_buffer) (n : \u2115) :\n\t(\u2200 (pos' : \u2115) (err : dlist string), p cb n \u2260 parse_result.fail pos' err) \u2194 \u2203 (pos' : \u2115) (result : \u03b1), p cb n = parse_result.done pos' result :=", "nl_statement_of_codex": "Let $p$ be a parser and $cb$ a character buffer. Then $p$ succeeds on $cb$ if and only if there is a position $pos'$ and a result $result$ such that $p$ succeeds on $cb$ at position $pos'$ with result $result$."}
{"name": "nat.gcd_dvd_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.gcd_dvd_right (m n : \u2115) :\n\tm.gcd n \u2223 n :=", "nl_statement_of_codex": "The greatest common divisor of $m$ and $n$ divides $n$."}
{"name": "algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace_hom_base", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/open_immersion.lean", "formal_statement": "theorem algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace_hom_base\n\t{C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_products C]\n\t{X : algebraic_geometry.PresheafedSpace C}\n\t(Y : algebraic_geometry.SheafedSpace C) (f : X \u27f6 Y.to_PresheafedSpace)\n\t[H : algebraic_geometry.PresheafedSpace.is_open_immersion f] :\n\t(algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace_hom Y f).base = f.base :=", "nl_statement_of_codex": "Let $C$ be a category with products. Let $X$ be a presheafed space over $C$ and let $Y$ be a sheafed space over $C$. Let $f:X\\to Y$ be a morphism of presheafed spaces. Then the base of the morphism of sheafed spaces $f:X\\to Y$ is $f$."}
{"name": "inv_eq_iff_mul_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem inv_eq_iff_mul_eq_one {G : Type*} [group G] {a b : G} :\n\ta\u207b\u00b9 = b \u2194 a * b = 1 :=", "nl_statement_of_codex": "Let $G$ be a group and let $a, b\\in G$. Then $a^{-1}=b$ if and only if $ab=1$."}
{"name": "clifford_algebra.even_odd_mul_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/clifford_algebra/grading.lean", "formal_statement": "theorem clifford_algebra.even_odd_mul_le {R M : Type*} [comm_ring R]\n\t[add_comm_group M] [module R M] (Q : quadratic_form R M) (i j : zmod 2) :\n\tclifford_algebra.even_odd Q i * clifford_algebra.even_odd Q j \u2264 clifford_algebra.even_odd Q (i + j) :=", "nl_statement_of_codex": "Let $Q$ be a quadratic form on a module $M$ over a commutative ring $R$. Then the even and odd parts of $Q$ satisfy $Q_iQ_j\\le Q_{i+j}$."}
{"name": "simple_graph.incidence_set_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/basic.lean", "formal_statement": "theorem simple_graph.incidence_set_subset {V : Type u} (G : simple_graph V)\n\t(v : V) :\n\tG.incidence_set v \u2286 G.edge_set :=", "nl_statement_of_codex": "Let $G$ be a simple graph. Then the incidence set of a vertex $v$ is a subset of the edge set of $G$."}
{"name": "lattice_ordered_comm_group.pos_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/lattice_group.lean", "formal_statement": "theorem lattice_ordered_comm_group.pos_zero {\u03b1 : Type u} [lattice \u03b1]\n\t[add_comm_group \u03b1] :\n\t0\u207a = 0 :=", "nl_statement_of_codex": "In a lattice-ordered commutative group, $0^+ = 0$."}
{"name": "continuous_inf_dom_left\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem continuous_inf_dom_left\u2082 {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n\t{ta1 ta2 : topological_space \u03b1} {tb1 tb2 : topological_space \u03b2}\n\t{tc1 : topological_space \u03b3} (h : continuous (\u03bb (p : \u03b1 \u00d7 \u03b2), f p.fst p.snd)) :\n\tcontinuous (\u03bb (p : \u03b1 \u00d7 \u03b2), f p.fst p.snd) :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. If $f$ is continuous, then $f$ is continuous."}
{"name": "add_le_cancellable.le_add_tsub_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem add_le_cancellable.le_add_tsub_swap {\u03b1 : Type*} [preorder \u03b1]\n\t[add_comm_semigroup \u03b1] [has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1}\n\t(hb : add_le_cancellable b) :\n\ta \u2264 b + a - b :=", "nl_statement_of_codex": "Let $a, b$ be elements of a preordered additive commutative semigroup with a subtraction operation. If $b$ is cancellable, then $a\\leq b+a-b$."}
{"name": "real.sin_arcsin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/inverse.lean", "formal_statement": "theorem real.sin_arcsin {x : \u211d} (hx\u2081 : -1 \u2264 x) (hx\u2082 : x \u2264 1) :\n\treal.sin (real.arcsin x) = x :=", "nl_statement_of_codex": "For all $x\\in [-1,1]$, $\\sin(\\arcsin(x))=x$."}
{"name": "strict_mono_to_dual_comp_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem strict_mono_to_dual_comp_iff {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\tstrict_mono (\u21d1order_dual.to_dual \u2218 f) \u2194 strict_anti f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function between preordered sets. Then $f$ is strictly increasing if and only if $f$ is strictly decreasing."}
{"name": "order.ideal.top_to_lower_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/ideal.lean", "formal_statement": "theorem order.ideal.top_to_lower_set {P : Type*} [has_le P]\n\t[is_directed P has_le.le] [nonempty P] :\n\t\u22a4.to_lower_set = \u22a4 :=", "nl_statement_of_codex": "Let $P$ be a directed poset with a least element. Then the lower set of the least element is the whole poset."}
{"name": "fractional_ideal.le_div_iff_mul_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.le_div_iff_mul_le {R\u2081 : Type*} [comm_ring R\u2081]\n\t{K : Type*} [field K] [algebra R\u2081 K] [frac : is_fraction_ring R\u2081 K]\n\t[is_domain R\u2081] {I J J' : fractional_ideal (non_zero_divisors R\u2081) K}\n\t(hJ' : J' \u2260 0) :\n\tI \u2264 J / J' \u2194 I * J' \u2264 J :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $K$ a field, and $I, J, J'$ fractional ideals of $K$. Then $I\\leq J/J'$ if and only if $I\\cdot J'\\leq J$."}
{"name": "algebraic_geometry.Scheme.pullback.pullback_p1_iso_hom_\u03b9_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/pullbacks.lean", "formal_statement": "theorem algebraic_geometry.Scheme.pullback.pullback_p1_iso_hom_\u03b9_assoc\n\t{X Y Z : algebraic_geometry.Scheme} (\ud835\udcb0 : X.open_cover) (f : X \u27f6 Z) (g : Y \u27f6 Z)\n\t[\u2200 (i : \ud835\udcb0.J), category_theory.limits.has_pullback (\ud835\udcb0.map i \u226b f) g] (i : \ud835\udcb0.J)\n\t{X' : algebraic_geometry.Scheme}\n\t(f' : (algebraic_geometry.Scheme.pullback.gluing \ud835\udcb0 f g).glued \u27f6 X') :\n\t(algebraic_geometry.Scheme.pullback.pullback_p1_iso \ud835\udcb0 f g i).hom \u226b (algebraic_geometry.Scheme.pullback.gluing \ud835\udcb0 f g).\u03b9 i \u226b f' = category_theory.limits.pullback.fst \u226b f' :=", "nl_statement_of_codex": "Let $X, Y, Z$ be schemes and let $f:X\\to Z$ and $g:Y\\to Z$ be morphisms of schemes. Let $\ud835\udcb0$ be an open cover of $X$. Suppose that for each $i\\in J$ there is a pullback of $\ud835\udcb0.map i\\circ f$ and $g$. Let $i\\in J$ and let $f':(X\\times_Z Y)_i\\to X'$ be a morphism of schemes. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\n(X\\times_Z Y)_i \\arrow"}
{"name": "quaternion.one_im_j", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion.one_im_j {R : Type*} [comm_ring R] :\n\t1.im_j = 0 :=", "nl_statement_of_codex": "The imaginary part of $1$ is $0$."}
{"name": "sigma.lt_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sigma/order.lean", "formal_statement": "theorem sigma.lt_def {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), has_lt (\u03b1 i)]\n\t{a b : \u03a3 (i : \u03b9), \u03b1 i} :\n\ta < b \u2194 \u2203 (h : a.fst = b.fst), eq.rec a.snd h < b.snd :=", "nl_statement_of_codex": "Let $a, b$ be elements of $\\Sigma_{i\\in I}A_i$. Then $a<b$ if and only if there is an $i\\in I$ such that $a_i<b_i$."}
{"name": "regular_expression.one_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/regular_expressions.lean", "formal_statement": "theorem regular_expression.one_def {\u03b1 : Type*} :\n\tregular_expression.epsilon = 1 :=", "nl_statement_of_codex": "The empty word is the identity element of the free monoid."}
{"name": "units.coe_unop_op_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/opposite.lean", "formal_statement": "theorem units.coe_unop_op_equiv {M : Type*} [monoid M] (u : M\u1d50\u1d52\u1d56\u02e3) :\n\t\u2191(mul_opposite.unop (\u21d1units.op_equiv u)) = mul_opposite.unop \u2191u :=", "nl_statement_of_codex": "Let $M$ be a monoid. Then the inverse of the inverse of a unit $u$ is $u$."}
{"name": "lp.norm_eq_card_dsupport", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lp_space.lean", "formal_statement": "theorem lp.norm_eq_card_dsupport {\u03b1 E : \u03b1 \u2192 Type*}\n\t[\u03a0 (i : \u03b1), normed_group (E i)] (f : \u21a5(lp E 0)) :\n\t\u2225f\u2225 = \u2191(_.to_finset.card) :=", "nl_statement_of_codex": "Let $E$ be a family of normed groups. Then the $L^0$-norm of a function $f:E\\to\\mathbb{R}$ is equal to the cardinality of the support of $f$."}
{"name": "filter.has_basis.cauchy_seq_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean", "formal_statement": "theorem filter.has_basis.cauchy_seq_iff {\u03b1 : Type u} {\u03b2 : Type v}\n\t[uniform_space \u03b1] {\u03b3 : Sort u_1} [nonempty \u03b2] [semilattice_sup \u03b2] {u : \u03b2 \u2192 \u03b1}\n\t{p : \u03b3 \u2192 Prop} {s : \u03b3 \u2192 set (\u03b1 \u00d7 \u03b1)} (h : (uniformity \u03b1).has_basis p s) :\n\tcauchy_seq u \u2194 \u2200 (i : \u03b3), p i \u2192 (\u2203 (N : \u03b2), \u2200 (m : \u03b2), m \u2265 N \u2192 \u2200 (n : \u03b2), n \u2265 N \u2192 (u m, u n) \u2208 s i) :=", "nl_statement_of_codex": "Let $X$ be a uniform space. A sequence $(u_n)$ in $X$ is Cauchy if and only if for each $i$ in some index set $I$, if $p(i)$ holds, then there is an $N$ such that for all $m,n\\geq N$, $(u_m,u_n)\\in s(i)$."}
{"name": "mem_closure_of_frequently_of_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem mem_closure_of_frequently_of_tendsto {\u03b1 : Type u} {\u03b2 : Type v}\n\t[topological_space \u03b1] {f : \u03b2 \u2192 \u03b1} {b : filter \u03b2} {a : \u03b1} {s : set \u03b1}\n\t(h : \u2203\u1da0 (x : \u03b2) in b, f x \u2208 s) (hf : filter.tendsto f b (nhds a)) :\n\ta \u2208 closure s :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Let $a\\in Y$ and let $S\\subset Y$. If $f(X)$ intersects $S$ frequently, then $a$ is in the closure of $S$."}
{"name": "mv_polynomial.adjoin_range_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.adjoin_range_X {R : Type u} {\u03c3 : Type*} [comm_semiring R] :\n\talgebra.adjoin R (set.range mv_polynomial.X) = \u22a4 :=", "nl_statement_of_codex": "The polynomial ring $R[X_1,\\ldots,X_n]$ is the algebraic closure of $R$."}
{"name": "nat.size_le_size", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/pow.lean", "formal_statement": "theorem nat.size_le_size {m n : \u2115} (h : m \u2264 n) :\n\tm.size \u2264 n.size :=", "nl_statement_of_codex": "If $m\\leq n$, then $\\mathrm{size}(m)\\leq \\mathrm{size}(n)$."}
{"name": "closure_eq_compl_interior_compl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem closure_eq_compl_interior_compl {\u03b1 : Type u} [topological_space \u03b1]\n\t{s : set \u03b1} :\n\tclosure s = (interior s\u1d9c)\u1d9c :=", "nl_statement_of_codex": "The closure of a set $S$ is the complement of the interior of the complement of $S$."}
{"name": "multiset.mem_map_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.mem_map_of_mem {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) {a : \u03b1}\n\t{s : multiset \u03b1} (h : a \u2208 s) :\n\tf a \u2208 multiset.map f s :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $a\\in A$. Then $f(a)\\in f(A)$."}
{"name": "homological_complex.eq_to_hom_d", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/differential_object.lean", "formal_statement": "theorem homological_complex.eq_to_hom_d {\u03b2 : Type*} [add_comm_group \u03b2] {b : \u03b2}\n\t{V : Type*} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V]\n\t(X : category_theory.differential_object (category_theory.graded_object_with_shift b V))\n\t{x y : \u03b2} (h : x = y) :\n\tX.X_eq_to_hom h \u226b X.d y = X.d x \u226b X.X_eq_to_hom _ :=", "nl_statement_of_codex": "Let $X$ be a differential object in a category $V$ with zero morphisms. Let $x,y\\in\\beta$. Then the morphism $X_x\\to X_y$ induced by $x=y$ is a chain map."}
{"name": "finsum_of_is_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finsum_of_is_empty {M : Type*} {\u03b1 : Sort u_4} [add_comm_monoid M]\n\t[is_empty \u03b1] (f : \u03b1 \u2192 M) :\n\tfinsum (\u03bb (i : \u03b1), f i) = 0 :=", "nl_statement_of_codex": "If $A$ is an empty set, then $\\sum_{a\\in A}f(a)=0$."}
{"name": "finset.vadd_finset_inter_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/pointwise.lean", "formal_statement": "theorem finset.vadd_finset_inter_subset {\u03b1 \u03b2 : Type*} [decidable_eq \u03b2]\n\t[has_vadd \u03b1 \u03b2] {s\u2081 s\u2082 : finset \u03b2} {a : \u03b1} :\n\ta +\u1d65 s\u2081 \u2229 s\u2082 \u2286 (a +\u1d65 s\u2081) \u2229 (a +\u1d65 s\u2082) :=", "nl_statement_of_codex": "Let $s_1, s_2$ be finite sets and let $a$ be an element of a vector space. Then $a+s_1\\cap s_2\\subseteq a+s_1\\cap a+s_2$."}
{"name": "order_hom.comp_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/basic.lean", "formal_statement": "theorem order_hom.comp_mono {\u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t[preorder \u03b3] \u2983g\u2081 g\u2082 : \u03b2 \u2192o \u03b3\u2984 (hg : g\u2081 \u2264 g\u2082) \u2983f\u2081 f\u2082 : \u03b1 \u2192o \u03b2\u2984 (hf : f\u2081 \u2264 f\u2082) :\n\tg\u2081.comp f\u2081 \u2264 g\u2082.comp f\u2082 :=", "nl_statement_of_codex": "Let $f_1, f_2:A\\to B$ and $g_1, g_2:B\\to C$ be order-preserving maps. If $f_1\\leq f_2$ and $g_1\\leq g_2$, then $g_1\\circ f_1\\leq g_2\\circ f_2$."}
{"name": "linear_map.coe_to_seminorm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/weak_dual.lean", "formal_statement": "theorem linear_map.coe_to_seminorm {\ud835\udd5c E : Type*} [normed_field \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] {f : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c} :\n\t\u21d1(f.to_seminorm) = \u03bb (x : E), \u2225\u21d1f x\u2225 :=", "nl_statement_of_codex": "Let $E$ be a normed vector space over a normed field $K$. Let $f:E\\to K$ be a linear map. Then the seminorm $x\\mapsto \\|f(x)\\|$ is equal to the seminorm $x\\mapsto \\|f\\|(x)$."}
{"name": "exists_associated_pow_of_mul_eq_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/gcd_monoid/basic.lean", "formal_statement": "theorem exists_associated_pow_of_mul_eq_pow {\u03b1 : Type*}\n\t[cancel_comm_monoid_with_zero \u03b1] [gcd_monoid \u03b1] {a b c : \u03b1}\n\t(hab : is_unit (gcd_monoid.gcd a b)) {k : \u2115} (h : a * b = c ^ k) :\n\t\u2203 (d : \u03b1), associated (d ^ k) a :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a gcd monoid $M$ such that $a$ and $b$ are relatively prime. If $a\\cdot b=c^k$, then there is an element $d\\in M$ such that $d^k$ is associated to $a$."}
{"name": "alg_equiv.of_linear_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.of_linear_equiv_apply {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w}\n\t[comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082]\n\t(l : A\u2081 \u2243\u2097[R] A\u2082) (map_mul : \u2200 (x y : A\u2081), \u21d1l (x * y) = \u21d1l x * \u21d1l y)\n\t(commutes : \u2200 (r : R), \u21d1l (\u21d1(algebra_map R A\u2081) r) = \u21d1(algebra_map R A\u2082) r)\n\t(\u1fb0 : A\u2081) :\n\t\u21d1(alg_equiv.of_linear_equiv l map_mul commutes) \u1fb0 = \u21d1l \u1fb0 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $A_1$ and $A_2$ be semirings, and let $R$ be an $R$-algebra. Let $l:A_1\\to A_2$ be a linear map such that $l(xy)=l(x)l(y)$ and $l(r\\cdot x)=r\\cdot l(x)$ for all $x,y\\in A_1$ and $r\\in R$. Then $l$ is an algebra homomorphism."}
{"name": "submonoid_class.coe_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem submonoid_class.coe_one {M : Type*} [mul_one_class M] {A : Type*}\n\t[set_like A M] [hA : submonoid_class A M] (S' : A) :\n\t\u21911 = 1 :=", "nl_statement_of_codex": "Let $M$ be a monoid with identity $1$ and let $A$ be a submonoid of $M$. Then $1\\in A$."}
{"name": "finset.map_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.map_injective {\u03b1 \u03b2 : Type*} (f : \u03b1 \u21aa \u03b2) :\n\tfunction.injective (finset.map f) :=", "nl_statement_of_codex": "The map $f:A\\to B$ is injective if and only if the map $f:A\\to B$ is injective."}
{"name": "ennreal.sub_lt_self_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.sub_lt_self_iff {a b : ennreal} (ha : a \u2260 \u22a4) :\n\ta - b < a \u2194 0 < a \u2227 0 < b :=", "nl_statement_of_codex": "Let $a,b$ be extended non-negative reals. Then $a-b<a$ if and only if $a>0$ and $b>0$."}
{"name": "modular_group.tendsto_norm_sq_coprime_pair", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/modular.lean", "formal_statement": "theorem modular_group.tendsto_norm_sq_coprime_pair (z : upper_half_plane) :\n\tfilter.tendsto (\u03bb (p : fin 2 \u2192 \u2124), \u21d1complex.norm_sq (\u2191(p 0) * \u2191z + \u2191(p 1))) filter.cofinite filter.at_top :=", "nl_statement_of_codex": "The sequence $(p_0z+p_1)_{(p_0,p_1)\\in\\mathbb{Z}^2}$ tends to infinity."}
{"name": "measure_theory.outer_measure.mk_metric_mono_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/hausdorff.lean", "formal_statement": "theorem measure_theory.outer_measure.mk_metric_mono_smul {X : Type*}\n\t[emetric_space X] {m\u2081 m\u2082 : ennreal \u2192 ennreal} { : ennreal} (hc : c \u2260 \u22a4)\n\t(h0 : c \u2260 0) (hle : m\u2081 \u2264\u1da0[nhds_within 0 (set.Ici 0)] c \u2022 m\u2082) :\n\tmeasure_theory.outer_measure.mk_metric m\u2081 \u2264 c \u2022 measure_theory.outer_measure.mk_metric m\u2082 :=", "nl_statement_of_codex": "Let $X$ be a metric space and let $m_1, m_2:X\\to [0,\\infty]$ be functions. If $c\\in (0,\\infty)$ and $m_1(x)\\leq c\\cdot m_2(x)$ for all $x\\in X$, then $\\mu_1(A)\\leq c\\cdot \\mu_2(A)$ for all $A\\subset X$."}
{"name": "iff_of_false", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem iff_of_false {a b : Prop} (ha : \u00aca) (hb : \u00acb) :\n\ta \u2194 b :=", "nl_statement_of_codex": "If $a$ and $b$ are false, then $a$ if and only if $b$."}
{"name": "has_subset.subset.ssubset_of_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/rel_classes.lean", "formal_statement": "theorem has_subset.subset.ssubset_of_ne {\u03b1 : Type u} [has_subset \u03b1]\n\t[has_ssubset \u03b1]\n\t[is_nonstrict_strict_order \u03b1 has_subset.subset has_ssubset.ssubset] {a b : \u03b1}\n\t[is_antisymm \u03b1 has_subset.subset] (h\u2081 : a \u2286 b) (h\u2082 : a \u2260 b) :\n\ta \u2282 b :=", "nl_statement_of_codex": "Let $A$ be a set. If $A\\subset B$ and $A\\neq B$, then $A\\subsetneq B$."}
{"name": "mul_opposite.unop_star", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/star/basic.lean", "formal_statement": "theorem mul_opposite.unop_star {R : Type u} [has_star R] (r : R\u1d50\u1d52\u1d56) :\n\tmul_opposite.unop (has_star.star r) = has_star.star (mul_opposite.unop r) :=", "nl_statement_of_codex": "Let $R$ be a ring with involution. Then the involution on $R$ is an involution on $R^-$."}
{"name": "rat.mul_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/defs.lean", "formal_statement": "theorem rat.mul_assoc (a b c : \u211a) :\n\ta * b * c = a * (b * c) :=", "nl_statement_of_codex": "The multiplication of rational numbers is associative."}
{"name": "finset.image_add_right_Ioc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/locally_finite.lean", "formal_statement": "theorem finset.image_add_right_Ioc {\u03b1 : Type*}\n\t[ordered_cancel_add_comm_monoid \u03b1] [has_exists_add_of_le \u03b1] [decidable_eq \u03b1]\n\t[locally_finite_order \u03b1] (a b c : \u03b1) :\n\tfinset.image (\u03bb (_x : \u03b1), _x + c) (finset.Ioc a b) = finset.Ioc (a + c) (b + c) :=", "nl_statement_of_codex": "Let $R$ be an ordered commutative monoid with $0$ and let $a,b,c\\in R$. Then $\\{a+c,a+c+1,\\ldots,b+c\\}=\\{x+c:a\\le x\\le b\\}$."}
{"name": "rat.coe_cast_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/cast.lean", "formal_statement": "theorem rat.coe_cast_hom {\u03b1 : Type*} [division_ring \u03b1] [char_zero \u03b1] :\n\t\u21d1(rat.cast_hom \u03b1) = coe :=", "nl_statement_of_codex": "The map $\\mathbb{Q}\\to \\mathbb{Q}$ given by $q\\mapsto q$ is equal to the map $\\mathbb{Q}\\to \\mathbb{Q}$ given by $q\\mapsto q$."}
{"name": "nat.arithmetic_function.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/arithmetic_function.lean", "formal_statement": "theorem nat.arithmetic_function.ext {R : Type*} [has_zero R]\n\t\u2983f g : nat.arithmetic_function R\u2984 (h : \u2200 (x : \u2115), \u21d1f x = \u21d1g x) :\n\tf = g :=", "nl_statement_of_codex": "Let $f, g:\\mathbb{N}\\to R$ be arithmetic functions. Then $f=g$ if and only if $f(n)=g(n)$ for all $n\\in\\mathbb{N}$."}
{"name": "polynomial.coe_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_series/basic.lean", "formal_statement": "theorem polynomial.coe_add {R : Type*} [comm_semiring R] (\u03c6 \u03c8 : polynomial R) :\n\t\u2191(\u03c6 + \u03c8) = \u2191\u03c6 + \u2191\u03c8 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring. Then the map $p\\mapsto p$ is a ring homomorphism from the polynomial ring $R[x]$ to the ring of polynomials with coefficients in $R$."}
{"name": "measure_theory.measure.restrict_congr_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.restrict_congr_mono {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1} {s t : set \u03b1}\n\t(hs : s \u2286 t) (h : \u03bc.restrict t = \u03bd.restrict t) :\n\t\u03bc.restrict s = \u03bd.restrict s :=", "nl_statement_of_codex": "Let $\u03bc$ and $\u03bd$ be measures on a measurable space $(X,\\mathcal{A})$. If $\u03bc$ and $\u03bd$ agree on a set $A\\in\\mathcal{A}$, then they agree on any subset $B\\subset A$."}
{"name": "continuous_linear_map.coe_fn_of_is_closed_graph", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/banach.lean", "formal_statement": "theorem continuous_linear_map.coe_fn_of_is_closed_graph {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] [complete_space F]\n\t[complete_space E] {g : E \u2192\u2097[\ud835\udd5c] F} (hg : is_closed \u2191(g.graph)) :\n\t\u21d1(continuous_linear_map.of_is_closed_graph hg) = \u21d1g :=", "nl_statement_of_codex": "Let $E$ and $F$ be complete normed spaces over a nondiscrete normed field $K$. Let $g:E\\to F$ be a linear map. If the graph of $g$ is closed, then the continuous linear map $g$ is equal to the continuous linear map of the closed graph of $g$."}
{"name": "rtensor_hom_equiv_hom_rtensor_to_linear_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/contraction.lean", "formal_statement": "theorem rtensor_hom_equiv_hom_rtensor_to_linear_map (R M P Q : Type*)\n\t[comm_ring R] [add_comm_group M] [add_comm_group P] [add_comm_group Q]\n\t[module R M] [module R P] [module R Q] [module.free R M] [module.finite R M]\n\t[nontrivial R] :\n\t(rtensor_hom_equiv_hom_rtensor R M P Q).to_linear_map = tensor_product.rtensor_hom_to_hom_rtensor R M P Q :=", "nl_statement_of_codex": "The map $f:M\\otimes P\\to Hom(M,Q)$ defined by $f(m\\otimes p)(m')=m\\cdot m'\\cdot p$ is a linear map."}
{"name": "category_theory.coyoneda.obj_op_op_hom_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/yoneda.lean", "formal_statement": "theorem category_theory.coyoneda.obj_op_op_hom_app {C : Type u\u2081}\n\t[category_theory.category C] (X : C) (X_1 : C\u1d52\u1d56)\n\t(\u1fb0 : (category_theory.coyoneda.obj (opposite.op (opposite.op X))).obj X_1) :\n\t(category_theory.coyoneda.obj_op_op X).hom.app X_1 \u1fb0 = quiver.hom.unop \u1fb0 :=", "nl_statement_of_codex": "Let $C$ be a category. Let $X$ be an object of $C$ and let $X_1$ be an object of $C^{\\rm op}$. Let $\\alpha$ be a morphism from $X_1$ to $X$ in $C^{\\rm op}$. Then the morphism from $X_1$ to $X$ in $C$ obtained by applying the functor $C^{\\rm op}\\to C$ to $\\alpha$ is the same as the morphism from $X_1$ to $X$ in $C$ obtained by applying the functor $C^{\\rm op}\\to C$ to $\\alpha$."}
{"name": "measure_theory.simple_func.fin_meas_supp.meas_preimage_singleton_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.simple_func.fin_meas_supp.meas_preimage_singleton_ne_zero\n\t{\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} [has_zero \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} {f : measure_theory.simple_func \u03b1 \u03b2}\n\t(h : f.fin_meas_supp \u03bc) {y : \u03b2} (hy : y \u2260 0) :\n\t\u21d1\u03bc (\u21d1f \u207b\u00b9' {y}) < \u22a4 :=", "nl_statement_of_codex": "Let $f$ be a simple function on a measurable space $(X,\\mathcal{A})$ with finite measure support. If $y\\neq 0$, then the preimage of $y$ under $f$ has finite measure."}
{"name": "prime.abs", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/prime.lean", "formal_statement": "theorem prime.abs {\u03b1 : Type*} [comm_ring \u03b1] [linear_order \u03b1] {p : \u03b1}\n\t(hp : prime p) :\n\tprime |p| :=", "nl_statement_of_codex": "If $p$ is a prime number, then $|p|$ is a prime number."}
{"name": "lub_Iio_eq_self_or_Iio_eq_Iic", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem lub_Iio_eq_self_or_Iio_eq_Iic {\u03b3 : Type w} [partial_order \u03b3] {j : \u03b3}\n\t(i : \u03b3) (hj : is_lub (set.Iio i) j) :\n\tj = i \u2228 set.Iio i = set.Iic j :=", "nl_statement_of_codex": "Let $i$ and $j$ be elements of a partially ordered set $X$. If $j$ is the least upper bound of the set $\\{x\\in X:x<i\\}$, then either $j=i$ or $\\{x\\in X:x<i\\}=\\{x\\in X:x\\leq j\\}$."}
{"name": "finpartition.parts_nonempty_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/partition/finpartition.lean", "formal_statement": "theorem finpartition.parts_nonempty_iff {\u03b1 : Type*} [lattice \u03b1] [order_bot \u03b1]\n\t{a : \u03b1} {P : finpartition a} :\n\tP.parts.nonempty \u2194 a \u2260 \u22a5 :=", "nl_statement_of_codex": "Let $P$ be a finite partition of $a$. Then $P$ is nonempty if and only if $a\\neq 0$."}
{"name": "quaternion_algebra.self_add_conj'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion_algebra.self_add_conj' {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R}\n\t(a : quaternion_algebra R c\u2081 c\u2082) :\n\ta + \u21d1quaternion_algebra.conj a = \u2191(2 * a.re) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $c_1, c_2\\in R$. Let $a$ be a quaternion algebra over $R$ with coefficients $c_1$ and $c_2$. Then $a+\\overline{a}=2\\Re(a)$."}
{"name": "subring.exists_list_of_mem_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/basic.lean", "formal_statement": "theorem subring.exists_list_of_mem_closure {R : Type u} [ring R] {s : set R}\n\t{x : R} (h : x \u2208 subring.closure s) :\n\t\u2203 (L : list (list R)), (\u2200 (t : list R), t \u2208 L \u2192 \u2200 (y : R), y \u2208 t \u2192 y \u2208 s \u2228 y = -1) \u2227 (list.map list.prod L).sum = x :=", "nl_statement_of_codex": "Let $R$ be a ring and let $s$ be a subset of $R$. Let $x\\in R$. If $x$ is in the subring generated by $s$, then there is a list $L$ of lists of elements of $s$ such that $x$ is the sum of the products of the elements of the lists in $L$."}
{"name": "cubic.disc_ne_zero_iff_roots_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/cubic_discriminant.lean", "formal_statement": "theorem cubic.disc_ne_zero_iff_roots_ne {F K : Type*} {P : cubic F} [field F]\n\t[field K] {\u03c6 : F \u2192+* K} {x y z : K} (ha : P.a \u2260 0)\n\t(h3 : (cubic.map \u03c6 P).roots = {x, y, z}) :\n\tP.disc \u2260 0 \u2194 x \u2260 y \u2227 x \u2260 z \u2227 y \u2260 z :=", "nl_statement_of_codex": "Let $P$ be a cubic polynomial with coefficients in a field $F$ and let $K$ be a field extension of $F$. Let $x, y, z$ be the roots of $P$ in $K$. Then $P$ has distinct roots if and only if $P$ has nonzero discriminant."}
{"name": "measure_theory.absolutely_continuous_map_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/prod.lean", "formal_statement": "theorem measure_theory.absolutely_continuous_map_inv {G : Type*}\n\t[measurable_space G] [group G] [has_measurable_mul\u2082 G]\n\t(\u03bc : measure_theory.measure G) [measure_theory.sigma_finite \u03bc]\n\t[has_measurable_inv G] [\u03bc.is_mul_left_invariant] :\n\t\u03bc.absolutely_continuous (measure_theory.measure.map has_inv.inv \u03bc) :=", "nl_statement_of_codex": "Let $G$ be a group with a measure $\\mu$. Then $\\mu$ is absolutely continuous with respect to the measure $\\mu\\circ\\iota$ where $\\iota$ is the inversion map."}
{"name": "nat.size_bit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/pow.lean", "formal_statement": "theorem nat.size_bit {b : bool} {n : \u2115} (h : nat.bit b n \u2260 0) :\n\t(nat.bit b n).size = n.size.succ :=", "nl_statement_of_codex": "The size of the number $2^n+b$ is $n+1$."}
{"name": "string.str_ne_str_right", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/string/basic.lean", "formal_statement": "theorem string.str_ne_str_right (c\u2081 c\u2082 : char) {s\u2081 s\u2082 : string} :\n\ts\u2081 \u2260 s\u2082 \u2192 s\u2081.str c\u2081 \u2260 s\u2082.str c\u2082 :=", "nl_statement_of_codex": "Let $c_1, c_2$ be characters and let $s_1, s_2$ be strings. If $s_1\\neq s_2$, then $s_1.str(c_1)\\neq s_2.str(c_2)$."}
{"name": "div_le_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/field.lean", "formal_statement": "theorem div_le_one_iff {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1} :\n\ta / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a :=", "nl_statement_of_codex": "Let $a, b$ be elements of a linear ordered field. Then $a/b\\leq 1$ if and only if $0<b$ and $a\\leq b$ or $b=0$ or $b<0$ and $b\\leq a$."}
{"name": "finset.sorted_last_eq_max'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/sort.lean", "formal_statement": "theorem finset.sorted_last_eq_max' {\u03b1 : Type*} [linear_order \u03b1] {s : finset \u03b1}\n\t{h : (finset.sort has_le.le s).length - 1 < (finset.sort has_le.le s).length} :\n\t(finset.sort has_le.le s).nth_le ((finset.sort has_le.le s).length - 1) h = s.max' _ :=", "nl_statement_of_codex": "Let $s$ be a finite set of elements of a linearly ordered set $X$. Then the last element of the sorted list of elements of $s$ is the maximum element of $s$."}
{"name": "nnreal.coe_tsum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/nnreal.lean", "formal_statement": "theorem nnreal.coe_tsum {\u03b1 : Type*} {f : \u03b1 \u2192 nnreal} :\n\t\u2191\u2211' (a : \u03b1), f a = \u2211' (a : \u03b1), \u2191(f a) :=", "nl_statement_of_codex": "Let $f:A\\to\\mathbb{R}_{\\geq 0}$ be a function. Then $\\sum_{a\\in A}f(a)=\\sum_{a\\in A}f(a)$."}
{"name": "order_ring_iso.symm_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/hom/ring.lean", "formal_statement": "theorem order_ring_iso.symm_symm {\u03b1 \u03b2 : Type*} [has_mul \u03b1] [has_add \u03b1]\n\t[has_le \u03b1] [has_mul \u03b2] [has_add \u03b2] [has_le \u03b2] (e : \u03b1 \u2243+*o \u03b2) :\n\te.symm.symm = e :=", "nl_statement_of_codex": "Let $R$ and $S$ be ordered rings. If $f:R\\to S$ is an order-preserving ring isomorphism, then $f^{-1}$ is also an order-preserving ring isomorphism."}
{"name": "set.indicator_finset_bUnion_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/indicator_function.lean", "formal_statement": "theorem set.indicator_finset_bUnion_apply {\u03b1 M : Type*} [add_comm_monoid M]\n\t{\u03b9 : Type*} (I : finset \u03b9) (s : \u03b9 \u2192 set \u03b1) {f : \u03b1 \u2192 M}\n\t(h : \u2200 (i : \u03b9), i \u2208 I \u2192 \u2200 (j : \u03b9), j \u2208 I \u2192 i \u2260 j \u2192 disjoint (s i) (s j))\n\t(x : \u03b1) :\n\t(\u22c3 (i : \u03b9) (H : i \u2208 I), s i).indicator f x = I.sum (\u03bb (i : \u03b9), (s i).indicator f x) :=", "nl_statement_of_codex": "Let $I$ be a finite set, let $s:I\\to\\mathcal{P}(X)$ be a function, and let $f:X\\to M$ be a function. Suppose that $s(i)\\cap s(j)=\\emptyset$ for all $i,j\\in I$ with $i\\neq j$. Then $\\bigcup_{i\\in I}s(i)=\\sum_{i\\in I}s(i)$."}
{"name": "topological_vector_bundle.trivialization.symm_apply_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/vector_bundle/basic.lean", "formal_statement": "theorem topological_vector_bundle.trivialization.symm_apply_apply\n\t{R B F E : B \u2192 Type*} [semiring R] [\u03a0 (x : B), add_comm_monoid (E x)]\n\t[\u03a0 (x : B), module R (E x)] [topological_space F] [add_comm_monoid F]\n\t[module R F] [topological_space B] [topological_space (bundle.total_space E)]\n\t(e : topological_vector_bundle.trivialization R F E) {x : bundle.total_space E}\n\t(hx : x \u2208 e.to_fiber_bundle_trivialization.to_local_homeomorph.to_local_equiv.source) :\n\t\u21d1(e.to_fiber_bundle_trivialization.to_local_homeomorph.symm) (\u21d1e x) = x :=", "nl_statement_of_codex": "Let $E$ be a topological vector bundle over $B$ with fiber $F$. Let $e$ be a trivialization of $E$. Then the inverse of $e$ is the inverse of $e$."}
{"name": "category_theory.limits.biprod.map_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.biprod.map_snd {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{W X Y Z : C} [category_theory.limits.has_binary_biproduct W X]\n\t[category_theory.limits.has_binary_biproduct Y Z] (f : W \u27f6 Y) (g : X \u27f6 Z) :\n\tcategory_theory.limits.biprod.map f g \u226b category_theory.limits.biprod.snd = category_theory.limits.biprod.snd \u226b g :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $W,X,Y,Z$ be objects of $C$ with binary biproducts. Let $f:W\\to Y$ and $g:X\\to Z$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nW\\oplus X & \\xrightarrow{f\\oplus g} & Y\\oplus Z \\\\\n\\downarrow & & \\downarrow \\\\\nX & \\xrightarrow{g} & Z\n\\end{array}$$"}
{"name": "of_boolring_le_of_boolring_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/boolean_ring.lean", "formal_statement": "theorem of_boolring_le_of_boolring_iff {\u03b1 : Type*} [boolean_algebra \u03b1]\n\t{a b : as_boolring \u03b1} :\n\t\u21d1of_boolring a \u2264 \u21d1of_boolring b \u2194 a * b = a :=", "nl_statement_of_codex": "Let $A$ be a boolean algebra. Then $a\\leq b$ in $A$ if and only if $a\\cdot b=a$."}
{"name": "continuous_linear_equiv.symm_to_diffeomorph", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/diffeomorph.lean", "formal_statement": "theorem continuous_linear_equiv.symm_to_diffeomorph {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] (e : E \u2243L[\ud835\udd5c] E') :\n\te.symm.to_diffeomorph = e.to_diffeomorph.symm :=", "nl_statement_of_codex": "Let $E$ and $E'$ be normed spaces over a nondiscrete normed field $K$. Let $e:E\\to E'$ be a continuous linear isomorphism. Then $e^{-1}$ is a diffeomorphism if and only if $e$ is a diffeomorphism."}
{"name": "category_theory.category_of_elements.from_to_costructured_arrow_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/elements.lean", "formal_statement": "theorem category_theory.category_of_elements.from_to_costructured_arrow_eq\n\t{C : Type u} [category_theory.category C] (F : C\u1d52\u1d56 \u2964 Type v) :\n\t(category_theory.category_of_elements.to_costructured_arrow F).right_op \u22d9 category_theory.category_of_elements.from_costructured_arrow F = \ud835\udfed F.elements :=", "nl_statement_of_codex": "Let $C$ be a category and let $F:C^{op}\\to Set$ be a functor. Then the composition of the right adjoint of the functor $F$ with the left adjoint of $F$ is the identity functor on the category of elements of $F$."}
{"name": "mv_polynomial.bind\u2081_comp_rename", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/monad.lean", "formal_statement": "theorem mv_polynomial.bind\u2081_comp_rename {\u03c3 \u03c4 R : Type*} [comm_semiring R]\n\t{\u03c5 : Type*} (f : \u03c4 \u2192 mv_polynomial \u03c5 R) (g : \u03c3 \u2192 \u03c4) :\n\t(mv_polynomial.bind\u2081 f).comp (mv_polynomial.rename g) = mv_polynomial.bind\u2081 (f \u2218 g) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $\\sigma, \\tau$ be types, and let $f:\\tau\\to R[\\tau]$ and $g:\\sigma\\to\\tau$. Then $(R[\\tau]\\to R[\\sigma])\\circ(R[\\sigma]\\to R[\\tau])=R[\\sigma]\\to R[\\tau]$."}
{"name": "neg_of_mul_neg_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem neg_of_mul_neg_right {\u03b1 : Type u} [linear_ordered_semiring \u03b1] {a b : \u03b1}\n\t(h : a * b < 0) (ha : 0 \u2264 a) :\n\tb < 0 :=", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring. If $a,b\\in R$ and $a\\geq 0$ and $ab<0$, then $b<0$."}
{"name": "prime.ne_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/associated.lean", "formal_statement": "theorem prime.ne_one {\u03b1 : Type*} [comm_monoid_with_zero \u03b1] {p : \u03b1}\n\t(hp : prime p) :\n\tp \u2260 1 :=", "nl_statement_of_codex": "A prime element $p$ is not equal to $1$."}
{"name": "measure_theory.tendsto_lintegral_norm_of_dominated_convergence", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l1_space.lean", "formal_statement": "theorem measure_theory.tendsto_lintegral_norm_of_dominated_convergence\n\t{\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {bound : \u03b1 \u2192 \u211d}\n\t(F_measurable : \u2200 (n : \u2115), measure_theory.ae_strongly_measurable (F n) \u03bc)\n\t(bound_has_finite_integral : measure_theory.has_finite_integral bound \u03bc)\n\t(h_bound : \u2200 (n : \u2115), \u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2225F n a\u2225 \u2264 bound a)\n\t(h_lim : \u2200\u1d50 (a : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (n : \u2115), F n a) filter.at_top (nhds (f a))) :\n\tfilter.tendsto (\u03bb (n : \u2115), \u222b\u207b (a : \u03b1), ennreal.of_real \u2225F n a - f a\u2225 \u2202\u03bc) filter.at_top (nhds 0) :=", "nl_statement_of_codex": "Let $F_n:X\\to\\mathbb{R}$ be a sequence of measurable functions such that $F_n(x)\\to f(x)$ for almost every $x\\in X$. Suppose that $|F_n(x)|\\leq g(x)$ for all $n$ and almost every $x\\in X$, where $g$ is integrable. Then $\\int_X|F_n(x)-f(x)|\\to 0$."}
{"name": "submodules_ring_basis.to_ring_subgroups_basis", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/nonarchimedean/bases.lean", "formal_statement": "theorem submodules_ring_basis.to_ring_subgroups_basis {\u03b9 R A : Type*}\n\t[comm_ring R] [comm_ring A] [algebra R A] {B : \u03b9 \u2192 submodule R A}\n\t(hB : submodules_ring_basis B) :\n\tring_subgroups_basis (\u03bb (i : \u03b9), (B i).to_add_subgroup) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $A$ be a commutative $R$-algebra, and let $B$ be a family of submodules of $A$ that is a ring basis for $A$. Then the family of additive subgroups of $A$ obtained by applying the functor $-\\to\\mathbb{Z}$ to the family $B$ is a ring basis for $A$."}
{"name": "metric.thickening_thickening_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean", "formal_statement": "theorem metric.thickening_thickening_subset {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1] (\u03b5 \u03b4 : \u211d) (s : set \u03b1) :\n\tmetric.thickening \u03b5 (metric.thickening \u03b4 s) \u2286 metric.thickening (\u03b5 + \u03b4) s :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $s$ be a subset of $X$. Then the thickening of the thickening of $s$ by $\\epsilon$ is contained in the thickening of $s$ by $\\epsilon+\\delta$."}
{"name": "lower_semicontinuous_on.lower_semicontinuous_within_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/semicontinuous.lean", "formal_statement": "theorem lower_semicontinuous_on.lower_semicontinuous_within_at {\u03b1 : Type*}\n\t[topological_space \u03b1] {\u03b2 : Type*} [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : set \u03b1}\n\t(h : lower_semicontinuous_on f s) (hx : x \u2208 s) :\n\tlower_semicontinuous_within_at f s x :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a preordered set. Let $f:X\\to Y$ and let $s\\subset X$. If $f$ is lower semicontinuous on $s$, then $f$ is lower semicontinuous at $x$ for each $x\\in s$."}
{"name": "nilpotent_iff_mem_prime", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/nilpotent.lean", "formal_statement": "theorem nilpotent_iff_mem_prime {R : Type u} {x : R} [comm_semiring R] :\n\tis_nilpotent x \u2194 \u2200 (J : ideal R), J.is_prime \u2192 x \u2208 J :=", "nl_statement_of_codex": "An element $x$ of a commutative semiring $R$ is nilpotent if and only if $x$ is in every prime ideal of $R$."}
{"name": "continuous_linear_map.coe_flip\u2097\u1d62'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.coe_flip\u2097\u1d62' {\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 E F G : Type*}\n\t[semi_normed_group E] [semi_normed_group F] [semi_normed_group G]\n\t[nondiscrete_normed_field \ud835\udd5c] [nondiscrete_normed_field \ud835\udd5c\u2082]\n\t[nondiscrete_normed_field \ud835\udd5c\u2083] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c\u2082 F]\n\t[normed_space \ud835\udd5c\u2083 G] {\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} {\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [ring_hom_isometric \u03c3\u2082\u2083]\n\t[ring_hom_isometric \u03c3\u2081\u2083] :\n\t\u21d1(continuous_linear_map.flip\u2097\u1d62' E F G \u03c3\u2082\u2083 \u03c3\u2081\u2083) = continuous_linear_map.flip :=", "nl_statement_of_codex": "Let $E, F, G$ be semi-normed groups, and let $\\sigma_{23}, \\sigma_{13}$ be isometric ring homomorphisms. Then the continuous linear map $\\sigma_{23}\\circ\\sigma_{13}^{-1}$ is equal to the continuous linear map $\\sigma_{13}\\circ\\sigma_{23}^{-1}$."}
{"name": "nontrivial_of_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/nontrivial.lean", "formal_statement": "theorem nontrivial_of_lt {\u03b1 : Type*} [preorder \u03b1] (x y : \u03b1) (h : x < y) :\n\tnontrivial \u03b1 :=", "nl_statement_of_codex": "Let $x,y$ be elements of a preorder $P$. If $x<y$, then $P$ is nontrivial."}
{"name": "function.End.smul_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/defs.lean", "formal_statement": "theorem function.End.smul_def {\u03b1 : Type*} (f : function.End \u03b1) (a : \u03b1) :\n\tf \u2022 a = f a :=", "nl_statement_of_codex": "Let $f$ be a function from $A$ to $A$. Then $f\\cdot a=f(a)$."}
{"name": "eq_rec_heq", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/logic.lean", "formal_statement": "theorem eq_rec_heq {\u03b1 : Sort u} {\u03c6 : \u03b1 \u2192 Sort v} {a a' : \u03b1} (h : a = a')\n\t(p : \u03c6 a) :\n\th.rec_on p == p :=", "nl_statement_of_codex": "Let $a,a'$ be elements of a type $\u03b1$ and let $p$ be an element of the type $\\phi(a)$. If $a=a'$, then $p$ is equal to $p$."}
{"name": "category_theory.limits.epi_of_is_colimit_parallel_family", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/wide_equalizers.lean", "formal_statement": "theorem category_theory.limits.epi_of_is_colimit_parallel_family {J : Type w}\n\t{C : Type u} [category_theory.category C] {X Y : C} {f : J \u2192 (X \u27f6 Y)}\n\t[nonempty J]\n\t{ : category_theory.limits.cocone (category_theory.limits.parallel_family f)}\n\t(i : category_theory.limits.is_colimit c) :\n\tcategory_theory.epi (c.\u03b9.app category_theory.limits.walking_parallel_family.one) :=", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y$ be objects of $C$. Let $f:J\\to C(X,Y)$ be a functor from a nonempty category $J$ to the category of morphisms from $X$ to $Y$. Suppose that $c$ is a colimit of $f$. Then the morphism $c_{\\mathrm{one}}:X\\to Y$ is an epimorphism."}
{"name": "measure_theory.ae_cover.ae_tendsto_indicator", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/integral_eq_improper.lean", "formal_statement": "theorem measure_theory.ae_cover.ae_tendsto_indicator {\u03b1 \u03b9 : Type*}\n\t[measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {l : filter \u03b9} {\u03b2 : Type*}\n\t[has_zero \u03b2] [topological_space \u03b2] (f : \u03b1 \u2192 \u03b2) {\u03c6 : \u03b9 \u2192 set \u03b1}\n\t(h\u03c6 : measure_theory.ae_cover \u03bc l \u03c6) :\n\t\u2200\u1d50 (x : \u03b1) \u2202\u03bc, filter.tendsto (\u03bb (i : \u03b9), (\u03c6 i).indicator f x) l (nhds (f x)) :=", "nl_statement_of_codex": "Let $(X,\\mathcal{A},\\mu)$ be a measure space, let $f:X\\to\\mathbb{R}$ be a measurable function, and let $\\{\\phi_i\\}_{i\\in I}$ be a family of measurable sets such that $\\mu(\\bigcup_{i\\in I}\\phi_i)=\\mu(X)$. Then for $\\mu$-almost every $x\\in X$, the sequence $\\{\\phi_i(x)\\}_{i\\in I}$ converges to $f(x)$."}
{"name": "category_theory.idempotents.karoubi_karoubi.equivalence_unit_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/idempotents/karoubi_karoubi.lean", "formal_statement": "theorem category_theory.idempotents.karoubi_karoubi.equivalence_unit_iso\n\t(C : Type*) [category_theory.category C] :\n\t(category_theory.idempotents.karoubi_karoubi.equivalence C).unit_iso = category_theory.idempotents.karoubi_karoubi.unit_iso C :=", "nl_statement_of_codex": "The unit isomorphism of the Karoubi envelope of a category $C$ is the same as the unit isomorphism of $C$."}
{"name": "has_sum_geometric_of_abs_lt_1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/specific_limits/normed.lean", "formal_statement": "theorem has_sum_geometric_of_abs_lt_1 {r : \u211d} (h : |r| < 1) :\n\thas_sum (\u03bb (n : \u2115), r ^ n) (1 - r)\u207b\u00b9 :=", "nl_statement_of_codex": "If $|r|<1$, then the geometric series $\\sum_{n=0}^\\infty r^n$ converges to $\\frac{1}{1-r}$."}
{"name": "measure_theory.pdf_undef", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/density.lean", "formal_statement": "theorem measure_theory.pdf_undef {\u03b1 E : Type*} [measurable_space E]\n\t{m : measurable_space \u03b1} {\u2119 : measure_theory.measure \u03b1}\n\t{\u03bc : measure_theory.measure E} {X : \u03b1 \u2192 E}\n\t(h : \u00acmeasure_theory.has_pdf X \u00ab\u2119\u00bb \u03bc) :\n\tmeasure_theory.pdf X \u00ab\u2119\u00bb \u03bc = 0 :=", "nl_statement_of_codex": "If $X$ does not have a probability density function with respect to $\\mu$, then the probability density function of $X$ with respect to $\\mu$ is $0$."}
{"name": "complex.im_clm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/basic.lean", "formal_statement": "theorem complex.im_clm_apply (z : \u2102) :\n\t\u21d1complex.im_clm z = z.im :=", "nl_statement_of_codex": "The imaginary part of $z$ is equal to the imaginary part of $z$."}
{"name": "padic_seq.equiv_zero_of_val_eq_of_equiv_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_numbers.lean", "formal_statement": "theorem padic_seq.equiv_zero_of_val_eq_of_equiv_zero {p : \u2115}\n\t[fact (nat.prime p)] {f g : padic_seq p}\n\t(h : \u2200 (k : \u2115), padic_norm p (\u21d1f k) = padic_norm p (\u21d1g k)) (hf : f \u2248 0) :\n\tg \u2248 0 :=", "nl_statement_of_codex": "Let $p$ be a prime number. Let $f,g:\\mathbb{N}\\to\\mathbb{Q}_p$ be two sequences. If $v_p(f(n))=v_p(g(n))$ for all $n\\in\\mathbb{N}$ and $f\\sim 0$, then $g\\sim 0$."}
{"name": "besicovitch.is_empty_satellite_config_multiplicity", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/covering/besicovitch_vector_space.lean", "formal_statement": "theorem besicovitch.is_empty_satellite_config_multiplicity (E : Type*)\n\t[normed_group E] [normed_space \u211d E] [finite_dimensional \u211d E] :\n\tis_empty (besicovitch.satellite_config E (besicovitch.multiplicity E) (besicovitch.good_\u03c4 E)) :=", "nl_statement_of_codex": "Let $E$ be a finite dimensional real normed space. Then the set of all Besicovitch configurations of multiplicity $m$ is empty."}
{"name": "first_order.language.substructure.to_elementary_substructure_to_substructure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/elementary_maps.lean", "formal_statement": "theorem first_order.language.substructure.to_elementary_substructure_to_substructure\n\t{L : first_order.language} {M : Type*} [L.Structure M] (S : L.substructure M)\n\t(htv : \u2200 (n : \u2115) (\u03c6 : L.bounded_formula empty (n + 1)) (x : fin n \u2192 \u21a5S) (a : M), \u03c6.realize inhabited.default (fin.snoc (coe \u2218 x) a) \u2192 (\u2203 (b : \u21a5S), \u03c6.realize inhabited.default (fin.snoc (coe \u2218 x) \u2191b))) :\n\t(S.to_elementary_substructure htv).to_substructure = S :=", "nl_statement_of_codex": "Let $L$ be a first-order language and let $M$ be an $L$-structure. Let $S$ be an $L$-substructure of $M$. Suppose that for each $n\\in\\mathbb{N}$, each $L$-formula $\\phi(x_1,\\ldots,x_n,y)$ and each $a_1,\\ldots,a_n\\in S$, if $\\phi(a_1,\\ldots,a_n,a)$ holds in $M$ for some $a\\in M$, then there is $b\\in S$ such that $\\phi(a_1,"}
{"name": "non_unital_alg_hom.one_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/non_unital_alg.lean", "formal_statement": "theorem non_unital_alg_hom.one_apply {R : Type u} {A : Type v} [monoid R]\n\t[non_unital_non_assoc_semiring A] [distrib_mul_action R A] (a : A) :\n\t\u21d11 a = a :=", "nl_statement_of_codex": "Let $R$ be a monoid and $A$ be a non-unital non-associative semiring. Then the identity map on $A$ is a non-unital algebra homomorphism."}
{"name": "bot_hom.coe_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/bounded.lean", "formal_statement": "theorem bot_hom.coe_comp {\u03b1 \u03b2 \u03b3 : Type*} [has_bot \u03b1] [has_bot \u03b2] [has_bot \u03b3]\n\t(f : bot_hom \u03b2 \u03b3) (g : bot_hom \u03b1 \u03b2) :\n\t\u21d1(f.comp g) = \u21d1f \u2218 \u21d1g :=", "nl_statement_of_codex": "Let $f:B\\to C$ and $g:A\\to B$ be functions. Then $f\\circ g$ is the function $f\\circ g:A\\to C$ defined by $(f\\circ g)(x)=f(g(x))$."}
{"name": "ideal.polynomial.is_maximal_comap_C_of_is_maximal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/jacobson.lean", "formal_statement": "theorem ideal.polynomial.is_maximal_comap_C_of_is_maximal {R : Type*}\n\t[comm_ring R] [ideal.is_jacobson R] (P : ideal (polynomial R))\n\t[hP : P.is_maximal] [nontrivial R]\n\t(hP' : \u2200 (x : R), \u21d1polynomial.C x \u2208 P \u2192 x = 0) :\n\t(ideal.comap polynomial.C P).is_maximal :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with identity. Let $P$ be a maximal ideal of $R[x]$. If $P$ does not contain any nonzero constant polynomials, then the ideal $P\\cap R$ is maximal in $R$."}
{"name": "bounded_continuous_function.dist_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/bounded.lean", "formal_statement": "theorem bounded_continuous_function.dist_eq {\u03b1 : Type u} {\u03b2 : Type v}\n\t[topological_space \u03b1] [pseudo_metric_space \u03b2]\n\t{f g : bounded_continuous_function \u03b1 \u03b2} :\n\thas_dist.dist f g = has_Inf.Inf {C : \u211d | 0 \u2264 C \u2227 \u2200 (x : \u03b1), has_dist.dist (\u21d1f x) (\u21d1g x) \u2264 C} :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be bounded continuous functions. Then the distance between $f$ and $g$ is the infimum of the set of all $C\\in\\mathbb{R}$ such that $0\\leq C$ and $d(f(x),g(x))\\leq C$ for all $x\\in X$."}
{"name": "relation.trans_gen_idem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/relation.lean", "formal_statement": "theorem relation.trans_gen_idem {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n\trelation.trans_gen (relation.trans_gen r) = relation.trans_gen r :=", "nl_statement_of_codex": "The transitive closure of the transitive closure of a relation $r$ is the transitive closure of $r$."}
{"name": "inner_product_space.is_self_adjoint.has_strict_fderiv_at_re_apply_inner_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/rayleigh.lean", "formal_statement": "theorem inner_product_space.is_self_adjoint.has_strict_fderiv_at_re_apply_inner_self\n\t{F : Type*} [inner_product_space \u211d F] {T : F \u2192L[\u211d] F}\n\t(hT : inner_product_space.is_self_adjoint \u2191T) (x\u2080 : F) :\n\thas_strict_fderiv_at T.re_apply_inner_self (bit0 (\u21d1innerSL (\u21d1T x\u2080))) x\u2080 :=", "nl_statement_of_codex": "Let $F$ be a real inner product space and let $T:F\\to F$ be a self-adjoint linear map. Then the function $x\\mapsto \\langle Tx,x\\rangle$ has a strict derivative at $x_0$."}
{"name": "star_convex_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/star.lean", "formal_statement": "theorem star_convex_empty {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_smul \ud835\udd5c E] (x : E) :\n\tstar_convex \ud835\udd5c x \u2205 :=", "nl_statement_of_codex": "The empty set is star-convex with respect to any point."}
{"name": "is_coprime.is_unit_of_dvd'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/coprime/basic.lean", "formal_statement": "theorem is_coprime.is_unit_of_dvd' {R : Type u} [comm_semiring R] {a b x : R}\n\t(h : is_coprime a b) (ha : x \u2223 a) (hb : x \u2223 b) :\n\tis_unit x :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring. Let $a,b,x\\in R$. If $a$ and $b$ are coprime and $x$ divides both $a$ and $b$, then $x$ is a unit."}
{"name": "linear_map.comap_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_map.comap_injective {R R\u2082 M M\u2082 : Type*2} [semiring R]\n\t[semiring R\u2082] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M]\n\t[module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} [ring_hom_surjective \u03c4\u2081\u2082] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082}\n\t(hf : f.range = \u22a4) :\n\tfunction.injective (submodule.comap f) :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, $M$ and $M'$ be $R$-modules, and $f:M\\to M'$ be a linear map. If $f$ is surjective, then the map $f^*:M'^*\\to M^*$ is injective."}
{"name": "witt_polynomial_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/witt_polynomial.lean", "formal_statement": "theorem witt_polynomial_one (p : \u2115) (R : Type*) [comm_ring R] :\n\twitt_polynomial p R 1 = \u21d1mv_polynomial.C \u2191p * mv_polynomial.X 1 + mv_polynomial.X 0 ^ p :=", "nl_statement_of_codex": "The Witt polynomial of $1$ is $pX+X^p$."}
{"name": "nat.floor_eq_on_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/floor.lean", "formal_statement": "theorem nat.floor_eq_on_Ico {\u03b1 : Type*} [linear_ordered_semiring \u03b1]\n\t[floor_semiring \u03b1] (n : \u2115) (a : \u03b1) (H : a \u2208 set.Ico \u2191n (\u2191n + 1)) :\n\t\u230aa\u230b\u208a = n :=", "nl_statement_of_codex": "Let $a$ be a real number such that $n\\leq a<n+1$. Then $\\lfloor a\\rfloor=n$."}
{"name": "measurable_space.self_subset_generate_measurable_rec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/card_measurable_space.lean", "formal_statement": "theorem measurable_space.self_subset_generate_measurable_rec {\u03b1 : Type u}\n\t(s : set (set \u03b1)) (i : (quotient.out (cardinal.aleph 1).ord).\u03b1) :\n\ts \u2286 measurable_space.generate_measurable_rec s i :=", "nl_statement_of_codex": "Let $s$ be a set of subsets of $\\alpha$ and let $i$ be an ordinal. Then $s$ is a subset of the set of measurable sets generated by $s$."}
{"name": "setoid.classes_eqv_classes", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/setoid/partition.lean", "formal_statement": "theorem setoid.classes_eqv_classes {\u03b1 : Type*} {r : setoid \u03b1} (a : \u03b1) :\n\t\u2203! (b : set \u03b1) (H : b \u2208 r.classes), a \u2208 b :=", "nl_statement_of_codex": "Let $r$ be an equivalence relation on a set $X$. Then for each $x\\in X$ there is a unique equivalence class $[x]$ containing $x$."}
{"name": "norm_num.int_to_nat_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/norm_num.lean", "formal_statement": "theorem norm_num.int_to_nat_neg (a : \u2124) (h : 0 < a) :\n\t(-a).to_nat = 0 :=", "nl_statement_of_codex": "If $a$ is a positive integer, then $-a$ is mapped to $0$ by the function $\\mathbb{Z}\\to\\mathbb{N}$."}
{"name": "convex_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/basic.lean", "formal_statement": "theorem convex_empty {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_smul \ud835\udd5c E] :\n\tconvex \ud835\udd5c \u2205 :=", "nl_statement_of_codex": "The empty set is convex."}
{"name": "is_greatest.is_least_image2", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem is_greatest.is_least_image2 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}\n\t[preorder \u03b1] [preorder \u03b2] [preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1} {t : set \u03b2}\n\t{a : \u03b1} {b : \u03b2} (h\u2080 : \u2200 (b : \u03b2), antitone (function.swap f b))\n\t(h\u2081 : \u2200 (a : \u03b1), antitone (f a)) (ha : is_greatest s a) (hb : is_greatest t b) :\n\tis_least (set.image2 f s t) (f a b) :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. Let $a\\in A$ and $b\\in B$ be the greatest elements of $A$ and $B$, respectively. Then $f(a,b)$ is the least element of $f(A\\times B)$."}
{"name": "add_freiman_hom.sub_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/freiman.lean", "formal_statement": "theorem add_freiman_hom.sub_apply {\u03b1 G : Type*} [add_comm_monoid \u03b1]\n\t[add_comm_group G] {A : set \u03b1} {n : \u2115} (f g : A \u2192+[n] G) (x : \u03b1) :\n\t\u21d1(f - g) x = \u21d1f x - \u21d1g x :=", "nl_statement_of_codex": "Let $A$ be a set, $G$ an abelian group, and $f,g:A\\to G$. Then $(f-g)(x)=f(x)-g(x)$."}
{"name": "ideal.span_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/basic.lean", "formal_statement": "theorem ideal.span_one {\u03b1 : Type u} [semiring \u03b1] :\n\tideal.span 1 = \u22a4 :=", "nl_statement_of_codex": "The span of $1$ is the whole ring."}
{"name": "one_one_reducible.mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/reduce.lean", "formal_statement": "theorem one_one_reducible.mk {\u03b1 \u03b2 : Type*} [primcodable \u03b1] [primcodable \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (q : \u03b2 \u2192 Prop) (h : computable f) (i : function.injective f) :\n\t(\u03bb (a : \u03b1), q (f a)) \u2264\u2081 q :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a computable function. Then the function $g:A\\to B$ defined by $g(a)=f(a)$ is computable."}
{"name": "topological_group.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem topological_group.ext {G : Type*} [group G] {t t' : topological_space G}\n\t(tg : topological_group G) (tg' : topological_group G) (h : nhds 1 = nhds 1) :\n\tt = t' :=", "nl_statement_of_codex": "Let $G$ be a group. If $G$ is a topological group with respect to two topologies $t$ and $t'$, then $t=t'$."}
{"name": "ideal.is_homogeneous.Sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/graded_algebra/homogeneous_ideal.lean", "formal_statement": "theorem ideal.is_homogeneous.Sup {\u03b9 \u03c3 A : Type*} [semiring A] [decidable_eq \u03b9]\n\t[add_monoid \u03b9] [set_like \u03c3 A] [add_submonoid_class \u03c3 A] {\ud835\udc9c : \u03b9 \u2192 \u03c3}\n\t[graded_ring \ud835\udc9c] {\u2110 : set (ideal A)}\n\t(h : \u2200 (I : ideal A), I \u2208 \u2110 \u2192 ideal.is_homogeneous \ud835\udc9c I) :\n\tideal.is_homogeneous \ud835\udc9c (has_Sup.Sup \u2110) :=", "nl_statement_of_codex": "Let $A$ be a graded ring and let $\\mathcal{I}$ be a set of homogeneous ideals of $A$. Then $\\sup\\mathcal{I}$ is a homogeneous ideal of $A$."}
{"name": "finset.one_lt_card", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/card.lean", "formal_statement": "theorem finset.one_lt_card {\u03b1 : Type*} {s : finset \u03b1} :\n\t1 < s.card \u2194 \u2203 (a : \u03b1) (H : a \u2208 s) (b : \u03b1) (H : b \u2208 s), a \u2260 b :=", "nl_statement_of_codex": "Let $s$ be a finite set. Then $1<|s|$ if and only if there are two distinct elements $a,b\\in s$."}
{"name": "right_ord_continuous.coe_to_order_embedding", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/ord_continuous.lean", "formal_statement": "theorem right_ord_continuous.coe_to_order_embedding {\u03b1 : Type u} {\u03b2 : Type v}\n\t[semilattice_inf \u03b1] [semilattice_inf \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : right_ord_continuous f) (h : function.injective f) :\n\t\u21d1(right_ord_continuous.to_order_embedding f hf h) = f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a right-order continuous function between two complete lattices. If $f$ is injective, then $f$ is an order embedding."}
{"name": "set.right_mem_Ioo", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.right_mem_Ioo {\u03b1 : Type*} [preorder \u03b1] {a b : \u03b1} :\n\tb \u2208 set.Ioo a b \u2194 false :=", "nl_statement_of_codex": "$b\\in(a,b)$ if and only if $a<b$."}
{"name": "algebra.finite_type.iff_quotient_mv_polynomial'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/finiteness.lean", "formal_statement": "theorem algebra.finite_type.iff_quotient_mv_polynomial' {R A : Type*}\n\t[comm_ring R] [comm_ring A] [algebra R A] :\n\talgebra.finite_type R A \u2194 \u2203 (\u03b9 : Type u_2) (_x : fintype \u03b9) (f : mv_polynomial \u03b9 R \u2192\u2090[R] A), function.surjective \u21d1f :=", "nl_statement_of_codex": "$A$ is a finite type $R$-algebra if and only if there is a finite set $I$ and a surjective $R$-algebra homomorphism $f:R[I]\\to A$."}
{"name": "model_with_corners_self_coe_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/smooth_manifold_with_corners.lean", "formal_statement": "theorem model_with_corners_self_coe_symm (\ud835\udd5c : Type*)\n\t[nondiscrete_normed_field \ud835\udd5c] (E : Type*) [normed_group E] [normed_space \ud835\udd5c E] :\n\t\u21d1((model_with_corners_self \ud835\udd5c E).symm) = id :=", "nl_statement_of_codex": "The inverse of the model with corners self map is the identity map."}
{"name": "is_strong_antichain.insert", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/antichain.lean", "formal_statement": "theorem is_strong_antichain.insert {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : set \u03b1}\n\t{a : \u03b1} (hs : is_strong_antichain r s)\n\t(h : \u2200 \u2983b : \u03b1\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u2200 (c : \u03b1), \u00acr a c \u2228 \u00acr b c) :\n\tis_strong_antichain r (has_insert.insert a s) :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $A$. Let $s$ be a strong antichain of $r$. Let $a$ be an element of $A$. Suppose that for each $b\\in s$, if $a\\neq b$, then for each $c\\in A$, either $a$ and $c$ are not related by $r$ or $b$ and $c$ are not related by $r$. Then $s\\cup\\{a\\}$ is a strong antichain of $r$."}
{"name": "fin.add_one_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.add_one_pos {n : \u2115} (i : fin (n + 1)) (h : i < fin.last n) :\n\t0 < i + 1 :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $i$ be an element of $[n]$. If $i<n$, then $i+1>0$."}
{"name": "metric.to_glue_l_isometry", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/gluing.lean", "formal_statement": "theorem metric.to_glue_l_isometry {X : Type u} {Y : Type v} {Z : Type w}\n\t[nonempty Z] [metric_space Z] [metric_space X] [metric_space Y] {\u03a6 : Z \u2192 X}\n\t{\u03a8 : Z \u2192 Y} (h\u03a6 : isometry \u03a6) (h\u03a8 : isometry \u03a8) :\n\tisometry (metric.to_glue_l h\u03a6 h\u03a8) :=", "nl_statement_of_codex": "Let $X$ and $Y$ be metric spaces and let $Z$ be a nonempty metric space. Let $\\Phi:Z\\to X$ and $\\Psi:Z\\to Y$ be isometries. Then the map $\\Phi\\times\\Psi:Z\\to X\\times Y$ is an isometry."}
{"name": "add_units.eq_neg_add_iff_add_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/units.lean", "formal_statement": "theorem add_units.eq_neg_add_iff_add_eq {\u03b1 : Type u} [add_monoid \u03b1]\n\t(b : add_units \u03b1) {a c : \u03b1} :\n\ta = \u2191-b + c \u2194 \u2191b + a = c :=", "nl_statement_of_codex": "Let $a, c$ be elements of an additive monoid $A$ and let $b$ be an invertible element of $A$. Then $a=b^{-1}+c$ if and only if $b+a=c$."}
{"name": "has_lt.lt.trans'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/basic.lean", "formal_statement": "theorem has_lt.lt.trans' {\u03b1 : Type u} [preorder \u03b1] {a b c : \u03b1} :\n\tb < c \u2192 a < b \u2192 a < c :=", "nl_statement_of_codex": "If $a<b$ and $b<c$, then $a<c$."}
{"name": "multiset.filter_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.filter_sub {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t[decidable_eq \u03b1] (s t : multiset \u03b1) :\n\tmultiset.filter p (s - t) = multiset.filter p s - multiset.filter p t :=", "nl_statement_of_codex": "Let $p$ be a predicate on a type $\u03b1$. Then the multiset difference of the multiset filters of $s$ and $t$ is the multiset filter of the multiset difference of $s$ and $t$."}
{"name": "min_mul_mul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid.lean", "formal_statement": "theorem min_mul_mul_right {\u03b1 : Type u} [linear_order \u03b1] [has_mul \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] (a b c : \u03b1) :\n\tlinear_order.min (a * c) (b * c) = linear_order.min a b * c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order with multiplication. Then $\\min(ac,bc)=\\min(a,b)c$."}
{"name": "real.tan_nat_mul_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem real.tan_nat_mul_pi (n : \u2115) :\n\treal.tan (\u2191n * real.pi) = 0 :=", "nl_statement_of_codex": "For all $n\\in\\mathbb{N}$, $\\tan(n\\pi)=0$."}
{"name": "complex.has_fderiv_at_cpow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow_deriv.lean", "formal_statement": "theorem complex.has_fderiv_at_cpow {p : \u2102 \u00d7 \u2102}\n\t(hp : 0 < p.fst.re \u2228 p.fst.im \u2260 0) :\n\thas_fderiv_at (\u03bb (x : \u2102 \u00d7 \u2102), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) \u2022 continuous_linear_map.fst \u2102 \u2102 \u2102 + (p.fst ^ p.snd * complex.log p.fst) \u2022 continuous_linear_map.snd \u2102 \u2102 \u2102) p :=", "nl_statement_of_codex": "The function $f(x,y)=x^y$ is differentiable at $(p,q)$ if $p\\neq 0$ or $p$ is not real."}
{"name": "submodule.mem_torsion_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/torsion.lean", "formal_statement": "theorem submodule.mem_torsion_iff {R M : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [module R M] (x : M) :\n\tx \u2208 submodule.torsion R M \u2194 \u2203 (a : \u21a5(non_zero_divisors R)), a \u2022 x = 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and $M$ be an $R$-module. Then $x\\in M$ is torsion if and only if there is a non-zero divisor $a\\in R$ such that $ax=0$."}
{"name": "simple_graph.subgraph.spanning_coe_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/subgraph.lean", "formal_statement": "theorem simple_graph.subgraph.spanning_coe_top {V : Type u} {G : simple_graph V} :\n\t\u22a4.spanning_coe = G :=", "nl_statement_of_codex": "The complete graph on a set $V$ is a spanning subgraph of itself."}
{"name": "lp.tsum_mul_le_mul_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lp_space.lean", "formal_statement": "theorem lp.tsum_mul_le_mul_norm {\u03b1 E : \u03b1 \u2192 Type*}\n\t[\u03a0 (i : \u03b1), normed_group (E i)] {p q : ennreal}\n\t(hpq : p.to_real.is_conjugate_exponent q.to_real) (f : \u21a5(lp E p))\n\t(g : \u21a5(lp E q)) :\n\tsummable (\u03bb (i : \u03b1), \u2225\u21d1f i\u2225 * \u2225\u21d1g i\u2225) \u2227 \u2211' (i : \u03b1), \u2225\u21d1f i\u2225 * \u2225\u21d1g i\u2225 \u2264 \u2225f\u2225 * \u2225g\u2225 :=", "nl_statement_of_codex": "Let $p,q$ be conjugate exponents. Then the series $\\sum_{i\\in\\alpha} \\|f_i\\|\\|g_i\\|$ is absolutely convergent and $\\sum_{i\\in\\alpha} \\|f_i\\|\\|g_i\\|\\leq \\|f\\|\\|g\\|$."}
{"name": "geom_gold_is_sol_fib_rec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/golden_ratio.lean", "formal_statement": "theorem geom_gold_is_sol_fib_rec :\n\tfib_rec.is_solution (has_pow.pow golden_ratio) :=", "nl_statement_of_codex": "The geometric solution of the Fibonacci recurrence is the golden ratio."}
{"name": "measure_theory.measure.mutually_singular.comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/mutually_singular.lean", "formal_statement": "theorem measure_theory.measure.mutually_singular.comm {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1} :\n\t\u03bc.mutually_singular \u03bd \u2194 \u03bd.mutually_singular \u03bc :=", "nl_statement_of_codex": "Two measures $\\mu$ and $\\nu$ on a measurable space $(X,\\mathcal{A})$ are mutually singular if and only if $\\nu$ and $\\mu$ are mutually singular."}
{"name": "set.prod_self_ssubset_prod_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/prod.lean", "formal_statement": "theorem set.prod_self_ssubset_prod_self {\u03b1 : Type*} {s\u2081 s\u2082 : set \u03b1} :\n\ts\u2081 \u00d7\u02e2 s\u2081 \u2282 s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 \u2282 s\u2082 :=", "nl_statement_of_codex": "Let $s_1$ and $s_2$ be sets. Then $s_1\\times s_1\\subset s_2\\times s_2$ if and only if $s_1\\subset s_2$."}
{"name": "add_equiv.symm_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/equiv.lean", "formal_statement": "theorem add_equiv.symm_mk {M N : Type*} [has_add M] [has_add N] (f : M \u2192 N)\n\t(g : N \u2192 M) (h\u2081 : function.left_inverse g f) (h\u2082 : function.right_inverse g f)\n\t(h\u2083 : \u2200 (x y : M), f (x + y) = f x + f y) :\n\t{to_fun := f, inv_fun := g, left_inv := h\u2081, right_inv := h\u2082, map_add' := h\u2083}.symm = {to_fun := g, inv_fun := f, left_inv := _, right_inv := _, map_add' := _} :=", "nl_statement_of_codex": "Let $M$ and $N$ be two types with addition. Let $f:M\\to N$ and $g:N\\to M$ be two functions such that $g$ is a left inverse of $f$, $f$ is a right inverse of $g$, and $f$ is additive. Then the symmetric of the additive equivalence $(f,g)$ is the additive equivalence $(g,f)$."}
{"name": "function.injective.left_inv_of_inv_of_mem_range", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem function.injective.left_inv_of_inv_of_mem_range {\u03b1 \u03b2 : Type*}\n\t[fintype \u03b1] [decidable_eq \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : function.injective f)\n\t(b : \u21a5(set.range f)) :\n\tf (hf.inv_of_mem_range b) = \u2191b :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $f$ has a left inverse."}
{"name": "category_theory.kleisli.adjunction.to_kleisli_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/kleisli.lean", "formal_statement": "theorem category_theory.kleisli.adjunction.to_kleisli_map {C : Type u}\n\t[category_theory.category C] (T : category_theory.monad C) (X Y : C)\n\t(f : X \u27f6 Y) :\n\t(category_theory.kleisli.adjunction.to_kleisli T).map f = f \u226b T.\u03b7.app Y :=", "nl_statement_of_codex": "Let $T$ be a monad on a category $C$. Then the map $f\\mapsto f\\circ \\eta_Y$ is a functor from $C$ to the Kleisli category of $T$."}
{"name": "list.eq_or_mem_of_mem_insert", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.eq_or_mem_of_mem_insert {\u03b1 : Type*} {l : list \u03b1} {a b : \u03b1}\n\t[decidable_eq \u03b1] (h : a \u2208 has_insert.insert b l) :\n\ta = b \u2228 a \u2208 l :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b1$ and let $a, b$ be elements of $\u03b1$. If $a$ is in the list $l$ with $b$ inserted, then $a$ is equal to $b$ or $a$ is in $l$."}
{"name": "Lim_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/separation.lean", "formal_statement": "theorem Lim_eq {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1] {f : filter \u03b1}\n\t{a : \u03b1} [f.ne_bot] (h : f \u2264 nhds a) :\n\tLim f = a :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $f$ be a filter on $X$. If $f$ converges to $a$, then $a$ is the limit of $f$."}
{"name": "filter.bot_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.bot_smul {\u03b1 \u03b2 : Type*} [has_smul \u03b1 \u03b2] {g : filter \u03b2} :\n\t\u22a5 \u2022 g = \u22a5 :=", "nl_statement_of_codex": "The filter $\u22a5$ is the zero element of the monoid of filters under the operation of multiplication by a fixed element."}
{"name": "multiset.induction_on_multiset_quot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.induction_on_multiset_quot {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t{p : multiset (quot r) \u2192 Prop} (s : multiset (quot r)) :\n\t(\u2200 (s : multiset \u03b1), p (multiset.map (quot.mk r) s)) \u2192 p s :=", "nl_statement_of_codex": "Let $r$ be an equivalence relation on a set $A$. Let $s$ be a multiset of elements of $A/r$. Then $s$ is a multiset of elements of $A$."}
{"name": "ring_hom.is_integral_elem_of_is_integral_elem_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/integral_closure.lean", "formal_statement": "theorem ring_hom.is_integral_elem_of_is_integral_elem_comp {R S T : Type*}\n\t[comm_ring R] [comm_ring S] [comm_ring T] (f : R \u2192+* S) (g : S \u2192+* T) {x : T}\n\t(h : (g.comp f).is_integral_elem x) :\n\tg.is_integral_elem x :=", "nl_statement_of_codex": "Let $R, S, T$ be commutative rings and let $f:R\\to S$ and $g:S\\to T$ be ring homomorphisms. If $g\\circ f$ is an integral element of $T$, then $g$ is an integral element of $T$."}
{"name": "mv_polynomial.coeff_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/comm_ring.lean", "formal_statement": "theorem mv_polynomial.coeff_neg {R : Type u} (\u03c3 : Type*) [comm_ring R]\n\t(m : \u03c3 \u2192\u2080 \u2115) (p : mv_polynomial \u03c3 R) :\n\tmv_polynomial.coeff m (-p) = -mv_polynomial.coeff m p :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $p$ be a multivariate polynomial over $R$. Then the coefficient of $m$ in $-p$ is $-1$ times the coefficient of $m$ in $p$."}
{"name": "monoid_hom.coe_mrange", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem monoid_hom.coe_mrange {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t{F : Type*} [mc : monoid_hom_class F M N] (f : F) :\n\t\u2191(monoid_hom.mrange f) = set.range \u21d1f :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids and let $f:M\\to N$ be a monoid homomorphism. Then the image of $f$ is equal to the image of the induced map $f:M\\to N$."}
{"name": "category_theory.monoidal.lax_to_transported_\u03bc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/transport.lean", "formal_statement": "theorem category_theory.monoidal.lax_to_transported_\u03bc {C : Type u\u2081}\n\t[category_theory.category C] [category_theory.monoidal_category C]\n\t{D : Type u\u2082} [category_theory.category D] (e : C \u224c D) (X Y : C) :\n\t(category_theory.monoidal.lax_to_transported e).\u03bc X Y = e.functor.map (e.unit_inv.app X \u2297 e.unit_inv.app Y) :=", "nl_statement_of_codex": "Let $C$ and $D$ be monoidal categories and let $e:C\\to D$ be an equivalence of categories. Then the lax monoidal functor $e$ is transported to a monoidal functor $e'$ by $e'(X)=e(X)$ and $e'(X\\otimes Y)=e(X)\\otimes e(Y)$."}
{"name": "measure_theory.ae_nonneg_restrict_of_forall_set_integral_nonneg_inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ae_eq_of_integral.lean", "formal_statement": "theorem measure_theory.ae_nonneg_restrict_of_forall_set_integral_nonneg_inter\n\t{\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{f : \u03b1 \u2192 \u211d} {t : set \u03b1} (h\u03bct : \u21d1\u03bc t \u2260 \u22a4)\n\t(hf : measure_theory.integrable_on f t \u03bc)\n\t(hf_zero : \u2200 (s : set \u03b1), measurable_set s \u2192 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc) :\n\t0 \u2264\u1d50[\u03bc.restrict t] f :=", "nl_statement_of_codex": "Let $f$ be a measurable function on a measurable space $(X,\\mathcal{A})$ and let $\\mu$ be a measure on $(X,\\mathcal{A})$. Let $t\\in\\mathcal{A}$ be such that $\\mu(t)<\\infty$. If $f$ is integrable on $t$ and $f\\geq 0$ on $t$, then $f\\geq 0$ almost everywhere on $t$."}
{"name": "real.to_nnreal_lt_to_nnreal_iff_of_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/nnreal.lean", "formal_statement": "theorem real.to_nnreal_lt_to_nnreal_iff_of_nonneg {r p : \u211d} (hr : 0 \u2264 r) :\n\tr.to_nnreal < p.to_nnreal \u2194 r < p :=", "nl_statement_of_codex": "If $r$ is a nonnegative real number, then $r<p$ if and only if $r$ is less than $p$ in the nonnegative reals."}
{"name": "lie_submodule.is_nilpotent_iff_exists_lcs_eq_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/nilpotent.lean", "formal_statement": "theorem lie_submodule.is_nilpotent_iff_exists_lcs_eq_bot {R : Type u}\n\t{L : Type v} {M : Type w} [comm_ring R] [lie_ring L] [lie_algebra R L]\n\t[add_comm_group M] [module R M] [lie_ring_module L M] [lie_module R L M]\n\t(N : lie_submodule R L M) :\n\tlie_module.is_nilpotent R L \u21a5N \u2194 \u2203 (k : \u2115), lie_submodule.lcs k N = \u22a5 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a Lie $R$-module. Then the Lie submodule $N$ of $M$ is nilpotent if and only if there exists $k\\in\\mathbb{N}$ such that $N^{(k)}=\\{0\\}$."}
{"name": "stream.all_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/stream/init.lean", "formal_statement": "theorem stream.all_def {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) (s : stream \u03b1) :\n\tstream.all p s = \u2200 (n : \u2115), p (s.nth n) :=", "nl_statement_of_codex": "Let $s$ be a stream of elements of a type $\u03b1$. Then $s$ satisfies a property $p$ if and only if $p$ holds for all elements of $s$."}
{"name": "category_theory.limits.multispan_index.\u03b9_snd_sigma_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/multiequalizer.lean", "formal_statement": "theorem category_theory.limits.multispan_index.\u03b9_snd_sigma_map {C : Type u}\n\t[category_theory.category C] (I : category_theory.limits.multispan_index C)\n\t[category_theory.limits.has_coproduct I.left]\n\t[category_theory.limits.has_coproduct I.right] (b : I.L) :\n\tcategory_theory.limits.sigma.\u03b9 I.left b \u226b I.snd_sigma_map = I.snd b \u226b category_theory.limits.sigma.\u03b9 I.right (I.snd_from b) :=", "nl_statement_of_codex": "Let $C$ be a category and let $I$ be a multispan index. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\n\\coprod_{a\\in I.left} I.left.obj a \\arrow[r, "}
{"name": "set.countable.union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/countable.lean", "formal_statement": "theorem set.countable.union {\u03b1 : Type u} {s\u2081 s\u2082 : set \u03b1} (h\u2081 : s\u2081.countable)\n\t(h\u2082 : s\u2082.countable) :\n\t(s\u2081 \u222a s\u2082).countable :=", "nl_statement_of_codex": "The union of two countable sets is countable."}
{"name": "set.disjoint_sUnion_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.disjoint_sUnion_right {\u03b1 : Type*} {s : set \u03b1} {S : set (set \u03b1)} :\n\tdisjoint s (\u22c3\u2080 S) \u2194 \u2200 (t : set \u03b1), t \u2208 S \u2192 disjoint s t :=", "nl_statement_of_codex": "Let $s$ and $S$ be sets. Then $s$ and $\\bigcup S$ are disjoint if and only if $s$ and $t$ are disjoint for all $t\\in S$."}
{"name": "is_noetherian_of_tower", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem is_noetherian_of_tower (R : Type*) {S M : Type*} [semiring R]\n\t[semiring S] [add_comm_monoid M] [has_smul R S] [module S M] [module R M]\n\t[is_scalar_tower R S M] (h : is_noetherian R M) :\n\tis_noetherian S M :=", "nl_statement_of_codex": "Let $R$ be a ring, $S$ a subring of $R$, and $M$ an $R$-module. If $M$ is a Noetherian $R$-module, then $M$ is a Noetherian $S$-module."}
{"name": "spectrum.nonempty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/spectrum.lean", "formal_statement": "theorem spectrum.nonempty {A : Type*} [normed_ring A] [normed_algebra \u2102 A]\n\t[complete_space A] [nontrivial A] (a : A) :\n\t(spectrum \u2102 a).nonempty :=", "nl_statement_of_codex": "The spectrum of a non-trivial element of a complete normed algebra is non-empty."}
{"name": "filter.map_at_bot_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.map_at_bot_eq {\u03b1 \u03b2 : Type*} [nonempty \u03b1] [semilattice_inf \u03b1]\n\t{f : \u03b1 \u2192 \u03b2} :\n\tfilter.map f filter.at_bot = \u2a05 (a : \u03b1), filter.principal (f '' {a' : \u03b1 | a' \u2264 a}) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then $\\mathcal{F}(f)=\\bigwedge_{a\\in A}\\mathcal{F}(f(a))$."}
{"name": "mul_aut.coe_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/aut.lean", "formal_statement": "theorem mul_aut.coe_one (M : Type*) [has_mul M] :\n\t\u21d11 = id :=", "nl_statement_of_codex": "The identity function is the multiplicative identity of the group of automorphisms of a monoid."}
{"name": "opens.pretopology_of_grothendieck", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/spaces.lean", "formal_statement": "theorem opens.pretopology_of_grothendieck (T : Type u) [topological_space T] :\n\tcategory_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T :=", "nl_statement_of_codex": "The pretopology of the Grothendieck topology on the opens of a topological space $T$ is the pretopology of $T$."}
{"name": "multiset.map_filter_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.map_filter_map {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 option \u03b2) (g : \u03b2 \u2192 \u03b3)\n\t(s : multiset \u03b1) :\n\tmultiset.map g (multiset.filter_map f s) = multiset.filter_map (\u03bb (x : \u03b1), option.map g (f x)) s :=", "nl_statement_of_codex": "Let $f:A\\to\\mathrm{option}(B)$ and $g:B\\to C$. Then $\\mathrm{map}(g,\\mathrm{filter\\_map}(f,A))=\\mathrm{filter\\_map}(g\\circ f,A)$."}
{"name": "function.involutive.bijective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.involutive.bijective {\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1}\n\t(h : function.involutive f) :\n\tfunction.bijective f :=", "nl_statement_of_codex": "Let $f:A\\to A$ be an involution. Then $f$ is bijective."}
{"name": "monoid.exponent_exists_iff_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/exponent.lean", "formal_statement": "theorem monoid.exponent_exists_iff_ne_zero {G : Type u} [monoid G] :\n\tmonoid.exponent_exists G \u2194 monoid.exponent G \u2260 0 :=", "nl_statement_of_codex": "The exponent of a monoid $G$ exists if and only if the exponent of $G$ is not zero."}
{"name": "category_theory.arrow.lift.fac_left_of_from_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/arrow.lean", "formal_statement": "theorem category_theory.arrow.lift.fac_left_of_from_mk {T : Type u}\n\t[category_theory.category T] {X Y : T} {f : X \u27f6 Y}\n\t{g : category_theory.arrow T} (sq : category_theory.arrow.mk f \u27f6 g)\n\t[category_theory.arrow.has_lift sq] :\n\tf \u226b category_theory.arrow.lift sq = sq.left :=", "nl_statement_of_codex": "Let $T$ be a category, let $X, Y$ be objects of $T$, let $f:X\\to Y$ be a morphism, let $g$ be an arrow of $T$, and let $sq$ be the arrow $mk(f)\\to g$. If $sq$ has a lift, then the left factor of $sq$ is $f$."}
{"name": "measure_theory.null_measurable_set.Union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/null_measurable.lean", "formal_statement": "theorem measure_theory.null_measurable_set.Union {\u03b9 \u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [encodable \u03b9]\n\t{s : \u03b9 \u2192 set \u03b1} (h : \u2200 (i : \u03b9), measure_theory.null_measurable_set (s i) \u03bc) :\n\tmeasure_theory.null_measurable_set (\u22c3 (i : \u03b9), s i) \u03bc :=", "nl_statement_of_codex": "Let $(X,\\mathcal{A},\\mu)$ be a measure space. If $A_i\\in\\mathcal{A}$ for all $i\\in I$ and $\\mu(A_i)=0$ for all $i\\in I$, then $\\mu(\\bigcup_{i\\in I}A_i)=0$."}
{"name": "metric.lipschitz_inf_nndist_pt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean", "formal_statement": "theorem metric.lipschitz_inf_nndist_pt {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t(s : set \u03b1) :\n\tlipschitz_with 1 (\u03bb (x : \u03b1), metric.inf_nndist x s) :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $s\\subset X$. Then the function $f:X\\to\\mathbb{R}$ defined by $f(x)=\\inf\\{d(x,y):y\\in s\\}$ is Lipschitz with constant $1$."}
{"name": "fintype.card_le_of_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem fintype.card_le_of_injective {\u03b1 \u03b2 : Type*} [fintype \u03b1] [fintype \u03b2]\n\t(f : \u03b1 \u2192 \u03b2) (hf : function.injective f) :\n\tfintype.card \u03b1 \u2264 fintype.card \u03b2 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $|A|\\leq |B|$."}
{"name": "irrational.of_one_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/irrational.lean", "formal_statement": "theorem irrational.of_one_div {x : \u211d} (h : irrational (1 / x)) :\n\tirrational x :=", "nl_statement_of_codex": "If $1/x$ is irrational, then $x$ is irrational."}
{"name": "conj_classes.mem_carrier_iff_mk_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/conj.lean", "formal_statement": "theorem conj_classes.mem_carrier_iff_mk_eq {\u03b1 : Type u} [monoid \u03b1] {a : \u03b1}\n\t{b : conj_classes \u03b1} :\n\ta \u2208 b.carrier \u2194 conj_classes.mk a = b :=", "nl_statement_of_codex": "Let $G$ be a monoid and let $a,b\\in G$. Then $a\\in b^G$ if and only if $a^G=b^G$."}
{"name": "topological_space.is_separable.image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bases.lean", "formal_statement": "theorem topological_space.is_separable.image {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {\u03b2 : Type*} [topological_space \u03b2] {s : set \u03b1}\n\t(hs : topological_space.is_separable s) {f : \u03b1 \u2192 \u03b2} (hf : continuous f) :\n\ttopological_space.is_separable (f '' s) :=", "nl_statement_of_codex": "Let $X$ be a separable topological space and let $Y$ be a topological space. Let $f:X\\to Y$ be a continuous function. Then $f(X)$ is separable."}
{"name": "continuous_add_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/monoid.lean", "formal_statement": "theorem continuous_add_right {M : Type*} [topological_space M] [has_add M]\n\t[has_continuous_add M] (a : M) :\n\tcontinuous (\u03bb (b : M), b + a) :=", "nl_statement_of_codex": "Let $M$ be a topological space with addition. Then the function $f:M\\to M$ defined by $f(b)=b+a$ is continuous."}
{"name": "uliftable.up_down", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/control/uliftable.lean", "formal_statement": "theorem uliftable.up_down {f : Type u\u2080 \u2192 Type u\u2081}\n\t{g : Type (max u\u2080 v\u2080) \u2192 Type v\u2081} [uliftable f g] {\u03b1 : Type u\u2080}\n\t(x : g (ulift \u03b1)) :\n\tuliftable.up (uliftable.down x) = x :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:C\\to D$ be functions. If $f$ is uliftable to $g$, then $g(f(x))=f(g(x))$ for all $x\\in A$."}
{"name": "commute.inv_left\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_with_zero/basic.lean", "formal_statement": "theorem commute.inv_left\u2080 {G\u2080 : Type*} [group_with_zero G\u2080] {a b : G\u2080}\n\t(h : commute a b) :\n\tcommute a\u207b\u00b9 b :=", "nl_statement_of_codex": "Let $G$ be a group with zero. If $a$ and $b$ commute, then $a^{-1}$ and $b$ commute."}
{"name": "matrix.hadamard_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/hadamard.lean", "formal_statement": "theorem matrix.hadamard_zero {\u03b1 m n : Type*} (A : matrix m n \u03b1)\n\t[mul_zero_class \u03b1] :\n\tA.hadamard 0 = 0 :=", "nl_statement_of_codex": "Let $A$ be an $m\\times n$ matrix over a ring $R$. Then the Hadamard product of $A$ and the zero matrix is the zero matrix."}
{"name": "le_mul_inv_iff_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem le_mul_inv_iff_le {\u03b1 : Type u} [group \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] {a b : \u03b1} :\n\t1 \u2264 a * b\u207b\u00b9 \u2194 b \u2264 a :=", "nl_statement_of_codex": "Let $G$ be a group and let $a, b\\in G$. Then $1\\leq ab^{-1}$ if and only if $b\\leq a$."}
{"name": "lipschitz_with.vsub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/add_torsor.lean", "formal_statement": "theorem lipschitz_with.vsub {\u03b1 V P : Type*} [semi_normed_group V]\n\t[pseudo_metric_space P] [normed_add_torsor V P] [pseudo_emetric_space \u03b1]\n\t{f g : \u03b1 \u2192 P} {Kf Kg : nnreal} (hf : lipschitz_with Kf f)\n\t(hg : lipschitz_with Kg g) :\n\tlipschitz_with (Kf + Kg) (f -\u1d65 g) :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to P$ be functions. If $f$ is $K_f$-Lipschitz and $g$ is $K_g$-Lipschitz, then $f-g$ is $(K_f+K_g)$-Lipschitz."}
{"name": "local_homeomorph.is_image.map_nhds_within_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/local_homeomorph.lean", "formal_statement": "theorem local_homeomorph.is_image.map_nhds_within_eq {\u03b1 \u03b2 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] {e : local_homeomorph \u03b1 \u03b2}\n\t{s : set \u03b1} {t : set \u03b2} {x : \u03b1} (h : e.is_image s t)\n\t(hx : x \u2208 e.to_local_equiv.source) :\n\tfilter.map \u21d1e (nhds_within x s) = nhds_within (\u21d1e x) t :=", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Let $s\\subset X$ and $t\\subset Y$. If $e$ is the image of $s$ under $e$, then $e$ is the image of $t$ under $e^{-1}$."}
{"name": "list.tprod.elim_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/prod/tprod.lean", "formal_statement": "theorem list.tprod.elim_mk {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [decidable_eq \u03b9] (l : list \u03b9)\n\t(f : \u03a0 (i : \u03b9), \u03b1 i) {i : \u03b9} (hi : i \u2208 l) :\n\t(list.tprod.mk l f).elim hi = f i :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b9$ and let $f:\u03b9\\to\\alpha$ be a function. Then $(\\prod_{i\\in l}f(i))_i=f(i)$."}
{"name": "abs_mul_abs_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem abs_mul_abs_self {\u03b1 : Type u} [linear_ordered_ring \u03b1] (a : \u03b1) :\n\t|a| * |a| = a * a :=", "nl_statement_of_codex": "For any $a\\in\\mathbb{R}$, $|a|^2=a^2$."}
{"name": "measure_theory.ae_cover.lintegral_tendsto_of_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/integral_eq_improper.lean", "formal_statement": "theorem measure_theory.ae_cover.lintegral_tendsto_of_nat {\u03b1 : Type*}\n\t[measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {\u03c6 : \u2115 \u2192 set \u03b1}\n\t(h\u03c6 : measure_theory.ae_cover \u03bc filter.at_top \u03c6) {f : \u03b1 \u2192 ennreal}\n\t(hfm : ae_measurable f \u03bc) :\n\tfilter.tendsto (\u03bb (i : \u2115), \u222b\u207b (x : \u03b1) in \u03c6 i, f x \u2202\u03bc) filter.at_top (nhds (\u222b\u207b (x : \u03b1), f x \u2202\u03bc)) :=", "nl_statement_of_codex": "Let $(X,\\mathcal{A},\\mu)$ be a measure space and let $\\phi_n:X\\to\\mathbb{R}$ be a sequence of measurable functions such that $\\mu(\\bigcup_{n=1}^\\infty\\phi_n)=1$. Then $\\int\\phi_n\\,d\\mu\\to\\int\\phi\\,d\\mu$."}
{"name": "alg_equiv.map_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.map_add {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w}\n\t[comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082]\n\t(e : A\u2081 \u2243\u2090[R] A\u2082) (x y : A\u2081) :\n\t\u21d1e (x + y) = \u21d1e x + \u21d1e y :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $A_1$ and $A_2$ be $R$-algebras, and let $e:A_1\\to A_2$ be an algebra isomorphism. Then $e(x+y)=e(x)+e(y)$ for all $x,y\\in A_1$."}
{"name": "esakia_hom.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order/hom/esakia.lean", "formal_statement": "theorem esakia_hom.ext {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [preorder \u03b1]\n\t[topological_space \u03b2] [preorder \u03b2] {f g : esakia_hom \u03b1 \u03b2}\n\t(h : \u2200 (a : \u03b1), \u21d1f a = \u21d1g a) :\n\tf = g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be Esakia homomorphisms. Then $f=g$ if and only if $f(a)=g(a)$ for all $a\\in\\alpha$."}
{"name": "convex_hyperplane", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/basic.lean", "formal_statement": "theorem convex_hyperplane {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [module \ud835\udd5c E] [ordered_add_comm_monoid \u03b2] [module \ud835\udd5c \u03b2]\n\t[ordered_smul \ud835\udd5c \u03b2] {f : E \u2192 \u03b2} (h : is_linear_map \ud835\udd5c f) (r : \u03b2) :\n\tconvex \ud835\udd5c {w : E | f w = r} :=", "nl_statement_of_codex": "Let $E$ and $B$ be ordered vector spaces over $\\mathbb{R}$ or $\\mathbb{C}$. Let $f:E\\to B$ be a linear map. Then the set $\\{w\\in E: f(w)=r\\}$ is convex for any $r\\in B$."}
{"name": "category_theory.Ran_is_sheaf_of_cover_lifting.pulledback_family_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/cover_lifting.lean", "formal_statement": "theorem category_theory.Ran_is_sheaf_of_cover_lifting.pulledback_family_apply\n\t{C D : Type u} [category_theory.category C] [category_theory.category D]\n\t{A : Type w} [category_theory.category A] [category_theory.limits.has_limits A]\n\t{J : category_theory.grothendieck_topology C} {G : C \u2964 D}\n\t(\u2131 : category_theory.Sheaf J A) {X : A} {U : D} (S : category_theory.sieve U)\n\t(x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj \u2131.val \u22d9 category_theory.coyoneda.obj (opposite.op X)) S.arrows)\n\t(Y : category_theory.structured_arrow (opposite.op U) G.op) {W : C}\n\t{f : W \u27f6 opposite.unop Y.right}\n\t(Hf : category_theory.presieve.functor_pullback G \u21d1(category_theory.sieve.pullback Y.hom.unop S) f) :\n\tcategory_theory.Ran_is_sheaf_of_cover_lifting.pulledback_family \u2131 S x Y f Hf = x (G.map f \u226b Y.hom.unop) Hf \u226b ((category_theory.Ran.adjunction A G.op).counit.app \u2131.val).app (opposite.op W) :=", "nl_statement_of_codex": "Let $C, D$ be categories, $A$ a category with limits, $J$ a Grothendieck topology on $C$, $G:C\\to D$ a functor, $\\mathcal{F}$ a sheaf on $C$ with values in $A$, $X$ an object of $A$, $U$ an object of $D$, $S$ a sieve on $U$, $x$ an element of the family of elements of $\\mathcal{F}(U)$ indexed by $S$, $Y$ a structured arrow from $U$ to $G$, $W$ an object of $C$, $f:W\\to G^{"}
{"name": "matrix.diagonal_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem matrix.diagonal_mul {m n : Type*} {\u03b1 : Type v}\n\t[non_unital_non_assoc_semiring \u03b1] [fintype m] [decidable_eq m] (d : m \u2192 \u03b1)\n\t(M : matrix m n \u03b1) (i : m) (j : n) :\n\t(matrix.diagonal d).mul M i j = d i * M i j :=", "nl_statement_of_codex": "Let $M$ be an $m\\times n$ matrix over a non-unital non-associative semiring $R$. Then the product of $M$ with the diagonal matrix with entries $d_i$ is the matrix with entries $d_iM_{ij}$."}
{"name": "le_add_of_nonneg_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem le_add_of_nonneg_of_le {\u03b1 : Type*} [add_zero_class \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b c : \u03b1}\n\t(ha : 0 \u2264 a) (hbc : b \u2264 c) :\n\tb \u2264 a + c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a preordered additive monoid. If $a\\geq 0$ and $b\\leq c$, then $b\\leq a+c$."}
{"name": "lazy_list.append_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/lazy_list/basic.lean", "formal_statement": "theorem lazy_list.append_nil {\u03b1 : Type*} (xs : lazy_list \u03b1) :\n\txs.append (\u03bb (\u00ab_\u00bb : unit), lazy_list.nil) = xs :=", "nl_statement_of_codex": "The lazy list $xs$ is equal to the lazy list $xs$ appended to the empty lazy list."}
{"name": "box_integral.integration_params.eventually_is_partition", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/filter.lean", "formal_statement": "theorem box_integral.integration_params.eventually_is_partition {\u03b9 : Type*}\n\t[fintype \u03b9] (l : box_integral.integration_params) (I : box_integral.box \u03b9) :\n\t\u2200\u1da0 (\u03c0 : box_integral.tagged_prepartition I) in l.to_filter_Union I \u22a4, \u03c0.is_partition :=", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $l$ be a set of integration parameters. Then for all partitions $\\pi$ of $I$ in $l$, $\\pi$ is a partition."}
{"name": "open_subgroup.comap_comap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/open_subgroup.lean", "formal_statement": "theorem open_subgroup.comap_comap {G : Type*} [group G] [topological_space G]\n\t{N : Type*} [group N] [topological_space N] {P : Type*} [group P]\n\t[topological_space P] (K : open_subgroup P) (f\u2082 : N \u2192* P)\n\t(hf\u2082 : continuous \u21d1f\u2082) (f\u2081 : G \u2192* N) (hf\u2081 : continuous \u21d1f\u2081) :\n\topen_subgroup.comap f\u2081 hf\u2081 (open_subgroup.comap f\u2082 hf\u2082 K) = open_subgroup.comap (f\u2082.comp f\u2081) _ K :=", "nl_statement_of_codex": "Let $G, N, P$ be topological groups and let $K$ be an open subgroup of $P$. Let $f_1:G\\to N$ and $f_2:N\\to P$ be continuous homomorphisms. Then the open subgroup of $G$ generated by $f_2\\circ f_1$ is equal to the open subgroup of $G$ generated by $f_1$."}
{"name": "category_theory.inv_map_unit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/fully_faithful.lean", "formal_statement": "theorem category_theory.inv_map_unit {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] {L : C \u2964 D} {R : D \u2964 C} (h : L \u22a3 R)\n\t{X : C} [category_theory.is_iso (h.unit.app X)] :\n\tcategory_theory.inv (L.map (h.unit.app X)) = h.counit.app (L.obj X) :=", "nl_statement_of_codex": "Let $L:C\\to D$ and $R:D\\to C$ be adjoint functors. If $L$ is an isomorphism, then $R$ is an isomorphism."}
{"name": "polynomial.of_finsupp_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.of_finsupp_eq_one {R : Type u} [semiring R]\n\t{a : add_monoid_algebra R \u2115} :\n\t{to_finsupp := a} = 1 \u2194 a = 1 :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $a$ be an element of the monoid algebra $R[x]$. Then $a=1$ if and only if $a$ is the constant polynomial $1$."}
{"name": "tropical.untrop_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/tropical/basic.lean", "formal_statement": "theorem tropical.untrop_inv {R : Type u} [has_neg R] (x : tropical R) :\n\ttropical.untrop x\u207b\u00b9 = -tropical.untrop x :=", "nl_statement_of_codex": "The inverse of a tropical number is the negative of the tropical number."}
{"name": "set.Ico_subset_Icc_union_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Ico_subset_Icc_union_Ico {\u03b1 : Type*} [linear_order \u03b1] {a b c : \u03b1} :\n\tset.Ico a c \u2286 set.Icc a b \u222a set.Ico b c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order. Then $[a,c]\\subset [a,b]\\cup [b,c]$."}
{"name": "is_integral_iff_is_integral_closure_finite", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/integral_closure.lean", "formal_statement": "theorem is_integral_iff_is_integral_closure_finite {R A : Type*} [comm_ring R]\n\t[comm_ring A] [algebra R A] {r : A} :\n\tis_integral R r \u2194 \u2203 (s : set R), s.finite \u2227 is_integral \u21a5(subring.closure s) r :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $A$ be an $R$-algebra. Then $r\\in A$ is integral over $R$ if and only if there is a finite subset $s$ of $R$ such that $r$ is integral over the subring of $A$ generated by $s$."}
{"name": "function.uncurry_curry", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/function.lean", "formal_statement": "theorem function.uncurry_curry {\u03b1 : Type u\u2081} {\u03b2 : Type u\u2082} {\u03c6 : Type u\u2083}\n\t(f : \u03b1 \u00d7 \u03b2 \u2192 \u03c6) :\n\tfunction.uncurry (function.curry f) = f :=", "nl_statement_of_codex": "The function $f:\\alpha\\times\\beta\\to\\phi$ is equal to the composition of the functions $f\\circ\\langle\\rangle:\\alpha\\to\\beta\\to\\phi$ and $\\langle\\rangle:\\beta\\to\\alpha\\to\\beta$."}
{"name": "inseparable.specializes'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/inseparable.lean", "formal_statement": "theorem inseparable.specializes' {X : Type*} [topological_space X] {x y : X}\n\t(h : inseparable x y) :\n\ty \u2933 x :=", "nl_statement_of_codex": "If $x$ and $y$ are inseparable, then $y$ specializes to $x$."}
{"name": "cauchy_seq_sum_of_eventually_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem cauchy_seq_sum_of_eventually_eq {E : Type*} [semi_normed_group E]\n\t{u v : \u2115 \u2192 E} {N : \u2115} (huv : \u2200 (n : \u2115), n \u2265 N \u2192 u n = v n)\n\t(hv : cauchy_seq (\u03bb (n : \u2115), (finset.range (n + 1)).sum (\u03bb (k : \u2115), v k))) :\n\tcauchy_seq (\u03bb (n : \u2115), (finset.range (n + 1)).sum (\u03bb (k : \u2115), u k)) :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group. Let $u,v:\\mathbb{N}\\to E$ be sequences such that $u(n)=v(n)$ for all $n\\geq N$. If the sequence $\\sum_{k=0}^n v(k)$ is Cauchy, then the sequence $\\sum_{k=0}^n u(k)$ is Cauchy."}
{"name": "norm_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem norm_zero {E : Type*} [semi_normed_group E] :\n\t\u22250\u2225 = 0 :=", "nl_statement_of_codex": "The norm of the zero element of a semi-normed group is zero."}
{"name": "subsemigroup.mem_map_iff_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem subsemigroup.mem_map_iff_mem {M N : Type*} [has_mul M] [has_mul N]\n\t{f : M \u2192\u2099* N} (hf : function.injective \u21d1f) {S : subsemigroup M} {x : M} :\n\t\u21d1f x \u2208 subsemigroup.map f S \u2194 x \u2208 S :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids, let $f:M\\to N$ be a monoid homomorphism, and let $S$ be a submonoid of $M$. Then $f(x)\\in f(S)$ if and only if $x\\in S$."}
{"name": "ideal.inertia_deg_of_subsingleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/ramification_inertia.lean", "formal_statement": "theorem ideal.inertia_deg_of_subsingleton {R : Type u} [comm_ring R]\n\t{S : Type v} [comm_ring S] (f : R \u2192+* S) (p : ideal R) (P : ideal S)\n\t[hp : p.is_maximal] [hQ : subsingleton (S \u29f8 P)] :\n\tideal.inertia_deg f p P = 0 :=", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings, let $f:R\\to S$ be a ring homomorphism, let $p$ be a maximal ideal of $R$, and let $P$ be an ideal of $S$. If $S/P$ is a singleton, then the inertia degree of $f$ at $p$ is zero."}
{"name": "set.ord_connected_iff_interval_subset_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/ord_connected.lean", "formal_statement": "theorem set.ord_connected_iff_interval_subset_right {\u03b1 : Type*} [linear_order \u03b1]\n\t{s : set \u03b1} {x : \u03b1} (hx : x \u2208 s) :\n\ts.ord_connected \u2194 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 set.interval y x \u2286 s :=", "nl_statement_of_codex": "Let $s$ be a subset of a linear order $X$. Then $s$ is connected if and only if for all $x\\in s$ and $y\\in s$, the interval $[y,x]$ is contained in $s$."}
{"name": "polynomial.C_bit0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.C_bit0 {R : Type u} {a : R} [semiring R] :\n\t\u21d1polynomial.C (bit0 a) = bit0 (\u21d1polynomial.C a) :=", "nl_statement_of_codex": "The polynomial $x\\mapsto 2a$ is equal to $2$ times the polynomial $x\\mapsto a$."}
{"name": "homeomorph.prod_punit_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homeomorph.lean", "formal_statement": "theorem homeomorph.prod_punit_apply (\u03b1 : Type*) [topological_space \u03b1] :\n\t\u21d1(homeomorph.prod_punit \u03b1) = prod.fst :=", "nl_statement_of_codex": "The map $f:X\\times\\{0\\}\\to X$ defined by $f(x,0)=x$ is a homeomorphism."}
{"name": "constant_coeff_witt_structure_rat_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/structure_polynomial.lean", "formal_statement": "theorem constant_coeff_witt_structure_rat_zero (p : \u2115) {idx : Type*}\n\t[hp : fact (nat.prime p)] (\u03a6 : mv_polynomial idx \u211a) :\n\t\u21d1mv_polynomial.constant_coeff (witt_structure_rat p \u03a6 0) = \u21d1mv_polynomial.constant_coeff \u03a6 :=", "nl_statement_of_codex": "Let $p$ be a prime number and let $\\Phi$ be a multivariate polynomial with rational coefficients. Then the constant coefficient of the Witt structure of $\\Phi$ at $0$ is equal to the constant coefficient of $\\Phi$."}
{"name": "submonoid.localization_map.mul_equiv_of_mul_equiv_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.mul_equiv_of_mul_equiv_eq {M : Type*}\n\t[comm_monoid M] {S : submonoid M} {N : Type*} [comm_monoid N] {P : Type*}\n\t[comm_monoid P] (f : S.localization_map N) {T : submonoid P} {Q : Type*}\n\t[comm_monoid Q] {k : T.localization_map Q} {j : M \u2243* P}\n\t(H : submonoid.map j.to_monoid_hom S = T) (x : M) :\n\t\u21d1(f.mul_equiv_of_mul_equiv k H) (\u21d1(f.to_map) x) = \u21d1(k.to_map) (\u21d1j x) :=", "nl_statement_of_codex": "Let $M$ and $N$ be commutative monoids, let $S$ be a submonoid of $M$, let $P$ and $Q$ be commutative monoids, let $T$ be a submonoid of $P$, let $f:S^{-1}M\\to N$ and $k:T^{-1}P\\to Q$ be localization maps, and let $j:M\\to P$ be a monoid isomorphism. If $j(S)=T$, then $f(x/1)=k(j(x)/1)$ for all $x\\in M$."}
{"name": "sequentially_complete.seq_is_cauchy_seq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean", "formal_statement": "theorem sequentially_complete.seq_is_cauchy_seq {\u03b1 : Type u} [uniform_space \u03b1]\n\t{f : filter \u03b1} (hf : cauchy f) {U : \u2115 \u2192 set (\u03b1 \u00d7 \u03b1)}\n\t(U_mem : \u2200 (n : \u2115), U n \u2208 uniformity \u03b1)\n\t(U_le : \u2200 (s : set (\u03b1 \u00d7 \u03b1)), s \u2208 uniformity \u03b1 \u2192 (\u2203 (n : \u2115), U n \u2286 s)) :\n\tcauchy_seq (sequentially_complete.seq hf U_mem) :=", "nl_statement_of_codex": "Let $X$ be a sequentially complete uniform space. Let $f$ be a Cauchy filter on $X$. Let $U_n$ be a sequence of entourages of $X$ such that $U_n\\subset U_{n+1}$ for all $n$. Then the sequence $f_n$ defined by $f_n(x)=f(U_n)$ is a Cauchy sequence."}
{"name": "tendsto_uniformly_on_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/uniform_convergence.lean", "formal_statement": "theorem tendsto_uniformly_on_empty {\u03b1 \u03b2 \u03b9 : Type*} [uniform_space \u03b2]\n\t{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : filter \u03b9} :\n\ttendsto_uniformly_on F f p \u2205 :=", "nl_statement_of_codex": "Let $F:\\mathbb{I}\\times\\mathbb{A}\\to\\mathbb{B}$ be a function and let $f:\\mathbb{A}\\to\\mathbb{B}$ be a function. Then $F$ converges uniformly to $f$ on the empty set."}
{"name": "category_theory.presieve.cover_by_image_structure.fac_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/dense_subsite.lean", "formal_statement": "theorem category_theory.presieve.cover_by_image_structure.fac_assoc {C : Type*}\n\t[category_theory.category C] {D : Type*} [category_theory.category D]\n\t{G : C \u2964 D} {V U : D} {f : V \u27f6 U}\n\t(self : category_theory.presieve.cover_by_image_structure G f) {X' : D}\n\t(f' : U \u27f6 X') :\n\tself.lift \u226b self.map \u226b f' = f \u226b f' :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $G:C\\to D$ be a functor. Let $V,U,X'$ be objects of $D$ and let $f:V\\to U$ and $f':U\\to X'$ be morphisms in $D$. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\nV \\arrow[r, "}
{"name": "topological_space.clopens.coe_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sets/closeds.lean", "formal_statement": "theorem topological_space.clopens.coe_top {\u03b1 : Type*} [topological_space \u03b1] :\n\t\u2191\u22a4 = set.univ :=", "nl_statement_of_codex": "The clopen set corresponding to the topology on $X$ is the whole space $X$."}
{"name": "filter.tendsto_at_top_add_nonneg_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.tendsto_at_top_add_nonneg_right {\u03b1 \u03b2 : Type*}\n\t[ordered_add_comm_monoid \u03b2] {l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2}\n\t(hf : filter.tendsto f l filter.at_top) (hg : \u2200 (x : \u03b1), 0 \u2264 g x) :\n\tfilter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_top :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions such that $f$ tends to infinity and $g$ is nonnegative. Then $f+g$ tends to infinity."}
{"name": "quaternion_group.xa_pow_four", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/specific_groups/quaternion.lean", "formal_statement": "theorem quaternion_group.xa_pow_four {n : \u2115} (i : zmod (2 * n)) :\n\tquaternion_group.xa i ^ 4 = 1 :=", "nl_statement_of_codex": "In the quaternion group of order $2n$, the element $x_a$ has order $4$."}
{"name": "set.left_inv_on.image_image'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/function.lean", "formal_statement": "theorem set.left_inv_on.image_image' {\u03b1 : Type u} {\u03b2 : Type v} {s s\u2081 : set \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1} (hf : set.left_inv_on f' f s) (hs : s\u2081 \u2286 s) :\n\tf' '' (f '' s\u2081) = s\u2081 :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $f':B\\to A$ be functions. If $f'$ is a left inverse of $f$ on $A$, then $f'(f(A))=A$."}
{"name": "alg_equiv.bijective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.bijective {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w}\n\t[comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082]\n\t(e : A\u2081 \u2243\u2090[R] A\u2082) :\n\tfunction.bijective \u21d1e :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A_1$ and $A_2$ be $R$-algebras. If $e:A_1\\to A_2$ is an algebra isomorphism, then $e$ is a bijection."}
{"name": "rbmap.mem_insert", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rbmap/default.lean", "formal_statement": "theorem rbmap.mem_insert {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t[decidable_rel lt] [is_strict_weak_order \u03b1 lt] (k : \u03b1) (m : rbmap \u03b1 \u03b2 lt)\n\t(v : \u03b2) :\n\tk \u2208 m.insert k v :=", "nl_statement_of_codex": "Let $m$ be a red-black map. Then $k$ is in the red-black map $m.insert(k,v)$."}
{"name": "ordinal.opow_le_of_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.opow_le_of_limit {a b c : ordinal} (a0 : a \u2260 0) (h : b.is_limit) :\n\ta ^ b \u2264 c \u2194 \u2200 (b' : ordinal), b' < b \u2192 a ^ b' \u2264 c :=", "nl_statement_of_codex": "Let $a, b, c$ be ordinals. If $a\\neq 0$ and $b$ is a limit ordinal, then $a^b\\leq c$ if and only if $a^b'\\leq c$ for all $b'<b$."}
{"name": "monotone.strict_mono_of_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem monotone.strict_mono_of_injective {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[partial_order \u03b2] {f : \u03b1 \u2192 \u03b2} (h\u2081 : monotone f) (h\u2082 : function.injective f) :\n\tstrict_mono f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function between partially ordered sets. If $f$ is injective, then $f$ is strictly monotone."}
{"name": "category_theory.subobject.of_le_mk_comp_of_mk_le_mk_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/basic.lean", "formal_statement": "theorem category_theory.subobject.of_le_mk_comp_of_mk_le_mk_assoc {C : Type u\u2081}\n\t[category_theory.category C] {B A\u2081 A\u2082 : C} (X : category_theory.subobject B)\n\t(f : A\u2081 \u27f6 B) [category_theory.mono f] (g : A\u2082 \u27f6 B) [category_theory.mono g]\n\t(h\u2081 : X \u2264 category_theory.subobject.mk f)\n\t(h\u2082 : category_theory.subobject.mk f \u2264 category_theory.subobject.mk g) {X' : C}\n\t(f' : A\u2082 \u27f6 X') :\n\tX.of_le_mk f h\u2081 \u226b category_theory.subobject.of_mk_le_mk f g h\u2082 \u226b f' = X.of_le_mk g _ \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, $B$ an object of $C$, $A_1, A_2$ objects of $C$, $X$ a subobject of $B$, $f:A_1\\to B$ a monomorphism, $g:A_2\\to B$ a monomorphism, $h_1:X\\leq \\mathrm{Im}(f)$, $h_2:\\mathrm{Im}(f)\\leq \\mathrm{Im}(g)$, $X'$ an object of $C$, $f':A_2\\to X'$. Then $X'\\circ h_1\\circ h_"}
{"name": "category_theory.limits.pushout_cocone.unop_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/opposites.lean", "formal_statement": "theorem category_theory.limits.pushout_cocone.unop_snd {C : Type u\u2081}\n\t[category_theory.category C] {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : X \u27f6 Z}\n\t( : category_theory.limits.pushout_cocone f g) :\n\tc.unop.snd = c.inr.unop :=", "nl_statement_of_codex": "Let $C$ be a category. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$ and $g:X\\to Z$ be morphisms. Let $c$ be a pushout cocone of $f$ and $g$. Then the morphism $c.unop.snd$ is equal to the morphism $c.inr.unop$."}
{"name": "add_group_filter_basis.nhds_zero_has_basis", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/filter_basis.lean", "formal_statement": "theorem add_group_filter_basis.nhds_zero_has_basis {G : Type u} [add_group G]\n\t(B : add_group_filter_basis G) :\n\t(nhds 0).has_basis (\u03bb (V : set G), V \u2208 B) id :=", "nl_statement_of_codex": "The filter of neighborhoods of $0$ in an additive group $G$ has a basis consisting of the sets in the filter basis $B$."}
{"name": "set_like.is_homogeneous_zero_submodule", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/internal.lean", "formal_statement": "theorem set_like.is_homogeneous_zero_submodule {\u03b9 S R : Type*} [has_zero \u03b9]\n\t[semiring S] [add_comm_monoid R] [module S R] (A : \u03b9 \u2192 submodule S R) :\n\tset_like.is_homogeneous A 0 :=", "nl_statement_of_codex": "Let $A$ be a family of submodules of a module $R$ over a semiring $S$. Then $0\\in A$."}
{"name": "polynomial.of_finsupp_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.of_finsupp_neg {R : Type u} [ring R]\n\t{a : add_monoid_algebra R \u2115} :\n\t{to_finsupp := -a} = -{to_finsupp := a} :=", "nl_statement_of_codex": "The negation of a polynomial is the negation of its finitely supported representation."}
{"name": "cont_mdiff_within_at.of_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem cont_mdiff_within_at.of_succ {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*}\n\t[topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {f : M \u2192 M'} {s : set M} {x : M} {n : \u2115}\n\t(h : cont_mdiff_within_at I I' \u2191(n.succ) f s x) :\n\tcont_mdiff_within_at I I' \u2191n f s x :=", "nl_statement_of_codex": "Let $f:M\\to M'$ be a function between manifolds. If $f$ is $n+1$ times continuously differentiable at $x\\in M$, then $f$ is $n$ times continuously differentiable at $x$."}
{"name": "inner_add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem inner_add_left {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E]\n\t{x y z : E} :\n\thas_inner.inner (x + y) z = has_inner.inner x z + has_inner.inner y z :=", "nl_statement_of_codex": "Let $E$ be an inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Then for all $x,y,z\\in E$, we have $\\langle x+y,z\\rangle=\\langle x,z\\rangle+\\langle y,z\\rangle$."}
{"name": "nat.factorization_choose_le_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/choose/factorization.lean", "formal_statement": "theorem nat.factorization_choose_le_one {p n k : \u2115} (p_large : n < p ^ 2) :\n\t\u21d1((n.choose k).factorization) p \u2264 1 :=", "nl_statement_of_codex": "Let $p$ be a prime and let $n, k$ be natural numbers. If $n<p^2$, then the exponent of $p$ in the prime factorization of $\\binom{n}{k}$ is at most $1$."}
{"name": "tendsto_locally_uniformly_on.comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/uniform_convergence.lean", "formal_statement": "theorem tendsto_locally_uniformly_on.comp {\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [uniform_space \u03b2]\n\t{F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {p : filter \u03b9} [topological_space \u03b1]\n\t[topological_space \u03b3] {t : set \u03b3} (h : tendsto_locally_uniformly_on F f p s)\n\t(g : \u03b3 \u2192 \u03b1) (hg : set.maps_to g t s) (cg : continuous_on g t) :\n\ttendsto_locally_uniformly_on (\u03bb (n : \u03b9), F n \u2218 g) (f \u2218 g) p t :=", "nl_statement_of_codex": "Let $F:\\mathbb{N}\\to C(X,Y)$ be a sequence of continuous functions from a topological space $X$ to a uniform space $Y$. Let $f:X\\to Y$ be a continuous function. Let $g:Z\\to X$ be a continuous function. Then the sequence of functions $F_n\\circ g:Z\\to Y$ converges uniformly to $f\\circ g$."}
{"name": "cardinal.continuum_to_part_enat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/continuum.lean", "formal_statement": "theorem cardinal.continuum_to_part_enat :\n\t\u21d1cardinal.to_part_enat cardinal.continuum = \u22a4 :=", "nl_statement_of_codex": "The cardinality of the continuum is equal to the cardinality of the set of all ordinals."}
{"name": "order_iso.with_top_congr_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/basic.lean", "formal_statement": "theorem order_iso.with_top_congr_apply {\u03b1 \u03b2 : Type*} [partial_order \u03b1]\n\t[partial_order \u03b2] (e : \u03b1 \u2243o \u03b2) (o : option \u03b1) :\n\t\u21d1(e.with_top_congr) o = option.map \u21d1e o :=", "nl_statement_of_codex": "Let $e:A\\to B$ be an order isomorphism. Then $e$ induces an order isomorphism $e':A\\cup\\{\\top\\}\\to B\\cup\\{\\top\\}$ by $e'(a)=e(a)$ for $a\\in A$ and $e'(\\top)=\\top$. Then $e'$ is the unique order isomorphism with this property."}
{"name": "basis.to_matrix_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/basis.lean", "formal_statement": "theorem basis.to_matrix_apply {\u03b9 \u03b9' R M : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [module R M] (e : basis \u03b9 R M) (v : \u03b9' \u2192 M) (i : \u03b9)\n\t(j : \u03b9') :\n\te.to_matrix v i j = \u21d1(\u21d1(e.repr) (v j)) i :=", "nl_statement_of_codex": "Let $M$ be a $R$-module and let $e$ be a basis of $M$. Let $v:\\mathbb{I}'\\to M$ be a function. Then the $(i,j)$-entry of the matrix of $v$ with respect to $e$ is the $i$-th coordinate of the image of $v(j)$ under the representation of $e$."}
{"name": "image_to_kernel_comp_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/image_to_kernel.lean", "formal_statement": "theorem image_to_kernel_comp_left {V : Type u} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] {A B C : V} (f : A \u27f6 B)\n\t(g : B \u27f6 C) [category_theory.limits.has_kernels V]\n\t[category_theory.limits.has_images V] {Z : V} (h : Z \u27f6 A) (w : f \u226b g = 0) :\n\timage_to_kernel (h \u226b f) g _ = (category_theory.limits.image_subobject (h \u226b f)).of_le (category_theory.limits.image_subobject f) _ \u226b image_to_kernel f g w :=", "nl_statement_of_codex": "Let $V$ be a category with zero morphisms and kernels and images. Let $A, B, C$ be objects of $V$ and let $f:A\\to B$ and $g:B\\to C$ be morphisms. Let $Z$ be an object of $V$ and let $h:Z\\to A$ be a morphism. If $f\\circ g=0$, then the image of $h\\circ f$ is contained in the kernel of $g$."}
{"name": "rbmap.find_entry_insert_of_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rbmap/default.lean", "formal_statement": "theorem rbmap.find_entry_insert_of_ne {\u03b1 : Type u} {\u03b2 : Type v}\n\t{lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [decidable_rel lt] [is_strict_total_order \u03b1 lt] {k\u2081 k\u2082 : \u03b1}\n\t(m : rbmap \u03b1 \u03b2 lt) (v : \u03b2) :\n\tk\u2081 \u2260 k\u2082 \u2192 (m.insert k\u2081 v).find_entry k\u2082 = m.find_entry k\u2082 :=", "nl_statement_of_codex": "Let $m$ be a red-black map. If $k_1\\neq k_2$, then the find_entry of $m$ with key $k_2$ is the same as the find_entry of $m$ with key $k_2$ after inserting a value $v$ with key $k_1$."}
{"name": "frontier_Ioc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem frontier_Ioc {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] [densely_ordered \u03b1] [no_max_order \u03b1] {a b : \u03b1} (h : a < b) :\n\tfrontier (set.Ioc a b) = {a, b} :=", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{R}$ with $a<b$. Then the frontier of the open interval $(a,b)$ is $\\{a,b\\}$."}
{"name": "interval_integral.integral_comp_mul_deriv''", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/interval_integral.lean", "formal_statement": "theorem interval_integral.integral_comp_mul_deriv'' {a b : \u211d} {f f' g : \u211d \u2192 \u211d}\n\t(hf : continuous_on f (set.interval a b))\n\t(hff' : \u2200 (x : \u211d), x \u2208 set.Ioo (linear_order.min a b) (linear_order.max a b) \u2192 has_deriv_within_at f (f' x) (set.Ioi x) x)\n\t(hf' : continuous_on f' (set.interval a b))\n\t(hg : continuous_on g (f '' set.interval a b)) :\n\t\u222b (x : \u211d) in a..b, (g \u2218 f) x * f' x = \u222b (u : \u211d) in f a..f b, g u :=", "nl_statement_of_codex": "Let $f, f', g: \\mathbb{R}\\to\\mathbb{R}$ be continuous functions. Suppose that $f$ is differentiable on $(a,b)$ and that $f'$ is continuous on $[a,b]$. Suppose that $g$ is continuous on $f([a,b])$. Then $\\int_a^b g(f(x))f'(x)dx=\\int_{f(a)}^{f(b)}g(u)du$."}
{"name": "lattice.biimp_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/imp.lean", "formal_statement": "theorem lattice.biimp_comm {\u03b1 : Type*} [boolean_algebra \u03b1] (a b : \u03b1) :\n\ta \u21d4\u2092 b = b \u21d4\u2092 a :=", "nl_statement_of_codex": "In a boolean algebra, $a\\leftrightarrow b=b\\leftrightarrow a$."}
{"name": "add_neg_cancel_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/defs.lean", "formal_statement": "theorem add_neg_cancel_right {G : Type*} [add_group G] (a b : G) :\n\ta + b + -b = a :=", "nl_statement_of_codex": "For all $a,b\\in G$, $a+b-b=a$."}
{"name": "map_ne_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem map_ne_one_iff {R S F : Type*} [has_one R] [has_one S]\n\t[one_hom_class F R S] (f : F) (hf : function.injective \u21d1f) {x : R} :\n\t\u21d1f x \u2260 1 \u2194 x \u2260 1 :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings with identity and let $F$ be a class of ring homomorphisms from $R$ to $S$. Let $f:R\\to S$ be a homomorphism in $F$. Then $f(x)\\neq 1$ if and only if $x\\neq 1$."}
{"name": "absolute_value.is_admissible.exists_approx_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/class_number/admissible_absolute_value.lean", "formal_statement": "theorem absolute_value.is_admissible.exists_approx_aux {R : Type*}\n\t[euclidean_domain R] {abv : absolute_value R \u2124} (n : \u2115) (h : abv.is_admissible)\n\t{\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : R} (hb : b \u2260 0)\n\t(A : fin (h.card \u03b5 ^ n).succ \u2192 fin n \u2192 R) :\n\t\u2203 (i\u2080 i\u2081 : fin (h.card \u03b5 ^ n).succ), i\u2080 \u2260 i\u2081 \u2227 \u2200 (k : fin n), \u2191(\u21d1abv (A i\u2081 k % b - A i\u2080 k % b)) < \u21d1abv b \u2022 \u03b5 :=", "nl_statement_of_codex": "Let $R$ be a Euclidean domain, let $b\\in R$ be nonzero, and let $A:\\mathbb{N}\\times\\mathbb{N}\\to R$. Then there exist $i_0, i_1\\in\\mathbb{N}$ such that $i_0\\neq i_1$ and $\\lvert A(i_1,k)\\bmod b-A(i_0,k)\\bmod b\\rvert<\\lvert b\\rvert\\varepsilon$ for all $k\\in\\mathbb{N}$."}
{"name": "measurable_space.generate_from_sup_generate_from", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space_def.lean", "formal_statement": "theorem measurable_space.generate_from_sup_generate_from {\u03b1 : Type*}\n\t{s t : set (set \u03b1)} :\n\tmeasurable_space.generate_from s \u2294 measurable_space.generate_from t = measurable_space.generate_from (s \u222a t) :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets of subsets of a set $X$. Then the smallest $\\sigma$-algebra containing $s$ and $t$ is the smallest $\\sigma$-algebra containing $s\\cup t$."}
{"name": "pfun.mem_dom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pfun.lean", "formal_statement": "theorem pfun.mem_dom {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192. \u03b2) (x : \u03b1) :\n\tx \u2208 f.dom \u2194 \u2203 (y : \u03b2), y \u2208 f x :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a partial function. Then $x\\in X$ is in the domain of $f$ if and only if there is a $y\\in Y$ such that $f(x)=y$."}
{"name": "affine_equiv.point_reflection_fixed_iff_of_injective_bit0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_equiv.lean", "formal_statement": "theorem affine_equiv.point_reflection_fixed_iff_of_injective_bit0 (k : Type*)\n\t{P\u2081 V\u2081 : Type*} [ring k] [add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081]\n\t{x y : P\u2081} (h : function.injective bit0) :\n\t\u21d1(affine_equiv.point_reflection k x) y = y \u2194 y = x :=", "nl_statement_of_codex": "Let $P_1$ be an affine space over $k$ and let $x,y\\in P_1$. Then $y$ is fixed by the point reflection $r_x$ if and only if $y=x$."}
{"name": "normed_ring.inverse_one_sub_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/units.lean", "formal_statement": "theorem normed_ring.inverse_one_sub_norm {R : Type*} [normed_ring R]\n\t[complete_space R] :\n\t(\u03bb (t : R), ring.inverse (1 - t)) =O[nhds 0] \u03bb (t : R), 1 :=", "nl_statement_of_codex": "The function $f(t)=\\frac{1}{1-t}$ is $O(1)$ as $t\\to 0$."}
{"name": "equiv.as_embedding_range", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/embedding.lean", "formal_statement": "theorem equiv.as_embedding_range {\u03b1 : Sort u_1} {\u03b2 : Type*} {p : \u03b2 \u2192 Prop}\n\t(e : \u03b1 \u2243 subtype p) :\n\tset.range \u21d1(e.as_embedding) = set_of p :=", "nl_statement_of_codex": "Let $p$ be a property of elements of $B$. Then the range of the embedding of $A$ into the subtype of $B$ consisting of elements satisfying $p$ is the set of elements of $B$ satisfying $p$."}
{"name": "continuous_linear_map.norm_to_span_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.norm_to_span_singleton (\ud835\udd5c : Type*) {E : Type*}\n\t[semi_normed_group E] [nondiscrete_normed_field \ud835\udd5c] [normed_space \ud835\udd5c E] (x : E) :\n\t\u2225continuous_linear_map.to_span_singleton \ud835\udd5c x\u2225 = \u2225x\u2225 :=", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$. Then the norm of the linear map $T:E\\to E$ defined by $T(y)=\\langle x,y\\rangle x$ is equal to the norm of $x$."}
{"name": "algebraic_geometry.PresheafedSpace.colimit_cocone_\u03b9_app_base", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/presheafed_space/has_colimits.lean", "formal_statement": "theorem algebraic_geometry.PresheafedSpace.colimit_cocone_\u03b9_app_base\n\t{J : Type u'} [category_theory.category J] {C : Type u}\n\t[category_theory.category C]\n\t[category_theory.limits.has_colimits_of_shape J Top]\n\t[\u2200 (X : Top), category_theory.limits.has_limits_of_shape J\u1d52\u1d56 (Top.presheaf C X)]\n\t(F : J \u2964 algebraic_geometry.PresheafedSpace C) (j : J) :\n\t((algebraic_geometry.PresheafedSpace.colimit_cocone F).\u03b9.app j).base = category_theory.limits.colimit.\u03b9 (F \u22d9 algebraic_geometry.PresheafedSpace.forget C) j :=", "nl_statement_of_codex": "Let $F:J\\to\\mathrm{Top}$ be a functor. Then the colimit of $F$ is the colimit of the functor $F\\circ\\mathrm{forget}:\\mathrm{Top}\\to\\mathrm{Top}$."}
{"name": "linear_map.ker_comp_of_ker_eq_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_map.ker_comp_of_ker_eq_bot {R R\u2082 R\u2083 M M\u2082 M\u2083 : Type*3}\n\t[semiring R] [semiring R\u2082] [semiring R\u2083] [add_comm_monoid M]\n\t[add_comm_monoid M\u2082] [add_comm_monoid M\u2083] [module R M] [module R\u2082 M\u2082]\n\t[module R\u2083 M\u2083] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}\n\t[ring_hom_comp_triple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083}\n\t(hg : g.ker = \u22a5) :\n\t(g.comp f).ker = f.ker :=", "nl_statement_of_codex": "Let $R, R_2, R_3$ be semirings, $M, M_2, M_3$ be commutative monoids, and $R, R_2, R_3$ act on $M, M_2, M_3$ respectively. Let $\\tau_{12}:R\\to R_2$, $\\tau_{23}:R_2\\to R_3$, $\\tau_{13}:R\\to R_3$ be ring homomorphisms such that $\\tau_{13}=\\tau_{23}\\circ\\tau_{12}$. Let $f:M\\to M_2$ and $g:M_"}
{"name": "list.eq_nil_of_prefix_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.eq_nil_of_prefix_nil {\u03b1 : Type*} {l : list \u03b1} :\n\tl <+: list.nil \u2192 l = list.nil :=", "nl_statement_of_codex": "If $l$ is a prefix of the empty list, then $l$ is the empty list."}
{"name": "computation.map_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.map_comp {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : \u03b1 \u2192 \u03b2)\n\t(g : \u03b2 \u2192 \u03b3) (s : computation \u03b1) :\n\tcomputation.map (g \u2218 f) s = computation.map g (computation.map f s) :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$. Then $g\\circ f:A\\to C$ and $(g\\circ f)\\circ s=g\\circ (f\\circ s)$."}
{"name": "set.finite.neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.finite.neg {\u03b1 : Type*} [has_involutive_neg \u03b1] {s : set \u03b1}\n\t(hs : s.finite) :\n\t(-s).finite :=", "nl_statement_of_codex": "Let $s$ be a finite set. Then $-s$ is finite."}
{"name": "pgame.move_left_lf_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.move_left_lf_of_le {x y : pgame} (h : x \u2264 y) (i : x.left_moves) :\n\t(x.move_left i).lf y :=", "nl_statement_of_codex": "Let $x$ and $y$ be two impartial games. If $x\\leq y$, then the left move of $x$ is less than or equal to $y$."}
{"name": "ennreal.coe_indicator", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.coe_indicator {\u03b1 : Type*} (s : set \u03b1) (f : \u03b1 \u2192 nnreal) (a : \u03b1) :\n\t\u2191(s.indicator f a) = s.indicator (\u03bb (x : \u03b1), \u2191(f x)) a :=", "nl_statement_of_codex": "Let $s$ be a set and let $f:s\\to \\mathbb{R}_{\\geq 0}$ be a function. Then the indicator function of $s$ with respect to $f$ is equal to the indicator function of $s$ with respect to the function $x\\mapsto \\lvert f(x)\\rvert$."}
{"name": "measure_theory.is_stopping_time.measurable_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/stopping.lean", "formal_statement": "theorem measure_theory.is_stopping_time.measurable_set {\u03b1 \u03b9 : Type*}\n\t{m : measurable_space \u03b1} [preorder \u03b9] {f : measure_theory.filtration \u03b9 m}\n\t{\u03c4 : \u03b1 \u2192 \u03b9} (h\u03c4 : measure_theory.is_stopping_time f \u03c4) (s : set \u03b1) :\n\tmeasurable_set s \u2194 \u2200 (i : \u03b9), measurable_set (s \u2229 {x : \u03b1 | \u03c4 x \u2264 i}) :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\tau:X\\to\\mathbb{N}$ be a stopping time. Then $S\\subset X$ is measurable if and only if $S\\cap\\{x\\in X:\\tau(x)\\leq i\\}$ is measurable for all $i\\in\\mathbb{N}$."}
{"name": "forall_true_iff'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem forall_true_iff' {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop}\n\t(h : \u2200 (a : \u03b1), p a \u2194 true) :\n\t(\u2200 (a : \u03b1), p a) \u2194 true :=", "nl_statement_of_codex": "For any proposition $p$ on a set $A$, $\\forall a\\in A, p(a)$ is true if and only if $p(a)$ is true for all $a\\in A$."}
{"name": "continuous_linear_map.coe_subtype_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/module/basic.lean", "formal_statement": "theorem continuous_linear_map.coe_subtype_val {R\u2081 : Type*} [semiring R\u2081]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] [module R\u2081 M\u2081]\n\t(p : submodule R\u2081 M\u2081) :\n\t\u2191(continuous_linear_map.subtype_val p) = p.subtype :=", "nl_statement_of_codex": "The subspace topology on a submodule $p$ of a topological module $M$ is the same as the subspace topology on the subtype $p.subtype$."}
{"name": "add_subgroup.fg_iff_add_submonoid.fg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/finiteness.lean", "formal_statement": "theorem add_subgroup.fg_iff_add_submonoid.fg {G : Type*} [add_group G]\n\t(P : add_subgroup G) :\n\tP.fg \u2194 P.to_add_submonoid.fg :=", "nl_statement_of_codex": "A subgroup $P$ of an abelian group $G$ is finitely generated if and only if the additive submonoid $P$ is finitely generated."}
{"name": "cont_mdiff_within_at_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem cont_mdiff_within_at_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*}\n\t[topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {s : set M} {x : M} {n : with_top \u2115} { : M'} :\n\tcont_mdiff_within_at I I' n (\u03bb (x : M), c) s x :=", "nl_statement_of_codex": "Let $E, E'$ be normed spaces over $\\mathbb{K}$, $H, H'$ be topological spaces, $M, M'$ be manifolds over $H, H'$, $I, I'$ be models with corners, $s$ be a subset of $M$, $x$ be a point in $M$, $n$ be a natural number, and $c$ be a point in $M'$. Then the function $f:M\\to M'$ defined by $f(x)=c$ is continuously differentiable at $x$."}
{"name": "Action.right_dual_\u03c1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/representation_theory/Action.lean", "formal_statement": "theorem Action.right_dual_\u03c1 {V : Type (u+1)} [category_theory.large_category V]\n\t[category_theory.monoidal_category V] {H : Group} (X : Action V \u2191H)\n\t[category_theory.right_rigid_category V] (h : \u21a5H) :\n\t\u21d1(X\u1601.\u03c1) h = (\u21d1(X.\u03c1) h\u207b\u00b9)\u1601 :=", "nl_statement_of_codex": "Let $V$ be a right rigid category and let $X$ be an action of $H$ on $V$. Then the right dual of the right action of $H$ on $X$ is the left action of $H$ on the right dual of $X$."}
{"name": "set.ne_insert_of_not_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.ne_insert_of_not_mem {\u03b1 : Type u} {s : set \u03b1} (t : set \u03b1) {a : \u03b1} :\n\ta \u2209 s \u2192 s \u2260 has_insert.insert a t :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets and let $a$ be an element. If $a$ is not in $s$, then $s$ is not equal to $s\\cup\\{a\\}$."}
{"name": "filter.mem_Sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.mem_Sup {\u03b1 : Type u} {x : set \u03b1} {s : set (filter \u03b1)} :\n\tx \u2208 has_Sup.Sup s \u2194 \u2200 (f : filter \u03b1), f \u2208 s \u2192 x \u2208 f :=", "nl_statement_of_codex": "Let $x$ be a subset of a set $X$ and let $S$ be a set of filters on $X$. Then $x$ is in the supremum of $S$ if and only if $x$ is in every filter in $S$."}
{"name": "subring.mem_comap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/basic.lean", "formal_statement": "theorem subring.mem_comap {R : Type u} {S : Type v} [ring R] [ring S]\n\t{s : subring S} {f : R \u2192+* S} {x : R} :\n\tx \u2208 subring.comap f s \u2194 \u21d1f x \u2208 s :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f:R\\to S$ be a ring homomorphism. Let $s$ be a subring of $S$. Then $x\\in f^{-1}(s)$ if and only if $f(x)\\in s$."}
{"name": "finset.image_bUnion_filter_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.image_bUnion_filter_eq {\u03b1 \u03b2 : Type*} [decidable_eq \u03b2]\n\t[decidable_eq \u03b1] (s : finset \u03b2) (g : \u03b2 \u2192 \u03b1) :\n\t(finset.image g s).bUnion (\u03bb (a : \u03b1), finset.filter (\u03bb (c : \u03b2), g c = a) s) = s :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $g:s\\to \\alpha$ be a function. Then the union of the images of $g$ and the fibers of $g$ is $s$."}
{"name": "real.rpow_sub_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem real.rpow_sub_one {x : \u211d} (hx : x \u2260 0) (y : \u211d) :\n\tx ^ (y - 1) = x ^ y / x :=", "nl_statement_of_codex": "For $x\\in\\mathbb{R}$ and $y\\in\\mathbb{R}$, if $x\\neq 0$, then $x^{y-1}=x^y/x$."}
{"name": "category_theory.abelian.functor.preserves_exact_of_preserves_finite_limits_of_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/right_derived.lean", "formal_statement": "theorem category_theory.abelian.functor.preserves_exact_of_preserves_finite_limits_of_mono\n\t{C : Type u} [category_theory.category C] {D : Type u}\n\t[category_theory.category D] (F : C \u2964 D) {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n\t[category_theory.abelian C] [category_theory.abelian D] [F.additive]\n\t[category_theory.limits.preserves_finite_limits F] [category_theory.mono f]\n\t(ex : category_theory.exact f g) :\n\tcategory_theory.exact (F.map f) (F.map g) :=", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor between abelian categories. If $F$ preserves finite limits and $f:X\\to Y$ is a monomorphism, then $F(f):F(X)\\to F(Y)$ is a monomorphism."}
{"name": "nat.pow_le_choose", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/choose/bounds.lean", "formal_statement": "theorem nat.pow_le_choose {\u03b1 : Type*} [linear_ordered_field \u03b1] (r n : \u2115) :\n\t\u2191(n + 1 - r) ^ r / \u2191(r.factorial) \u2264 \u2191(n.choose r) :=", "nl_statement_of_codex": "For all $n,r\\in\\mathbb{N}$, we have $(n+1-r)^r/r!\\leq n\\choose r$."}
{"name": "ordinal.to_pgame_add_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/ordinal.lean", "formal_statement": "theorem ordinal.to_pgame_add_mk (a b : ordinal) :\n\t\u27e6a.to_pgame\u27e7 + \u27e6b.to_pgame\u27e7 = \u27e6(a.nadd b).to_pgame\u27e7 :=", "nl_statement_of_codex": "The ordinal sum of two ordinals is equal to the ordinal sum of the corresponding ordinal games."}
{"name": "differentiable.mdifferentiable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/mfderiv.lean", "formal_statement": "theorem differentiable.mdifferentiable {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {f : E \u2192 E'} :\n\tdifferentiable \ud835\udd5c f \u2192 mdifferentiable (model_with_corners_self \ud835\udd5c E) (model_with_corners_self \ud835\udd5c E') f :=", "nl_statement_of_codex": "Let $E$ and $E'$ be normed spaces over a nondiscrete normed field $K$. If $f:E\\to E'$ is differentiable, then $f$ is mdifferentiable."}
{"name": "ordnode.valid'.balance", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.valid'.balance {\u03b1 : Type*} [preorder \u03b1] {l : ordnode \u03b1} {x : \u03b1}\n\t{r : ordnode \u03b1} {o\u2081 : with_bot \u03b1} {o\u2082 : with_top \u03b1}\n\t(hl : ordnode.valid' o\u2081 l \u2191x) (hr : ordnode.valid' \u2191x r o\u2082)\n\t(H : \u2203 (l' r' : \u2115), ordnode.balanced_sz l' r' \u2227 (l.size.dist l' \u2264 1 \u2227 r.size = r' \u2228 r.size.dist r' \u2264 1 \u2227 l.size = l')) :\n\tordnode.valid' o\u2081 (l.balance x r) o\u2082 :=", "nl_statement_of_codex": "Let $l, r$ be valid ordered nodes with $l\\leq x\\leq r$. If $l$ and $r$ are almost balanced, then $l.balance(x,r)$ is valid."}
{"name": "embedding_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem embedding_inr {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] :\n\tembedding sum.inr :=", "nl_statement_of_codex": "The map $x\\mapsto (0,x)$ is an embedding."}
{"name": "equiv.swap_apply_ne_self_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/basic.lean", "formal_statement": "theorem equiv.swap_apply_ne_self_iff {\u03b1 : Sort u} [decidable_eq \u03b1] {a b x : \u03b1} :\n\t\u21d1(equiv.swap a b) x \u2260 x \u2194 a \u2260 b \u2227 (x = a \u2228 x = b) :=", "nl_statement_of_codex": "Let $a,b,x$ be elements of a set $X$. Then $x$ is not fixed by the permutation $(a\\ b)$ if and only if $a\\neq b$ and $x=a$ or $x=b$."}
{"name": "lipschitz_on_with.edist_lt_of_edist_lt_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/lipschitz.lean", "formal_statement": "theorem lipschitz_on_with.edist_lt_of_edist_lt_div {\u03b1 : Type u} {\u03b2 : Type v}\n\t[pseudo_emetric_space \u03b1] [pseudo_emetric_space \u03b2] {K : nnreal} {s : set \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} (hf : lipschitz_on_with K f s) {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s)\n\t{d : ennreal} (hd : has_edist.edist x y < d / \u2191K) :\n\thas_edist.edist (f x) (f y) < d :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a Lipschitz function with constant $K$. Let $x,y\\in X$ and let $d>0$. If $d(x,y)<d/K$, then $d(f(x),f(y))<d$."}
{"name": "alist.mem_union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/alist.lean", "formal_statement": "theorem alist.mem_union {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {a : \u03b1}\n\t{s\u2081 s\u2082 : alist \u03b2} :\n\ta \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 \u2228 a \u2208 s\u2082 :=", "nl_statement_of_codex": "Let $s_1$ and $s_2$ be lists of type $\\alpha$. Then $a\\in s_1\\cup s_2$ if and only if $a\\in s_1$ or $a\\in s_2$."}
{"name": "fin.reverse_induction_cast_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.reverse_induction_cast_succ {n : \u2115} {C : fin (n + 1) \u2192 Sort u_1}\n\t(h0 : C (fin.last n)) (hs : \u03a0 (i : fin n), C i.succ \u2192 C (\u21d1fin.cast_succ i))\n\t(i : fin n) :\n\tfin.reverse_induction h0 hs (\u21d1fin.cast_succ i) = hs i (fin.reverse_induction h0 hs i.succ) :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $C$ be a function from $\\mathrm{Fin}(n+1)$ to a type. Suppose that $C$ satisfies the following two conditions:\n\\begin{enumerate}\n\\item $C(n)$\n\\item For each $i\\in\\mathrm{Fin}(n)$, $C(i+1)$ implies $C(i)$.\n\\end{enumerate}\nThen $C(i)$ holds for each $i\\in\\mathrm{Fin}(n)$."}
{"name": "punit.zero_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/punit_instances.lean", "formal_statement": "theorem punit.zero_eq :\n\t0 = punit.star :=", "nl_statement_of_codex": "The zero element of the unitary ring $\\mathbb{Z}[i]$ is $0$."}
{"name": "continuous_generated_from", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order.lean", "formal_statement": "theorem continuous_generated_from {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}\n\t{t : topological_space \u03b1} {b : set (set \u03b2)}\n\t(h : \u2200 (s : set \u03b2), s \u2208 b \u2192 is_open (f \u207b\u00b9' s)) :\n\tcontinuous f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f$ is continuous at each point of $X$, then $f$ is continuous."}
{"name": "graded_ring.proj_zero_ring_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/graded_algebra/basic.lean", "formal_statement": "theorem graded_ring.proj_zero_ring_hom_apply {\u03b9 A \u03c3 : Type*} [semiring A]\n\t[decidable_eq \u03b9] [canonically_ordered_add_monoid \u03b9] [set_like \u03c3 A]\n\t[add_submonoid_class \u03c3 A] (\ud835\udc9c : \u03b9 \u2192 \u03c3) [graded_ring \ud835\udc9c] (a : A) :\n\t\u21d1(graded_ring.proj_zero_ring_hom \ud835\udc9c) a = \u2191(\u21d1(\u21d1(direct_sum.decompose \ud835\udc9c) a) 0) :=", "nl_statement_of_codex": "Let $A$ be a graded ring. Then the projection of $A$ onto the degree zero component is the same as the projection of the direct sum decomposition of $A$ onto the degree zero component."}
{"name": "continuous_map.homotopy.curry_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homotopy/basic.lean", "formal_statement": "theorem continuous_map.homotopy.curry_apply {X : Type u} {Y : Type v}\n\t[topological_space X] [topological_space Y] {f\u2080 f\u2081 : C(X, Y)}\n\t(F : f\u2080.homotopy f\u2081) (t : \u21a5unit_interval) (x : X) :\n\t\u21d1(\u21d1(F.curry) t) x = \u21d1F (t, x) :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $f_0, f_1:X\\to Y$ be continuous maps. Let $F:X\\times I\\to Y$ be a homotopy between $f_0$ and $f_1$. Then for each $t\\in I$ the map $F_t:X\\to Y$ defined by $F_t(x)=F(t,x)$ is continuous."}
{"name": "units_equiv_prod_subtype_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem units_equiv_prod_subtype_apply_coe (\u03b1 : Type*) [monoid \u03b1] (u : \u03b1\u02e3) :\n\t\u2191(\u21d1(units_equiv_prod_subtype \u03b1) u) = (\u2191u, \u2191u\u207b\u00b9) :=", "nl_statement_of_codex": "Let $\u03b1$ be a monoid. Then the map $u\\mapsto (u,u^{-1})$ is an isomorphism from the group of units of $\u03b1$ to the product $\u03b1\\times \u03b1$."}
{"name": "eq.subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem eq.subset {\u03b1 : Type*} {s t : set \u03b1} :\n\ts = t \u2192 s \u2286 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets. If $s=t$, then $s\\subset t$."}
{"name": "complex.is_trivial_topological_fiber_bundle_re", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/re_im_topology.lean", "formal_statement": "theorem complex.is_trivial_topological_fiber_bundle_re :\n\tis_trivial_topological_fiber_bundle \u211d complex.re :=", "nl_statement_of_codex": "The real part function $re: \\mathbb{C}\\to \\mathbb{R}$ is a trivial topological fiber bundle."}
{"name": "multilinear_map.restr_norm_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/multilinear.lean", "formal_statement": "theorem multilinear_map.restr_norm_le {\ud835\udd5c : Type u} {G : Type wG} {G' : Type wG'}\n\t[nondiscrete_normed_field \ud835\udd5c] [normed_group G] [normed_space \ud835\udd5c G]\n\t[normed_group G'] [normed_space \ud835\udd5c G'] {k n : \u2115}\n\t(f : multilinear_map \ud835\udd5c (\u03bb (i : fin n), G) G') (s : finset (fin n))\n\t(hk : s.card = k) (z : G) {C : \u211d}\n\t(H : \u2200 (m : fin n \u2192 G), \u2225\u21d1f m\u2225 \u2264 C * finset.univ.prod (\u03bb (i : fin n), \u2225m i\u2225))\n\t(v : fin k \u2192 G) :\n\t\u2225\u21d1(f.restr s hk z) v\u2225 \u2264 C * \u2225z\u2225 ^ (n - k) * finset.univ.prod (\u03bb (i : fin k), \u2225v i\u2225) :=", "nl_statement_of_codex": "Let $f:G^n\\to G'$ be a multilinear map. Let $s$ be a subset of $\\{1,\\ldots,n\\}$ with $k$ elements. Then for all $z\\in G$ and $v\\in G^k$ we have $\\|f(z,v)\\|\\leq C\\|z\\|^{n-k}\\|v\\|$."}
{"name": "is_closed_ge'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem is_closed_ge' {\u03b1 : Type u} [topological_space \u03b1] [preorder \u03b1]\n\t[t : order_closed_topology \u03b1] (a : \u03b1) :\n\tis_closed {b : \u03b1 | a \u2264 b} :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $a\\in X$. Then the set $\\{x\\in X: a\\leq x\\}$ is closed."}
{"name": "finset.smul_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/big_operators.lean", "formal_statement": "theorem finset.smul_sum {\u03b1 \u03b2 \u03b3 : Type*} [monoid \u03b1] [add_comm_monoid \u03b2]\n\t[distrib_mul_action \u03b1 \u03b2] {r : \u03b1} {f : \u03b3 \u2192 \u03b2} {s : finset \u03b3} :\n\tr \u2022 s.sum (\u03bb (x : \u03b3), f x) = s.sum (\u03bb (x : \u03b3), r \u2022 f x) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $A$ be an $R$-module, and let $S$ be a finite set. Then for any $r\\in R$ and any function $f:S\\to A$, we have $r\\cdot\\sum_{s\\in S}f(s)=\\sum_{s\\in S}r\\cdot f(s)$."}
{"name": "path.homotopy.symm_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homotopy/path.lean", "formal_statement": "theorem path.homotopy.symm_symm {X : Type u} [topological_space X] {x\u2080 x\u2081 : X}\n\t{p\u2080 p\u2081 : path x\u2080 x\u2081} (F : p\u2080.homotopy p\u2081) :\n\tF.symm.symm = F :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $x_0, x_1\\in X$. Let $p_0, p_1:I\\to X$ be paths from $x_0$ to $x_1$. If $p_0$ is homotopic to $p_1$, then $p_1$ is homotopic to $p_0$."}
{"name": "option.not_is_some_iff_eq_none", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/option/basic.lean", "formal_statement": "theorem option.not_is_some_iff_eq_none {\u03b1 : Type*} {o : option \u03b1} :\n\t\u00ac\u21a5(o.is_some) \u2194 o = option.none :=", "nl_statement_of_codex": "An option $o$ is not some if and only if $o$ is none."}
{"name": "inv_mul_lt_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem inv_mul_lt_one_iff {\u03b1 : Type u} [group \u03b1] [has_lt \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt] {a b : \u03b1} :\n\ta\u207b\u00b9 * b < 1 \u2194 b < a :=", "nl_statement_of_codex": "Let $G$ be a group and let $a, b\\in G$. Then $a^{-1}b<1$ if and only if $b<a$."}
{"name": "ne_top_of_le_ne_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem ne_top_of_le_ne_top {\u03b1 : Type u} [partial_order \u03b1] [order_top \u03b1]\n\t{a b : \u03b1} (hb : b \u2260 \u22a4) (hab : a \u2264 b) :\n\ta \u2260 \u22a4 :=", "nl_statement_of_codex": "Let $a, b$ be elements of a partially ordered set with top element. If $b$ is not the top element and $a\\leq b$, then $a$ is not the top element."}
{"name": "filter.frequently_imp_distrib_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.frequently_imp_distrib_right {\u03b1 : Type u} {f : filter \u03b1}\n\t[f.ne_bot] {p : \u03b1 \u2192 Prop} {q : Prop} :\n\t(\u2203\u1da0 (x : \u03b1) in f, p x \u2192 q) \u2194 (\u2200\u1da0 (x : \u03b1) in f, p x) \u2192 q :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$. Then $f$ frequently satisfies $p$ implies $q$ if and only if $f$ frequently satisfies $p$ and $q$."}
{"name": "SemiNormedGroup.explicit_cokernel_desc_comp_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/SemiNormedGroup/kernels.lean", "formal_statement": "theorem SemiNormedGroup.explicit_cokernel_desc_comp_eq_zero\n\t{X Y Z W : SemiNormedGroup} {f : X \u27f6 Y} {g : Y \u27f6 Z} {h : Z \u27f6 W}\n\t(cond : f \u226b g = 0) (cond2 : g \u226b h = 0) :\n\tSemiNormedGroup.explicit_cokernel_desc cond \u226b h = 0 :=", "nl_statement_of_codex": "Let $X, Y, Z, W$ be seminormed groups and let $f:X\\to Y$, $g:Y\\to Z$, $h:Z\\to W$ be morphisms. If $f\\circ g=0$ and $g\\circ h=0$, then $(\\mathrm{coker}(f))\\circ h=0$."}
{"name": "add_hom.coe_prod_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/prod.lean", "formal_statement": "theorem add_hom.coe_prod_map {M N M' N' : Type*} [has_add M] [has_add N]\n\t[has_add M'] [has_add N'] (f : add_hom M M') (g : add_hom N N') :\n\t\u21d1(f.prod_map g) = prod.map \u21d1f \u21d1g :=", "nl_statement_of_codex": "Let $M, N, M', N'$ be sets with addition. Let $f:M\\to M'$ and $g:N\\to N'$ be additive maps. Then the map $f\\times g:M\\times N\\to M'\\times N'$ is additive."}
{"name": "polynomial.subsingleton_of_monic_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.subsingleton_of_monic_zero {R : Type u} [semiring R]\n\t(h : 0.monic) :\n\t(\u2200 (p q : polynomial R), p = q) \u2227 \u2200 (a b : R), a = b :=", "nl_statement_of_codex": "Let $R$ be a semiring. If $0$ is monic, then the polynomial ring $R[x]$ is a singleton."}
{"name": "has_fderiv_at.has_fderiv_within_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem has_fderiv_at.has_fderiv_within_at {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F}\n\t{x : E} {s : set E} (h : has_fderiv_at f f' x) :\n\thas_fderiv_within_at f f' s x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ and $f':E\\to F$ be linear maps. If $f$ is differentiable at $x\\in E$, then $f$ is differentiable at $x$ on $E$."}
{"name": "local_equiv.disjoint_union_target", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/local_equiv.lean", "formal_statement": "theorem local_equiv.disjoint_union_target {\u03b1 \u03b2 : Type*} (e e' : local_equiv \u03b1 \u03b2)\n\t(hs : disjoint e.source e'.source) (ht : disjoint e.target e'.target)\n\t[\u03a0 (x : \u03b1), decidable (x \u2208 e.source)] [\u03a0 (y : \u03b2), decidable (y \u2208 e.target)] :\n\t(e.disjoint_union e' hs ht).target = e.target \u222a e'.target :=", "nl_statement_of_codex": "Let $e$ and $e'$ be local equivalences between $\u03b1$ and $\u03b2$. If $e$ and $e'$ have disjoint source and disjoint target, then the target of $e\\cup e'$ is the union of the targets of $e$ and $e'$."}
{"name": "pgame.lf_iff_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/surreal/basic.lean", "formal_statement": "theorem pgame.lf_iff_lt {x y : pgame} (ox : x.numeric) (oy : y.numeric) :\n\tx.lf y \u2194 x < y :=", "nl_statement_of_codex": "Let $x$ and $y$ be two games. Then $x$ is less than or equal to $y$ if and only if $x$ is less than $y$."}
{"name": "ADE_inequality.admissible_A'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/ADE_inequality.lean", "formal_statement": "theorem ADE_inequality.admissible_A' (q r : \u2115+) :\n\tADE_inequality.admissible (ADE_inequality.A' q r) :=", "nl_statement_of_codex": "The function $A'(q,r)$ is admissible."}
{"name": "mv_polynomial.map_comp_C", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/monad.lean", "formal_statement": "theorem mv_polynomial.map_comp_C {\u03c3 R S : Type*} [comm_semiring R]\n\t[comm_semiring S] (f : R \u2192+* S) :\n\t(mv_polynomial.map f).comp mv_polynomial.C = mv_polynomial.C.comp f :=", "nl_statement_of_codex": "Let $f:R\\to S$ be a ring homomorphism. Then $f$ commutes with the constant polynomial map."}
{"name": "category_theory.monoidal_nat_trans.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/natural_transformation.lean", "formal_statement": "theorem category_theory.monoidal_nat_trans.ext {C : Type u\u2081}\n\t{_inst_1 : category_theory.category C}\n\t{_inst_2 : category_theory.monoidal_category C} {D : Type u\u2082}\n\t{_inst_3 : category_theory.category D}\n\t{_inst_4 : category_theory.monoidal_category D}\n\t{F G : category_theory.lax_monoidal_functor C D}\n\t(x y : category_theory.monoidal_nat_trans F G)\n\t(h : x.to_nat_trans = y.to_nat_trans) :\n\tx = y :=", "nl_statement_of_codex": "Let $C$ and $D$ be monoidal categories and let $F,G:C\\to D$ be lax monoidal functors. If $x,y:F\\Rightarrow G$ are monoidal natural transformations such that $x=y$ as natural transformations, then $x=y$ as monoidal natural transformations."}
{"name": "neg_add_lt_iff_lt_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem neg_add_lt_iff_lt_add {\u03b1 : Type u} [add_group \u03b1] [has_lt \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_lt.lt] {a b c : \u03b1} :\n\t-b + a < c \u2194 a < b + c :=", "nl_statement_of_codex": "Let $a, b, c$ be elements of an additive group $G$ with a total order. Then $-b+a<c$ if and only if $a<b+c$."}
{"name": "monoid.exponent_min", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/exponent.lean", "formal_statement": "theorem monoid.exponent_min {G : Type u} [monoid G] (m : \u2115) (hpos : 0 < m)\n\t(hm : m < monoid.exponent G) :\n\t\u2203 (g : G), g ^ m \u2260 1 :=", "nl_statement_of_codex": "Let $G$ be a monoid. If $m$ is a positive integer less than the exponent of $G$, then there is an element $g\\in G$ such that $g^m\\neq 1$."}
{"name": "is_open_map_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem is_open_map_inv (G : Type w) [topological_space G]\n\t[has_involutive_inv G] [has_continuous_inv G] :\n\tis_open_map has_inv.inv :=", "nl_statement_of_codex": "The inverse map is an open map."}
{"name": "subgroup.le_pointwise_smul_iff\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/pointwise.lean", "formal_statement": "theorem subgroup.le_pointwise_smul_iff\u2080 {\u03b1 G : Type*} [group G]\n\t[group_with_zero \u03b1] [mul_distrib_mul_action \u03b1 G] {a : \u03b1} (ha : a \u2260 0)\n\t{S T : subgroup G} :\n\tS \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T :=", "nl_statement_of_codex": "Let $G$ be a group and let $S,T$ be subgroups of $G$. Let $a$ be an element of the group $\\mathbb{Z}$ of integers. Then $S\\leq aT$ if and only if $a^{-1}S\\leq T$."}
{"name": "nat.add_zero", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/basic.lean", "formal_statement": "theorem nat.add_zero (n : \u2115) :\n\tn + 0 = n :=", "nl_statement_of_codex": "For all natural numbers $n$, $n+0=n$."}
{"name": "equiv.set.sum_diff_subset_apply_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/set.lean", "formal_statement": "theorem equiv.set.sum_diff_subset_apply_inr {\u03b1 : Type*} {s t : set \u03b1}\n\t(h : s \u2286 t) [decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)] (x : \u21a5(t \\ s)) :\n\t\u21d1(equiv.set.sum_diff_subset h) (sum.inr x) = set.inclusion _ x :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets and let $h:s\\subset t$. Then the map $f:t\\setminus s\\to t$ defined by $f(x)=x$ is a bijection."}
{"name": "differentiable_on.fst", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem differentiable_on.fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {G : Type*} [normed_group G] [normed_space \ud835\udd5c G] {s : set E}\n\t{f\u2082 : E \u2192 F \u00d7 G} (h : differentiable_on \ud835\udd5c f\u2082 s) :\n\tdifferentiable_on \ud835\udd5c (\u03bb (x : E), (f\u2082 x).fst) s :=", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F\\times G$ be differentiable on $E$. Then the projection $f_1:E\\to F$ is differentiable on $E$."}
{"name": "dfinsupp.map_range_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.map_range_single {\u03b9 : Type u} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081}\n\t{\u03b2\u2082 : \u03b9 \u2192 Type v\u2082} [dec : decidable_eq \u03b9] [\u03a0 (i : \u03b9), has_zero (\u03b2\u2081 i)]\n\t[\u03a0 (i : \u03b9), has_zero (\u03b2\u2082 i)] {f : \u03a0 (i : \u03b9), \u03b2\u2081 i \u2192 \u03b2\u2082 i}\n\t{hf : \u2200 (i : \u03b9), f i 0 = 0} {i : \u03b9} {b : \u03b2\u2081 i} :\n\tdfinsupp.map_range f hf (dfinsupp.single i b) = dfinsupp.single i (f i b) :=", "nl_statement_of_codex": "Let $f: \\beta_1\\to \\beta_2$ be a function. Then $f$ maps the singleton $\\{(i,b)\\}$ to the singleton $\\{(i,f(b))\\}$."}
{"name": "ring_hom.coe_add_monoid_hom_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/ring.lean", "formal_statement": "theorem ring_hom.coe_add_monoid_hom_injective {\u03b1 \u03b2 : Type*}\n\t{r\u03b1 : non_assoc_semiring \u03b1} {r\u03b2 : non_assoc_semiring \u03b2} :\n\tfunction.injective coe :=", "nl_statement_of_codex": "The map from ring homomorphisms to additive monoid homomorphisms is injective."}
{"name": "category_theory.presheaf_to_Sheaf_map_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sheafification.lean", "formal_statement": "theorem category_theory.presheaf_to_Sheaf_map_val {C : Type u}\n\t[category_theory.category C] (J : category_theory.grothendieck_topology C)\n\t(D : Type w) [category_theory.category D] [category_theory.concrete_category D]\n\t[category_theory.limits.preserves_limits (category_theory.forget D)]\n\t[\u2200 (P : C\u1d52\u1d56 \u2964 D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)]\n\t[\u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 D]\n\t[\u03a0 (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)\u1d52\u1d56 (category_theory.forget D)]\n\t[category_theory.reflects_isomorphisms (category_theory.forget D)]\n\t(P Q : C\u1d52\u1d56 \u2964 D) (\u03b7 : P \u27f6 Q) :\n\t((category_theory.presheaf_to_Sheaf J D).map \u03b7).val = J.sheafify_map \u03b7 :=", "nl_statement_of_codex": "Let $C$ be a category and $J$ a Grothendieck topology on $C$. Let $D$ be a category with finite limits and colimits of shape $J$-coverings. Then the functor $P\\mapsto J$-sheafification of $P$ is a left adjoint to the forgetful functor from $J$-sheaves to presheaves."}
{"name": "box_integral.prepartition.subset_Union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/basic.lean", "formal_statement": "theorem box_integral.prepartition.subset_Union {\u03b9 : Type*}\n\t{I J : box_integral.box \u03b9} (\u03c0 : box_integral.prepartition I) (h : J \u2208 \u03c0) :\n\t\u2191J \u2286 \u03c0.Union :=", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $\\pi$ be a prepartition of $I$. Then the union of the elements of $\\pi$ is a subset of $I$."}
{"name": "absorbent_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/seminorm.lean", "formal_statement": "theorem absorbent_ball {\ud835\udd5c E : Type*} [normed_field \ud835\udd5c] [semi_normed_group E]\n\t[normed_space \ud835\udd5c E] {r : \u211d} {x : E} (hx : \u2225x\u2225 < r) :\n\tabsorbent \ud835\udd5c (metric.ball x r) :=", "nl_statement_of_codex": "Let $E$ be a normed space over a normed field $K$. Then the ball $B(x,r)$ is absorbent in $K$."}
{"name": "is_R_or_C.conj_ae_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/is_R_or_C.lean", "formal_statement": "theorem is_R_or_C.conj_ae_coe {K : Type*} [is_R_or_C K] :\n\t\u21d1is_R_or_C.conj_ae = \u21d1(star_ring_end K) :=", "nl_statement_of_codex": "The conjugation map on a real or complex field is equal to the conjugation map on the corresponding star ring."}
{"name": "nat.card_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/finite.lean", "formal_statement": "theorem nat.card_prod (\u03b1 \u03b2 : Type*) :\n\tnat.card (\u03b1 \u00d7 \u03b2) = nat.card \u03b1 * nat.card \u03b2 :=", "nl_statement_of_codex": "The cardinality of the product of two sets is the product of their cardinalities."}
{"name": "polynomial.derivative_C", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/derivative.lean", "formal_statement": "theorem polynomial.derivative_C {R : Type u} [semiring R] {a : R} :\n\t\u21d1polynomial.derivative (\u21d1polynomial.C a) = 0 :=", "nl_statement_of_codex": "The derivative of the constant polynomial $a$ is $0$."}
{"name": "continuous_map.coe_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/algebra.lean", "formal_statement": "theorem continuous_map.coe_mul {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [has_mul \u03b2] [has_continuous_mul \u03b2] (f g : C(\u03b1, \u03b2)) :\n\t\u21d1(f * g) = \u21d1f * \u21d1g :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be continuous maps. Then the map $f\\cdot g:X\\to Y$ is continuous."}
{"name": "ordnode.size_balance_l", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.size_balance_l {\u03b1 : Type*} {l : ordnode \u03b1} {x : \u03b1}\n\t{r : ordnode \u03b1} (hl : l.balanced) (hr : r.balanced) (sl : l.sized)\n\t(sr : r.sized)\n\t(H : (\u2203 (l' : \u2115), ordnode.raised l' l.size \u2227 ordnode.balanced_sz l' r.size) \u2228 \u2203 (r' : \u2115), ordnode.raised r.size r' \u2227 ordnode.balanced_sz l.size r') :\n\t(l.balance_l x r).size = l.size + r.size + 1 :=", "nl_statement_of_codex": "Let $l, r$ be balanced nodes with sizes $l.size, r.size$. Then the size of the node $l.balance_l x r$ is $l.size+r.size+1$."}
{"name": "le_add_iff_nonneg_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem le_add_iff_nonneg_right {\u03b1 : Type*} [add_zero_class \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[contravariant_class \u03b1 \u03b1 has_add.add has_le.le] (a : \u03b1) {b : \u03b1} :\n\ta \u2264 a + b \u2194 0 \u2264 b :=", "nl_statement_of_codex": "Let $a, b$ be elements of an additive monoid with zero. Then $a\\leq a+b$ if and only if $0\\leq b$."}
{"name": "real.cosh_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/exponential.lean", "formal_statement": "theorem real.cosh_pos (x : \u211d) :\n\t0 < real.cosh x :=", "nl_statement_of_codex": "The hyperbolic cosine function is positive."}
{"name": "sym.repeat_left_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sym/basic.lean", "formal_statement": "theorem sym.repeat_left_inj {\u03b1 : Type*} {a b : \u03b1} {n : \u2115} (h : n \u2260 0) :\n\tsym.repeat a n = sym.repeat b n \u2194 a = b :=", "nl_statement_of_codex": "Let $a, b$ be elements of a set $X$ and let $n$ be a positive integer. Then $a^n=b^n$ if and only if $a=b$."}
{"name": "matrix.circulant_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/circulant.lean", "formal_statement": "theorem matrix.circulant_add {\u03b1 n : Type*} [has_add \u03b1] [has_sub n] (v w : n \u2192 \u03b1) :\n\tmatrix.circulant (v + w) = matrix.circulant v + matrix.circulant w :=", "nl_statement_of_codex": "The circulant matrix of the sum of two vectors is the sum of the circulant matrices of the two vectors."}
{"name": "generalized_continued_fraction.first_numerator_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/continued_fractions/translations.lean", "formal_statement": "theorem generalized_continued_fraction.first_numerator_eq {K : Type*}\n\t{g : generalized_continued_fraction K} [division_ring K]\n\t{gp : generalized_continued_fraction.pair K}\n\t(zeroth_s_eq : g.s.nth 0 = option.some gp) :\n\tg.numerators 1 = gp.b * g.h + gp.a :=", "nl_statement_of_codex": "Let $g$ be a generalized continued fraction. Then the first numerator of $g$ is equal to $b_0h_0+a_0$."}
{"name": "polynomial.root_set_finite", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/ring_division.lean", "formal_statement": "theorem polynomial.root_set_finite {T : Type w} [comm_ring T] (p : polynomial T)\n\t(S : Type*) [comm_ring S] [is_domain S] [algebra T S] :\n\t(p.root_set S).finite :=", "nl_statement_of_codex": "The set of roots of a polynomial $p$ over a domain $S$ is finite."}
{"name": "has_sum_sum_of_ne_finset_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean", "formal_statement": "theorem has_sum_sum_of_ne_finset_zero {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1]\n\t[topological_space \u03b1] {f : \u03b2 \u2192 \u03b1} {s : finset \u03b2}\n\t(hf : \u2200 (b : \u03b2), b \u2209 s \u2192 f b = 0) :\n\thas_sum f (s.sum (\u03bb (b : \u03b2), f b)) :=", "nl_statement_of_codex": "Let $f:B\\to A$ be a function and let $S$ be a finite set. If $f(b)=0$ for all $b\\in B\\setminus S$, then $f$ has sum $\\sum_{b\\in S}f(b)$."}
{"name": "nat.arithmetic_function.card_factors_apply_prime_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/arithmetic_function.lean", "formal_statement": "theorem nat.arithmetic_function.card_factors_apply_prime_pow {p k : \u2115}\n\t(hp : nat.prime p) :\n\t\u21d1nat.arithmetic_function.card_factors (p ^ k) = k :=", "nl_statement_of_codex": "The number of factors of $p^k$ is $k$."}
{"name": "convex.to_cone_eq_Inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/cone.lean", "formal_statement": "theorem convex.to_cone_eq_Inf {\ud835\udd5c E : Type*} [linear_ordered_field \ud835\udd5c]\n\t[ordered_add_comm_group E] [module \ud835\udd5c E] {s : set E} (hs : convex \ud835\udd5c s) :\n\tconvex.to_cone s hs = has_Inf.Inf {t : convex_cone \ud835\udd5c E | s \u2286 \u2191t} :=", "nl_statement_of_codex": "Let $E$ be a vector space over a linear ordered field $K$ and let $s$ be a convex subset of $E$. Then the convex cone generated by $s$ is the intersection of all convex cones containing $s$."}
{"name": "infi_split_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/complete_lattice.lean", "formal_statement": "theorem infi_split_single {\u03b1 \u03b2 : Type*} [complete_lattice \u03b1] (f : \u03b2 \u2192 \u03b1)\n\t(i\u2080 : \u03b2) :\n\t(\u2a05 (i : \u03b2), f i) = f i\u2080 \u2293 \u2a05 (i : \u03b2) (h : i \u2260 i\u2080), f i :=", "nl_statement_of_codex": "Let $f:B\\to A$ be a function. Then $\\inf_{i\\in B}f(i)=f(i_0)\\wedge\\inf_{i\\in B\\setminus\\{i_0\\}}f(i)$."}
{"name": "topological_space.opens.map_comp_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Top/opens.lean", "formal_statement": "theorem topological_space.opens.map_comp_eq {X Y Z : Top} (f : X \u27f6 Y)\n\t(g : Y \u27f6 Z) :\n\ttopological_space.opens.map (f \u226b g) = topological_space.opens.map g \u22d9 topological_space.opens.map f :=", "nl_statement_of_codex": "Let $X, Y, Z$ be topological spaces and let $f:X\\to Y$ and $g:Y\\to Z$ be continuous maps. Then the map $g\\circ f:X\\to Z$ is continuous."}
{"name": "finrank_alg_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/fixed.lean", "formal_statement": "theorem finrank_alg_hom (K : Type u) (V : Type v) [field K] [field V]\n\t[algebra K V] [finite_dimensional K V] :\n\tfintype.card (V \u2192\u2090[K] V) \u2264 finite_dimensional.finrank V (V \u2192\u2097[K] V) :=", "nl_statement_of_codex": "Let $K$ be a field and let $V$ be a finite dimensional $K$-algebra. Then the number of $K$-algebra homomorphisms from $V$ to $V$ is less than or equal to the dimension of $V$ as a $K$-vector space."}
{"name": "lie_equiv.coe_linear_equiv_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/basic.lean", "formal_statement": "theorem lie_equiv.coe_linear_equiv_injective {R : Type u} {L\u2081 : Type v}\n\t{L\u2082 : Type w} [comm_ring R] [lie_ring L\u2081] [lie_ring L\u2082] [lie_algebra R L\u2081]\n\t[lie_algebra R L\u2082] :\n\tfunction.injective coe :=", "nl_statement_of_codex": "The map $L\\mapsto L\\otimes_\\mathbb{Z}\\mathbb{R}$ is injective on the set of Lie algebras over $\\mathbb{Z}$."}
{"name": "ideal.mem_radical_of_pow_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.mem_radical_of_pow_mem {R : Type u} [comm_semiring R]\n\t{I : ideal R} {x : R} {m : \u2115} (hx : x ^ m \u2208 I.radical) :\n\tx \u2208 I.radical :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $I$ be an ideal of $R$. If $x^m\\in I^\\sqrt{}$, then $x\\in I^\\sqrt{}$."}
{"name": "omega_complete_partial_order.\u03c9Sup_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/omega_complete_partial_order.lean", "formal_statement": "theorem omega_complete_partial_order.\u03c9Sup_le_iff {\u03b1 : Type u}\n\t[omega_complete_partial_order \u03b1] ( : omega_complete_partial_order.chain \u03b1)\n\t(x : \u03b1) :\n\tomega_complete_partial_order.\u03c9Sup c \u2264 x \u2194 \u2200 (i : \u2115), \u21d1c i \u2264 x :=", "nl_statement_of_codex": "Let $c$ be an omega-chain in an omega-complete partial order. Then $\\omega\\text{-}\\sup c\\leq x$ if and only if $c_i\\leq x$ for all $i\\in\\mathbb{N}$."}
{"name": "hash_map.keys_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/hash_map.lean", "formal_statement": "theorem hash_map.keys_empty {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1]\n\t(hash_fn : \u03b1 \u2192 \u2115) (n : \u2115 := 8) :\n\t(mk_hash_map hash_fn n).keys = list.nil :=", "nl_statement_of_codex": "The keys of an empty hash map are the empty list."}
{"name": "bornology.is_cobounded.all", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bornology/basic.lean", "formal_statement": "theorem bornology.is_cobounded.all {\u03b1 : Type*} [bornology \u03b1] [bounded_space \u03b1]\n\t(s : set \u03b1) :\n\tbornology.is_cobounded s :=", "nl_statement_of_codex": "The whole space is cobounded."}
{"name": "has_deriv_at.continuous_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_at.continuous_at {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c}\n\t(h : has_deriv_at f f' x) :\n\tcontinuous_at f x :=", "nl_statement_of_codex": "Let $f: \\mathbb{R}\\to \\mathbb{R}$ be differentiable at $x$. Then $f$ is continuous at $x$."}
{"name": "category_theory.functor.right_derived_obj_iso_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/right_derived.lean", "formal_statement": "theorem category_theory.functor.right_derived_obj_iso_inv {C : Type u}\n\t[category_theory.category C] {D : Type*} [category_theory.category D]\n\t[category_theory.abelian C] [category_theory.has_injective_resolutions C]\n\t[category_theory.abelian D] (F : C \u2964 D) [F.additive] (n : \u2115) {X : C}\n\t(P : category_theory.InjectiveResolution X) :\n\t(F.right_derived_obj_iso n P).inv = (homotopy_category.homology_functor D (complex_shape.up \u2115) n).map ((homotopy_category.quotient D (complex_shape.up \u2115)).map ((F.map_homological_complex (complex_shape.up \u2115)).map (category_theory.functor.right_derived_obj_iso._proof_14.some.homotopy_equiv P).inv)) :=", "nl_statement_of_codex": "Let $C$ and $D$ be abelian categories and let $F:C\\to D$ be an additive functor. Let $X$ be an object of $C$ and let $P$ be an injective resolution of $X$. Then the inverse of the $n$th right derived object of $F$ at $X$ is the image of the inverse of the $n$th homology of the homotopy equivalence of the image of $P$ under $F$ under the homology functor."}
{"name": "measure_theory.measure.to_ennreal_vector_measure_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/vector_measure.lean", "formal_statement": "theorem measure_theory.measure.to_ennreal_vector_measure_add {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} (\u03bc \u03bd : measure_theory.measure \u03b1) :\n\t(\u03bc + \u03bd).to_ennreal_vector_measure = \u03bc.to_ennreal_vector_measure + \u03bd.to_ennreal_vector_measure :=", "nl_statement_of_codex": "Let $\\mu$ and $\\nu$ be measures on a measurable space $X$. Then the measure $\\mu+\\nu$ is the sum of the measures $\\mu$ and $\\nu$."}
{"name": "neg_abs_le_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem neg_abs_le_self {\u03b1 : Type u} [add_group \u03b1] [linear_order \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] (a : \u03b1) :\n\t-|a| \u2264 a :=", "nl_statement_of_codex": "Let $a$ be an element of an ordered additive group. Then $-|a|\\leq a$."}
{"name": "nnreal.tsum_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem nnreal.tsum_pos {\u03b1 : Type*} {g : \u03b1 \u2192 nnreal} (hg : summable g) (i : \u03b1)\n\t(hi : 0 < g i) :\n\t0 < \u2211' (b : \u03b1), g b :=", "nl_statement_of_codex": "Let $g:\\alpha\\to\\mathbb{R}_{\\geq 0}$ be a summable function. If $g(i)>0$ for some $i\\in\\alpha$, then $\\sum_{b\\in\\alpha}g(b)>0$."}
{"name": "linear_isometry.comp_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem linear_isometry.comp_assoc {R R\u2082 R\u2083 R\u2084 E E\u2082 E\u2083 E\u2084 : Type*} [semiring R]\n\t[semiring R\u2082] [semiring R\u2083] [semiring R\u2084] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}\n\t{\u03c3\u2081\u2084 : R \u2192+* R\u2084} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084} {\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084}\n\t[ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084]\n\t[ring_hom_comp_triple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084] [ring_hom_comp_triple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084]\n\t[semi_normed_group E] [semi_normed_group E\u2082] [semi_normed_group E\u2083]\n\t[semi_normed_group E\u2084] [module R E] [module R\u2082 E\u2082] [module R\u2083 E\u2083]\n\t[module R\u2084 E\u2084] (f : E\u2083 \u2192\u209b\u2097\u1d62[\u03c3\u2083\u2084] E\u2084) (g : E\u2082 \u2192\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) (h : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\t(f.comp g).comp h = f.comp (g.comp h) :=", "nl_statement_of_codex": "Let $R, R_2, R_3, R_4$ be semirings, let $\u03c3_{12}:R\\to R_2$, $\u03c3_{13}:R\\to R_3$, $\u03c3_{14}:R\\to R_4$, $\u03c3_{23}:R_2\\to R_3$, $\u03c3_{24}:R_2\\to R_4$, $\u03c3_{34}:R_3\\to R_4$ be ring homomorphisms, and let $E, E_2, E_3, E_4$ be semi-normed groups. Suppose that $E$ is a $R$-module, $E_2$ is"}
{"name": "or_not", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem or_not {p : Prop} :\n\tp \u2228 \u00acp :=", "nl_statement_of_codex": "For any proposition $p$, either $p$ is true or $p$ is false."}
{"name": "uniform_continuous_subtype_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem uniform_continuous_subtype_val {\u03b1 : Type*} {p : \u03b1 \u2192 Prop}\n\t[uniform_space \u03b1] :\n\tuniform_continuous subtype.val :=", "nl_statement_of_codex": "The function $f:A\\to A$ defined by $f(a)=a$ is uniformly continuous."}
{"name": "tendsto_sub_nhds_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem tendsto_sub_nhds_zero_iff {G : Type w} [add_group G]\n\t[topological_space G] [topological_add_group G] {\u03b1 : Type*} {l : filter \u03b1}\n\t{x : G} {u : \u03b1 \u2192 G} :\n\tfilter.tendsto (\u03bb (n : \u03b1), u n - x) l (nhds 0) \u2194 filter.tendsto u l (nhds x) :=", "nl_statement_of_codex": "Let $G$ be a topological group. Then the following are equivalent:\n(1) $u_n\\to x$ in $G$;\n(2) $u_n-x\\to 0$ in $G$."}
{"name": "function.surjective_of_right_cancellable_Prop", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.surjective_of_right_cancellable_Prop {\u03b1 : Sort u_1}\n\t{\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2}\n\t(h : \u2200 (g\u2081 g\u2082 : \u03b2 \u2192 Prop), g\u2081 \u2218 f = g\u2082 \u2218 f \u2192 g\u2081 = g\u2082) :\n\tfunction.surjective f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. If for any two functions $g_1, g_2:B\\to\\mathrm{Prop}$ such that $g_1\\circ f=g_2\\circ f$, we have $g_1=g_2$, then $f$ is surjective."}
{"name": "one_one_equiv_refl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/reduce.lean", "formal_statement": "theorem one_one_equiv_refl {\u03b1 : Type*} [primcodable \u03b1] (p : \u03b1 \u2192 Prop) :\n\tone_one_equiv p p :=", "nl_statement_of_codex": "The identity function is a one-one equivalence between $p$ and $p$."}
{"name": "valuation_subring.mem_unit_group_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/valuation/valuation_subring.lean", "formal_statement": "theorem valuation_subring.mem_unit_group_iff {K : Type*} [field K]\n\t(A : valuation_subring K) (x : K\u02e3) :\n\tx \u2208 A.unit_group \u2194 \u21d1(A.valuation) \u2191x = 1 :=", "nl_statement_of_codex": "Let $K$ be a field and let $A$ be a valuation subring of $K$. Then $x\\in A^\\times$ if and only if $\\mathrm{val}(x)=1$."}
{"name": "list.append_eq_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.append_eq_nil {\u03b1 : Type u} {p q : list \u03b1} :\n\tp ++ q = list.nil \u2194 p = list.nil \u2227 q = list.nil :=", "nl_statement_of_codex": "The concatenation of two lists is the empty list if and only if both lists are empty."}
{"name": "cardinal.mk_bounded_subset_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/ordinal.lean", "formal_statement": "theorem cardinal.mk_bounded_subset_le {\u03b1 : Type u} (s : set \u03b1) ( : cardinal) :\n\tcardinal.mk {t // t \u2286 s \u2227 cardinal.mk \u21a5t \u2264 c} \u2264 linear_order.max (cardinal.mk \u21a5s) cardinal.aleph_0 ^ c :=", "nl_statement_of_codex": "Let $s$ be a set and let $c$ be a cardinal. Then the cardinality of the set of subsets of $s$ of cardinality at most $c$ is at most $\\max\\{|s|,\\aleph_0^c\\}$."}
{"name": "category_theory.grothendieck_topology.iso_to_plus_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/plus.lean", "formal_statement": "theorem category_theory.grothendieck_topology.iso_to_plus_inv {C : Type u}\n\t[category_theory.category C] (J : category_theory.grothendieck_topology C)\n\t{D : Type w} [category_theory.category D]\n\t[\u2200 (P : C\u1d52\u1d56 \u2964 D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)]\n\t(P : C\u1d52\u1d56 \u2964 D)\n\t[\u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 D]\n\t(hP : category_theory.presheaf.is_sheaf J P) :\n\t(J.iso_to_plus P hP).inv = J.plus_lift (\ud835\udfd9 P) hP :=", "nl_statement_of_codex": "Let $C$ be a category and $J$ a Grothendieck topology on $C$. Let $D$ be a category and let $P:C^{op}\\to D$ be a functor. Suppose that for each $X\\in C$ and each covering $S$ of $X$ in $J$, the multiequalizer of $S$ exists in $D$. Suppose also that for each $X\\in C$, the colimit of $S^{op}$ exists in $D$ for each covering $S$ of $X$ in $J$. If $P$ is a sheaf, then the inverse of the isomorphism $J.iso_to"}
{"name": "prod.rprod_wf", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/wf.lean", "formal_statement": "theorem prod.rprod_wf {\u03b1 : Type u} {\u03b2 : Type v} {ra : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t{rb : \u03b2 \u2192 \u03b2 \u2192 Prop} (ha : well_founded ra) (hb : well_founded rb) :\n\twell_founded (prod.rprod ra rb) :=", "nl_statement_of_codex": "If $ra$ and $rb$ are well-founded relations on $\u03b1$ and $\u03b2$, respectively, then $ra\\times rb$ is a well-founded relation on $\u03b1\\times \u03b2$."}
{"name": "alg_hom.bijective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean", "formal_statement": "theorem alg_hom.bijective {F : Type*} [field F] {E : Type*} [field E]\n\t[algebra F E] [finite_dimensional F E] (\u03d5 : E \u2192\u2090[F] E) :\n\tfunction.bijective \u21d1\u03d5 :=", "nl_statement_of_codex": "Let $F$ be a field and let $E$ be a finite dimensional $F$-algebra. Then every $F$-algebra homomorphism $E\\to E$ is bijective."}
{"name": "category_theory.has_shift_mk_shift_to_lax_monoidal_functor_to_functor", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/shift.lean", "formal_statement": "theorem category_theory.has_shift_mk_shift_to_lax_monoidal_functor_to_functor\n\t(C : Type u) (A : Type*) [category_theory.category C] [add_monoid A]\n\t(h : category_theory.shift_mk_core C A) :\n\tcategory_theory.has_shift.shift.to_lax_monoidal_functor.to_functor = category_theory.discrete.functor h.F :=", "nl_statement_of_codex": "The functor $F$ associated to the shift-mk-core $h$ is the discrete functor associated to $h.F$."}
{"name": "symm_diff_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/symm_diff.lean", "formal_statement": "theorem symm_diff_bot {\u03b1 : Type*} [generalized_boolean_algebra \u03b1] (a : \u03b1) :\n\ta \u2206 \u22a5 = a :=", "nl_statement_of_codex": "Let $A$ be a generalized boolean algebra. Then $a\\Delta\\bot=a$ for all $a\\in A$."}
{"name": "order_iso.symm_preimage_preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/basic.lean", "formal_statement": "theorem order_iso.symm_preimage_preimage {\u03b1 \u03b2 : Type*} [has_le \u03b1] [has_le \u03b2]\n\t(e : \u03b1 \u2243o \u03b2) (s : set \u03b2) :\n\t\u21d1(e.symm) \u207b\u00b9' (\u21d1e \u207b\u00b9' s) = s :=", "nl_statement_of_codex": "Let $e:A\\to B$ be an order isomorphism. Then $e^{-1}(e^{-1}(S))=S$ for any subset $S$ of $B$."}
{"name": "list.perm.inter_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/perm.lean", "formal_statement": "theorem list.perm.inter_right {\u03b1 : Type uu} [decidable_eq \u03b1] {l\u2081 l\u2082 : list \u03b1}\n\t(t\u2081 : list \u03b1) :\n\tl\u2081 ~ l\u2082 \u2192 l\u2081 \u2229 t\u2081 ~ l\u2082 \u2229 t\u2081 :=", "nl_statement_of_codex": "Let $l_1, l_2, t_1$ be lists of elements of a set $A$. If $l_1$ and $l_2$ are permutations of each other, then $l_1\\cap t_1$ and $l_2\\cap t_1$ are permutations of each other."}
{"name": "continuous_on.of_dslope", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/dslope.lean", "formal_statement": "theorem continuous_on.of_dslope {\ud835\udd5c E : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_group E] [normed_space \ud835\udd5c E] {f : \ud835\udd5c \u2192 E} {a : \ud835\udd5c} {s : set \ud835\udd5c}\n\t(h : continuous_on (dslope f a) s) :\n\tcontinuous_on f s :=", "nl_statement_of_codex": "Let $f: \\mathbb{K}\\to E$ be a function, where $\\mathbb{K}$ is a nondiscrete normed field and $E$ is a normed group. If the derivative of $f$ is continuous, then $f$ is continuous."}
{"name": "Top.presheaf.stalk_functor_map_germ_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sheaves/stalks.lean", "formal_statement": "theorem Top.presheaf.stalk_functor_map_germ_apply {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_colimits C] {X : Top}\n\t{F G : Top.presheaf C X} (U : topological_space.opens \u21a5X) (x : \u21a5U) (f : F \u27f6 G)\n\t[I : category_theory.concrete_category C] (x_1 : \u21a5(F.obj (opposite.op U))) :\n\t\u21d1((Top.presheaf.stalk_functor C x.val).map f) (\u21d1(F.germ x) x_1) = \u21d1(G.germ x) (\u21d1(f.app (opposite.op U)) x_1) :=", "nl_statement_of_codex": "Let $C$ be a category with colimits, let $X$ be a topological space, let $F,G:X\\to C$ be presheaves on $X$, let $U$ be an open subset of $X$, let $x\\in U$, let $f:F\\to G$ be a morphism of presheaves, let $x_1\\in F(U)$, and let $I$ be a concrete category. Then the germ of $f$ at $x$ applied to the germ of $F$ at $x$ applied to $x_1$ is equal to the germ of $G$ at $x$ applied to the germ of $"}
{"name": "module.End.generalized_eigenspace_le_maximal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/eigenspace.lean", "formal_statement": "theorem module.End.generalized_eigenspace_le_maximal {R : Type v} {M : Type w}\n\t[comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (\u03bc : R)\n\t(k : \u2115) :\n\t\u21d1(f.generalized_eigenspace \u03bc) k \u2264 f.maximal_generalized_eigenspace \u03bc :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ an $R$-module, and $f:M\\to M$ an $R$-linear map. Let $\\mu$ be an eigenvalue of $f$. Then the $k$-th generalized eigenspace of $f$ corresponding to $\\mu$ is contained in the maximal generalized eigenspace of $f$ corresponding to $\\mu$."}
{"name": "cont_diff_on.mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff_on.mono {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} {n : with_top \u2115}\n\t(h : cont_diff_on \ud835\udd5c n f s) {t : set E} (hst : t \u2286 s) :\n\tcont_diff_on \ud835\udd5c n f t :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over $\\mathbb{K}$ and let $f:E\\to F$. If $f$ is $n$-times continuously differentiable on $S$, then $f$ is $n$-times continuously differentiable on $T$."}
{"name": "Sup_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/pointwise.lean", "formal_statement": "theorem Sup_add {\u03b1 : Type*} [complete_lattice \u03b1] [add_group \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] (s t : set \u03b1) :\n\thas_Sup.Sup (s + t) = has_Sup.Sup s + has_Sup.Sup t :=", "nl_statement_of_codex": "Let $s$ and $t$ be subsets of a complete lattice $L$ with a group structure. Then $\\sup(s+t)=\\sup(s)+\\sup(t)$."}
{"name": "intermediate_field.inclusion_inclusion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/intermediate_field.lean", "formal_statement": "theorem intermediate_field.inclusion_inclusion {K L : Type*} [field K] [field L]\n\t[algebra K L] {E F G : intermediate_field K L} (hEF : E \u2264 F) (hFG : F \u2264 G)\n\t(x : \u21a5E) :\n\t\u21d1(intermediate_field.inclusion hFG) (\u21d1(intermediate_field.inclusion hEF) x) = \u21d1(intermediate_field.inclusion _) x :=", "nl_statement_of_codex": "Let $K$ and $L$ be fields and let $E, F, G$ be intermediate fields. If $E\\leq F$ and $F\\leq G$, then the inclusion map $E\\to G$ is the composition of the inclusion maps $E\\to F$ and $F\\to G$."}
{"name": "category_theory.yoneda'_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/types.lean", "formal_statement": "theorem category_theory.yoneda'_comp :\n\tcategory_theory.yoneda' \u22d9 category_theory.SheafOfTypes_to_presheaf category_theory.types_grothendieck_topology = category_theory.yoneda :=", "nl_statement_of_codex": "The Yoneda embedding is the composition of the sheafification functor and the Yoneda embedding."}
{"name": "gauge_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/gauge.lean", "formal_statement": "theorem gauge_smul {E : Type*} [add_comm_group E] [module \u211d E] {\u03b1 : Type*}\n\t[linear_ordered_field \u03b1] [mul_action_with_zero \u03b1 \u211d] [ordered_smul \u03b1 \u211d]\n\t[module \u03b1 E] [is_scalar_tower \u03b1 \u211d (set E)] {s : set E}\n\t(symmetric : \u2200 (x : E), x \u2208 s \u2192 -x \u2208 s) (r : \u03b1) (x : E) :\n\tgauge s (r \u2022 x) = |r| \u2022 gauge s x :=", "nl_statement_of_codex": "Let $E$ be a real vector space and let $s$ be a symmetric subset of $E$. Then for all $r\\in\\mathbb{R}$ and $x\\in E$, we have $\\operatorname{gauge}(s,rx)=|r|\\operatorname{gauge}(s,x)$."}
{"name": "complex.has_strict_fderiv_at_log_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/log_deriv.lean", "formal_statement": "theorem complex.has_strict_fderiv_at_log_real {x : \u2102} (h : 0 < x.re \u2228 x.im \u2260 0) :\n\thas_strict_fderiv_at complex.log (x\u207b\u00b9 \u2022 1) x :=", "nl_statement_of_codex": "The function $f(z)=\\log(z^{-1})$ has a strict derivative at $z=1$."}
{"name": "measurable_from_quotient", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_from_quotient {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[measurable_space \u03b2] {s : setoid \u03b1} {f : quotient s \u2192 \u03b2} :\n\tmeasurable f \u2194 measurable (f \u2218 quotient.mk') :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between measurable spaces. Then $f$ is measurable if and only if $f\\circ\\pi:X/\\sim\\to Y$ is measurable, where $\\pi:X\\to X/\\sim$ is the quotient map."}
{"name": "div_two_lt_of_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/field.lean", "formal_statement": "theorem div_two_lt_of_pos {\u03b1 : Type*} [linear_ordered_semifield \u03b1] {a : \u03b1}\n\t(h : 0 < a) :\n\ta / 2 < a :=", "nl_statement_of_codex": "Let $R$ be a linearly ordered ring. If $a\\in R$ is positive, then $a/2<a$."}
{"name": "div_add_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/field/basic.lean", "formal_statement": "theorem div_add_div {\u03b1 : Type*} [semifield \u03b1] {b d : \u03b1} (a c : \u03b1) (hb : b \u2260 0)\n\t(hd : d \u2260 0) :\n\ta / b + c / d = (a * d + b * c) / (b * d) :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a semifield $R$. If $b$ and $d$ are nonzero, then $a/b+c/d=(ad+bc)/(bd)$."}
{"name": "omega_complete_partial_order.id_continuous'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/omega_complete_partial_order.lean", "formal_statement": "theorem omega_complete_partial_order.id_continuous' {\u03b1 : Type u}\n\t[omega_complete_partial_order \u03b1] :\n\tomega_complete_partial_order.continuous' id :=", "nl_statement_of_codex": "The identity function is continuous on an omega-complete partial order."}
{"name": "is_compact.bdd_above_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem is_compact.bdd_above_image {\u03b1 : Type u} {\u03b2 : Type v}\n\t[topological_space \u03b1] [linear_order \u03b1] [order_closed_topology \u03b1] [nonempty \u03b1]\n\t[topological_space \u03b2] {f : \u03b2 \u2192 \u03b1} {K : set \u03b2} (hK : is_compact K)\n\t(hf : continuous_on f K) :\n\tbdd_above (f '' K) :=", "nl_statement_of_codex": "Let $K$ be a compact subset of a topological space $X$ and let $f:X\\to Y$ be a continuous function. Then the image $f(K)$ is bounded above."}
{"name": "filter.not_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.not_le {\u03b1 : Type u} {f g : filter \u03b1} :\n\t\u00acf \u2264 g \u2194 \u2203 (s : set \u03b1) (H : s \u2208 g), s \u2209 f :=", "nl_statement_of_codex": "Let $f$ and $g$ be filters on a set $X$. Then $f\\leq g$ if and only if for every $s\\in g$ there is an $t\\in f$ such that $t\\subset s$."}
{"name": "set.subset_center_units", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/center.lean", "formal_statement": "theorem set.subset_center_units {M : Type*} [monoid M] :\n\tcoe \u207b\u00b9' set.center M \u2286 set.center M\u02e3 :=", "nl_statement_of_codex": "The inverse of the center of a monoid is contained in the center of the monoid."}
{"name": "pgame.quot_zero_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/basic.lean", "formal_statement": "theorem pgame.quot_zero_mul (x : pgame) :\n\t\u27e60 * x\u27e7 = \u27e60\u27e7 :=", "nl_statement_of_codex": "The quotient of zero times a partial game is zero."}
{"name": "is_p_group.disjoint_of_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/p_group.lean", "formal_statement": "theorem is_p_group.disjoint_of_ne {G : Type*} [group G] (p\u2081 p\u2082 : \u2115)\n\t[hp\u2081 : fact (nat.prime p\u2081)] [hp\u2082 : fact (nat.prime p\u2082)] (hne : p\u2081 \u2260 p\u2082)\n\t(H\u2081 H\u2082 : subgroup G) (hH\u2081 : is_p_group p\u2081 \u21a5H\u2081) (hH\u2082 : is_p_group p\u2082 \u21a5H\u2082) :\n\tdisjoint H\u2081 H\u2082 :=", "nl_statement_of_codex": "Let $G$ be a group and let $p_1, p_2$ be distinct primes. Let $H_1, H_2$ be $p_1$- and $p_2$-subgroups of $G$, respectively. Then $H_1$ and $H_2$ are disjoint."}
{"name": "polynomial.coeff_det_X_add_C_card", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/polynomial.lean", "formal_statement": "theorem polynomial.coeff_det_X_add_C_card {n \u03b1 : Type*} [decidable_eq n]\n\t[fintype n] [comm_ring \u03b1] (A B : matrix n n \u03b1) :\n\t(polynomial.X \u2022 A.map \u21d1polynomial.C + B.map \u21d1polynomial.C).det.coeff (fintype.card n) = A.det :=", "nl_statement_of_codex": "Let $A$ and $B$ be $n\\times n$ matrices over a commutative ring $R$. Then the coefficient of $X^n$ in the determinant of $XA+B$ is $A$."}
{"name": "category_theory.adjunction.hom_equiv_counit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/basic.lean", "formal_statement": "theorem category_theory.adjunction.hom_equiv_counit {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t{F : C \u2964 D} {G : D \u2964 C} (self : F \u22a3 G) {X : C} {Y : D} {g : X \u27f6 G.obj Y} :\n\t\u21d1((self.hom_equiv X Y).symm) g = F.map g \u226b self.counit.app Y :=", "nl_statement_of_codex": "Let $F:C\\to D$ and $G:D\\to C$ be adjoint functors. Then the counit of the adjunction is the inverse of the unit."}
{"name": "homotopy.symm_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/homotopy.lean", "formal_statement": "theorem homotopy.symm_hom {\u03b9 : Type*} {V : Type u} [category_theory.category V]\n\t[category_theory.preadditive V] { : complex_shape \u03b9}\n\t{C D : homological_complex V c} {f g : C \u27f6 D} (h : homotopy f g) (i j : \u03b9) :\n\th.symm.hom i j = (-h.hom) i j :=", "nl_statement_of_codex": "Let $C$ and $D$ be homological complexes over a preadditive category $V$. Let $f,g:C\\to D$ be morphisms of complexes. If $h:f\\simeq g$ is a homotopy, then $h^{-1}$ is given by $h^{-1}_{i,j}=-h_{i,j}$."}
{"name": "category_theory.subobject.of_mk_le_mk_comp_of_mk_le_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/basic.lean", "formal_statement": "theorem category_theory.subobject.of_mk_le_mk_comp_of_mk_le_mk {C : Type u\u2081}\n\t[category_theory.category C] {B A\u2081 A\u2082 A\u2083 : C} (f : A\u2081 \u27f6 B)\n\t[category_theory.mono f] (g : A\u2082 \u27f6 B) [category_theory.mono g] (h : A\u2083 \u27f6 B)\n\t[category_theory.mono h]\n\t(h\u2081 : category_theory.subobject.mk f \u2264 category_theory.subobject.mk g)\n\t(h\u2082 : category_theory.subobject.mk g \u2264 category_theory.subobject.mk h) :\n\tcategory_theory.subobject.of_mk_le_mk f g h\u2081 \u226b category_theory.subobject.of_mk_le_mk g h h\u2082 = category_theory.subobject.of_mk_le_mk f h _ :=", "nl_statement_of_codex": "Let $C$ be a category. Let $f:A_1\\to B$ and $g:A_2\\to B$ be monomorphisms. Let $h:A_3\\to B$ be a morphism. Suppose that $A_1\\to A_2$ and $A_2\\to A_3$ are monomorphisms. Then the composition of the morphisms $A_1\\to A_2$ and $A_2\\to A_3$ is the morphism $A_1\\to A_3$."}
{"name": "lie_submodule.lie_le_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/ideal_operations.lean", "formal_statement": "theorem lie_submodule.lie_le_right {R : Type u} {L : Type v} {M : Type w}\n\t[comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M]\n\t[lie_ring_module L M] [lie_module R L M] (N : lie_submodule R L M)\n\t(I : lie_ideal R L) :\n\t\u2045I,N\u2046 \u2264 N :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a Lie $R$-module. Let $N$ be a Lie submodule of $M$ and $I$ a Lie ideal of $L$. Then $[I,N]\\leq N$."}
{"name": "module.Baer.extension_of_max_adjoin.extension_to_fun_wd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/injective.lean", "formal_statement": "theorem module.Baer.extension_of_max_adjoin.extension_to_fun_wd {R : Type u}\n\t[ring R] {Q : Type (max u v)} [add_comm_group Q] [module R Q]\n\t{M N : Type (max u v)} [add_comm_group M] [add_comm_group N] [module R M]\n\t[module R N] (i : M \u2192\u2097[R] N) (f : M \u2192\u2097[R] Q) [fact (function.injective \u21d1i)]\n\t(h : module.Baer R Q) {y : N}\n\t(x : \u21a5((module.Baer.extension_of_max i f).to_linear_pmap.domain \u2294 submodule.span R {y}))\n\t(a : \u21a5((module.Baer.extension_of_max i f).to_linear_pmap.domain)) (r : R)\n\t(eq1 : \u2191x = \u2191a + r \u2022 y) :\n\tmodule.Baer.extension_of_max_adjoin.extension_to_fun i f h x = \u21d1((module.Baer.extension_of_max i f).to_linear_pmap) a + \u21d1(module.Baer.extension_of_max_adjoin.extend_ideal_to i f h y) r :=", "nl_statement_of_codex": "Let $R$ be a ring, $Q$ an $R$-module, $M$ and $N$ $R$-modules, $i:M\\to N$ an injective $R$-module homomorphism, and $f:M\\to Q$ an $R$-module homomorphism. Suppose that $Q$ is Baer. Let $y\\in N$ and let $x\\in M\\oplus Ry$. Then the extension of $f$ to $M\\oplus Ry$ is given by $f(x)+r\\cdot f(y)$."}
{"name": "topological_vector_bundle.trivialization.coe_symm\u2097", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/vector_bundle/basic.lean", "formal_statement": "theorem topological_vector_bundle.trivialization.coe_symm\u2097 {R B F E : B \u2192 Type*}\n\t[semiring R] [\u03a0 (x : B), add_comm_monoid (E x)] [\u03a0 (x : B), module R (E x)]\n\t[topological_space F] [add_comm_monoid F] [module R F] [topological_space B]\n\t[topological_space (bundle.total_space E)]\n\t(e : topological_vector_bundle.trivialization R F E) (b : B) :\n\t\u21d1(e.symm\u2097 b) = e.symm b :=", "nl_statement_of_codex": "Let $E$ be a topological vector bundle over $B$ with fiber $F$. Let $e$ be a trivialization of $E$. Then the map $e^{-1}$ is the inverse of $e$."}
{"name": "measure_theory.quasi_measure_preserving_div_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/prod.lean", "formal_statement": "theorem measure_theory.quasi_measure_preserving_div_left {G : Type*}\n\t[measurable_space G] [group G] [has_measurable_mul\u2082 G]\n\t(\u03bc : measure_theory.measure G) [measure_theory.sigma_finite \u03bc]\n\t[has_measurable_inv G] [\u03bc.is_mul_left_invariant] (g : G) :\n\tmeasure_theory.measure.quasi_measure_preserving (\u03bb (h : G), g / h) \u03bc \u03bc :=", "nl_statement_of_codex": "Let $G$ be a group with a left-invariant measure $\\mu$. Then the map $h\\mapsto gh$ is measure-preserving."}
{"name": "vadd_mem_span_points_of_mem_span_points_of_mem_vector_span", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_subspace.lean", "formal_statement": "theorem vadd_mem_span_points_of_mem_span_points_of_mem_vector_span (k : Type*)\n\t{V P : Type*} [ring k] [add_comm_group V] [module k V] [add_torsor V P]\n\t{s : set P} {p : P} {v : V} (hp : p \u2208 span_points k s)\n\t(hv : v \u2208 vector_span k s) :\n\tv +\u1d65 p \u2208 span_points k s :=", "nl_statement_of_codex": "Let $k$ be a ring, $V$ a $k$-module, and $P$ an $V$-torsor. Let $s$ be a set of points in $P$. If $p$ is in the span of $s$ and $v$ is in the vector span of $s$, then $v+p$ is in the span of $s$."}
{"name": "set.image2_vsub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.image2_vsub {\u03b1 \u03b2 : Type*} [has_vsub \u03b1 \u03b2] {s t : set \u03b2} :\n\tset.image2 has_vsub.vsub s t = s -\u1d65 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $s-t$ is the image of $s\\times t$ under the function $(x,y)\\mapsto x-y$."}
{"name": "fractional_ideal.eq_span_singleton_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.eq_span_singleton_mul {R : Type*} [comm_ring R]\n\t{S : submonoid R} {P : Type*} [comm_ring P] [algebra R P]\n\t[loc : is_localization S P] {x : P} {I J : fractional_ideal S P} :\n\tI = fractional_ideal.span_singleton S x * J \u2194 (\u2200 (zI : P), zI \u2208 I \u2192 (\u2203 (zJ : P) (H : zJ \u2208 J), x * zJ = zI)) \u2227 \u2200 (z : P), z \u2208 J \u2192 x * z \u2208 I :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a submonoid of $R$, $P$ a commutative ring, $R\\to P$ an algebra homomorphism, and $x\\in P$. Then two fractional ideals $I, J$ of $S$ in $P$ are equal if and only if for each $z\\in I$ there is $z'\\in J$ such that $xz'=z$ and for each $z\\in J$ we have $xz\\in I$."}
{"name": "submodule.quotient.mk_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/quotient.lean", "formal_statement": "theorem submodule.quotient.mk_zero {R M : Type*} [ring R] [add_comm_group M]\n\t[module R M] (p : submodule R M) :\n\tsubmodule.quotient.mk 0 = 0 :=", "nl_statement_of_codex": "Let $R$ be a ring and $M$ be an $R$-module. Let $p$ be a submodule of $M$. Then the zero element of $M/p$ is the equivalence class of $0$."}
{"name": "mul_inv_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/field.lean", "formal_statement": "theorem mul_inv_le_iff {\u03b1 : Type*} [linear_ordered_semifield \u03b1] {a b c : \u03b1}\n\t(h : 0 < b) :\n\ta * b\u207b\u00b9 \u2264 c \u2194 a \u2264 b * c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linearly ordered semifield $R$. If $b>0$, then $ab^{-1}\\leq c$ if and only if $a\\leq bc$."}
{"name": "nonempty_psigma", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/nonempty.lean", "formal_statement": "theorem nonempty_psigma {\u03b1 : Sort u_1} {\u03b2 : \u03b1 \u2192 Sort u_2} :\n\tnonempty (psigma \u03b2) \u2194 \u2203 (a : \u03b1), nonempty (\u03b2 a) :=", "nl_statement_of_codex": "There exists a nonempty $\\Sigma$-type if and only if there exists an element $a$ such that the type $\\beta(a)$ is nonempty."}
{"name": "Algebra.id_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Algebra/basic.lean", "formal_statement": "theorem Algebra.id_apply {R : Type u} [comm_ring R] {M : Module R} (m : \u21a5M) :\n\t\u21d1(\ud835\udfd9 M) m = m :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $M$ be an $R$-module. Then the identity map on $M$ is the identity map on $M$."}
{"name": "intermediate_field.adjoin_contains_field_as_subfield", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/adjoin.lean", "formal_statement": "theorem intermediate_field.adjoin_contains_field_as_subfield {E : Type*}\n\t[field E] (S : set E) (F : subfield E) :\n\t\u2191F \u2286 \u2191(intermediate_field.adjoin \u21a5F S) :=", "nl_statement_of_codex": "Let $E$ be a field and let $F$ be a subfield of $E$. Then $F$ is a subfield of the field $E(S)$."}
{"name": "box_integral.integrable.has_integral", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/basic.lean", "formal_statement": "theorem box_integral.integrable.has_integral {\u03b9 : Type u} {E : Type v}\n\t{F : Type w} [normed_group E] [normed_space \u211d E] [normed_group F]\n\t[normed_space \u211d F] {I : box_integral.box \u03b9} [fintype \u03b9]\n\t{l : box_integral.integration_params} {f : (\u03b9 \u2192 \u211d) \u2192 E}\n\t{vol : box_integral.box_additive_map \u03b9 (E \u2192L[\u211d] F) \u22a4}\n\t(h : box_integral.integrable I l f vol) :\n\tbox_integral.has_integral I l f vol (box_integral.integral I l f vol) :=", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$, let $f:I\\to\\mathbb{R}^m$ be a function, and let $vol$ be a volume form on $I$. If $f$ is integrable, then the integral of $f$ is equal to the integral of $f$."}
{"name": "algebraic_geometry.structure_sheaf.const_congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.structure_sheaf.const_congr (R : Type u)\n\t[comm_ring R] {f\u2081 f\u2082 g\u2081 g\u2082 : R}\n\t{U : topological_space.opens \u21a5(algebraic_geometry.prime_spectrum.Top R)}\n\t{hu : \u2200 (x : \u21a5(algebraic_geometry.prime_spectrum.Top R)), x \u2208 U \u2192 g\u2081 \u2208 (prime_spectrum.as_ideal x).prime_compl}\n\t(hf : f\u2081 = f\u2082) (hg : g\u2081 = g\u2082) :\n\talgebraic_geometry.structure_sheaf.const R f\u2081 g\u2081 U hu = algebraic_geometry.structure_sheaf.const R f\u2082 g\u2082 U _ :=", "nl_statement_of_codex": "Let $R$ be a commutative ring. Let $f_1, f_2, g_1, g_2\\in R$ and let $U$ be an open subset of the prime spectrum of $R$. Suppose that for each $x\\in U$, $g_1$ is not in the prime ideal $x$. Then the function $f_1/g_1$ is equal to the function $f_2/g_2$ on $U$."}
{"name": "set.preimage_smul_inv\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.preimage_smul_inv\u2080 {\u03b1 \u03b2 : Type*} [group_with_zero \u03b1]\n\t[mul_action \u03b1 \u03b2] {a : \u03b1} (ha : a \u2260 0) (t : set \u03b2) :\n\t(\u03bb (x : \u03b2), a\u207b\u00b9 \u2022 x) \u207b\u00b9' t = a \u2022 t :=", "nl_statement_of_codex": "Let $G$ be a group with zero and let $G$ act on a set $X$. Let $a\\in G$ be nonzero. Then the preimage of $a\\cdot X$ under the map $x\\mapsto a^{-1}\\cdot x$ is $X$."}
{"name": "category_theory.limits.prod.map_iso_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/binary_products.lean", "formal_statement": "theorem category_theory.limits.prod.map_iso_hom {C : Type u}\n\t[category_theory.category C] {W X Y Z : C}\n\t[category_theory.limits.has_binary_product W X]\n\t[category_theory.limits.has_binary_product Y Z] (f : W \u2245 Y) (g : X \u2245 Z) :\n\t(category_theory.limits.prod.map_iso f g).hom = category_theory.limits.prod.map f.hom g.hom :=", "nl_statement_of_codex": "Let $C$ be a category. Let $W,X,Y,Z$ be objects of $C$ and let $f:W\\to Y$ and $g:X\\to Z$ be isomorphisms. Then the map $f\\times g:W\\times X\\to Y\\times Z$ is an isomorphism."}
{"name": "add_subgroup_class.inclusion_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup_class.inclusion_right {G : Type*} [add_group G] {S : Type*}\n\t{H K : S} [set_like S G] [hSG : add_subgroup_class S G] (h : H \u2264 K) (x : \u21a5K)\n\t(hx : \u2191x \u2208 H) :\n\t\u21d1(add_subgroup_class.inclusion h) \u27e8\u2191x, hx\u27e9 = x :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $S$ be a set of subgroups of $G$. Let $H$ and $K$ be subgroups of $G$ such that $H\\leq K$. Let $x\\in K$. If $x\\in H$, then the inclusion map $H\\to K$ maps $x$ to $x$."}
{"name": "fin.coe_fin_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.coe_fin_le {n : \u2115} {a b : fin n} :\n\t\u2191a \u2264 \u2191b \u2194 a \u2264 b :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $a, b$ be elements of $\\mathbb{F}_n$. Then $a\\leq b$ if and only if $a\\leq b$."}
{"name": "complex.neg_pi_div_two_le_arg_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/arg.lean", "formal_statement": "theorem complex.neg_pi_div_two_le_arg_iff {z : \u2102} :\n\t-(real.pi / 2) \u2264 z.arg \u2194 0 \u2264 z.re \u2228 0 \u2264 z.im :=", "nl_statement_of_codex": "The argument of a complex number $z$ is at least $-\\pi/2$ if and only if $z$ is in the first or fourth quadrant."}
{"name": "list.sublist.sum_le_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/big_operators.lean", "formal_statement": "theorem list.sublist.sum_le_sum {M : Type*} [add_monoid M] [preorder M]\n\t[covariant_class M M (function.swap has_add.add) has_le.le]\n\t[covariant_class M M has_add.add has_le.le] {l\u2081 l\u2082 : list M} (h : l\u2081 <+ l\u2082)\n\t(h\u2081 : \u2200 (a : M), a \u2208 l\u2082 \u2192 0 \u2264 a) :\n\tl\u2081.sum \u2264 l\u2082.sum :=", "nl_statement_of_codex": "Let $M$ be an additive monoid with a preorder. Let $l_1, l_2$ be lists of elements of $M$. If $l_1$ is a sublist of $l_2$ and $l_2$ is non-negative, then $\\sum_{x\\in l_1}x\\leq\\sum_{x\\in l_2}x$."}
{"name": "measure_theory.signed_measure.to_jordan_decomposition_smul_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/decomposition/jordan.lean", "formal_statement": "theorem measure_theory.signed_measure.to_jordan_decomposition_smul_real\n\t{\u03b1 : Type*} [measurable_space \u03b1] (s : measure_theory.signed_measure \u03b1) (r : \u211d) :\n\t(r \u2022 s).to_jordan_decomposition = r \u2022 s.to_jordan_decomposition :=", "nl_statement_of_codex": "Let $s$ be a signed measure on a measurable space $X$. Then the Jordan decomposition of $rs$ is $r$ times the Jordan decomposition of $s$."}
{"name": "zsqrtd.coe_int_dvd_coe_int", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.coe_int_dvd_coe_int {d : \u2124} (a b : \u2124) :\n\t\u2191a \u2223 \u2191b \u2194 a \u2223 b :=", "nl_statement_of_codex": "For any integers $a$ and $b$, $a$ divides $b$ if and only if $\\sqrt{d}a$ divides $\\sqrt{d}b$."}
{"name": "mem_ball_iff_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem mem_ball_iff_norm {E : Type*} [semi_normed_group E] {g h : E} {r : \u211d} :\n\th \u2208 metric.ball g r \u2194 \u2225h - g\u2225 < r :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $g, h\\in E$. Then $h\\in B(g,r)$ if and only if $\\|h-g\\|<r$."}
{"name": "add_subgroup.map_zero_eq_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.map_zero_eq_bot {G : Type*} [add_group G]\n\t(K : add_subgroup G) {N : Type*} [add_group N] :\n\tadd_subgroup.map 0 K = \u22a5 :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $K$ be an additive subgroup of $G$. Then the image of $0$ under the map $G\\to G/K$ is the trivial subgroup of $G/K$."}
{"name": "not_and_self", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/logic.lean", "formal_statement": "theorem not_and_self (a : Prop) :\n\t\u00aca \u2227 a \u2194 false :=", "nl_statement_of_codex": "$\\neg a\\land a$ is always false."}
{"name": "set.insert_union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.insert_union {\u03b1 : Type u} {a : \u03b1} {s t : set \u03b1} :\n\thas_insert.insert a s \u222a t = has_insert.insert a (s \u222a t) :=", "nl_statement_of_codex": "Let $A$ be a set and let $a\\in A$. Then $A\\cup\\{a\\}=\\{a\\}\\cup A$."}
{"name": "pmf.filter_apply_eq_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/probability_mass_function/constructions.lean", "formal_statement": "theorem pmf.filter_apply_eq_zero_iff {\u03b1 : Type*} {p : pmf \u03b1} {s : set \u03b1}\n\t(h : \u2203 (a : \u03b1) (H : a \u2208 s), a \u2208 p.support) (a : \u03b1) :\n\t\u21d1(p.filter s h) a = 0 \u2194 a \u2209 s \u2228 a \u2209 p.support :=", "nl_statement_of_codex": "Let $p$ be a probability mass function on a set $X$ and let $s$ be a subset of $X$. Then $p(s)=0$ if and only if $s$ is disjoint from the support of $p$."}
{"name": "topological_space.metrizable_space_of_t3_second_countable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/metrizable.lean", "formal_statement": "theorem topological_space.metrizable_space_of_t3_second_countable (X : Type*)\n\t[topological_space X] [t3_space X]\n\t[topological_space.second_countable_topology X] :\n\ttopological_space.metrizable_space X :=", "nl_statement_of_codex": "Let $X$ be a $T_3$ space. If $X$ is second countable, then $X$ is metrizable."}
{"name": "module.End.generalized_eigenspace_restrict", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/eigenspace.lean", "formal_statement": "theorem module.End.generalized_eigenspace_restrict {R : Type v} {M : Type w}\n\t[comm_ring R] [add_comm_group M] [module R M] (f : module.End R M)\n\t(p : submodule R M) (k : \u2115) (\u03bc : R) (hfp : \u2200 (x : M), x \u2208 p \u2192 \u21d1f x \u2208 p) :\n\t\u21d1(module.End.generalized_eigenspace (linear_map.restrict f hfp) \u03bc) k = submodule.comap p.subtype (\u21d1(f.generalized_eigenspace \u03bc) k) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ an $R$-module, and $f:M\\to M$ an $R$-linear map. Let $p$ be a submodule of $M$ and let $k$ be a natural number. Let $\\mu$ be an element of $R$. Suppose that $f(p)\\subset p$. Then the $k$-th generalized eigenspace of $f$ restricted to $p$ is equal to the $k$-th generalized eigenspace of $f$."}
{"name": "conformal_at_iff_is_conformal_map_fderiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/conformal/normed_space.lean", "formal_statement": "theorem conformal_at_iff_is_conformal_map_fderiv {X Y : Type*} [normed_group X]\n\t[normed_group Y] [normed_space \u211d X] [normed_space \u211d Y] {f : X \u2192 Y} {x : X} :\n\tconformal_at f x \u2194 is_conformal_map (fderiv \u211d f x) :=", "nl_statement_of_codex": "Let $X$ and $Y$ be normed spaces over $\\mathbb{R}$ and let $f:X\\to Y$. Then $f$ is conformal at $x$ if and only if the derivative of $f$ at $x$ is a conformal map."}
{"name": "projective_spectrum.mem_coe_basic_open", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/projective_spectrum/topology.lean", "formal_statement": "theorem projective_spectrum.mem_coe_basic_open {R A : Type*} [comm_semiring R]\n\t[comm_ring A] [algebra R A] (\ud835\udc9c : \u2115 \u2192 submodule R A) [graded_algebra \ud835\udc9c] (f : A)\n\t(x : projective_spectrum \ud835\udc9c) :\n\tx \u2208 \u2191(projective_spectrum.basic_open \ud835\udc9c f) \u2194 f \u2209 x.as_homogeneous_ideal :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a commutative ring, and $\\mathcal{A}$ a graded algebra over $R$. Then $f\\in A$ is in the basic open set $D(f)$ of the projective spectrum of $\\mathcal{A}$ if and only if $f$ is not in the homogeneous ideal corresponding to $x$."}
{"name": "polynomial.degree_normalize", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/field_division.lean", "formal_statement": "theorem polynomial.degree_normalize {R : Type u} [field R] {p : polynomial R} :\n\t(\u21d1normalize p).degree = p.degree :=", "nl_statement_of_codex": "The degree of a polynomial is the same as the degree of its normalization."}
{"name": "add_units.is_add_unit_add_units_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/units.lean", "formal_statement": "theorem add_units.is_add_unit_add_units_add {M : Type*} [add_monoid M]\n\t(u : add_units M) (a : M) :\n\tis_add_unit (\u2191u + a) \u2194 is_add_unit a :=", "nl_statement_of_codex": "Let $M$ be an additive monoid. Then $u+a$ is an additive unit if and only if $a$ is an additive unit."}
{"name": "inf_right_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/lattice.lean", "formal_statement": "theorem inf_right_comm {\u03b1 : Type u} [semilattice_inf \u03b1] (a b c : \u03b1) :\n\ta \u2293 b \u2293 c = a \u2293 c \u2293 b :=", "nl_statement_of_codex": "The infimum of three elements is independent of the order of the elements."}
{"name": "matrix.pos_def_to_quadratic_form'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/pos_def.lean", "formal_statement": "theorem matrix.pos_def_to_quadratic_form' {n : Type*} [fintype n]\n\t[decidable_eq n] {M : matrix n n \u211d} (hM : M.pos_def) :\n\tM.to_quadratic_form'.pos_def :=", "nl_statement_of_codex": "Let $M$ be a positive definite matrix. Then the quadratic form associated to $M$ is positive definite."}
{"name": "finset.subtype_Icc_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/locally_finite.lean", "formal_statement": "theorem finset.subtype_Icc_eq {\u03b1 : Type*} [preorder \u03b1] (p : \u03b1 \u2192 Prop)\n\t[decidable_pred p] [locally_finite_order \u03b1] (a b : subtype p) :\n\tfinset.Icc a b = finset.subtype p (finset.Icc \u2191a \u2191b) :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a preorder $\u03b1$. Let $a,b$ be elements of the subtype $p$. Then the interval $[a,b]$ is equal to the subtype of $p$ of the interval $[a,b]$."}
{"name": "supr_infi_of_monotone", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/finite.lean", "formal_statement": "theorem supr_infi_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [fintype \u03b9] [preorder \u03b9']\n\t[nonempty \u03b9'] [is_directed \u03b9' has_le.le] [order.frame \u03b1] {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1}\n\t(hf : \u2200 (i : \u03b9), monotone (f i)) :\n\t(\u2a06 (j : \u03b9'), \u2a05 (i : \u03b9), f i j) = \u2a05 (i : \u03b9), \u2a06 (j : \u03b9'), f i j :=", "nl_statement_of_codex": "Let $f:I\\times I'\\to A$ be a function where $I$ is finite, $I'$ is nonempty and directed, and $A$ is a frame. If $f$ is monotone in the second variable, then $\\sup_{j\\in I'}\\inf_{i\\in I}f(i,j)=\\inf_{i\\in I}\\sup_{j\\in I'}f(i,j)$."}
{"name": "eq_empty_or_univ_of_vadd_invariant_closed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/minimal.lean", "formal_statement": "theorem eq_empty_or_univ_of_vadd_invariant_closed (M : Type*) {\u03b1 : Type*}\n\t[add_monoid M] [topological_space \u03b1] [add_action M \u03b1]\n\t[add_action.is_minimal M \u03b1] {s : set \u03b1} (hs : is_closed s)\n\t(hsmul : \u2200 (c : M), c +\u1d65 s \u2286 s) :\n\ts = \u2205 \u2228 s = set.univ :=", "nl_statement_of_codex": "Let $M$ be a topological space and let $s$ be a closed subset of $M$. If $s$ is invariant under the action of $M$ on $M$, then $s$ is either empty or the whole space."}
{"name": "cont_mdiff_at_iff_cont_diff_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem cont_mdiff_at_iff_cont_diff_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {n : with_top \u2115} {f : E \u2192 E'} {x : E} :\n\tcont_mdiff_at (model_with_corners_self \ud835\udd5c E) (model_with_corners_self \ud835\udd5c E') n f x \u2194 cont_diff_at \ud835\udd5c n f x :=", "nl_statement_of_codex": "Let $E$ and $E'$ be normed spaces over a nondiscrete normed field $K$. Then a function $f:E\\to E'$ is $n$-times continuously differentiable at $x$ if and only if it is $n$-times continuously differentiable at $x$ in the sense of model spaces."}
{"name": "set.Union_set_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Union_set_of {\u03b1 : Type*} {\u03b9 : Sort u_4} (P : \u03b9 \u2192 \u03b1 \u2192 Prop) :\n\t(\u22c3 (i : \u03b9), {x : \u03b1 | P i x}) = {x : \u03b1 | \u2203 (i : \u03b9), P i x} :=", "nl_statement_of_codex": "The union of the sets $\\{x\\in A\\mid P(i,x)\\}$ is equal to the set $\\{x\\in A\\mid \\exists i\\in I, P(i,x)\\}$."}
{"name": "free_group.inv_bind", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/free_group.lean", "formal_statement": "theorem free_group.inv_bind {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 free_group \u03b2)\n\t(x : free_group \u03b1) :\n\tx\u207b\u00b9 >>= f = (x >>= f)\u207b\u00b9 :=", "nl_statement_of_codex": "Let $f:\\alpha\\to F(B)$ be a function and let $x\\in F(A)$. Then $x^{-1}\\cdot f=f(x^{-1})$."}
{"name": "linear_map.minpoly_dvd_charpoly", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/charpoly/basic.lean", "formal_statement": "theorem linear_map.minpoly_dvd_charpoly {K : Type u} {M : Type v} [field K]\n\t[add_comm_group M] [module K M] [finite_dimensional K M] (f : M \u2192\u2097[K] M) :\n\tminpoly K f \u2223 f.charpoly :=", "nl_statement_of_codex": "Let $K$ be a field, $M$ a finite dimensional $K$-module, and $f:M\\to M$ a $K$-linear map. Then the minimal polynomial of $f$ divides the characteristic polynomial of $f$."}
{"name": "spectrum.pow_norm_pow_one_div_tendsto_nhds_spectral_radius", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/spectrum.lean", "formal_statement": "theorem spectrum.pow_norm_pow_one_div_tendsto_nhds_spectral_radius {A : Type*}\n\t[normed_ring A] [normed_algebra \u2102 A] [complete_space A] [norm_one_class A]\n\t(a : A) :\n\tfilter.tendsto (\u03bb (n : \u2115), ennreal.of_real (\u2225a ^ n\u2225 ^ (1 / \u2191n))) filter.at_top (nhds (spectral_radius \u2102 a)) :=", "nl_statement_of_codex": "Let $A$ be a normed ring with a normed algebra structure over $\\mathbb{C}$ and with a norm one class. Let $a\\in A$. Then the sequence $\\left(\\|a^n\\|^{1/n}\\right)_{n\\in\\mathbb{N}}$ converges to the spectral radius of $a$."}
{"name": "is_connected.is_preconnected", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/connected.lean", "formal_statement": "theorem is_connected.is_preconnected {\u03b1 : Type u} [topological_space \u03b1]\n\t{s : set \u03b1} (h : is_connected s) :\n\tis_preconnected s :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a connected subset of $X$. Then $A$ is preconnected."}
{"name": "cont_mdiff_on.continuous_on_tangent_map_within", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem cont_mdiff_on.continuous_on_tangent_map_within {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{H : Type*} [topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M]\n\t[Is : smooth_manifold_with_corners I M] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M \u2192 M'}\n\t{s : set M} {n : with_top \u2115} (hf : cont_mdiff_on I I' n f s) (hmn : 1 \u2264 n)\n\t(hs : unique_mdiff_on I s) :\n\tcontinuous_on (tangent_map_within I I' f s) (tangent_bundle.proj I M \u207b\u00b9' s) :=", "nl_statement_of_codex": "Let $f:M\\to M'$ be a $C^n$ map between smooth manifolds with corners. Then the tangent map $Tf:TM\\to TM'$ is continuous."}
{"name": "rat.add_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/defs.lean", "formal_statement": "theorem rat.add_mk (a b c : \u2124) :\n\trat.mk (a + b) c = rat.mk a c + rat.mk b c :=", "nl_statement_of_codex": "$\\frac{a+b}{c}=\\frac{a}{c}+\\frac{b}{c}$."}
{"name": "bounded_lattice_hom.as_boolring_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/boolean_ring.lean", "formal_statement": "theorem bounded_lattice_hom.as_boolring_apply {\u03b1 \u03b2 : Type*} [boolean_algebra \u03b1]\n\t[boolean_algebra \u03b2] (f : bounded_lattice_hom \u03b1 \u03b2) (\u1fb0 : as_boolring \u03b1) :\n\t\u21d1(f.as_boolring) \u1fb0 = (\u21d1to_boolring \u2218 \u21d1f \u2218 \u21d1of_boolring) \u1fb0 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a bounded lattice homomorphism. Then $f$ is a Boolean ring homomorphism if and only if $f$ is a Boolean algebra homomorphism."}
{"name": "is_fraction_ring.is_fraction_ring_iff_of_base_ring_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/fraction_ring.lean", "formal_statement": "theorem is_fraction_ring.is_fraction_ring_iff_of_base_ring_equiv {R : Type*}\n\t[comm_ring R] (S : Type*) [comm_ring S] [algebra R S] {P : Type*} [comm_ring P]\n\t(h : R \u2243+* P) :\n\tis_fraction_ring R S \u2194 is_fraction_ring P S :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a commutative $R$-algebra, and $P$ a commutative ring. If $R$ is isomorphic to $P$ as rings, then $S$ is a fraction ring of $R$ if and only if $S$ is a fraction ring of $P$."}
{"name": "composition.coe_inv_embedding", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/composition.lean", "formal_statement": "theorem composition.coe_inv_embedding {n : \u2115} ( : composition n) (j : fin n) :\n\t\u2191(c.inv_embedding j) = \u2191j - c.size_up_to \u2191(c.index j) :=", "nl_statement_of_codex": "Let $c$ be a composition of $n$. Then the inverse embedding of $c$ at $j$ is equal to $j$ minus the size of $c$ up to $j$."}
{"name": "finite_field.X_pow_card_sub_X_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/finite/basic.lean", "formal_statement": "theorem finite_field.X_pow_card_sub_X_ne_zero (K' : Type*) [field K'] {p : \u2115}\n\t(hp : 1 < p) :\n\tpolynomial.X ^ p - polynomial.X \u2260 0 :=", "nl_statement_of_codex": "Let $K$ be a field of characteristic $p>1$. Then $X^p-X\\neq 0$."}
{"name": "map_zsmul'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem map_zsmul' {G H F : Type*} [sub_neg_monoid G] [sub_neg_monoid H]\n\t[add_monoid_hom_class F G H] (f : F) (hf : \u2200 (x : G), \u21d1f (-x) = -\u21d1f x) (a : G)\n\t(n : \u2124) :\n\t\u21d1f (n \u2022 a) = n \u2022 \u21d1f a :=", "nl_statement_of_codex": "Let $G$ and $H$ be sub-neg-monoids and let $F$ be an additive monoid homomorphism from $G$ to $H$. If $f$ is a function from $G$ to $H$ such that $f(-x)=-f(x)$ for all $x\\in G$, then $f(n\\cdot a)=n\\cdot f(a)$ for all $a\\in G$ and $n\\in\\mathbb{Z}$."}
{"name": "fderiv_const_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem fderiv_const_add {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} ( : F) :\n\tfderiv \ud835\udd5c (\u03bb (y : E), c + f y) x = fderiv \ud835\udd5c f x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ and $c\\in F$. Then the derivative of $f+c$ at $x$ is the derivative of $f$ at $x$."}
{"name": "derivation.map_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/derivation.lean", "formal_statement": "theorem derivation.map_sum {R : Type*} [comm_semiring R] {A : Type*}\n\t[comm_semiring A] [algebra R A] {M : Type*} [add_comm_monoid M] [module A M]\n\t[module R M] (D : derivation R A M) {\u03b9 : Type*} (s : finset \u03b9) (f : \u03b9 \u2192 A) :\n\t\u21d1D (s.sum (\u03bb (i : \u03b9), f i)) = s.sum (\u03bb (i : \u03b9), \u21d1D (f i)) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a commutative semiring, $M$ an $A$-module, and $D$ a derivation from $R$ to $M$. Then $D$ is a derivation from $A$ to $M$."}
{"name": "list.length_of_fn_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/of_fn.lean", "formal_statement": "theorem list.length_of_fn_aux {\u03b1 : Type u} {n : \u2115} (f : fin n \u2192 \u03b1) (m : \u2115)\n\t(h : m \u2264 n) (l : list \u03b1) :\n\t(list.of_fn_aux f m h l).length = l.length + m :=", "nl_statement_of_codex": "Let $f: \\{0,\\ldots,n-1\\}\\to \\alpha$ and let $l$ be a list of $\\alpha$'s. Then the length of the list $f(0):\\ldots:f(n-1):l$ is $n+l.length$."}
{"name": "order_top.tendsto_at_top_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem order_top.tendsto_at_top_nhds {\u03b2 : Type v} {\u03b1 : Type*} [partial_order \u03b1]\n\t[order_top \u03b1] [topological_space \u03b2] (f : \u03b1 \u2192 \u03b2) :\n\tfilter.tendsto f filter.at_top (nhds (f \u22a4)) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function from a partially ordered set $A$ with a top element to a topological space $B$. Then $f$ tends to $f(\\top)$ at $\\infty$."}
{"name": "dense_embedding.prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/dense_embedding.lean", "formal_statement": "theorem dense_embedding.prod {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [topological_space \u03b3] [topological_space \u03b4] {e\u2081 : \u03b1 \u2192 \u03b2}\n\t{e\u2082 : \u03b3 \u2192 \u03b4} (de\u2081 : dense_embedding e\u2081) (de\u2082 : dense_embedding e\u2082) :\n\tdense_embedding (\u03bb (p : \u03b1 \u00d7 \u03b3), (e\u2081 p.fst, e\u2082 p.snd)) :=", "nl_statement_of_codex": "Let $e_1:A\\to B$ and $e_2:C\\to D$ be dense embeddings. Then the map $e:A\\times C\\to B\\times D$ defined by $e(a,c)=(e_1(a),e_2(c))$ is a dense embedding."}
{"name": "and_or_distrib_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem and_or_distrib_left {a b c : Prop} :\n\ta \u2227 (b \u2228 c) \u2194 a \u2227 b \u2228 a \u2227 c :=", "nl_statement_of_codex": "$(a\\land(b\\lor c))\\iff(a\\land b)\\lor(a\\land c)$."}
{"name": "box_integral.box_additive_map.upper_sub_lower_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/additive.lean", "formal_statement": "theorem box_integral.box_additive_map.upper_sub_lower_apply {n : \u2115} {G : Type u}\n\t[add_comm_group G] (I\u2080 : box_integral.box (fin (n + 1))) (i : fin (n + 1))\n\t(f : \u211d \u2192 box_integral.box (fin n) \u2192 G)\n\t(fb : \u21a5(set.Icc (I\u2080.lower i) (I\u2080.upper i)) \u2192 box_integral.box_additive_map (fin n) G \u2191(I\u2080.face i))\n\t(hf : \u2200 (x : \u211d) (hx : x \u2208 set.Icc (I\u2080.lower i) (I\u2080.upper i)) (J : box_integral.box (fin n)), f x J = \u21d1(fb \u27e8x, hx\u27e9) J)\n\t(J : box_integral.box (fin (n + 1))) :\n\t\u21d1(box_integral.box_additive_map.upper_sub_lower I\u2080 i f fb hf) J = f (J.upper i) (J.face i) - f (J.lower i) (J.face i) :=", "nl_statement_of_codex": "Let $n$ be a natural number, let $G$ be an additive commutative group, let $I_0$ be a box in $\\mathbb{R}^{n+1}$, let $i$ be an element of $\\{0,\\ldots,n\\}$, let $f:\\mathbb{R}\\times\\mathbb{R}^n\\to G$, let $f_b$ be a function from the interval $[I_0.lower(i),I_0.upper(i)]$ to the additive map from $\\mathbb{R}^n$ to $G$ defined by $f_b(x)(J)=f(x,"}
{"name": "is_add_subgroup.trivial_normal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_subgroup.trivial_normal {G : Type*} [add_group G] :\n\tis_normal_add_subgroup (is_add_subgroup.trivial G) :=", "nl_statement_of_codex": "The trivial subgroup of an additive group is a normal subgroup."}
{"name": "algebra.discr_eq_det_embeddings_matrix_reindex_pow_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/discriminant.lean", "formal_statement": "theorem algebra.discr_eq_det_embeddings_matrix_reindex_pow_two {\u03b9 : Type w}\n\t[fintype \u03b9] (K : Type u) {L : Type v} (E : Type z) [field K] [field L]\n\t[field E] [algebra K L] [algebra K E] [module.finite K L] [is_alg_closed E]\n\t(b : \u03b9 \u2192 L) [decidable_eq \u03b9] [is_separable K L] (e : \u03b9 \u2243 (L \u2192\u2090[K] E)) :\n\t\u21d1(algebra_map K E) (algebra.discr K b) = (algebra.embeddings_matrix_reindex K E b e).det ^ 2 :=", "nl_statement_of_codex": "Let $K$ be a field, $L$ be a finite-dimensional $K$-algebra, and $E$ be an algebraically closed field containing $L$. Let $b$ be a basis of $L$ and $e$ be an isomorphism from $L$ to $E$. Then the discriminant of $L$ is equal to the square of the determinant of the matrix of $e$."}
{"name": "category_theory.limits.coprod.desc_comp_inl_comp_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/binary_products.lean", "formal_statement": "theorem category_theory.limits.coprod.desc_comp_inl_comp_inr {C : Type u}\n\t[category_theory.category C] {W X Y Z : C}\n\t[category_theory.limits.has_binary_coproduct W Y]\n\t[category_theory.limits.has_binary_coproduct X Z] (g : W \u27f6 X) (g' : Y \u27f6 Z) :\n\tcategory_theory.limits.coprod.desc (g \u226b category_theory.limits.coprod.inl) (g' \u226b category_theory.limits.coprod.inr) = category_theory.limits.coprod.map g g' :=", "nl_statement_of_codex": "Let $C$ be a category and let $W,X,Y,Z$ be objects of $C$. Suppose that $W\\oplus Y$ and $X\\oplus Z$ exist. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nW\\oplus Y & \\xrightarrow{g\\oplus g'} & X\\oplus Z \\\\\n\\downarrow & & \\downarrow \\\\\nW & \\xrightarrow{g} & X \\\\\n\\downarrow & & \\downarrow \\\\\nY & \\xrightarrow{g'} & Z\n\\end{array}$$"}
{"name": "lie_subalgebra.is_cartan_subalgebra_iff_is_ucs_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/cartan_subalgebra.lean", "formal_statement": "theorem lie_subalgebra.is_cartan_subalgebra_iff_is_ucs_limit {R : Type u}\n\t{L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L]\n\t(H : lie_subalgebra R L) :\n\tH.is_cartan_subalgebra \u2194 H.to_lie_submodule.is_ucs_limit :=", "nl_statement_of_codex": "Let $L$ be a Lie algebra over a commutative ring $R$. Let $H$ be a Lie subalgebra of $L$. Then $H$ is a Cartan subalgebra of $L$ if and only if $H$ is a universal Cartan subalgebra of $L$."}
{"name": "set.Union_lift_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/Union_lift.lean", "formal_statement": "theorem set.Union_lift_mk {\u03b1 \u03b9 \u03b2 : Type*} {S : \u03b9 \u2192 set \u03b1}\n\t{f : \u03a0 (i : \u03b9), \u21a5(S i) \u2192 \u03b2}\n\t{hf : \u2200 (i j : \u03b9) (x : \u03b1) (hxi : x \u2208 S i) (hxj : x \u2208 S j), f i \u27e8x, hxi\u27e9 = f j \u27e8x, hxj\u27e9}\n\t{T : set \u03b1} {hT : T \u2286 set.Union S} {i : \u03b9} (x : \u21a5(S i)) (hx : \u2191x \u2208 T) :\n\tset.Union_lift S f hf T hT \u27e8\u2191x, hx\u27e9 = f i x :=", "nl_statement_of_codex": "Let $S$ be a family of sets indexed by $I$ and let $f:S_i\\to B$ be a family of functions indexed by $I$. Suppose that $f_i(x)=f_j(x)$ whenever $x\\in S_i\\cap S_j$. Let $T$ be a set such that $T\\subset \\bigcup_{i\\in I} S_i$. Then the function $f$ induces a function $f':T\\to B$ by $f'(x)=f_i(x)$ if $x\\in S_i$. Then $f'(x)=f_i(x)$ if $"}
{"name": "add_units.continuous_embed_product", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/constructions.lean", "formal_statement": "theorem add_units.continuous_embed_product {M : Type*} [topological_space M]\n\t[add_monoid M] :\n\tcontinuous \u21d1(add_units.embed_product M) :=", "nl_statement_of_codex": "The map $M\\to M\\times M$ given by $x\\mapsto (x,x)$ is continuous."}
{"name": "category_theory.abelian.pseudoelement.pseudo_zero_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/pseudoelements.lean", "formal_statement": "theorem category_theory.abelian.pseudoelement.pseudo_zero_aux {C : Type u}\n\t[category_theory.category C] [category_theory.abelian C] {P : C} (Q : C)\n\t(f : category_theory.over P) :\n\tf \u2248 \u21910 \u2194 f.hom = 0 :=", "nl_statement_of_codex": "Let $C$ be an abelian category and let $P$ be an object of $C$. Then a morphism $f:P\\to Q$ is zero if and only if $f$ is isomorphic to the zero morphism."}
{"name": "polynomial.nat_degree_prod'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/polynomial/big_operators.lean", "formal_statement": "theorem polynomial.nat_degree_prod' {R : Type u} {\u03b9 : Type w} (s : finset \u03b9)\n\t[comm_semiring R] (f : \u03b9 \u2192 polynomial R)\n\t(h : s.prod (\u03bb (i : \u03b9), (f i).leading_coeff) \u2260 0) :\n\t(s.prod (\u03bb (i : \u03b9), f i)).nat_degree = s.sum (\u03bb (i : \u03b9), (f i).nat_degree) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $f_1,\\ldots,f_n$ be polynomials in $R[x]$. If the leading coefficients of $f_1,\\ldots,f_n$ are nonzero, then the degree of $f_1\\cdots f_n$ is the sum of the degrees of $f_1,\\ldots,f_n$."}
{"name": "convex.combo_interior_self_subset_interior", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/topology.lean", "formal_statement": "theorem convex.combo_interior_self_subset_interior {E \ud835\udd5c : Type*}\n\t[linear_ordered_field \ud835\udd5c] [add_comm_group E] [module \ud835\udd5c E] [topological_space E]\n\t[topological_add_group E] [has_continuous_const_smul \ud835\udd5c E] {s : set E}\n\t(hs : convex \ud835\udd5c s) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n\ta \u2022 interior s + b \u2022 s \u2286 interior s :=", "nl_statement_of_codex": "Let $E$ be a topological vector space over $\\mathbb{R}$ and let $s$ be a convex subset of $E$. Then $a\\cdot\\operatorname{int}(s)+b\\cdot s\\subseteq\\operatorname{int}(s)$ for all $a,b\\in\\mathbb{R}$ such that $0<a$ and $0\\leq b$ and $a+b=1$."}
{"name": "local_equiv.is_image.maps_to", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/local_equiv.lean", "formal_statement": "theorem local_equiv.is_image.maps_to {\u03b1 \u03b2 : Type*} {e : local_equiv \u03b1 \u03b2}\n\t{s : set \u03b1} {t : set \u03b2} (h : e.is_image s t) :\n\tset.maps_to \u21d1e (e.source \u2229 s) (e.target \u2229 t) :=", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Let $A\\subset X$ and $B\\subset Y$. If $e(A)=B$, then $e^{-1}(B)=A$."}
{"name": "linear_map.rtensor_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/tensor_product.lean", "formal_statement": "theorem linear_map.rtensor_id {R : Type*} [comm_semiring R] (M N : Type*)\n\t[add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] :\n\tlinear_map.rtensor M linear_map.id = linear_map.id :=", "nl_statement_of_codex": "The tensor product of the identity map on $M$ with the identity map on $N$ is the identity map on $M\\otimes N$."}
{"name": "hamming_dist_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/information_theory/hamming.lean", "formal_statement": "theorem hamming_dist_pos {\u03b9 \u03b2 : \u03b9 \u2192 Type*} [fintype \u03b9]\n\t[\u03a0 (i : \u03b9), decidable_eq (\u03b2 i)] {x y : \u03a0 (i : \u03b9), \u03b2 i} :\n\t0 < hamming_dist x y \u2194 x \u2260 y :=", "nl_statement_of_codex": "Let $x,y:\\prod_{i\\in I}B_i$ be two elements of the product space. Then $x\\neq y$ if and only if the Hamming distance between $x$ and $y$ is positive."}
{"name": "upper_bounds_smul_of_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/module.lean", "formal_statement": "theorem upper_bounds_smul_of_neg {k M : Type*} [linear_ordered_field k]\n\t[ordered_add_comm_group M] [module k M] [ordered_smul k M] {s : set M} { : k}\n\t(hc : c < 0) :\n\tupper_bounds (c \u2022 s) = c \u2022 lower_bounds s :=", "nl_statement_of_codex": "Let $k$ be a linearly ordered field, $M$ a linearly ordered $k$-module, and $s$ a subset of $M$. If $c<0$, then the upper bounds of $c\\cdot s$ are the scalar multiples of the lower bounds of $s$."}
{"name": "list.drop_left'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.drop_left' {\u03b1 : Type u} {l\u2081 l\u2082 : list \u03b1} {n : \u2115}\n\t(h : l\u2081.length = n) :\n\tlist.drop n (l\u2081 ++ l\u2082) = l\u2082 :=", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of the same type. Let $n$ be a natural number. If $l_1$ has length $n$, then the list obtained by dropping the first $n$ elements of $l_1$ followed by $l_2$ is $l_2$."}
{"name": "nat.binary_rec_eq", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/bitwise.lean", "formal_statement": "theorem nat.binary_rec_eq {C : \u2115 \u2192 Sort u} {z : C 0}\n\t{f : \u03a0 (b : bool) (n : \u2115), C n \u2192 C (nat.bit b n)} (h : f bool.ff 0 z = z)\n\t(b : bool) (n : \u2115) :\n\tnat.binary_rec z f (nat.bit b n) = f b n (nat.binary_rec z f n) :=", "nl_statement_of_codex": "Let $C$ be a family of sets indexed by the natural numbers. Let $z\\in C(0)$ and let $f:C(n)\\to C(2n)$ be a function. Then $f(z)=z$ and $f(2n+b)=f(b,n)$ for $b=0,1$."}
{"name": "set.singleton_inter_nonempty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.singleton_inter_nonempty {\u03b1 : Type u} {a : \u03b1} {s : set \u03b1} :\n\t({a} \u2229 s).nonempty \u2194 a \u2208 s :=", "nl_statement_of_codex": "Let $a$ be an element of a set $S$. Then $\\{a\\}\\cap S$ is nonempty if and only if $a\\in S$."}
{"name": "topological_add_group_Inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem topological_add_group_Inf {G : Type w} [add_group G]\n\t{ts : set (topological_space G)}\n\t(h : \u2200 (t : topological_space G), t \u2208 ts \u2192 topological_add_group G) :\n\ttopological_add_group G :=", "nl_statement_of_codex": "Let $G$ be an additive group. If $G$ is a topological additive group with respect to each topology in a set $T$ of topologies on $G$, then $G$ is a topological additive group with respect to the infimum of the topologies in $T$."}
{"name": "filter.mem_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.mem_smul {\u03b1 \u03b2 : Type*} [has_smul \u03b1 \u03b2] {f : filter \u03b1}\n\t{g : filter \u03b2} {t : set \u03b2} :\n\tt \u2208 f \u2022 g \u2194 \u2203 (t\u2081 : set \u03b1) (t\u2082 : set \u03b2), t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 \u2022 t\u2082 \u2286 t :=", "nl_statement_of_codex": "Let $f$ and $g$ be filters on $\u03b1$ and $\u03b2$ respectively. Then $t\\in f\\cdot g$ if and only if there are $t_1\\in f$ and $t_2\\in g$ such that $t_1\\cdot t_2\\subset t$."}
{"name": "finite_dimensional.eq_of_le_of_finrank_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean", "formal_statement": "theorem finite_dimensional.eq_of_le_of_finrank_eq {K : Type u} {V : Type v}\n\t[division_ring K] [add_comm_group V] [module K V] {S\u2081 S\u2082 : submodule K V}\n\t[finite_dimensional K \u21a5S\u2082] (hle : S\u2081 \u2264 S\u2082)\n\t(hd : finite_dimensional.finrank K \u21a5S\u2081 = finite_dimensional.finrank K \u21a5S\u2082) :\n\tS\u2081 = S\u2082 :=", "nl_statement_of_codex": "Let $K$ be a division ring, $V$ a $K$-module, and $S_1, S_2$ submodules of $V$. If $S_1\\leq S_2$ and $\\dim_K S_1=\\dim_K S_2$, then $S_1=S_2$."}
{"name": "equiv.perm.to_list_pow_apply_eq_rotate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/concrete.lean", "formal_statement": "theorem equiv.perm.to_list_pow_apply_eq_rotate {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] (p : equiv.perm \u03b1) (x : \u03b1) (k : \u2115) :\n\tp.to_list (\u21d1(p ^ k) x) = (p.to_list x).rotate k :=", "nl_statement_of_codex": "Let $p$ be a permutation of a finite set $X$. Then the $k$-th power of $p$ is the rotation of the list of elements of $X$ by $k$."}
{"name": "linear_independent_iff_not_smul_mem_span", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_independent.lean", "formal_statement": "theorem linear_independent_iff_not_smul_mem_span {\u03b9 R M : Type*} {v : \u03b9 \u2192 M}\n\t[ring R] [add_comm_group M] [module R M] :\n\tlinear_independent R v \u2194 \u2200 (i : \u03b9) (a : R), a \u2022 v i \u2208 submodule.span R (v '' (set.univ \\ {i})) \u2192 a = 0 :=", "nl_statement_of_codex": "A set of vectors $v_1,\\ldots,v_n$ is linearly independent if and only if for each $i$ and each $a$, $av_i$ is in the span of $v_1,\\ldots,v_{i-1},v_{i+1},\\ldots,v_n$ only if $a=0$."}
{"name": "pell.eq_pow_of_pell", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/pell.lean", "formal_statement": "theorem pell.eq_pow_of_pell {m n k : \u2115} :\n\tn ^ k = m \u2194 k = 0 \u2227 m = 1 \u2228 0 < k \u2227 (n = 0 \u2227 m = 0 \u2228 0 < n \u2227 \u2203 (w a t z : \u2115) (a1 : 1 < a), pell.xn a1 k \u2261 pell.yn a1 k * (a - n) + m [MOD t] \u2227 2 * a * n = t + (n * n + 1) \u2227 m < t \u2227 n \u2264 w \u2227 k \u2264 w \u2227 a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1) :=", "nl_statement_of_codex": "Let $m, n, k$ be natural numbers. Then $n^k=m$ if and only if $k=0$ and $m=1$ or $k>0$ and $n=0$ and $m=0$ or $n>0$ and there exist $w, a, t, z\\in\\mathbb{N}$ such that $1<a$, $x_k(a)\\equiv y_k(a)(a-n)+m\\pmod{t}$, $2an=t+(n^2+1)$, $m<t$, $n\\leq w$, $k\\leq w$, and $a^"}
{"name": "stream.nth_zip", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/stream/init.lean", "formal_statement": "theorem stream.nth_zip {\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)\n\t(n : \u2115) (s\u2081 : stream \u03b1) (s\u2082 : stream \u03b2) :\n\t(stream.zip f s\u2081 s\u2082).nth n = f (s\u2081.nth n) (s\u2082.nth n) :=", "nl_statement_of_codex": "Let $f:\\alpha\\times\\beta\\to\\delta$ be a function. Then the $n$-th element of the stream $s_1\\times s_2$ is $f(s_1(n),s_2(n))$."}
{"name": "simple_graph.walk.dart_snd_mem_support_of_mem_darts", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.dart_snd_mem_support_of_mem_darts {V : Type u}\n\t{G : simple_graph V} {u v : V} (p : G.walk u v) {d : G.dart} (h : d \u2208 p.darts) :\n\td.to_prod.snd \u2208 p.support :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $u,v$ be vertices of $G$. Let $p$ be a walk from $u$ to $v$ in $G$. Let $d$ be a dart of $G$. If $d$ is a dart of $p$, then the second component of $d$ is a vertex of $p$."}
{"name": "set.indicator_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/indicator_function.lean", "formal_statement": "theorem set.indicator_univ {\u03b1 M : Type*} [has_zero M] (f : \u03b1 \u2192 M) :\n\tset.univ.indicator f = f :=", "nl_statement_of_codex": "The indicator function of the universal set is the identity function."}
{"name": "has_subset.subset.ssubset_of_not_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/rel_classes.lean", "formal_statement": "theorem has_subset.subset.ssubset_of_not_subset {\u03b1 : Type u} [has_subset \u03b1]\n\t[has_ssubset \u03b1]\n\t[is_nonstrict_strict_order \u03b1 has_subset.subset has_ssubset.ssubset] {a b : \u03b1}\n\t(h\u2081 : a \u2286 b) (h\u2082 : \u00acb \u2286 a) :\n\ta \u2282 b :=", "nl_statement_of_codex": "Let $A$ and $B$ be sets. If $A\\subset B$ and $B\\not\\subset A$, then $A\\subsetneq B$."}
{"name": "measurable_set.exists_measurable_proj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_set.exists_measurable_proj {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {s : set \u03b1} (hs : measurable_set s) (hne : s.nonempty) :\n\t\u2203 (f : \u03b1 \u2192 \u21a5s), measurable f \u2227 \u2200 (x : \u21a5s), f \u2191x = x :=", "nl_statement_of_codex": "Let $s$ be a nonempty measurable set. Then there exists a measurable function $f:s\\to s$ such that $f(x)=x$ for all $x\\in s$."}
{"name": "box_integral.integral_sum_sub_partitions", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/basic.lean", "formal_statement": "theorem box_integral.integral_sum_sub_partitions {\u03b9 : Type u} {E : Type v}\n\t{F : Type w} [normed_group E] [normed_space \u211d E] [normed_group F]\n\t[normed_space \u211d F] {I : box_integral.box \u03b9} (f : (\u03b9 \u2192 \u211d) \u2192 E)\n\t(vol : box_integral.box_additive_map \u03b9 (E \u2192L[\u211d] F) \u22a4)\n\t{\u03c0\u2081 \u03c0\u2082 : box_integral.tagged_prepartition I} (h\u2081 : \u03c0\u2081.is_partition)\n\t(h\u2082 : \u03c0\u2082.is_partition) :\n\tbox_integral.integral_sum f vol \u03c0\u2081 - box_integral.integral_sum f vol \u03c0\u2082 = (\u03c0\u2081.to_prepartition \u2293 \u03c0\u2082.to_prepartition).boxes.sum (\u03bb (J : box_integral.box \u03b9), \u21d1(\u21d1vol J) (f ((\u03c0\u2081.inf_prepartition \u03c0\u2082.to_prepartition).tag J)) - \u21d1(\u21d1vol J) (f ((\u03c0\u2082.inf_prepartition \u03c0\u2081.to_prepartition).tag J))) :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed groups and let $f:E\\to F$. Let $\\pi_1$ and $\\pi_2$ be partitions of $I$. Then the integral of $f$ with respect to $\\pi_1$ minus the integral of $f$ with respect to $\\pi_2$ is equal to the sum of the integrals of $f$ with respect to the partitions $\\pi_1\\cap\\pi_2$ and $\\pi_2\\cap\\pi_1$."}
{"name": "supr\u2082_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/complete_lattice.lean", "formal_statement": "theorem supr\u2082_le_iff {\u03b1 : Type*} {\u03b9 : Sort u_5} {\u03ba : \u03b9 \u2192 Sort u_7}\n\t[complete_lattice \u03b1] {a : \u03b1} {f : \u03a0 (i : \u03b9), \u03ba i \u2192 \u03b1} :\n\t(\u2a06 (i : \u03b9) (j : \u03ba i), f i j) \u2264 a \u2194 \u2200 (i : \u03b9) (j : \u03ba i), f i j \u2264 a :=", "nl_statement_of_codex": "Let $A$ be a complete lattice. Then $\\sup_{i\\in I, j\\in J_i} f(i,j)\\leq a$ if and only if $f(i,j)\\leq a$ for all $i\\in I$ and $j\\in J_i$."}
{"name": "ennreal.eventually_eq_of_to_real_eventually_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.eventually_eq_of_to_real_eventually_eq {\u03b1 : Type*}\n\t{l : filter \u03b1} {f g : \u03b1 \u2192 ennreal} (hfi : \u2200\u1da0 (x : \u03b1) in l, f x \u2260 \u22a4)\n\t(hgi : \u2200\u1da0 (x : \u03b1) in l, g x \u2260 \u22a4)\n\t(hfg : (\u03bb (x : \u03b1), (f x).to_real) =\u1da0[l] \u03bb (x : \u03b1), (g x).to_real) :\n\tf =\u1da0[l] g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\mathbb{R}_{\\geq 0}$ be functions. If $f(x)\\neq\\infty$ and $g(x)\\neq\\infty$ for all $x\\in\\alpha$, and if $f(x)=g(x)$ for all $x\\in\\alpha$, then $f=g$."}
{"name": "list.nodup.inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/nodup.lean", "formal_statement": "theorem list.nodup.inter {\u03b1 : Type u} {l\u2081 : list \u03b1} [decidable_eq \u03b1]\n\t(l\u2082 : list \u03b1) :\n\tl\u2081.nodup \u2192 (l\u2081 \u2229 l\u2082).nodup :=", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of elements of a type $\u03b1$. If $l_1$ has no duplicates, then $l_1\\cap l_2$ has no duplicates."}
{"name": "primrec.comp\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/primrec.lean", "formal_statement": "theorem primrec.comp\u2082 {\u03b1 \u03b2 \u03b3 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2]\n\t[primcodable \u03b3] [primcodable \u03c3] {f : \u03b3 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : primrec f)\n\t(hg : primrec\u2082 g) :\n\tprimrec\u2082 (\u03bb (a : \u03b1) (b : \u03b2), f (g a b)) :=", "nl_statement_of_codex": "If $f:\\gamma\\to\\sigma$ and $g:\\alpha\\times\\beta\\to\\gamma$ are primitive recursive, then so is $f\\circ g:\\alpha\\times\\beta\\to\\sigma$."}
{"name": "pSet.exists_equiv_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/zfc.lean", "formal_statement": "theorem pSet.exists_equiv_left {x : pSet} {y : pSet} (h : x.equiv y)\n\t(i : x.type) :\n\t\u2203 (j : y.type), (x.func i).equiv (y.func j) :=", "nl_statement_of_codex": "Let $x$ and $y$ be pointed sets. If $x$ and $y$ are equivalent, then for each $i\\in x$ there is a $j\\in y$ such that $x(i)$ and $y(j)$ are equivalent."}
{"name": "mul_hom.prod_map_comap_prod'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem mul_hom.prod_map_comap_prod' {M N : Type*} [has_mul M] [has_mul N]\n\t{M' N' : Type*} [has_mul M'] [has_mul N'] (f : M \u2192\u2099* N) (g : M' \u2192\u2099* N')\n\t(S : subsemigroup N) (S' : subsemigroup N') :\n\tsubsemigroup.comap (f.prod_map g) (S.prod S') = (subsemigroup.comap f S).prod (subsemigroup.comap g S') :=", "nl_statement_of_codex": "Let $M, N, M', N'$ be semigroups and let $f:M\\to N$ and $g:M'\\to N'$ be semigroup homomorphisms. Let $S$ be a subsemigroup of $N$ and $S'$ be a subsemigroup of $N'$. Then the preimage of $S\\times S'$ under $f\\times g$ is equal to the product of the preimages of $S$ and $S'$ under $f$ and $g$, respectively."}
{"name": "lie_algebra.exists_engelian_lie_subalgebra_of_lt_normalizer", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/engel.lean", "formal_statement": "theorem lie_algebra.exists_engelian_lie_subalgebra_of_lt_normalizer\n\t{R : Type u\u2081} {L : Type u\u2082} [comm_ring R] [lie_ring L] [lie_algebra R L]\n\t{K : lie_subalgebra R L} (hK\u2081 : lie_algebra.is_engelian R \u21a5K)\n\t(hK\u2082 : K < K.normalizer) :\n\t\u2203 (K' : lie_subalgebra R L) (hK' : lie_algebra.is_engelian R \u21a5K'), K < K' :=", "nl_statement_of_codex": "Let $L$ be a Lie algebra over a commutative ring $R$. Let $K$ be an Engelian Lie subalgebra of $L$ such that $K$ is a proper subalgebra of its normalizer. Then there exists an Engelian Lie subalgebra $K'$ of $L$ such that $K$ is a proper subalgebra of $K'$."}
{"name": "set.sep_mem_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.sep_mem_eq {\u03b1 : Type u} {s t : set \u03b1} :\n\t{x \u2208 s | x \u2208 t} = s \u2229 t :=", "nl_statement_of_codex": "The set $\\{x\\in s\\mid x\\in t\\}$ is equal to $s\\cap t$."}
{"name": "roots_of_unity.coe_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/roots_of_unity.lean", "formal_statement": "theorem roots_of_unity.coe_pow {R : Type*} {k : \u2115+} [comm_monoid R]\n\t(\u03b6 : \u21a5(roots_of_unity k R)) (m : \u2115) :\n\t\u2191(\u03b6 ^ m) = \u2191\u03b6 ^ m :=", "nl_statement_of_codex": "Let $R$ be a commutative monoid and let $k$ be a positive integer. Let $\\zeta$ be a root of unity of order $k$ in $R$. Then $\\zeta^m$ is a root of unity of order $k$ in $R$."}
{"name": "star_mul'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/star/basic.lean", "formal_statement": "theorem star_mul' {R : Type u} [comm_semigroup R] [star_semigroup R] (x y : R) :\n\thas_star.star (x * y) = has_star.star x * has_star.star y :=", "nl_statement_of_codex": "Let $R$ be a commutative semigroup with an involution. Then the involution is a homomorphism."}
{"name": "homotopy_category.homology_functor_map_factors", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/homotopy_category.lean", "formal_statement": "theorem homotopy_category.homology_functor_map_factors {\u03b9 : Type*} (V : Type u)\n\t[category_theory.category V] [category_theory.preadditive V]\n\t( : complex_shape \u03b9) [category_theory.limits.has_zero_object V]\n\t[category_theory.limits.has_equalizers V] [category_theory.limits.has_images V]\n\t[category_theory.limits.has_image_maps V]\n\t[category_theory.limits.has_cokernels V] (i : \u03b9)\n\t{C D : homological_complex V c} (f : C \u27f6 D) :\n\t(homology_functor V c i).map f = (homotopy_category.homology_functor V c i).map ((homotopy_category.quotient V c).map f) :=", "nl_statement_of_codex": "Let $V$ be a preadditive category with zero object, equalizers, images, image maps, and cokernels. Let $c$ be a complex shape. Let $C$ and $D$ be homological complexes of shape $c$ over $V$. Let $f:C\\to D$ be a morphism of complexes. Then the map $f$ induces a map $f_*:H_i(C)\\to H_i(D)$."}
{"name": "tendsto_const_uniformity", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem tendsto_const_uniformity {\u03b1 \u03b2 : Type*} [uniform_space \u03b1] {a : \u03b1}\n\t{f : filter \u03b2} :\n\tfilter.tendsto (\u03bb (_x : \u03b2), (a, a)) f (uniformity \u03b1) :=", "nl_statement_of_codex": "Let $\u03b1$ be a uniform space and let $a$ be an element of $\u03b1$. Then the constant function $f:\u03b2\\to \u03b1$ with $f(x)=a$ for all $x\\in \u03b2$ converges uniformly to $a$."}
{"name": "category_theory.functor.monotone", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/preorder.lean", "formal_statement": "theorem category_theory.functor.monotone {X : Type u} {Y : Type v} [preorder X]\n\t[preorder Y] (f : X \u2964 Y) :\n\tmonotone f.obj :=", "nl_statement_of_codex": "Let $X$ and $Y$ be preorders and let $f:X\\to Y$ be a functor. Then $f$ is monotone."}
{"name": "linear_map.trace_aux_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/trace.lean", "formal_statement": "theorem linear_map.trace_aux_eq (R : Type u) [comm_semiring R] {M : Type v}\n\t[add_comm_monoid M] [module R M] {\u03b9 : Type w} [decidable_eq \u03b9] [fintype \u03b9]\n\t{\u03ba : Type*} [decidable_eq \u03ba] [fintype \u03ba] (b : basis \u03b9 R M) ( : basis \u03ba R M) :\n\tlinear_map.trace_aux R b = linear_map.trace_aux R c :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, and $b$ and $c$ bases of $M$. Then the trace of the identity map on $M$ with respect to $b$ is equal to the trace of the identity map on $M$ with respect to $c$."}
{"name": "category_theory.eq_to_hom_comp_shift_add_inv\u2081_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/shift.lean", "formal_statement": "theorem category_theory.eq_to_hom_comp_shift_add_inv\u2081_assoc {C : Type u}\n\t{A : Type*} [category_theory.category C] [add_monoid A]\n\t[category_theory.has_shift C A] (X : C) (i i' j : A) (h : i = i') {X' : C}\n\t(f' : (category_theory.shift_functor C (i' + j)).obj X \u27f6 X') :\n\tcategory_theory.eq_to_hom _ \u226b (category_theory.shift_add X i' j).inv \u226b f' = (category_theory.shift_add X i j).inv \u226b category_theory.eq_to_hom _ \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, $A$ an additive monoid, and $X$ an object of $C$. Let $i, i', j$ be elements of $A$ and let $f':X\\to X'$ be a morphism in $C$. If $i=i'$, then the following diagram commutes:\n\\begin{tikzcd}\nX \\arrow[r, "}
{"name": "add_monoid_hom.add_submonoid_comap_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem add_monoid_hom.add_submonoid_comap_apply_coe {M N : Type*}\n\t[add_zero_class M] [add_zero_class N] (f : M \u2192+ N) (N' : add_submonoid N)\n\t(x : \u21a5(add_submonoid.comap f N')) :\n\t\u2191(\u21d1(f.add_submonoid_comap N') x) = \u21d1f \u2191x :=", "nl_statement_of_codex": "Let $f:M\\to N$ be an additive monoid homomorphism. Let $N'$ be an additive submonoid of $N$. Then the induced map $f':M\\to N'$ is an additive monoid homomorphism."}
{"name": "monoid_hom.comp_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem monoid_hom.comp_mul {M N P : Type*} [mul_one_class M] [comm_monoid N]\n\t[comm_monoid P] (g : N \u2192* P) (f\u2081 f\u2082 : M \u2192* N) :\n\tg.comp (f\u2081 * f\u2082) = g.comp f\u2081 * g.comp f\u2082 :=", "nl_statement_of_codex": "Let $M, N, P$ be commutative monoids. Let $f_1, f_2:M\\to N$ and $g:N\\to P$ be monoid homomorphisms. Then $g\\circ(f_1\\cdot f_2)=(g\\circ f_1)\\cdot(g\\circ f_2)$."}
{"name": "zmod.val_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/zmod/basic.lean", "formal_statement": "theorem zmod.val_lt {n : \u2115} [fact (0 < n)] (a : zmod n) :\n\ta.val < n :=", "nl_statement_of_codex": "Let $n$ be a positive integer. Then the value of an element of $\\mathbb{Z}/n\\mathbb{Z}$ is less than $n$."}
{"name": "complex.im_clm_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/basic.lean", "formal_statement": "theorem complex.im_clm_coe :\n\t\u2191complex.im_clm = complex.im_lm :=", "nl_statement_of_codex": "The complex linear map $z\\mapsto \\mathrm{Im}(z)$ is equal to the complex linear map $z\\mapsto \\mathrm{Im}(z)$."}
{"name": "measure_theory.ae_eq_fun.integrable.smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l1_space.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.integrable.smul {\u03b1 \u03b2 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_group \u03b2]\n\t{\ud835\udd5c : Type*} [normed_field \ud835\udd5c] [normed_space \ud835\udd5c \u03b2] { : \ud835\udd5c} {f : \u03b1 \u2192\u2098[\u03bc] \u03b2} :\n\tf.integrable \u2192 (c \u2022 f).integrable :=", "nl_statement_of_codex": "Let $f:X\\to\\mathbb{R}$ be a measurable function. If $f$ is integrable, then so is $cf$."}
{"name": "set.subset_compl_singleton_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.subset_compl_singleton_iff {\u03b1 : Type u} {a : \u03b1} {s : set \u03b1} :\n\ts \u2286 {a}\u1d9c \u2194 a \u2209 s :=", "nl_statement_of_codex": "$s\\subseteq \\{a\\}^c$ if and only if $a\\notin s$."}