{"name": "int.not_even_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/parity.lean", "formal_statement": "theorem int.not_even_iff {n : \u2124} :\n\t\u00aceven n \u2194 n % 2 = 1 :=", "nl_statement_of_codex": "An integer $n$ is odd if and only if $n\\equiv 1\\pmod{2}$."}
{"name": "complex.sin_sq_add_cos_sq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/exponential.lean", "formal_statement": "theorem complex.sin_sq_add_cos_sq (x : \u2102) :\n\tcomplex.sin x ^ 2 + complex.cos x ^ 2 = 1 :=", "nl_statement_of_codex": "$\\sin^2(x)+\\cos^2(x)=1$."}
{"name": "punit.le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/punit_instances.lean", "formal_statement": "theorem punit.le (x y : punit) :\n\tx \u2264 y :=", "nl_statement_of_codex": "The partial order on the unit circle is the usual order on the real numbers."}
{"name": "add_monoid_algebra.non_unital_alg_hom_ext'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/monoid_algebra/basic.lean", "formal_statement": "theorem add_monoid_algebra.non_unital_alg_hom_ext' (k : Type u\u2081) {G : Type u\u2082}\n\t[semiring k] [has_add G] {A : Type u\u2083} [non_unital_non_assoc_semiring A]\n\t[distrib_mul_action k A] {\u03c6\u2081 \u03c6\u2082 : add_monoid_algebra k G \u2192\u2099\u2090[k] A}\n\t(h : \u03c6\u2081.to_mul_hom.comp (add_monoid_algebra.of_magma k G) = \u03c6\u2082.to_mul_hom.comp (add_monoid_algebra.of_magma k G)) :\n\t\u03c6\u2081 = \u03c6\u2082 :=", "nl_statement_of_codex": "Let $k$ be a semiring, $G$ an additive monoid, $A$ a non-unital non-associative semiring, and $\\phi_1,\\phi_2:k[G]\\to A$ non-unital algebra homomorphisms. If $\\phi_1$ and $\\phi_2$ agree on the underlying additive monoid, then $\\phi_1=\\phi_2$."}
{"name": "sym.cons_inj_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sym/basic.lean", "formal_statement": "theorem sym.cons_inj_left {\u03b1 : Type*} {n : \u2115} (a a' : \u03b1) (s : sym \u03b1 n) :\n\ta ::\u209b s = a' ::\u209b s \u2194 a = a' :=", "nl_statement_of_codex": "Let $a, a'$ be elements of a type $\u03b1$ and let $s$ be a symmetric sequence of length $n$ in $\u03b1$. Then $a::s=a'::s$ if and only if $a=a'$."}
{"name": "is_closed_supr_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order.lean", "formal_statement": "theorem is_closed_supr_iff {\u03b1 : Type u} {\u03b9 : Sort v}\n\t{t : \u03b9 \u2192 topological_space \u03b1} {s : set \u03b1} :\n\tis_closed s \u2194 \u2200 (i : \u03b9), is_closed s :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a subset of $X$. Then $A$ is closed if and only if $A$ is closed in each subspace of $X$."}
{"name": "ordnode.raised.dist_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.raised.dist_le {n m : \u2115} (H : ordnode.raised n m) :\n\tn.dist m \u2264 1 :=", "nl_statement_of_codex": "If $n$ and $m$ are in the same level of the ordinal tree, then $n$ and $m$ are at most one apart."}
{"name": "multiplicity.multiplicity_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/multiplicity.lean", "formal_statement": "theorem multiplicity.multiplicity_self {\u03b1 : Type*}\n\t[cancel_comm_monoid_with_zero \u03b1] [decidable_rel has_dvd.dvd] {a : \u03b1}\n\t(ha : \u00acis_unit a) (ha0 : a \u2260 0) :\n\tmultiplicity a a = 1 :=", "nl_statement_of_codex": "The multiplicity of $a$ in $a$ is $1$."}
{"name": "category_theory.limits.bicone.to_cocone_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.bicone.to_cocone_X {J : Type w} {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{F : J \u2192 C} (B : category_theory.limits.bicone F) :\n\tB.to_cocone.X = B.X :=", "nl_statement_of_codex": "The limit of a diagram $F:J\\to C$ is the same as the limit of the diagram $F$ restricted to the full subcategory of $J$ on the objects $j\\in J$."}
{"name": "convex.norm_image_sub_le_of_norm_fderiv_within_le'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/mean_value.lean", "formal_statement": "theorem convex.norm_image_sub_le_of_norm_fderiv_within_le' {E : Type*}\n\t[normed_group E] [normed_space \u211d E] {\ud835\udd5c G : Type*} [is_R_or_C \ud835\udd5c]\n\t[normed_space \ud835\udd5c E] [normed_group G] [normed_space \ud835\udd5c G] {f : E \u2192 G} {C : \u211d}\n\t{s : set E} {x y : E} {\u03c6 : E \u2192L[\ud835\udd5c] G} (hf : differentiable_on \ud835\udd5c f s)\n\t(bound : \u2200 (x : E), x \u2208 s \u2192 \u2225fderiv_within \ud835\udd5c f s x - \u03c6\u2225 \u2264 C) (hs : convex \u211d s)\n\t(xs : x \u2208 s) (ys : y \u2208 s) :\n\t\u2225f y - f x - \u21d1\u03c6 (y - x)\u2225 \u2264 C * \u2225y - x\u2225 :=", "nl_statement_of_codex": "Let $E$ and $G$ be normed spaces over $\\mathbb{R}$ or $\\mathbb{C}$. Let $f:E\\to G$ be differentiable on a convex set $s\\subset E$. Suppose that for each $x\\in s$ there is a linear map $\\phi_x:E\\to G$ such that $\\|f'(x)-\\phi_x\\|\\leq C$. Then for all $x,y\\in s$ we have $\\|f(y)-f(x)-\\phi_x(y-x)\\|\\leq C\\|y-x\\|$."}
{"name": "nat.arithmetic_function.coe_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/arithmetic_function.lean", "formal_statement": "theorem nat.arithmetic_function.coe_inj {R : Type*} [has_zero R]\n\t{f g : nat.arithmetic_function R} :\n\t\u21d1f = \u21d1g \u2194 f = g :=", "nl_statement_of_codex": "Two arithmetic functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(n)=g(n)$ for all $n\\in\\mathbb{N}$."}
{"name": "category_theory.limits.has_colimit.iso_of_nat_iso_inv_desc_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/has_limits.lean", "formal_statement": "theorem category_theory.limits.has_colimit.iso_of_nat_iso_inv_desc_assoc\n\t{J : Type u\u2081} [category_theory.category J] {C : Type u}\n\t[category_theory.category C] {F G : J \u2964 C}\n\t[category_theory.limits.has_colimit F] [category_theory.limits.has_colimit G]\n\t(t : category_theory.limits.cocone F) (w : F \u2245 G) {X' : C} (f' : t.X \u27f6 X') :\n\t(category_theory.limits.has_colimit.iso_of_nat_iso w).inv \u226b category_theory.limits.colimit.desc F t \u226b f' = category_theory.limits.colimit.desc G ((category_theory.limits.cocones.precompose w.inv).obj t) \u226b f' :=", "nl_statement_of_codex": "Let $F,G:J\\to C$ be functors and let $w:F\\to G$ be a natural isomorphism. Then the diagram\n$$\\require{AMScd}\n\\begin{CD}\nF @>w>> G\\\\\n@VVV @VVV\\\\\nt.X @>f'>> X'\n\\end{CD}\n$$\ncommutes if and only if the diagram\n$$\\require{AMScd}\n\\begin{CD}\nF @>w^{-1}>> G\\\\\n@VVV @VVV\\\\\nt.X @>f'>> X'\n\\end{CD}"}
{"name": "measure_theory.ae_eq_fun.coe_fn_pair", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ae_eq_fun.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.coe_fn_pair {\u03b1 \u03b2 \u03b3 : Type*}\n\t[measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2]\n\t[topological_space \u03b3] (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) :\n\t\u21d1(f.pair g) =\u1d50[\u03bc] \u03bb (x : \u03b1), (\u21d1f x, \u21d1g x) :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be measurable functions. Then the function $h:X\\to Y\\times Z$ defined by $h(x)=(f(x),g(x))$ is measurable."}
{"name": "set.Union\u2082_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.Union\u2082_sub {\u03b1 : Type*} {\u03b9 : Sort u_5} {\u03ba : \u03b9 \u2192 Sort u_6} [has_sub \u03b1]\n\t(s : \u03a0 (i : \u03b9), \u03ba i \u2192 set \u03b1) (t : set \u03b1) :\n\t(\u22c3 (i : \u03b9) (j : \u03ba i), s i j) - t = \u22c3 (i : \u03b9) (j : \u03ba i), s i j - t :=", "nl_statement_of_codex": "Let $s$ be a family of sets indexed by a family of sets $\\kappa_i$ indexed by $i\\in I$. Then $(\\bigcup_{i\\in I, j\\in \\kappa_i} s_{i,j})-t = \\bigcup_{i\\in I, j\\in \\kappa_i} (s_{i,j}-t)$."}
{"name": "matrix.sub_mul_vec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem matrix.sub_mul_vec {m n : Type*} {\u03b1 : Type v}\n\t[non_unital_non_assoc_ring \u03b1] [fintype n] (A B : matrix m n \u03b1) (x : n \u2192 \u03b1) :\n\t(A - B).mul_vec x = A.mul_vec x - B.mul_vec x :=", "nl_statement_of_codex": "Let $A$ and $B$ be $m\\times n$ matrices over a ring $R$ and let $x$ be an $n$-tuple of elements of $R$. Then $(A-B)x=Ax-Bx$."}
{"name": "path.add_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/path_connected.lean", "formal_statement": "theorem path.add_apply {X : Type*} [topological_space X] [has_add X]\n\t[has_continuous_add X] {a\u2081 b\u2081 a\u2082 b\u2082 : X} (\u03b3\u2081 : path a\u2081 b\u2081) (\u03b3\u2082 : path a\u2082 b\u2082)\n\t(t : \u21a5unit_interval) :\n\t\u21d1(\u03b3\u2081.add \u03b3\u2082) t = \u21d1\u03b3\u2081 t + \u21d1\u03b3\u2082 t :=", "nl_statement_of_codex": "Let $X$ be a topological space with addition and continuous addition. Let $a_1,b_1,a_2,b_2\\in X$ and let $\\gamma_1,\\gamma_2$ be paths from $a_1$ to $b_1$ and $a_2$ to $b_2$, respectively. Then the path $\\gamma_1+\\gamma_2$ is the path from $a_1+a_2$ to $b_1+b_2$."}
{"name": "mv_polynomial.is_noetherian_ring_fin_0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.is_noetherian_ring_fin_0 {R : Type u} [comm_ring R]\n\t[is_noetherian_ring R] :\n\tis_noetherian_ring (mv_polynomial (fin 0) R) :=", "nl_statement_of_codex": "The ring of multivariate polynomials over a noetherian ring is noetherian."}
{"name": "add_submonoid.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/basic.lean", "formal_statement": "theorem add_submonoid.ext {M : Type*} [add_zero_class M] {S T : add_submonoid M}\n\t(h : \u2200 (x : M), x \u2208 S \u2194 x \u2208 T) :\n\tS = T :=", "nl_statement_of_codex": "Let $M$ be an additive monoid with zero. Let $S$ and $T$ be additive submonoids of $M$. Then $S=T$ if and only if $S$ and $T$ have the same elements."}
{"name": "BoolRing.has_forget_to_CommRing_forget\u2082_obj_str_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/BoolRing.lean", "formal_statement": "theorem BoolRing.has_forget_to_CommRing_forget\u2082_obj_str_zero\n\t(X : category_theory.bundled boolean_ring) :\n\t0 = ring.zero :=", "nl_statement_of_codex": "The zero of a boolean ring is the same as the zero of a ring."}
{"name": "function.comp_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.comp_apply {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03c6 : Sort w} (f : \u03b2 \u2192 \u03c6)\n\t(g : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n\t(f \u2218 g) a = f (g a) :=", "nl_statement_of_codex": "Let $f:B\\to C$ and $g:A\\to B$. Then $(f\\circ g)(a)=f(g(a))$ for all $a\\in A$."}
{"name": "smooth_partition_of_unity.sum_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/partition_of_unity.lean", "formal_statement": "theorem smooth_partition_of_unity.sum_eq_one {\u03b9 : Type u\u03b9} {E : Type uE}\n\t[normed_group E] [normed_space \u211d E] [finite_dimensional \u211d E] {H : Type uH}\n\t[topological_space H] {I : model_with_corners \u211d E H} {M : Type uM}\n\t[topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]\n\t{s : set M} (f : smooth_partition_of_unity \u03b9 I M s) {x : M} (hx : x \u2208 s) :\n\tfinsum (\u03bb (i : \u03b9), \u21d1(\u21d1f i) x) = 1 :=", "nl_statement_of_codex": "Let $M$ be a smooth manifold with corners and let $s$ be a subset of $M$. Let $f$ be a smooth partition of unity subordinate to $s$. Then $\\sum_{i\\in I} f_i(x)=1$ for all $x\\in s$."}
{"name": "filter.map_vadd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.map_vadd {\u03b1 \u03b2 : Type*} [has_vadd \u03b1 \u03b2] {f : filter \u03b2} {a : \u03b1} :\n\tfilter.map (\u03bb (b : \u03b2), a +\u1d65 b) f = a +\u1d65 f :=", "nl_statement_of_codex": "Let $f$ be a filter on a vector space $V$ and let $a\\in V$. Then the filter $a+f$ is equal to the filter $f$ translated by $a$."}
{"name": "multiset.nodup.cons", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/nodup.lean", "formal_statement": "theorem multiset.nodup.cons {\u03b1 : Type*} {s : multiset \u03b1} {a : \u03b1} (m : a \u2209 s)\n\t(n : s.nodup) :\n\t(a ::\u2098 s).nodup :=", "nl_statement_of_codex": "If $a$ is not in $s$ and $s$ is a multiset without duplicates, then $a::s$ is a multiset without duplicates."}
{"name": "category_theory.eq_to_hom_comp_shift_add_inv\u2081", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/shift.lean", "formal_statement": "theorem category_theory.eq_to_hom_comp_shift_add_inv\u2081 {C : Type u} {A : Type*}\n\t[category_theory.category C] [add_monoid A] [category_theory.has_shift C A]\n\t(X : C) (i i' j : A) (h : i = i') :\n\tcategory_theory.eq_to_hom _ \u226b (category_theory.shift_add X i' j).inv = (category_theory.shift_add X i j).inv \u226b category_theory.eq_to_hom _ :=", "nl_statement_of_codex": "Let $C$ be a category, $A$ an additive monoid, and $X$ an object of $C$. Let $i, i', j$ be elements of $A$. If $i=i'$, then the morphism $X\\to X$ induced by $i'+j$ is the inverse of the morphism $X\\to X$ induced by $i+j$."}
{"name": "min_le_of_left_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/min_max.lean", "formal_statement": "theorem min_le_of_left_le {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} :\n\ta \u2264 c \u2192 linear_order.min a b \u2264 c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order. If $a\\leq c$, then $\\min(a,b)\\leq c$."}
{"name": "add_subgroup.comap_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.comap_injective {G : Type*} [add_group G] {N : Type*}\n\t[add_group N] {f : G \u2192+ N} (h : function.surjective \u21d1f) :\n\tfunction.injective (add_subgroup.comap f) :=", "nl_statement_of_codex": "Let $G$ and $N$ be additive groups and let $f:G\\to N$ be a surjective homomorphism. Then the induced map $f^*:N^*\\to G^*$ is injective."}
{"name": "has_sum.add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean", "formal_statement": "theorem has_sum.add {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1} [has_continuous_add \u03b1] (hf : has_sum f a)\n\t(hg : has_sum g b) :\n\thas_sum (\u03bb (b : \u03b2), f b + g b) (a + b) :=", "nl_statement_of_codex": "Let $f,g:\\beta\\to\\alpha$ be functions. If $f$ and $g$ have sums $a$ and $b$, respectively, then the function $h:\\beta\\to\\alpha$ defined by $h(b)=f(b)+g(b)$ has sum $a+b$."}
{"name": "category_theory.yoneda_equiv_symm_app_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/yoneda.lean", "formal_statement": "theorem category_theory.yoneda_equiv_symm_app_apply {C : Type u\u2081}\n\t[category_theory.category C] {X : C} {F : C\u1d52\u1d56 \u2964 Type v\u2081}\n\t(x : F.obj (opposite.op X)) (Y : C\u1d52\u1d56) (f : opposite.unop Y \u27f6 X) :\n\t(\u21d1(category_theory.yoneda_equiv.symm) x).app Y f = F.map f.op x :=", "nl_statement_of_codex": "Let $C$ be a category, $X$ an object of $C$, and $F:C^{op}\\to Set$ a functor. Let $x:F(X)$ and $Y$ be objects of $C^{op}$. Then the application of the inverse of the Yoneda embedding of $F$ to $x$ at $Y$ is equal to the image of $x$ under the functor $F$ along the morphism $f:Y\\to X$."}
{"name": "category_theory.is_iso_iff_mono_and_epi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/balanced.lean", "formal_statement": "theorem category_theory.is_iso_iff_mono_and_epi {C : Type u}\n\t[category_theory.category C] [category_theory.balanced C] {X Y : C} (f : X \u27f6 Y) :\n\tcategory_theory.is_iso f \u2194 category_theory.mono f \u2227 category_theory.epi f :=", "nl_statement_of_codex": "Let $C$ be a category. A morphism $f:X\\to Y$ is an isomorphism if and only if $f$ is both monic and epic."}
{"name": "topological_space.opens.map_id_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Top/opens.lean", "formal_statement": "theorem topological_space.opens.map_id_eq (X : Top) :\n\ttopological_space.opens.map (\ud835\udfd9 X) = \ud835\udfed (topological_space.opens \u21a5X) :=", "nl_statement_of_codex": "The map $id_X:X\\to X$ induces the identity map on the lattice of open sets of $X$."}
{"name": "function.comp.left_id", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/function.lean", "formal_statement": "theorem function.comp.left_id {\u03b1 : Sort u\u2081} {\u03b2 : Sort u\u2082} (f : \u03b1 \u2192 \u03b2) :\n\tid \u2218 f = f :=", "nl_statement_of_codex": "The identity function is the left identity of the composition of functions."}
{"name": "SemiNormedGroup.comp_explicit_cokernel_\u03c0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/SemiNormedGroup/kernels.lean", "formal_statement": "theorem SemiNormedGroup.comp_explicit_cokernel_\u03c0 {X Y : SemiNormedGroup}\n\t(f : X \u27f6 Y) :\n\tf \u226b SemiNormedGroup.explicit_cokernel_\u03c0 f = 0 :=", "nl_statement_of_codex": "Let $X$ and $Y$ be seminormed groups and let $f:X\\to Y$. Then $f$ factors through the cokernel of $f$."}
{"name": "category_theory.limits.limit.w", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/has_limits.lean", "formal_statement": "theorem category_theory.limits.limit.w {J : Type u\u2081}\n\t[category_theory.category J] {C : Type u} [category_theory.category C]\n\t(F : J \u2964 C) [category_theory.limits.has_limit F] {j j' : J} (f : j \u27f6 j') :\n\tcategory_theory.limits.limit.\u03c0 F j \u226b F.map f = category_theory.limits.limit.\u03c0 F j' :=", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor. Then the diagram $F$ has a limit if and only if for each $j\\in J$ there is a morphism $w_j:F(j)\\to L$ such that for each $f:j\\to j'$ in $J$ we have $w_{j'}\\circ F(f)=w_j$."}
{"name": "norm_le_add_norm_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem norm_le_add_norm_add {E : Type*} [semi_normed_group E] (u v : E) :\n\t\u2225u\u2225 \u2264 \u2225u + v\u2225 + \u2225v\u2225 :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group. Then for all $u,v\\in E$, $\\|u\\|\\leq \\|u+v\\|+\\|v\\|$."}
{"name": "subalgebra.coe_to_subring", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem subalgebra.coe_to_subring {R : Type u} {A : Type v} [comm_ring R]\n\t[ring A] [algebra R A] (S : subalgebra R A) :\n\t\u2191(S.to_subring) = \u2191S :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $A$ be an $R$-algebra. Let $S$ be a subalgebra of $A$. Then $S$ is a subring of $A$."}
{"name": "monovary.sum_mul_comp_perm_lt_sum_mul_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/rearrangement.lean", "formal_statement": "theorem monovary.sum_mul_comp_perm_lt_sum_mul_iff {\u03b9 \u03b1 : Type*}\n\t[linear_ordered_ring \u03b1] {\u03c3 : equiv.perm \u03b9} {f g : \u03b9 \u2192 \u03b1} [fintype \u03b9]\n\t(hfg : monovary f g) :\n\tfinset.univ.sum (\u03bb (i : \u03b9), f i * g (\u21d1\u03c3 i)) < finset.univ.sum (\u03bb (i : \u03b9), f i * g i) \u2194 \u00acmonovary f (g \u2218 \u21d1\u03c3) :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be monotone functions. Then $f$ is monotone with respect to $g\\circ\\sigma$ if and only if $\\sum_{i=1}^n f(i)g(\\sigma(i))\\geq\\sum_{i=1}^n f(i)g(i)$ for all $n\\in\\mathbb{N}$."}
{"name": "basis.to_lin_to_matrix", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/basis.lean", "formal_statement": "theorem basis.to_lin_to_matrix {\u03b9 \u03b9' R M : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [module R M] (e : basis \u03b9 R M) [fintype \u03b9] [fintype \u03b9']\n\t[decidable_eq \u03b9'] (v : basis \u03b9' R M) :\n\t\u21d1(matrix.to_lin v e) (e.to_matrix \u21d1v) = linear_map.id :=", "nl_statement_of_codex": "Let $M$ be a module over a commutative semiring $R$. Let $e$ and $v$ be bases of $M$. Then the matrix of the linear map $e\\to v$ is the matrix of the linear map $v\\to e$."}
{"name": "multiset.count_filter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.count_filter {\u03b1 : Type*} [decidable_eq \u03b1] {p : \u03b1 \u2192 Prop}\n\t[decidable_pred p] {a : \u03b1} {s : multiset \u03b1} :\n\tmultiset.count a (multiset.filter p s) = ite (p a) (multiset.count a s) 0 :=", "nl_statement_of_codex": "Let $p$ be a predicate on a set $A$. Let $a\\in A$ and let $s$ be a multiset of elements of $A$. Then the number of occurrences of $a$ in the multiset $s$ is equal to the number of occurrences of $a$ in the multiset $s$ if $p(a)$ is true and is equal to $0$ if $p(a)$ is false."}
{"name": "matrix.from_blocks_minor_sum_swap_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/block.lean", "formal_statement": "theorem matrix.from_blocks_minor_sum_swap_right {l m n o p \u03b1 : Type*2}\n\t(A : matrix n l \u03b1) (B : matrix n m \u03b1) (C : matrix o l \u03b1) (D : matrix o m \u03b1)\n\t(f : p \u2192 n \u2295 o) :\n\t(matrix.from_blocks A B C D).minor f sum.swap = (matrix.from_blocks B A D C).minor f id :=", "nl_statement_of_codex": "Let $A, B, C, D$ be matrices of appropriate sizes. Then the minor of the block matrix $\\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix}$ at the index $f$ is equal to the minor of the block matrix $\\begin{pmatrix} B & A \\\\ D & C \\end{pmatrix}$ at the index $f$."}
{"name": "continuous_linear_map.is_compact_image_coe_of_bounded_of_weak_closed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.is_compact_image_coe_of_bounded_of_weak_closed\n\t{\ud835\udd5c \ud835\udd5c\u2082 F : Type*} [normed_group F] [nondiscrete_normed_field \ud835\udd5c]\n\t[nondiscrete_normed_field \ud835\udd5c\u2082] [normed_space \ud835\udd5c\u2082 F] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n\t{E' : Type*1} [semi_normed_group E'] [normed_space \ud835\udd5c E']\n\t[ring_hom_isometric \u03c3\u2081\u2082] [proper_space F] {s : set (E' \u2192SL[\u03c3\u2081\u2082] F)}\n\t(hb : metric.bounded s)\n\t(hc : \u2200 (f : E' \u2192SL[\u03c3\u2081\u2082] F), \u21d1f \u2208 closure (coe_fn '' s) \u2192 f \u2208 s) :\n\tis_compact (coe_fn '' s) :=", "nl_statement_of_codex": "Let $E'$ be a semi-normed group, $F$ a normed space over a nondiscrete normed field $\\mathbb{K}$, and $\\sigma: \\mathbb{K}\\to \\mathbb{K}'$ a ring homomorphism. Let $s$ be a set of continuous linear maps from $E'$ to $F$ such that $s$ is bounded and weakly closed. Then $s$ is compact."}
{"name": "nat.two_lt_of_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.two_lt_of_ne {n : \u2115} :\n\tn \u2260 0 \u2192 n \u2260 1 \u2192 n \u2260 2 \u2192 2 < n :=", "nl_statement_of_codex": "If $n$ is not $0$, not $1$, and not $2$, then $2<n$."}
{"name": "zero_lt.left.mul_lt_one_of_lt_of_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas_zero_lt.lean", "formal_statement": "theorem zero_lt.left.mul_lt_one_of_lt_of_lt {\u03b1 : Type u} {a b : \u03b1}\n\t[mul_one_class \u03b1] [has_zero \u03b1] [preorder \u03b1] [zero_lt.pos_mul_strict_mono \u03b1]\n\t(ha : a < 1) (hb : b < 1) (a0 : 0 < a) :\n\ta * b < 1 :=", "nl_statement_of_codex": "Let $a,b$ be positive elements of a preordered monoid with $1$. If $a<1$ and $b<1$, then $ab<1$."}
{"name": "monoid_hom.map_div\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group_instances.lean", "formal_statement": "theorem monoid_hom.map_div\u2082 {M : Type uM} {N : Type uN} {P : Type uP}\n\t{mM : group M} {mN : mul_one_class N} {mP : comm_group P} (f : M \u2192* N \u2192* P)\n\t(m\u2081 m\u2082 : M) (n : N) :\n\t\u21d1(\u21d1f (m\u2081 / m\u2082)) n = \u21d1(\u21d1f m\u2081) n / \u21d1(\u21d1f m\u2082) n :=", "nl_statement_of_codex": "Let $M, N, P$ be groups and let $f:M\\to N\\to P$ be a group homomorphism. Then $f(m_1/m_2)n=f(m_1)n/f(m_2)n$."}
{"name": "nat.cast_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/char_zero/defs.lean", "formal_statement": "theorem nat.cast_injective {R : Type*} [add_monoid_with_one R] [char_zero R] :\n\tfunction.injective coe :=", "nl_statement_of_codex": "The function $\\mathbb{N}\\to R$ given by $n\\mapsto n$ is injective."}
{"name": "well_founded.self_le_of_strict_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/well_founded.lean", "formal_statement": "theorem well_founded.self_le_of_strict_mono {\u03b2 : Type*} [linear_order \u03b2]\n\t(h : well_founded has_lt.lt) {\u03c6 : \u03b2 \u2192 \u03b2} (h\u03c6 : strict_mono \u03c6) (n : \u03b2) :\n\tn \u2264 \u03c6 n :=", "nl_statement_of_codex": "Let $\u03b2$ be a linear order and let $\u03c6:\u03b2\\to \u03b2$ be a strict monotone function. Then $\u03c6(n)\\geq n$ for all $n\\in \u03b2$."}
{"name": "map_eq_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem map_eq_one_iff {M N F : Type*} [has_one M] [has_one N]\n\t[one_hom_class F M N] (f : F) (hf : function.injective \u21d1f) {x : M} :\n\t\u21d1f x = 1 \u2194 x = 1 :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity $1$ and let $F$ be a class of monoid homomorphisms from $M$ to $N$. Let $f:M\\to N$ be a homomorphism in $F$. Then $f(x)=1$ if and only if $x=1$."}
{"name": "projective_spectrum.zero_locus_supr_homogeneous_ideal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/projective_spectrum/topology.lean", "formal_statement": "theorem projective_spectrum.zero_locus_supr_homogeneous_ideal {R A : Type*}\n\t[comm_semiring R] [comm_ring A] [algebra R A] (\ud835\udc9c : \u2115 \u2192 submodule R A)\n\t[graded_algebra \ud835\udc9c] {\u03b3 : Sort u_3} (I : \u03b3 \u2192 homogeneous_ideal \ud835\udc9c) :\n\tprojective_spectrum.zero_locus \ud835\udc9c (\u2191\u2a06 (i : \u03b3), I i) = \u22c2 (i : \u03b3), projective_spectrum.zero_locus \ud835\udc9c \u2191(I i) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a commutative ring, and $\\mathcal{A}$ a graded algebra over $R$ and $A$. Let $\\gamma$ be a type and $I:\\gamma\\to \\mathcal{A}$ a function. Then the zero locus of the ideal $\\bigcup_{i\\in \\gamma} I(i)$ is the intersection of the zero loci of the ideals $I(i)$."}
{"name": "multiset.lcm_ndunion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/gcd_monoid/multiset.lean", "formal_statement": "theorem multiset.lcm_ndunion {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1]\n\t[normalized_gcd_monoid \u03b1] [decidable_eq \u03b1] (s\u2081 s\u2082 : multiset \u03b1) :\n\t(s\u2081.ndunion s\u2082).lcm = gcd_monoid.lcm s\u2081.lcm s\u2082.lcm :=", "nl_statement_of_codex": "The least common multiple of the multisets $s_1$ and $s_2$ is equal to the least common multiple of the least common multiples of $s_1$ and $s_2$."}
{"name": "freiman_hom.const_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/freiman.lean", "formal_statement": "theorem freiman_hom.const_apply {\u03b1 \u03b2 : Type*} [comm_monoid \u03b1] [comm_monoid \u03b2]\n\t{A : set \u03b1} (n : \u2115) (b : \u03b2) (x : \u03b1) :\n\t\u21d1(freiman_hom.const A n b) x = b :=", "nl_statement_of_codex": "Let $A$ be a subset of a commutative monoid $\u03b1$ and let $b$ be an element of a commutative monoid $\u03b2$. Then the Freiman homomorphism $f:A\\to \u03b2$ defined by $f(x)=b$ for all $x\\in A$ satisfies $f(x)=b$ for all $x\\in A$."}
{"name": "category_theory.limits.cofork.is_colimit.\u03c0_desc_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean", "formal_statement": "theorem category_theory.limits.cofork.is_colimit.\u03c0_desc_assoc {C : Type u}\n\t[category_theory.category C] {X Y : C} {f g : X \u27f6 Y}\n\t{s t : category_theory.limits.cofork f g}\n\t(hs : category_theory.limits.is_colimit s) {X' : C} (f' : t.X \u27f6 X') :\n\ts.\u03c0 \u226b hs.desc t \u226b f' = t.\u03c0 \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, let $X, Y$ be objects of $C$, let $f, g:X\\to Y$ be morphisms, let $s, t$ be coforks of $f$ and $g$, and let $X'$ be an object of $C$. If $s$ is a colimit of $f$ and $g$, then the diagram\n$$\\begin{array}{ccc}\ns.X & \\xrightarrow{s.\u03c0} & X \\\\\n\\downarrow{hs.desc t} & & \\downarrow{f'} \\\\\nt.X & \\xrightarrow{t.\u03c0} & X"}
{"name": "pgame.mk_add_move_left_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.mk_add_move_left_inr {xl xr yl yr : Type*} {xL : xl \u2192 pgame}\n\t{xR : xr \u2192 pgame} {yL : yl \u2192 pgame} {yR : yr \u2192 pgame} {i : yl} :\n\t(pgame.mk xl xr xL xR + pgame.mk yl yr yL yR).move_left (sum.inr i) = pgame.mk xl xr xL xR + (pgame.mk yl yr yL yR).move_left i :=", "nl_statement_of_codex": "Let $xL:xl\\to\\mathbb{N}$, $xR:xr\\to\\mathbb{N}$, $yL:yl\\to\\mathbb{N}$, $yR:yr\\to\\mathbb{N}$, and $i:yl$. Then $(xL+xR)+(yL+yR)$ is equal to $xL+xR+(yL+yR)$."}
{"name": "polynomial.degree_div_X_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/inductions.lean", "formal_statement": "theorem polynomial.degree_div_X_lt {R : Type u} [semiring R] {p : polynomial R}\n\t(hp0 : p \u2260 0) :\n\tp.div_X.degree < p.degree :=", "nl_statement_of_codex": "Let $p$ be a nonzero polynomial over a semiring $R$. Then the degree of $p$ is greater than the degree of $p$ divided by $X$."}
{"name": "polynomial.to_laurent_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/laurent.lean", "formal_statement": "theorem polynomial.to_laurent_inj {R : Type*} [semiring R] (f g : polynomial R) :\n\t\u21d1polynomial.to_laurent f = \u21d1polynomial.to_laurent g \u2194 f = g :=", "nl_statement_of_codex": "The map $f\\mapsto \\overline{f}$ from polynomials to Laurent polynomials is injective."}
{"name": "affine_isometry_equiv.vadd_const_to_affine_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/affine_isometry.lean", "formal_statement": "theorem affine_isometry_equiv.vadd_const_to_affine_equiv {\ud835\udd5c V P : Type*}\n\t[normed_field \ud835\udd5c] [semi_normed_group V] [normed_space \ud835\udd5c V]\n\t[pseudo_metric_space P] [normed_add_torsor V P] (p : P) :\n\t(affine_isometry_equiv.vadd_const \ud835\udd5c p).to_affine_equiv = affine_equiv.vadd_const \ud835\udd5c p :=", "nl_statement_of_codex": "The affine isometry $x\\mapsto x+p$ is affinely equivalent to the affine map $x\\mapsto x+p$."}
{"name": "enorm.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/enorm.lean", "formal_statement": "theorem enorm.ext {\ud835\udd5c V : Type*} [normed_field \ud835\udd5c] [add_comm_group V] [module \ud835\udd5c V]\n\t{e\u2081 e\u2082 : enorm \ud835\udd5c V} (h : \u2200 (x : V), \u21d1e\u2081 x = \u21d1e\u2082 x) :\n\te\u2081 = e\u2082 :=", "nl_statement_of_codex": "Two norms on a vector space $V$ are equal if and only if they agree on all vectors in $V$."}
{"name": "add_monoid_hom.mker_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem add_monoid_hom.mker_zero {M N : Type*} [add_zero_class M]\n\t[add_zero_class N] :\n\tadd_monoid_hom.mker 0 = \u22a4 :=", "nl_statement_of_codex": "The kernel of the zero map is the trivial subgroup."}
{"name": "finset.sum_dite_irrel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_dite_irrel {\u03b2 : Type u} {\u03b1 : Type v} [add_comm_monoid \u03b2]\n\t(p : Prop) [decidable p] (s : finset \u03b1) (f : p \u2192 \u03b1 \u2192 \u03b2) (g : \u00acp \u2192 \u03b1 \u2192 \u03b2) :\n\ts.sum (\u03bb (x : \u03b1), dite p (\u03bb (h : p), f h x) (\u03bb (h : \u00acp), g h x)) = dite p (\u03bb (h : p), s.sum (\u03bb (x : \u03b1), f h x)) (\u03bb (h : \u00acp), s.sum (\u03bb (x : \u03b1), g h x)) :=", "nl_statement_of_codex": "Let $p$ be a proposition and let $f,g:\\alpha\\to\\beta$ be functions. Then $\\sum_{x\\in s} dite(p,f,g)(x)=dite(p,\\sum_{x\\in s} f(x),\\sum_{x\\in s} g(x))$."}
{"name": "list.sublist_append_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.sublist_append_left {\u03b1 : Type u} (l\u2081 l\u2082 : list \u03b1) :\n\tl\u2081 <+ l\u2081 ++ l\u2082 :=", "nl_statement_of_codex": "The list $l_1$ is a sublist of $l_1++l_2$."}
{"name": "ereal.tendsto_nhds_top_iff_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ereal.lean", "formal_statement": "theorem ereal.tendsto_nhds_top_iff_real {\u03b1 : Type*} {m : \u03b1 \u2192 ereal}\n\t{f : filter \u03b1} :\n\tfilter.tendsto m f (nhds \u22a4) \u2194 \u2200 (x : \u211d), \u2200\u1da0 (a : \u03b1) in f, \u2191x < m a :=", "nl_statement_of_codex": "Let $m:\\alpha\\to\\mathbb{R}\\cup\\{\\pm\\infty\\}$ be a function. Then $\\lim_{\\alpha\\to\\infty}m(\\alpha)=\\infty$ if and only if for all $x\\in\\mathbb{R}$ there is an $\\alpha\\in\\alpha$ such that $x<m(\\alpha)$."}
{"name": "direct_sum.decompose_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/decomposition.lean", "formal_statement": "theorem direct_sum.decompose_sum {\u03b9 M \u03c3 : Type*} [decidable_eq \u03b9]\n\t[add_comm_monoid M] [set_like \u03c3 M] [add_submonoid_class \u03c3 M] (\u2133 : \u03b9 \u2192 \u03c3)\n\t[direct_sum.decomposition \u2133] {\u03b9' : Type*} (s : finset \u03b9') (f : \u03b9' \u2192 M) :\n\t\u21d1(direct_sum.decompose \u2133) (s.sum (\u03bb (i : \u03b9'), f i)) = s.sum (\u03bb (i : \u03b9'), \u21d1(direct_sum.decompose \u2133) (f i)) :=", "nl_statement_of_codex": "Let $M$ be an abelian monoid and let $\\mathcal{M}$ be a family of submonoids of $M$. Then the direct sum of the $\\mathcal{M}$ is a submonoid of $M$ and the decomposition map is a homomorphism."}
{"name": "category_theory.cokernel_op_op_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/opposite.lean", "formal_statement": "theorem category_theory.cokernel_op_op_inv {C : Type*}\n\t[category_theory.category C] [category_theory.abelian C] {X Y : C} (f : X \u27f6 Y) :\n\t(category_theory.cokernel_op_op f).inv = (category_theory.limits.kernel.lift f (category_theory.limits.cokernel.\u03c0 f.op).unop _).op :=", "nl_statement_of_codex": "Let $C$ be an abelian category. Let $f:X\\to Y$ be a morphism in $C$. Then the inverse of the cokernel of $f$ is the kernel of $f$."}
{"name": "arity.const_succ_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/zfc.lean", "formal_statement": "theorem arity.const_succ_apply {\u03b1 : Type u} (a : \u03b1) (n : \u2115) (x : \u03b1) :\n\tarity.const a n.succ x = arity.const a n :=", "nl_statement_of_codex": "Let $a$ be an element of a type $\u03b1$ and let $n$ be a natural number. Then $arity.const a (n+1) x = arity.const a n$."}
{"name": "nat.prime.mod_two_eq_one_iff_ne_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/prime.lean", "formal_statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : \u2115} [fact (nat.prime p)] :\n\tp % 2 = 1 \u2194 p \u2260 2 :=", "nl_statement_of_codex": "A prime $p$ is odd if and only if $p\\neq 2$."}
{"name": "multiset.noncomm_fold_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/noncomm_prod.lean", "formal_statement": "theorem multiset.noncomm_fold_coe {\u03b1 : Type*} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\t[assoc : is_associative \u03b1 op] (l : list \u03b1)\n\t(comm : \u2200 (x : \u03b1), x \u2208 \u2191l \u2192 \u2200 (y : \u03b1), y \u2208 \u2191l \u2192 op x y = op y x) (a : \u03b1) :\n\tmultiset.noncomm_fold op \u2191l comm a = list.foldr op a l :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a commutative monoid $M$ and let $a\\in M$. Then the noncommutative fold of $l$ with respect to $a$ is equal to the usual fold of $l$ with respect to $a$."}
{"name": "witt_structure_int_exists_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/structure_polynomial.lean", "formal_statement": "theorem witt_structure_int_exists_unique (p : \u2115) {idx : Type*}\n\t[hp : fact (nat.prime p)] (\u03a6 : mv_polynomial idx \u2124) :\n\t\u2203! (\u03c6 : \u2115 \u2192 mv_polynomial (idx \u00d7 \u2115) \u2124), \u2200 (n : \u2115), \u21d1(mv_polynomial.bind\u2081 \u03c6) (witt_polynomial p \u2124 n) = \u21d1(mv_polynomial.bind\u2081 (\u03bb (i : idx), \u21d1(mv_polynomial.rename (prod.mk i)) (witt_polynomial p \u2124 n))) \u03a6 :=", "nl_statement_of_codex": "Let $p$ be a prime number and let $\\Phi$ be a multivariate polynomial with integer coefficients. Then there exists a unique function $\\phi:\\mathbb{N}\\to\\mathbb{Z}[x_1,\\ldots,x_n]$ such that $\\phi(n)$ is a polynomial with integer coefficients and $\\phi(n)(x_1,\\ldots,x_n)=\\Phi(x_1^n,\\ldots,x_n^n)$ for all $n\\in\\mathbb{N}$."}
{"name": "matrix.det_permute", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/determinant.lean", "formal_statement": "theorem matrix.det_permute {n : Type*} [decidable_eq n] [fintype n] {R : Type v}\n\t[comm_ring R] (\u03c3 : equiv.perm n) (M : matrix n n R) :\n\tmatrix.det (\u03bb (i : n), M (\u21d1\u03c3 i)) = \u2191(\u21d1equiv.perm.sign \u03c3) * M.det :=", "nl_statement_of_codex": "Let $M$ be an $n\\times n$ matrix over a commutative ring $R$. Then the determinant of the matrix obtained by permuting the rows of $M$ is the sign of the permutation times the determinant of $M$."}
{"name": "real.log_pos_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/log/basic.lean", "formal_statement": "theorem real.log_pos_iff {x : \u211d} (hx : 0 < x) :\n\t0 < real.log x \u2194 1 < x :=", "nl_statement_of_codex": "Let $x$ be a positive real number. Then $0<\\log x$ if and only if $1<x$."}
{"name": "is_clopen_Inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/subset_properties.lean", "formal_statement": "theorem is_clopen_Inter {\u03b1 : Type u} [topological_space \u03b1] {\u03b2 : Type*}\n\t[fintype \u03b2] {s : \u03b2 \u2192 set \u03b1} (h : \u2200 (i : \u03b2), is_clopen (s i)) :\n\tis_clopen (\u22c2 (i : \u03b2), s i) :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $s_i$ be a finite collection of clopen subsets of $X$. Then $\\bigcap_{i\\in I}s_i$ is clopen."}
{"name": "polynomial.eq_cyclotomic_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/cyclotomic/basic.lean", "formal_statement": "theorem polynomial.eq_cyclotomic_iff {R : Type*} [comm_ring R] {n : \u2115}\n\t(hpos : 0 < n) (P : polynomial R) :\n\tP = polynomial.cyclotomic n R \u2194 P * n.proper_divisors.prod (\u03bb (i : \u2115), polynomial.cyclotomic i R) = polynomial.X ^ n - 1 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $n$ be a positive integer. Then a polynomial $P$ is equal to the $n$-th cyclotomic polynomial if and only if $P$ times the product of the cyclotomic polynomials of the proper divisors of $n$ is equal to $X^n-1$."}
{"name": "abs_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem abs_lt {\u03b1 : Type u} [add_group \u03b1] [linear_order \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a b : \u03b1}\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] :\n\t|a| < b \u2194 -b < a \u2227 a < b :=", "nl_statement_of_codex": "Let $a, b$ be elements of an ordered additive group. Then $|a|<b$ if and only if $-b<a<b$."}
{"name": "lipschitz_with.eval", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/lipschitz.lean", "formal_statement": "theorem lipschitz_with.eval {\u03b9 : Type x} {\u03b1 : \u03b9 \u2192 Type u}\n\t[\u03a0 (i : \u03b9), pseudo_emetric_space (\u03b1 i)] [fintype \u03b9] (i : \u03b9) :\n\tlipschitz_with 1 (function.eval i) :=", "nl_statement_of_codex": "The evaluation function $f(i)$ is Lipschitz with constant $1$."}
{"name": "measure_theory.ae_ball_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space_def.lean", "formal_statement": "theorem measure_theory.ae_ball_iff {\u03b1 \u03b9 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {S : set \u03b9} (hS : S.countable)\n\t{p : \u03b1 \u2192 \u03a0 (i : \u03b9), i \u2208 S \u2192 Prop} :\n\t(\u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200 (i : \u03b9) (H : i \u2208 S), p x i H) \u2194 \u2200 (i : \u03b9) (H : i \u2208 S), \u2200\u1d50 (x : \u03b1) \u2202\u03bc, p x i H :=", "nl_statement_of_codex": "Let $S$ be a countable set and let $p:X\\times S\\to\\{0,1\\}$ be a function. Then the following are equivalent:\n(1) For almost every $x\\in X$, $p(x,i)=1$ for all $i\\in S$.\n(2) For all $i\\in S$, $p(x,i)=1$ for almost every $x\\in X$."}
{"name": "ordinal.principal_mul_iff_le_two_or_omega_opow_opow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/principal.lean", "formal_statement": "theorem ordinal.principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} :\n\tordinal.principal has_mul.mul o \u2194 o \u2264 2 \u2228 \u2203 (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a :=", "nl_statement_of_codex": "The ordinal $o$ is principal if and only if $o\\leq 2$ or $o=\\omega^{\\omega^a}$ for some ordinal $a$."}
{"name": "real.has_strict_fderiv_at_rpow_of_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow_deriv.lean", "formal_statement": "theorem real.has_strict_fderiv_at_rpow_of_neg (p : \u211d \u00d7 \u211d) (hp : p.fst < 0) :\n\thas_strict_fderiv_at (\u03bb (x : \u211d \u00d7 \u211d), x.fst ^ x.snd) ((p.snd * p.fst ^ (p.snd - 1)) \u2022 continuous_linear_map.fst \u211d \u211d \u211d + (p.fst ^ p.snd * real.log p.fst - real.exp (real.log p.fst * p.snd) * real.sin (p.snd * real.pi) * real.pi) \u2022 continuous_linear_map.snd \u211d \u211d \u211d) p :=", "nl_statement_of_codex": "The function $f(x,y)=x^y$ has a strict derivative at $(x,y)$ if $x<0$."}
{"name": "is_preconnected_Iic", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/intermediate_value.lean", "formal_statement": "theorem is_preconnected_Iic {\u03b1 : Type u} [conditionally_complete_linear_order \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] [densely_ordered \u03b1] {a : \u03b1} :\n\tis_preconnected (set.Iic a) :=", "nl_statement_of_codex": "Let $\u03b1$ be a conditionally complete linear order with the order topology. Then the interval $[a,\\infty)$ is preconnected."}
{"name": "lt_mul_of_lt_mul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem lt_mul_of_lt_mul_right {\u03b1 : Type*} [has_mul \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] {a b c d : \u03b1}\n\t(h : a < b * c) (hle : b \u2264 d) :\n\ta < d * c :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a preordered monoid. If $a<bc$ and $b\\leq d$, then $a<dc$."}
{"name": "linear_map.ker_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_map.ker_smul {K V V\u2082 : Type*9} [field K] [add_comm_group V]\n\t[module K V] [add_comm_group V\u2082] [module K V\u2082] (f : V \u2192\u2097[K] V\u2082) (a : K)\n\t(h : a \u2260 0) :\n\t(a \u2022 f).ker = f.ker :=", "nl_statement_of_codex": "Let $K$ be a field, $V$ and $V_2$ be $K$-modules. Let $f:V\\to V_2$ be a linear map. Then the kernel of $af$ is equal to the kernel of $f$."}
{"name": "matrix.mat_poly_equiv_eval", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/charpoly/coeff.lean", "formal_statement": "theorem matrix.mat_poly_equiv_eval {R : Type u} [comm_ring R] {n : Type v}\n\t[decidable_eq n] [fintype n] (M : matrix n n (polynomial R)) (r : R) (i j : n) :\n\tpolynomial.eval (\u21d1(matrix.scalar n) r) (\u21d1mat_poly_equiv M) i j = polynomial.eval r (M i j) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $n$ be a finite type, and let $M$ be an $n\\times n$ matrix with entries in the polynomial ring $R[x]$. Then for all $r\\in R$ and $i,j\\in n$, we have that $r\\cdot M_{ij}(x)=M_{ij}(r)$."}
{"name": "ordering.compares_iff_of_compares_impl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/compare.lean", "formal_statement": "theorem ordering.compares_iff_of_compares_impl {\u03b1 \u03b2 : Type*} [linear_order \u03b1]\n\t[preorder \u03b2] {a b : \u03b1} {a' b' : \u03b2}\n\t(h : \u2200 {o : ordering}, o.compares a b \u2192 o.compares a' b') (o : ordering) :\n\to.compares a b \u2194 o.compares a' b' :=", "nl_statement_of_codex": "Let $a,b,a',b'$ be elements of two linear orders $A,B$. If $a\\leq b$ in $A$ implies $a'\\leq b'$ in $B$, then $a\\leq b$ in $A$ if and only if $a'\\leq b'$ in $B$."}
{"name": "fractional_ideal.mem_div_iff_of_nonzero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.mem_div_iff_of_nonzero {R\u2081 : Type*} [comm_ring R\u2081]\n\t{K : Type*} [field K] [algebra R\u2081 K] [frac : is_fraction_ring R\u2081 K]\n\t[is_domain R\u2081] {I J : fractional_ideal (non_zero_divisors R\u2081) K} (h : J \u2260 0)\n\t{x : K} :\n\tx \u2208 I / J \u2194 \u2200 (y : K), y \u2208 J \u2192 x * y \u2208 I :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $K$ a field, and $I, J$ fractional ideals of $K$. Then $x\\in I/J$ if and only if $x\\cdot y\\in I$ for all $y\\in J$."}
{"name": "topological_group.t3_space", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem topological_group.t3_space (G : Type w) [topological_space G] [group G]\n\t[topological_group G] [t1_space G] :\n\tt3_space G :=", "nl_statement_of_codex": "A topological group is a $T_3$ space."}
{"name": "finsupp.zero_not_mem_frange", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.zero_not_mem_frange {\u03b1 M : Type*} [has_zero M] {f : \u03b1 \u2192\u2080 M} :\n\t0 \u2209 f.frange :=", "nl_statement_of_codex": "The zero element is not in the range of a finitely supported function."}
{"name": "discrete_topology_iff_open_singleton_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem discrete_topology_iff_open_singleton_zero {G : Type w}\n\t[topological_space G] [add_group G] [has_continuous_add G] :\n\tdiscrete_topology G \u2194 is_open {0} :=", "nl_statement_of_codex": "The topology on a topological group $G$ is discrete if and only if $\\{0\\}$ is open."}
{"name": "set.mem_smul_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.mem_smul_set {\u03b1 \u03b2 : Type*} [has_smul \u03b1 \u03b2] {t : set \u03b2} {a : \u03b1}\n\t{x : \u03b2} :\n\tx \u2208 a \u2022 t \u2194 \u2203 (y : \u03b2), y \u2208 t \u2227 a \u2022 y = x :=", "nl_statement_of_codex": "Let $t$ be a set and let $a$ be an element of a ring $R$. Then $x\\in a\\cdot t$ if and only if there is an element $y\\in t$ such that $a\\cdot y=x$."}
{"name": "lp.coe_fn_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lp_space.lean", "formal_statement": "theorem lp.coe_fn_smul {\u03b1 E : \u03b1 \u2192 Type*} {p : ennreal}\n\t[\u03a0 (i : \u03b1), normed_group (E i)] {\ud835\udd5c : Type*} [normed_field \ud835\udd5c]\n\t[\u03a0 (i : \u03b1), normed_space \ud835\udd5c (E i)] ( : \ud835\udd5c) (f : \u21a5(lp E p)) :\n\t\u21d1(c \u2022 f) = c \u2022 \u21d1f :=", "nl_statement_of_codex": "Let $E$ be a family of normed spaces over a set $\\alpha$ and let $p\\in [1,\\infty]$. Then for any $c\\in\\mathbb{C}$ and any $f\\in L^p(E)$, we have $c\\cdot f=c\\cdot f$."}
{"name": "adjoin_root.lift_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/adjoin_root.lean", "formal_statement": "theorem adjoin_root.lift_mk {R : Type u} {S : Type v} [comm_ring R]\n\t{f : polynomial R} [comm_ring S] {i : R \u2192+* S} {a : S}\n\t(h : polynomial.eval\u2082 i a f = 0) (g : polynomial R) :\n\t\u21d1(adjoin_root.lift i a h) (\u21d1(adjoin_root.mk f) g) = polynomial.eval\u2082 i a g :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $f\\in R[x]$ and let $a\\in R$. Then the map $g\\mapsto f(a)$ is a ring homomorphism from $R[x]/(f)$ to $R$."}
{"name": "algebraic_independent.linear_independent", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/algebraic_independent.lean", "formal_statement": "theorem algebraic_independent.linear_independent {\u03b9 R A : Type*} {x : \u03b9 \u2192 A}\n\t[comm_ring R] [comm_ring A] [algebra R A] (hx : algebraic_independent R x) :\n\tlinear_independent R x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $A$ be a commutative $R$-algebra, and $x:\\mathbb{N}\\to A$. If $x$ is algebraically independent over $R$, then $x$ is linearly independent over $R$."}
{"name": "algebraic_geometry.structure_sheaf.to_open_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.structure_sheaf.to_open_apply (R : Type u)\n\t[comm_ring R]\n\t(U : topological_space.opens \u21a5(algebraic_geometry.prime_spectrum.Top R))\n\t(f : R) (x : \u21a5U) :\n\t(\u21d1(algebraic_geometry.structure_sheaf.to_open R U) f).val x = \u21d1(algebra_map R (algebraic_geometry.structure_sheaf.localizations R \u2191x)) f :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $U$ be an open subset of $\\operatorname{Spec}(R)$. Then the map $\\mathcal{O}_U\\to \\mathcal{O}_{\\operatorname{Spec}(R)}$ is given by the localization map $\\mathcal{O}_U\\to \\mathcal{O}_{\\operatorname{Spec}(R)}$."}
{"name": "int.modeq.sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/modeq.lean", "formal_statement": "theorem int.modeq.sub {n a b c d : \u2124} (h\u2081 : a \u2261 b [ZMOD n])\n\t(h\u2082 : c \u2261 d [ZMOD n]) :\n\ta - c \u2261 b - d [ZMOD n] :=", "nl_statement_of_codex": "If $a\\equiv b\\pmod{n}$ and $c\\equiv d\\pmod{n}$, then $a-c\\equiv b-d\\pmod{n}$."}
{"name": "direct_sum.mk_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/module.lean", "formal_statement": "theorem direct_sum.mk_smul (R : Type u) [semiring R] {\u03b9 : Type v}\n\t[dec_\u03b9 : decidable_eq \u03b9] {M : \u03b9 \u2192 Type w} [\u03a0 (i : \u03b9), add_comm_monoid (M i)]\n\t[\u03a0 (i : \u03b9), module R (M i)] (s : finset \u03b9) ( : R) (x : \u03a0 (i : \u21a5\u2191s), M i.val) :\n\t\u21d1(direct_sum.mk M s) (c \u2022 x) = c \u2022 \u21d1(direct_sum.mk M s) x :=", "nl_statement_of_codex": "Let $R$ be a semiring, let $M_i$ be an $R$-module for each $i\\in I$, and let $s\\subset I$. Then the map $\\oplus_{i\\in s}M_i\\to \\oplus_{i\\in I}M_i$ is an $R$-module homomorphism."}
{"name": "measure_theory.measure.restrict_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.restrict_sum {\u03b1 \u03b9 : Type*}\n\t{m0 : measurable_space \u03b1} (\u03bc : \u03b9 \u2192 measure_theory.measure \u03b1) {s : set \u03b1}\n\t(hs : measurable_set s) :\n\t(measure_theory.measure.sum \u03bc).restrict s = measure_theory.measure.sum (\u03bb (i : \u03b9), (\u03bc i).restrict s) :=", "nl_statement_of_codex": "Let $\u03bc_i$ be a family of measures on a measurable space $(X,\\mathcal{A})$. Then the restriction of the sum measure $\\sum_{i\\in I} \u03bc_i$ to a measurable set $A\\in\\mathcal{A}$ is equal to the sum measure $\\sum_{i\\in I} \u03bc_i\\restriction_A$."}
{"name": "list.join_eq_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/join.lean", "formal_statement": "theorem list.join_eq_nil {\u03b1 : Type*} {L : list (list \u03b1)} :\n\tL.join = list.nil \u2194 \u2200 (l : list \u03b1), l \u2208 L \u2192 l = list.nil :=", "nl_statement_of_codex": "The join of a list of lists is the empty list if and only if each list in the list of lists is the empty list."}
{"name": "commensurable.commensurator'_mem_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/commensurable.lean", "formal_statement": "theorem commensurable.commensurator'_mem_iff {G : Type*} [group G]\n\t(H : subgroup G) (g : conj_act G) :\n\tg \u2208 commensurable.commensurator' H \u2194 commensurable (g \u2022 H) H :=", "nl_statement_of_codex": "Let $G$ be a group and let $H$ be a subgroup of $G$. Then $g\\in G$ is in the commensurator of $H$ if and only if $gHg^{-1}$ is commensurable with $H$."}
{"name": "set.Icc_diff_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Icc_diff_left {\u03b1 : Type*} [partial_order \u03b1] {a b : \u03b1} :\n\tset.Icc a b \\ {a} = set.Ioc a b :=", "nl_statement_of_codex": "$[a,b]\\setminus\\{a\\}=[a,b)$."}
{"name": "equiv.subtype_equiv_codomain_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/basic.lean", "formal_statement": "theorem equiv.subtype_equiv_codomain_apply {X Y : Type*} [decidable_eq X]\n\t{x : X} (f : {x' // x' \u2260 x} \u2192 Y) (g : {g // g \u2218 coe = f}) :\n\t\u21d1(equiv.subtype_equiv_codomain f) g = \u2191g x :=", "nl_statement_of_codex": "Let $X$ and $Y$ be types, let $x\\in X$, and let $f:{x'\\in X\\mid x'\\neq x}\\to Y$. Let $g:{g\\in Y^X\\mid g\\circ\\iota=f}\\to Y$ be a function. Then $\\overline{g}(x)=g(x)$."}
{"name": "simple_graph.adj.ne'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/basic.lean", "formal_statement": "theorem simple_graph.adj.ne' {V : Type u} {G : simple_graph V} {a b : V}\n\t(h : G.adj a b) :\n\tb \u2260 a :=", "nl_statement_of_codex": "Let $G$ be a simple graph. If $a$ and $b$ are adjacent vertices of $G$, then $a\\neq b$."}
{"name": "dfinsupp.sum_sub_index", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.sum_sub_index {\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v}\n\t[dec : decidable_eq \u03b9] [\u03a0 (i : \u03b9), add_group (\u03b2 i)]\n\t[\u03a0 (i : \u03b9) (x : \u03b2 i), decidable (x \u2260 0)] [add_comm_group \u03b3]\n\t{f g : \u03a0\u2080 (i : \u03b9), \u03b2 i} {h : \u03a0 (i : \u03b9), \u03b2 i \u2192 \u03b3}\n\t(h_sub : \u2200 (i : \u03b9) (b\u2081 b\u2082 : \u03b2 i), h i (b\u2081 - b\u2082) = h i b\u2081 - h i b\u2082) :\n\t(f - g).sum h = f.sum h - g.sum h :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to R$ be two functions. Then $\\sum_{i\\in\\mathbb{N}}(f(i)-g(i))=\\sum_{i\\in\\mathbb{N}}f(i)-\\sum_{i\\in\\mathbb{N}}g(i)$."}
{"name": "measure_theory.measure.absolutely_continuous_of_le_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.absolutely_continuous_of_le_smul {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc \u03bc' : measure_theory.measure \u03b1} { : ennreal}\n\t(h\u03bc'_le : \u03bc' \u2264 c \u2022 \u03bc) :\n\t\u03bc'.absolutely_continuous \u03bc :=", "nl_statement_of_codex": "Let $\u03bc$ and $\u03bc'$ be measures on a measurable space $X$. If $\u03bc'\\leq c\\cdot \u03bc$ for some $c\\in\\mathbb{R}$, then $\u03bc'$ is absolutely continuous with respect to $\u03bc$."}
{"name": "pgame.inv_eq_of_lf_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/basic.lean", "formal_statement": "theorem pgame.inv_eq_of_lf_zero {x : pgame} (h : x.lf 0) :\n\tx\u207b\u00b9 = -(-x).inv' :=", "nl_statement_of_codex": "If $x$ is a pgame and $x$ is left-free, then $x^{-1}=-(-x)^{-1}$."}
{"name": "ennreal.continuous_mul_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.continuous_mul_const {a : ennreal} (ha : a \u2260 \u22a4) :\n\tcontinuous (\u03bb (x : ennreal), x * a) :=", "nl_statement_of_codex": "The function $f:x\\mapsto xa$ is continuous on $\\mathbb{R}_{\\geq 0}$."}
{"name": "real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem real_inner_div_norm_mul_norm_eq_neg_one_of_ne_zero_of_neg_mul\n\t{F : Type*} [inner_product_space \u211d F] {x : F} {r : \u211d} (hx : x \u2260 0) (hr : r < 0) :\n\thas_inner.inner x (r \u2022 x) / (\u2225x\u2225 * \u2225r \u2022 x\u2225) = -1 :=", "nl_statement_of_codex": "Let $F$ be a real inner product space and let $x\\in F$ and $r\\in\\mathbb{R}$. If $x\\neq 0$ and $r<0$, then $\\langle x, rx\\rangle/(\\|x\\|\\|rx\\|)=-1$."}
{"name": "alg_equiv.symm_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.symm_symm {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w}\n\t[comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082]\n\t(e : A\u2081 \u2243\u2090[R] A\u2082) :\n\te.symm.symm = e :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A_1$ and $A_2$ be $R$-algebras. Then the inverse of the inverse of an algebra isomorphism $A_1\\to A_2$ is the original algebra isomorphism."}
{"name": "lt_tsub_iff_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem lt_tsub_iff_left {\u03b1 : Type*} {a b c : \u03b1} [linear_order \u03b1]\n\t[add_comm_semigroup \u03b1] [has_sub \u03b1] [has_ordered_sub \u03b1] :\n\ta < b - c \u2194 c + a < b :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linearly ordered additive commutative semigroup with a subtraction operation. Then $a<b-c$ if and only if $c+a<b$."}
{"name": "set.image_pair", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.image_pair {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (a b : \u03b1) :\n\tf '' {a, b} = {f a, f b} :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then $f(\\{a,b\\})=\\{f(a),f(b)\\}$."}
{"name": "list.as_string_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/string/basic.lean", "formal_statement": "theorem list.as_string_eq {l : list char} {s : string} :\n\tl.as_string = s \u2194 l = s.to_list :=", "nl_statement_of_codex": "The list of characters $l$ is equal to the string $s$ if and only if $l$ is the list of characters of $s$."}
{"name": "zero_at_infty_continuous_map.coe_to_bcf_add_monoid_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/zero_at_infty.lean", "formal_statement": "theorem zero_at_infty_continuous_map.coe_to_bcf_add_monoid_hom {\u03b1 : Type u}\n\t{\u03b2 : Type v} [topological_space \u03b1] [normed_group \u03b2]\n\t(f : zero_at_infty_continuous_map \u03b1 \u03b2) :\n\t\u21d1(\u21d1zero_at_infty_continuous_map.to_bcf_add_monoid_hom f) = \u21d1f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a zero-at-infinity continuous map. Then the map $f:X\\to Y$ is equal to the map $f:X\\to Y$."}
{"name": "bor_ff", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/bool/lemmas.lean", "formal_statement": "theorem bor_ff (b : bool) :\n\tb || bool.ff = b :=", "nl_statement_of_codex": "$b\\lor \\mathrm{false}=b$."}
{"name": "turing.TM1.stmts\u2081_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/turing_machine.lean", "formal_statement": "theorem turing.TM1.stmts\u2081_self {\u0393 : Type*} [inhabited \u0393] {\u039b \u03c3 : Type*}\n\t{q : turing.TM1.stmt \u0393 \u039b \u03c3} :\n\tq \u2208 turing.TM1.stmts\u2081 q :=", "nl_statement_of_codex": "For any Turing machine $M$, $M$ halts on input $x$ if and only if $M$ halts on input $x$."}
{"name": "measure_theory.ae_strongly_measurable.measurable_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem measure_theory.ae_strongly_measurable.measurable_mk {\u03b1 \u03b2 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} [topological_space.pseudo_metrizable_space \u03b2] [measurable_space \u03b2]\n\t[borel_space \u03b2] (hf : measure_theory.ae_strongly_measurable f \u03bc) :\n\tmeasurable (measure_theory.ae_strongly_measurable.mk f hf) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a strongly measurable function. Then the function $f^*:X\\to Y$ defined by $f^*(x)=f(x)$ if $x\\in X$ and $f^*(x)=y_0$ otherwise, where $y_0$ is a fixed point in $Y$, is measurable."}
{"name": "BoolRing.iso.mk_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/BoolRing.lean", "formal_statement": "theorem BoolRing.iso.mk_inv {\u03b1 \u03b2 : BoolRing} (e : \u21a5\u03b1 \u2243+* \u21a5\u03b2) :\n\t(BoolRing.iso.mk e).inv = \u2191(e.symm) :=", "nl_statement_of_codex": "The inverse of the isomorphism $BoolRing.iso.mk(e)$ is the isomorphism $e.symm$."}
{"name": "nat.arithmetic_function.von_mangoldt_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/von_mangoldt.lean", "formal_statement": "theorem nat.arithmetic_function.von_mangoldt_nonneg {n : \u2115} :\n\t0 \u2264 \u21d1nat.arithmetic_function.von_mangoldt n :=", "nl_statement_of_codex": "The von Mangoldt function is non-negative."}
{"name": "subtype.preimage_coe_nonempty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem subtype.preimage_coe_nonempty {\u03b1 : Type*} {s t : set \u03b1} :\n\t(coe \u207b\u00b9' t).nonempty \u2194 (s \u2229 t).nonempty :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $s\\cap t$ is nonempty if and only if the preimage of $t$ under the coe function is nonempty."}
{"name": "cont_diff.comp_cont_diff_on\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff.comp_cont_diff_on\u2082 {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [normed_group G]\n\t[normed_space \ud835\udd5c G] {n : with_top \u2115} {E\u2081 E\u2082 : Type*} [normed_group E\u2081]\n\t[normed_group E\u2082] [normed_space \ud835\udd5c E\u2081] [normed_space \ud835\udd5c E\u2082] {g : E\u2081 \u00d7 E\u2082 \u2192 G}\n\t{f\u2081 : F \u2192 E\u2081} {f\u2082 : F \u2192 E\u2082} {s : set F} (hg : cont_diff \ud835\udd5c n g)\n\t(hf\u2081 : cont_diff_on \ud835\udd5c n f\u2081 s) (hf\u2082 : cont_diff_on \ud835\udd5c n f\u2082 s) :\n\tcont_diff_on \ud835\udd5c n (\u03bb (x : F), g (f\u2081 x, f\u2082 x)) s :=", "nl_statement_of_codex": "Let $F, G, E_1, E_2$ be normed spaces over $\\mathbb{K}$ and let $f_1:F\\to E_1$, $f_2:F\\to E_2$, $g:E_1\\times E_2\\to G$ be functions. If $g$ is $n$-times continuously differentiable and $f_1, f_2$ are $n$-times continuously differentiable on $S$, then $g\\circ (f_1, f_2)$ is $n$-times continuously differentiable on $S$."}
{"name": "differentiable_within_at.clog", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/log_deriv.lean", "formal_statement": "theorem differentiable_within_at.clog {E : Type*} [normed_group E]\n\t[normed_space \u2102 E] {f : E \u2192 \u2102} {s : set E} {x : E}\n\t(h\u2081 : differentiable_within_at \u2102 f s x) (h\u2082 : 0 < (f x).re \u2228 (f x).im \u2260 0) :\n\tdifferentiable_within_at \u2102 (\u03bb (t : E), complex.log (f t)) s x :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $f:E\\to\\mathbb{C}$. If $f$ is differentiable at $x\\in E$ and $f(x)$ is not on the negative real axis, then $\\log(f)$ is differentiable at $x$."}
{"name": "free_ring.coe_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/free_comm_ring.lean", "formal_statement": "theorem free_ring.coe_sub {\u03b1 : Type u} (x y : free_ring \u03b1) :\n\t\u2191(x - y) = \u2191x - \u2191y :=", "nl_statement_of_codex": "Let $R$ be a free ring on a set $A$. Then the map $R\\to R$ given by $x\\mapsto x-y$ is equal to the map $R\\to R$ given by $x\\mapsto x-y$."}
{"name": "matrix.is_symm_mul_transpose_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/symmetric.lean", "formal_statement": "theorem matrix.is_symm_mul_transpose_self {\u03b1 n : Type*} [fintype n]\n\t[comm_semiring \u03b1] (A : matrix n n \u03b1) :\n\t(A.mul A.transpose).is_symm :=", "nl_statement_of_codex": "Let $A$ be a square matrix over a commutative semiring. Then $A^TA$ is symmetric."}
{"name": "computation.of_think_terminates", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.of_think_terminates {\u03b1 : Type u} {s : computation \u03b1} :\n\ts.think.terminates \u2192 s.terminates :=", "nl_statement_of_codex": "If the computation $s$ terminates, then the computation $s.think$ terminates."}
{"name": "linear_independent.restrict_of_comp_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_independent.lean", "formal_statement": "theorem linear_independent.restrict_of_comp_subtype {\u03b9 R M : Type*} {v : \u03b9 \u2192 M}\n\t[semiring R] [add_comm_monoid M] [module R M] {s : set \u03b9}\n\t(hs : linear_independent R (v \u2218 coe)) :\n\tlinear_independent R (s.restrict v) :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ be an $R$-module, and $v:I\\to M$ be a function. If $v$ is linearly independent, then the restriction of $v$ to any subset $S$ of $I$ is linearly independent."}
{"name": "model_with_corners_prod_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/smooth_manifold_with_corners.lean", "formal_statement": "theorem model_with_corners_prod_coe {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H : Type*} [topological_space H] {H' : Type*}\n\t[topological_space H'] (I : model_with_corners \ud835\udd5c E H)\n\t(I' : model_with_corners \ud835\udd5c E' H') :\n\t\u21d1(I.prod I') = prod.map \u21d1I \u21d1I' :=", "nl_statement_of_codex": "Let $I$ and $I'$ be models with corners. Then the model with corners $I\\times I'$ is the product of the models with corners $I$ and $I'$."}
{"name": "irrational_rat_div_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/irrational.lean", "formal_statement": "theorem irrational_rat_div_iff {q : \u211a} {x : \u211d} :\n\tirrational (\u2191q / x) \u2194 q \u2260 0 \u2227 irrational x :=", "nl_statement_of_codex": "$\\frac{q}{x}$ is irrational if and only if $q\\neq 0$ and $x$ is irrational."}
{"name": "category_theory.split_mono.id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/epi_mono.lean", "formal_statement": "theorem category_theory.split_mono.id {C : Type u\u2081} [category_theory.category C]\n\t{X Y : C} (f : X \u27f6 Y) [category_theory.split_mono f] :\n\tf \u226b category_theory.retraction f = \ud835\udfd9 X :=", "nl_statement_of_codex": "Let $C$ be a category and let $f:X\\to Y$ be a split monomorphism. Then $f\\circ r_f=\\mathrm{id}_X$."}
{"name": "finset.image_some_erase_none", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/option.lean", "formal_statement": "theorem finset.image_some_erase_none {\u03b1 : Type*} [decidable_eq (option \u03b1)]\n\t(s : finset (option \u03b1)) :\n\tfinset.image option.some (\u21d1finset.erase_none s) = s.erase option.none :=", "nl_statement_of_codex": "Let $s$ be a finite set of options. Then the image of the set of non-none elements of $s$ under the some function is equal to the set of non-none elements of $s$."}
{"name": "pgame.is_option_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.is_option_neg {x y : pgame} :\n\tx.is_option (-y) \u2194 (-x).is_option y :=", "nl_statement_of_codex": "Let $x$ and $y$ be positional games. Then $x$ is an option of $-y$ if and only if $-x$ is an option of $y$."}
{"name": "compact_accumulate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/subset_properties.lean", "formal_statement": "theorem compact_accumulate {\u03b1 : Type u} [topological_space \u03b1] {K : \u2115 \u2192 set \u03b1}\n\t(hK : \u2200 (n : \u2115), is_compact (K n)) (n : \u2115) :\n\tis_compact (set.accumulate K n) :=", "nl_statement_of_codex": "Let $K_n$ be a sequence of compact sets in a topological space $X$. Then the set $\\bigcup_{i=1}^n K_i$ is compact."}
{"name": "finset.eq_singleton_iff_unique_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.eq_singleton_iff_unique_mem {\u03b1 : Type*} {s : finset \u03b1} {a : \u03b1} :\n\ts = {a} \u2194 a \u2208 s \u2227 \u2200 (x : \u03b1), x \u2208 s \u2192 x = a :=", "nl_statement_of_codex": "A finite set $s$ is equal to the singleton set $\\{a\\}$ if and only if $a$ is the unique element of $s$."}
{"name": "category_theory.Ran_is_sheaf_of_cover_lifting.get_section_is_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/cover_lifting.lean", "formal_statement": "theorem category_theory.Ran_is_sheaf_of_cover_lifting.get_section_is_unique\n\t{C D : Type u} [category_theory.category C] [category_theory.category D]\n\t{A : Type w} [category_theory.category A] [category_theory.limits.has_limits A]\n\t{J : category_theory.grothendieck_topology C}\n\t{K : category_theory.grothendieck_topology D} {G : C \u2964 D}\n\t(hu : category_theory.cover_lifting J K G) (\u2131 : category_theory.Sheaf J A)\n\t{X : A} {U : D} {S : category_theory.sieve U} (hS : S \u2208 \u21d1K U)\n\t{x : category_theory.presieve.family_of_elements ((category_theory.Ran G.op).obj \u2131.val \u22d9 category_theory.coyoneda.obj (opposite.op X)) S.arrows}\n\t(hx : x.compatible) (Y : category_theory.structured_arrow (opposite.op U) G.op)\n\t{y : ((\ud835\udfed (C\u1d52\u1d56 \u2964 A)).obj \u2131.val \u22d9 category_theory.coyoneda.obj (opposite.op X)).obj (opposite.op (opposite.unop Y.right))}\n\t(H : (category_theory.Ran_is_sheaf_of_cover_lifting.pulledback_family \u2131 S x Y).is_amalgamation y) :\n\ty = category_theory.Ran_is_sheaf_of_cover_lifting.get_section hu \u2131 hS hx Y :=", "nl_statement_of_codex": "Let $C, D$ be categories, $A$ a category with limits, $J$ a Grothendieck topology on $C$, $K$ a Grothendieck topology on $D$, $G:C\\to D$ a functor. Suppose that $G$ is a cover lifting from $J$ to $K$. Let $\\mathcal{F}$ be a sheaf on $J$ and let $X$ be an object of $A$. Let $U$ be an object of $D$ and let $S$ be a sieve on $U$. Suppose that $S$ is in $K$. Let $x$ be a compatible family of elements of"}
{"name": "submodule.prod_comap_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/prod.lean", "formal_statement": "theorem submodule.prod_comap_inr {R : Type u} {M : Type v} {M\u2082 : Type w}\n\t[semiring R] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M]\n\t[module R M\u2082] (p : submodule R M) (q : submodule R M\u2082) :\n\tsubmodule.comap (linear_map.inr R M M\u2082) (p.prod q) = q :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $M_2$ be $R$-modules. Then the image of the product of the submodules $p$ and $q$ under the map $M\\oplus M_2\\to M_2$ is $q$."}
{"name": "linear_equiv.map_smul\u209b\u2097", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/equiv.lean", "formal_statement": "theorem linear_equiv.map_smul\u209b\u2097 {R S M M\u2082 : Type*} [semiring R] [semiring S]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] {module_M : module R M}\n\t{module_S_M\u2082 : module S M\u2082} {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}\n\t{re\u2081 : ring_hom_inv_pair \u03c3 \u03c3'} {re\u2082 : ring_hom_inv_pair \u03c3' \u03c3} (e : M \u2243\u209b\u2097[\u03c3] M\u2082)\n\t( : R) (x : M) :\n\t\u21d1e (c \u2022 x) = \u21d1\u03c3 c \u2022 \u21d1e x :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings, let $M$ and $M_2$ be $R$-modules, and let $\u03c3:R\\to S$ be a ring homomorphism. Let $e:M\\to M_2$ be a linear equivalence. Then $e(cx)=\u03c3(c)e(x)$ for all $c\\in R$ and $x\\in M$."}
{"name": "pow_eq_zero_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/ring.lean", "formal_statement": "theorem pow_eq_zero_of_le {M : Type*} [monoid_with_zero M] {x : M} {n m : \u2115}\n\t(hn : n \u2264 m) (hx : x ^ n = 0) :\n\tx ^ m = 0 :=", "nl_statement_of_codex": "Let $M$ be a monoid with zero. Let $x\\in M$ and $n,m\\in\\mathbb{N}$. If $n\\leq m$ and $x^n=0$, then $x^m=0$."}
{"name": "set.indicator_nonpos_le_indicator", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/indicator_function.lean", "formal_statement": "theorem set.indicator_nonpos_le_indicator {\u03b1 \u03b2 : Type*} [linear_order \u03b2]\n\t[has_zero \u03b2] (s : set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n\t{x : \u03b1 | f x \u2264 0}.indicator f \u2264 s.indicator f :=", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{R}$ be a function. Then $\\sum_{x\\in X} \\max\\{0,f(x)\\}\\geq \\sum_{x\\in X} \\max\\{0,-f(x)\\}$."}
{"name": "measure_theory.L1.simple_func.set_to_L1s_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/set_to_l1.lean", "formal_statement": "theorem measure_theory.L1.simple_func.set_to_L1s_const {\u03b1 E F : Type*}\n\t[normed_group E] [normed_space \u211d E] [normed_group F] [normed_space \u211d F]\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measure_theory.is_finite_measure \u03bc] {T : set \u03b1 \u2192 (E \u2192L[\u211d] F)}\n\t(h_zero : \u2200 (s : set \u03b1), measurable_set s \u2192 \u21d1\u03bc s = 0 \u2192 T s = 0)\n\t(h_add : measure_theory.fin_meas_additive \u03bc T) (x : E) :\n\tmeasure_theory.L1.simple_func.set_to_L1s T (measure_theory.Lp.simple_func.indicator_const 1 measurable_set.univ _ x) = \u21d1(T set.univ) x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed groups and let $T:E\\to F$ be a measurable function. Then $T$ is additive if and only if $T(x+y)=T(x)+T(y)$ for all $x,y\\in E$."}
{"name": "le_sub_iff_add_le'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem le_sub_iff_add_le' {\u03b1 : Type u} [add_comm_group \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a b c : \u03b1} :\n\tb \u2264 c - a \u2194 a + b \u2264 c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of an additive commutative group. Then $b\\leq c-a$ if and only if $a+b\\leq c$."}
{"name": "list.mem_insert_nth", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.mem_insert_nth {\u03b1 : Type u} {a b : \u03b1} {n : \u2115} {l : list \u03b1}\n\t(hi : n \u2264 l.length) :\n\ta \u2208 list.insert_nth n b l \u2194 a = b \u2228 a \u2208 l :=", "nl_statement_of_codex": "Let $a,b$ be elements of a type $\u03b1$ and let $l$ be a list of elements of $\u03b1$. Then $a$ is an element of the list obtained by inserting $b$ at position $n$ in $l$ if and only if $a=b$ or $a$ is an element of $l$."}
{"name": "subsemigroup.centralizer_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/centralizer.lean", "formal_statement": "theorem subsemigroup.centralizer_le {M : Type*} {S T : set M} [semigroup M]\n\t(h : S \u2286 T) :\n\tsubsemigroup.centralizer T \u2264 subsemigroup.centralizer S :=", "nl_statement_of_codex": "Let $M$ be a semigroup and let $S, T$ be subsets of $M$. If $S\\subset T$, then the centralizer of $T$ is contained in the centralizer of $S$."}
{"name": "pfun.fn_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pfun.lean", "formal_statement": "theorem pfun.fn_apply {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192. \u03b2) (a : \u03b1) :\n\tf.fn a = (f a).get :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a partial function. Then $f(a)$ is defined if and only if $f.fn(a)$ is defined."}
{"name": "neg_strict_concave_on_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/function.lean", "formal_statement": "theorem neg_strict_concave_on_iff {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [ordered_add_comm_group \u03b2] [has_smul \ud835\udd5c E] [module \ud835\udd5c \u03b2]\n\t{s : set E} {f : E \u2192 \u03b2} :\n\tstrict_concave_on \ud835\udd5c s (-f) \u2194 strict_convex_on \ud835\udd5c s f :=", "nl_statement_of_codex": "Let $E$ be a set, $f:E\\to\\mathbb{R}$ a function, and $s\\subset E$. Then $f$ is strictly concave on $s$ if and only if $-f$ is strictly convex on $s$."}
{"name": "Mon_.mul_one_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/Mon_.lean", "formal_statement": "theorem Mon_.mul_one_hom {C : Type u\u2081} [category_theory.category C]\n\t[category_theory.monoidal_category C] {M : Mon_ C} {Z : C} (f : Z \u27f6 M.X) :\n\t(f \u2297 M.one) \u226b M.mul = (\u03c1_ Z).hom \u226b f :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $M$ be a monoid in $C$. Let $Z$ be an object of $C$. Let $f:Z\\to M$ be a morphism in $C$. Then $(f\\otimes 1_M)\\circ \\mu_M=\\rho_Z\\circ f$."}
{"name": "vsub_sub_vsub_cancel_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/add_torsor.lean", "formal_statement": "theorem vsub_sub_vsub_cancel_right {G P : Type*} [add_group G]\n\t[T : add_torsor G P] (p1 p2 p3 : P) :\n\tp1 -\u1d65 p3 - (p2 -\u1d65 p3) = p1 -\u1d65 p2 :=", "nl_statement_of_codex": "Let $G$ be an abelian group and let $P$ be an $G$-torsor. Then for all $p_1, p_2, p_3\\in P$, we have $p_1-p_3-(p_2-p_3)=p_1-p_2$."}
{"name": "Inf_hom.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/complete_lattice.lean", "formal_statement": "theorem Inf_hom.ext {\u03b1 \u03b2 : Type*} [has_Inf \u03b1] [has_Inf \u03b2] {f g : Inf_hom \u03b1 \u03b2}\n\t(h : \u2200 (a : \u03b1), \u21d1f a = \u21d1g a) :\n\tf = g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions. If $f(a)=g(a)$ for all $a\\in\\alpha$, then $f=g$."}
{"name": "linear_map.inl_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/prod.lean", "formal_statement": "theorem linear_map.inl_apply {R : Type u} {M : Type v} {M\u2082 : Type w}\n\t[semiring R] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M]\n\t[module R M\u2082] (x : M) :\n\t\u21d1(linear_map.inl R M M\u2082) x = (x, 0) :=", "nl_statement_of_codex": "The linear map $M\\to M\\oplus M_2$ given by $x\\mapsto (x,0)$ is the inclusion map $M\\to M\\oplus M_2$."}
{"name": "linear_isometry.congr_arg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem linear_isometry.congr_arg {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082]\n\t{\u03c3\u2081\u2082 : R \u2192+* R\u2082} [semi_normed_group E] [semi_normed_group E\u2082] [module R E]\n\t[module R\u2082 E\u2082] {f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} {x x' : E} :\n\tx = x' \u2192 \u21d1f x = \u21d1f x' :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $\\sigma:R\\to R'$ be a semiring homomorphism, let $E$ and $E'$ be semi-normed groups, let $R$ and $R'$ act on $E$ and $E'$ respectively, and let $f:E\\to E'$ be a linear isometry. Then $f(x)=f(x')$ if $x=x'$."}
{"name": "affine_isometry_equiv.coe_to_affine_isometry", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/affine_isometry.lean", "formal_statement": "theorem affine_isometry_equiv.coe_to_affine_isometry {\ud835\udd5c V V\u2082 P P\u2082 : Type*}\n\t[normed_field \ud835\udd5c] [semi_normed_group V] [semi_normed_group V\u2082]\n\t[normed_space \ud835\udd5c V] [normed_space \ud835\udd5c V\u2082] [pseudo_metric_space P]\n\t[pseudo_metric_space P\u2082] [normed_add_torsor V P] [normed_add_torsor V\u2082 P\u2082]\n\t(e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) :\n\t\u21d1(e.to_affine_isometry) = \u21d1e :=", "nl_statement_of_codex": "Let $P$ and $P'$ be normed add torsors over $V$ and $V'$ respectively. Then the affine isometry $e:P\\to P'$ is equal to the affine isometry $e.to\\_affine\\_isometry:P\\to P'$."}
{"name": "is_glb.exists_seq_antitone_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem is_glb.exists_seq_antitone_tendsto {\u03b1 : Type u} [topological_space \u03b1]\n\t[linear_order \u03b1] [order_topology \u03b1] {t : set \u03b1} {x : \u03b1}\n\t[(nhds x).is_countably_generated] (htx : is_glb t x) (ht : t.nonempty) :\n\t\u2203 (u : \u2115 \u2192 \u03b1), antitone u \u2227 (\u2200 (n : \u2115), x \u2264 u n) \u2227 filter.tendsto u filter.at_top (nhds x) \u2227 \u2200 (n : \u2115), u n \u2208 t :=", "nl_statement_of_codex": "Let $X$ be a topological space; let $t$ be a nonempty subset of $X$; let $x$ be a lower bound of $t$. Then there is a sequence $u$ in $X$ such that $u$ is decreasing, $x\\leq u(n)$ for all $n$, $u$ converges to $x$, and $u(n)\\in t$ for all $n$."}
{"name": "equiv.to_pequiv_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pequiv.lean", "formal_statement": "theorem equiv.to_pequiv_symm {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2243 \u03b2) :\n\tf.symm.to_pequiv = f.to_pequiv.symm :=", "nl_statement_of_codex": "The inverse of a permutation is a permutation."}
{"name": "intermediate_field.restrict_scalars_bot_eq_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/adjoin.lean", "formal_statement": "theorem intermediate_field.restrict_scalars_bot_eq_self {F : Type*} [field F]\n\t{E : Type*} [field E] [algebra F E] (K : intermediate_field F E) :\n\tintermediate_field.restrict_scalars F \u22a5 = K :=", "nl_statement_of_codex": "Let $F$ be a field and let $E$ be a field extension of $F$. Let $K$ be an intermediate field of $F$ and $E$. Then the restriction of scalars of $K$ to the trivial field is $K$."}
{"name": "category_theory.adjunction.mk_of_unit_counit_counit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/basic.lean", "formal_statement": "theorem category_theory.adjunction.mk_of_unit_counit_counit {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t{F : C \u2964 D} {G : D \u2964 C} (adj : category_theory.adjunction.core_unit_counit F G) :\n\t(category_theory.adjunction.mk_of_unit_counit adj).counit = adj.counit :=", "nl_statement_of_codex": "Let $F:C\\to D$ and $G:D\\to C$ be functors between categories $C$ and $D$. If $F$ and $G$ form an adjunction, then the counit of the adjunction is the same as the counit of the adjunction."}
{"name": "linear_independent.inl_union_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_independent.lean", "formal_statement": "theorem linear_independent.inl_union_inr {R M M' : Type*} [ring R]\n\t[add_comm_group M] [add_comm_group M'] [module R M] [module R M'] {s : set M}\n\t{t : set M'} (hs : linear_independent R (\u03bb (x : \u21a5s), \u2191x))\n\t(ht : linear_independent R (\u03bb (x : \u21a5t), \u2191x)) :\n\tlinear_independent R (\u03bb (x : \u21a5(\u21d1(linear_map.inl R M M') '' s \u222a \u21d1(linear_map.inr R M M') '' t)), \u2191x) :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ and $M'$ be $R$-modules. Let $s$ be a subset of $M$ and $t$ be a subset of $M'$. If $s$ and $t$ are linearly independent, then $s\\cup t$ is linearly independent."}
{"name": "measurable_from_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_from_top {\u03b1 \u03b2 : Type*} [measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\tmeasurable f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function. Then $f$ is measurable."}
{"name": "not_is_max_iff_ne_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem not_is_max_iff_ne_top {\u03b1 : Type u} [partial_order \u03b1] [order_top \u03b1]\n\t{a : \u03b1} :\n\t\u00acis_max a \u2194 a \u2260 \u22a4 :=", "nl_statement_of_codex": "Let $P$ be a partially ordered set with a top element. Then $a\\in P$ is not a maximal element if and only if $a\\neq \\top$."}
{"name": "measure_theory.extend_Union_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.extend_Union_nat {\u03b1 : Type*} {P : set \u03b1 \u2192 Prop}\n\t{m : \u03a0 (s : set \u03b1), P s \u2192 ennreal}\n\t(PU : \u2200 \u2983f : \u2115 \u2192 set \u03b1\u2984, (\u2200 (i : \u2115), P (f i)) \u2192 P (\u22c3 (i : \u2115), f i))\n\t{f : \u2115 \u2192 set \u03b1} (hm : \u2200 (i : \u2115), P (f i))\n\t(mU : m (\u22c3 (i : \u2115), f i) _ = \u2211' (i : \u2115), m (f i) _) :\n\tmeasure_theory.extend m (\u22c3 (i : \u2115), f i) = \u2211' (i : \u2115), measure_theory.extend m (f i) :=", "nl_statement_of_codex": "Let $P$ be a property of subsets of a set $X$ and let $m$ be a function from subsets of $X$ to the extended nonnegative reals. Suppose that $P$ is closed under countable unions. Then the measure of the union of a countable collection of sets is the sum of the measures of the sets."}
{"name": "measure_theory.null_measurable_set.bUnion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/null_measurable.lean", "formal_statement": "theorem measure_theory.null_measurable_set.bUnion {\u03b9 \u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b9 \u2192 set \u03b1}\n\t{s : set \u03b9} (hs : s.countable)\n\t(h : \u2200 (b : \u03b9), b \u2208 s \u2192 measure_theory.null_measurable_set (f b) \u03bc) :\n\tmeasure_theory.null_measurable_set (\u22c3 (b : \u03b9) (H : b \u2208 s), f b) \u03bc :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $f:I\\to X$ be a function from a countable set $I$ to $X$. Then the union of the images of $f$ is a null-measurable set."}
{"name": "matrix.neg_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/vec_notation.lean", "formal_statement": "theorem matrix.neg_empty {\u03b1 : Type u} [has_neg \u03b1] (v : fin 0 \u2192 \u03b1) :\n\t-v = matrix.vec_empty :=", "nl_statement_of_codex": "The negation of the zero vector is the zero vector."}
{"name": "add_group_seminorm.sub_rev", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/seminorm.lean", "formal_statement": "theorem add_group_seminorm.sub_rev {G : Type*} [add_comm_group G]\n\t(q : add_group_seminorm G) (x y : G) :\n\t\u21d1q (x - y) = \u21d1q (y - x) :=", "nl_statement_of_codex": "Let $G$ be an additive commutative group and let $q$ be an additive seminorm on $G$. Then $q(x-y)=q(y-x)$ for all $x,y\\in G$."}
{"name": "measure_theory.measure.ae_eq_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/pi.lean", "formal_statement": "theorem measure_theory.measure.ae_eq_pi {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9]\n\t[\u03a0 (i : \u03b9), measurable_space (\u03b1 i)]\n\t{\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)}\n\t[\u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)] {\u03b2 : \u03b9 \u2192 Type*}\n\t{f f' : \u03a0 (i : \u03b9), \u03b1 i \u2192 \u03b2 i} (h : \u2200 (i : \u03b9), f i =\u1d50[\u03bc i] f' i) :\n\t(\u03bb (x : \u03a0 (i : \u03b9), \u03b1 i) (i : \u03b9), f i (x i)) =\u1d50[measure_theory.measure.pi \u03bc] \u03bb (x : \u03a0 (i : \u03b9), \u03b1 i) (i : \u03b9), f' i (x i) :=", "nl_statement_of_codex": "Let $\\alpha$ and $\\beta$ be measurable spaces and let $\\mu$ be a $\\sigma$-finite measure on $\\alpha$. Let $f,g:\\alpha\\to\\beta$ be measurable functions. Then $f=g$ almost everywhere if and only if $f=g$ on a set of full measure."}
{"name": "is_primitive_root.zpow_eq_one_iff_dvd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/roots_of_unity.lean", "formal_statement": "theorem is_primitive_root.zpow_eq_one_iff_dvd {G : Type*} [comm_group G] {k : \u2115}\n\t{\u03b6 : G} (h : is_primitive_root \u03b6 k) (l : \u2124) :\n\t\u03b6 ^ l = 1 \u2194 \u2191k \u2223 l :=", "nl_statement_of_codex": "Let $G$ be a commutative group and let $k$ be a positive integer. Let $\\zeta$ be a primitive $k$th root of unity in $G$. Then $\\zeta^l=1$ if and only if $k$ divides $l$."}
{"name": "is_R_or_C.re_eq_complex_re", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/basic.lean", "formal_statement": "theorem is_R_or_C.re_eq_complex_re :\n\t\u21d1is_R_or_C.re = complex.re :=", "nl_statement_of_codex": "The real part of a complex number is equal to the real part of a complex number."}
{"name": "fin_congr_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/fin.lean", "formal_statement": "theorem fin_congr_apply_coe {n m : \u2115} (h : n = m) (k : fin n) :\n\t\u2191(\u21d1(fin_congr h) k) = \u2191k :=", "nl_statement_of_codex": "Let $n,m$ be natural numbers and let $h:n=m$. Then for any $k\\in\\mathbb{N}$ we have $k\\in\\mathbb{N}$."}
{"name": "topological_space.opens.local_homeomorph_subtype_coe_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/local_homeomorph.lean", "formal_statement": "theorem topological_space.opens.local_homeomorph_subtype_coe_coe {\u03b1 : Type*}\n\t[topological_space \u03b1] (s : topological_space.opens \u03b1) [nonempty \u21a5s] :\n\t\u21d1(s.local_homeomorph_subtype_coe) = coe :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a nonempty open subset of $X$. Then the map $A\\to A$ given by $x\\mapsto x$ is a homeomorphism."}
{"name": "real.sqrt_ne_zero'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/sqrt.lean", "formal_statement": "theorem real.sqrt_ne_zero' {x : \u211d} :\n\treal.sqrt x \u2260 0 \u2194 0 < x :=", "nl_statement_of_codex": "$\\sqrt{x}\\neq 0$ if and only if $x>0$."}
{"name": "Mon_.equiv_lax_monoidal_functor_punit.Mon_to_lax_monoidal_map_to_nat_trans_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/Mon_.lean", "formal_statement": "theorem Mon_.equiv_lax_monoidal_functor_punit.Mon_to_lax_monoidal_map_to_nat_trans_app\n\t(C : Type u\u2081) [category_theory.category C]\n\t[category_theory.monoidal_category C] (A B : Mon_ C) (f : A \u27f6 B)\n\t(_x : category_theory.discrete punit) :\n\t((Mon_.equiv_lax_monoidal_functor_punit.Mon_to_lax_monoidal C).map f).to_nat_trans.app _x = f.hom :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $A$ and $B$ be monoids in $C$. Let $f:A\\to B$ be a morphism of monoids. Then the morphism of lax monoidal functors $f$ induces a natural transformation $f:A\\to B$."}
{"name": "nat.shiftl_succ", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/bitwise.lean", "formal_statement": "theorem nat.shiftl_succ (m n : \u2115) :\n\tm.shiftl (n + 1) = bit0 (m.shiftl n) :=", "nl_statement_of_codex": "$m\\cdot 2^{n+1}=2\\cdot m\\cdot 2^n$."}
{"name": "add_action.card_eq_sum_card_add_group_sub_card_stabilizer'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/quotient.lean", "formal_statement": "theorem add_action.card_eq_sum_card_add_group_sub_card_stabilizer' (\u03b1 : Type u)\n\t(\u03b2 : Type v) [add_group \u03b1] [add_action \u03b1 \u03b2] [fintype \u03b1] [fintype \u03b2]\n\t[fintype (quotient (add_action.orbit_rel \u03b1 \u03b2))]\n\t[\u03a0 (b : \u03b2), fintype \u21a5(add_action.stabilizer \u03b1 b)]\n\t{\u03c6 : quotient (add_action.orbit_rel \u03b1 \u03b2) \u2192 \u03b2}\n\t(h\u03c6 : function.left_inverse quotient.mk' \u03c6) :\n\tfintype.card \u03b2 = finset.univ.sum (\u03bb (\u03c9 : quotient (add_action.orbit_rel \u03b1 \u03b2)), fintype.card \u03b1 / fintype.card \u21a5(add_action.stabilizer \u03b1 (\u03c6 \u03c9))) :=", "nl_statement_of_codex": "Let $G$ be a finite group acting on a finite set $X$. Then $|X|=\\sum_{x\\in X}|G|/|G_x|$."}
{"name": "continuous_linear_map.fst_comp_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/module/basic.lean", "formal_statement": "theorem continuous_linear_map.fst_comp_prod {R\u2081 : Type*} [semiring R\u2081]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] {M\u2083 : Type*} [topological_space M\u2083]\n\t[add_comm_monoid M\u2083] [module R\u2081 M\u2081] [module R\u2081 M\u2082] [module R\u2081 M\u2083]\n\t(f : M\u2081 \u2192L[R\u2081] M\u2082) (g : M\u2081 \u2192L[R\u2081] M\u2083) :\n\t(continuous_linear_map.fst R\u2081 M\u2082 M\u2083).comp (f.prod g) = f :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M_1, M_2, M_3$ be topological abelian monoids, and $f:M_1\\to M_2$ and $g:M_1\\to M_3$ be continuous linear maps. Then the composition of the projection map $M_2\\times M_3\\to M_2$ with the product map $f\\times g:M_1\\to M_2\\times M_3$ is equal to $f$."}
{"name": "has_fderiv_at_filter.add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem has_fderiv_at_filter.add {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f g : E \u2192 F} {f' g' : E \u2192L[\ud835\udd5c] F} {x : E} {L : filter E}\n\t(hf : has_fderiv_at_filter f f' x L) (hg : has_fderiv_at_filter g g' x L) :\n\thas_fderiv_at_filter (\u03bb (y : E), f y + g y) (f' + g') x L :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f,g:E\\to F$ and let $f',g':E\\to L(E,F)$ be the derivatives of $f$ and $g$, respectively. Then $f+g$ is differentiable at $x$ and its derivative is $f'+g'$."}
{"name": "formal_multilinear_series.comp_right_inv_aux1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/analytic/inverse.lean", "formal_statement": "theorem formal_multilinear_series.comp_right_inv_aux1 {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {n : \u2115} (hn : 0 < n)\n\t(p : formal_multilinear_series \ud835\udd5c E F) (q : formal_multilinear_series \ud835\udd5c F E)\n\t(v : fin n \u2192 F) :\n\t\u21d1(p.comp q n) v = {c : composition n | 1 < c.length}.to_finset.sum (\u03bb (c : composition n), \u21d1(p c.length) (q.apply_composition c v)) + \u21d1(p 1) (\u03bb (i : fin 1), \u21d1(q n) v) :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $p$ and $q$ be formal multilinear series from $E$ to $F$ and from $F$ to $E$, respectively. Then for any $n\\in\\mathbb{N}$ and any $n$-tuple $v$ of elements of $F$, we have\n$$\n\\begin{aligned}\n\\left(\\sum_{c\\in\\mathcal{C}_n}p_c\\circ q_c\\right)(v)&=\\sum_{c\\in\\mathcal{C}_n}p_{c"}
{"name": "category_theory.over.iterated_slice_backward_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/over.lean", "formal_statement": "theorem category_theory.over.iterated_slice_backward_map {T : Type u\u2081}\n\t[category_theory.category T] {X : T} (f : category_theory.over X)\n\t(g h : category_theory.over f.left) (\u03b1 : g \u27f6 h) :\n\tf.iterated_slice_backward.map \u03b1 = category_theory.over.hom_mk (category_theory.over.hom_mk \u03b1.left _) _ :=", "nl_statement_of_codex": "Let $T$ be a category, let $X$ be an object of $T$, let $f:Y\\to X$ be a morphism in $T$, let $g:Z\\to Y$ and $h:Z\\to Y$ be morphisms in $T$, and let $\\alpha:g\\to h$ be a morphism in $T$. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\nZ \\arrow[r, "}
{"name": "is_algebraic_rat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/algebraic.lean", "formal_statement": "theorem is_algebraic_rat (R : Type u) {A : Type v} [division_ring A] [field R]\n\t[char_zero R] [algebra R A] (n : \u211a) :\n\tis_algebraic R \u2191n :=", "nl_statement_of_codex": "Let $R$ be a field of characteristic zero and let $A$ be a division ring. If $R$ is an algebra over $A$, then every rational number is algebraic over $R$."}
{"name": "decidable.one_lt_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem decidable.one_lt_mul {\u03b1 : Type u} [ordered_semiring \u03b1] {a b : \u03b1}\n\t[decidable_rel has_le.le] (ha : 1 \u2264 a) (hb : 1 < b) :\n\t1 < a * b :=", "nl_statement_of_codex": "Let $a,b$ be positive elements of an ordered semiring. Then $ab$ is positive."}
{"name": "strict_anti.lt_iff_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem strict_anti.lt_iff_lt {\u03b1 : Type u} {\u03b2 : Type v} [linear_order \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : strict_anti f) {a b : \u03b1} :\n\tf a < f b \u2194 b < a :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a strict anti-homomorphism. Then $f(a)<f(b)$ if and only if $b<a$."}
{"name": "is_compact.measurable_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/borel_space.lean", "formal_statement": "theorem is_compact.measurable_set {\u03b1 : Type*} {s : set \u03b1} [topological_space \u03b1]\n\t[measurable_space \u03b1] [opens_measurable_space \u03b1] [t2_space \u03b1] (h : is_compact s) :\n\tmeasurable_set s :=", "nl_statement_of_codex": "Let $X$ be a topological space. If $X$ is compact, then $X$ is measurable."}
{"name": "list.append_inj_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.append_inj_right {\u03b1 : Type u} {s\u2081 s\u2082 t\u2081 t\u2082 : list \u03b1}\n\t(h : s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082) (hl : s\u2081.length = s\u2082.length) :\n\tt\u2081 = t\u2082 :=", "nl_statement_of_codex": "Let $s_1,s_2,t_1,t_2$ be lists of the same type. If $s_1++t_1=s_2++t_2$ and $|s_1|=|s_2|$, then $t_1=t_2$."}
{"name": "ordinal.enum_ord_def'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.enum_ord_def' {S : set ordinal} (o : ordinal) :\n\tordinal.enum_ord S o = has_Inf.Inf (S \u2229 set.Ici (o.blsub (\u03bb (a : ordinal) (_x : a < o), ordinal.enum_ord S a))) :=", "nl_statement_of_codex": "Let $S$ be a set of ordinals. Then the ordinal $o$ is the supremum of the set $S\\cap\\{x\\in\\mathbb{O}:x<o\\}$."}
{"name": "differentiable_at.prod_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem differentiable_at.prod_map {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {G : Type*} [normed_group G] [normed_space \ud835\udd5c G] {G' : Type*}\n\t[normed_group G'] [normed_space \ud835\udd5c G'] {f : E \u2192 F} {f\u2082 : G \u2192 G'} (p : E \u00d7 G)\n\t(hf : differentiable_at \ud835\udd5c f p.fst) (hf\u2082 : differentiable_at \ud835\udd5c f\u2082 p.snd) :\n\tdifferentiable_at \ud835\udd5c (\u03bb (p : E \u00d7 G), (f p.fst, f\u2082 p.snd)) p :=", "nl_statement_of_codex": "Let $E, F, G, G'$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ and $f':G\\to G'$ be differentiable at $p\\in E\\times G$. Then the function $f\\times f':E\\times G\\to F\\times G'$ is differentiable at $p$."}
{"name": "equiv.finset_congr_refl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem equiv.finset_congr_refl {\u03b1 : Type*} :\n\t(equiv.refl \u03b1).finset_congr = equiv.refl (finset \u03b1) :=", "nl_statement_of_codex": "The identity function on $\\mathbb{N}$ is equal to the identity function on $\\mathbb{N}$."}
{"name": "set.Union_ge_eq_Union_nat_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Union_ge_eq_Union_nat_add {\u03b1 : Type*} (u : \u2115 \u2192 set \u03b1) (n : \u2115) :\n\t(\u22c3 (i : \u2115) (H : i \u2265 n), u i) = \u22c3 (i : \u2115), u (i + n) :=", "nl_statement_of_codex": "Let $u:\\mathbb{N}\\to\\mathcal{P}(X)$ be a sequence of sets. Then $\\bigcup_{i\\geq n}u_i=\\bigcup_{i\\in\\mathbb{N}}u_{i+n}$."}
{"name": "mem_nhds_within_Ioi_iff_exists_Ioo_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset {\u03b1 : Type u}\n\t[topological_space \u03b1] [linear_order \u03b1] [order_topology \u03b1] [no_max_order \u03b1]\n\t{a : \u03b1} {s : set \u03b1} :\n\ts \u2208 nhds_within a (set.Ioi a) \u2194 \u2203 (u : \u03b1) (H : u \u2208 set.Ioi a), set.Ioo a u \u2286 s :=", "nl_statement_of_codex": "Let $a$ be a point in a linear order $X$ with no maximum. Then $s$ is a neighborhood of $a$ in $X$ if and only if there is an open interval $(a,u)$ contained in $s$."}
{"name": "composition_as_set.blocks_length", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/composition.lean", "formal_statement": "theorem composition_as_set.blocks_length {n : \u2115} ( : composition_as_set n) :\n\tc.blocks.length = c.length :=", "nl_statement_of_codex": "Let $c$ be a composition of $n$. Then the number of blocks of $c$ is equal to the length of $c$."}
{"name": "add_submonoid.mul_induction_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/pointwise.lean", "formal_statement": "theorem add_submonoid.mul_induction_on {R : Type*}\n\t[non_unital_non_assoc_semiring R] {M N : add_submonoid R} {C : R \u2192 Prop}\n\t{r : R} (hr : r \u2208 M * N) (hm : \u2200 (m : R), m \u2208 M \u2192 \u2200 (n : R), n \u2208 N \u2192 C (m * n))\n\t(ha : \u2200 (x y : R), C x \u2192 C y \u2192 C (x + y)) :\n\tC r :=", "nl_statement_of_codex": "Let $R$ be a non-unital non-associative semiring, let $M$ and $N$ be submonoids of $R$, and let $C$ be a property of elements of $R$. Suppose that $r\\in M\\cdot N$ and that $C$ is closed under addition and under multiplication by elements of $M$ and $N$. Then $C(r)$."}
{"name": "filter.mem_principal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.mem_principal {\u03b1 : Type u} {s t : set \u03b1} :\n\ts \u2208 filter.principal t \u2194 t \u2286 s :=", "nl_statement_of_codex": "The set $s$ is in the principal filter generated by $t$ if and only if $t\\subset s$."}
{"name": "setoid.eq_iff_classes_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/setoid/partition.lean", "formal_statement": "theorem setoid.eq_iff_classes_eq {\u03b1 : Type*} {r\u2081 r\u2082 : setoid \u03b1} :\n\tr\u2081 = r\u2082 \u2194 \u2200 (x : \u03b1), {y : \u03b1 | r\u2081.rel x y} = {y : \u03b1 | r\u2082.rel x y} :=", "nl_statement_of_codex": "Two setoids $r_1$ and $r_2$ on a set $A$ are equal if and only if the equivalence classes of $r_1$ and $r_2$ are equal."}
{"name": "continuous_linear_map.exists_approx_preimage_norm_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/banach.lean", "formal_statement": "theorem continuous_linear_map.exists_approx_preimage_norm_le {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] (f : E \u2192L[\ud835\udd5c] F)\n\t[complete_space F] (surj : function.surjective \u21d1f) :\n\t\u2203 (C : \u211d) (H : C \u2265 0), \u2200 (y : F), \u2203 (x : E), has_dist.dist (\u21d1f x) y \u2264 1 / 2 * \u2225y\u2225 \u2227 \u2225x\u2225 \u2264 C * \u2225y\u2225 :=", "nl_statement_of_codex": "Let $f:E\\to F$ be a continuous linear map between normed spaces. If $f$ is surjective, then there is a constant $C$ such that for each $y\\in F$ there is an $x\\in E$ such that $f(x)=y$ and $\\|x\\|\\leq C\\|y\\|$."}
{"name": "ideal.add_mem_iff_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/basic.lean", "formal_statement": "theorem ideal.add_mem_iff_left {\u03b1 : Type u} [ring \u03b1] (I : ideal \u03b1) {a b : \u03b1} :\n\tb \u2208 I \u2192 (a + b \u2208 I \u2194 a \u2208 I) :=", "nl_statement_of_codex": "Let $I$ be an ideal of a ring $R$. Then $a+b\\in I$ if and only if $a\\in I$."}
{"name": "algebraic_geometry.\u0393_Spec.left_triangle", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/Gamma_Spec_adjunction.lean", "formal_statement": "theorem algebraic_geometry.\u0393_Spec.left_triangle\n\t(X : algebraic_geometry.LocallyRingedSpace) :\n\talgebraic_geometry.Spec_\u0393_identity.inv.app (algebraic_geometry.LocallyRingedSpace.\u0393.obj (opposite.op X)) \u226b (algebraic_geometry.identity_to_\u0393_Spec.app X).val.c.app (opposite.op \u22a4) = \ud835\udfd9 ((\ud835\udfed CommRing).obj (algebraic_geometry.LocallyRingedSpace.\u0393.obj (opposite.op X))) :=", "nl_statement_of_codex": "The following diagram commutes:\n\\[\n\\begin{tikzcd}\n\\Gamma(X) \\arrow[r, "}
{"name": "norm_num.clear_denom_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/norm_num.lean", "formal_statement": "theorem norm_num.clear_denom_add {\u03b1 : Type*} [division_ring \u03b1]\n\t(a a' b b' c c' d : \u03b1) (h\u2080 : d \u2260 0) (ha : a * d = a') (hb : b * d = b')\n\t(hc : c * d = c') (h : a' + b' = c') :\n\ta + b = c :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a division ring $R$ such that $d\\neq 0$. If $ad=a'$, $bd=b'$, $cd=c'$, and $a'+b'=c'$, then $a+b=c$."}
{"name": "list.append_left_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.append_left_injective {\u03b1 : Type u} (t : list \u03b1) :\n\tfunction.injective (\u03bb (s : list \u03b1), s ++ t) :=", "nl_statement_of_codex": "The function $f:\\mathcal{P}(\\mathbb{N})\\to\\mathcal{P}(\\mathbb{N})$ defined by $f(A)=A\\cup\\{0\\}$ is injective."}
{"name": "algebraic_geometry.structure_sheaf.localization_to_stalk_stalk_to_fiber_ring_hom_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.structure_sheaf.localization_to_stalk_stalk_to_fiber_ring_hom_assoc\n\t(R : Type u) [comm_ring R] (x : \u21a5(algebraic_geometry.prime_spectrum.Top R))\n\t{X' : CommRing}\n\t(f' : CommRing.of (localization.at_prime (prime_spectrum.as_ideal x)) \u27f6 X') :\n\talgebraic_geometry.structure_sheaf.localization_to_stalk R x \u226b algebraic_geometry.structure_sheaf.stalk_to_fiber_ring_hom R x \u226b f' = f' :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $x$ be a prime ideal of $R$. Let $X'$ be a commutative ring and let $f':R_x\\to X'$ be a ring homomorphism. Then $f'$ is equal to the composition of the localization map $R_x\\to R_x$ and the stalk-to-fiber map $R_x\\to X'$."}
{"name": "box_integral.prepartition.mem_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/basic.lean", "formal_statement": "theorem box_integral.prepartition.mem_top {\u03b9 : Type*} {I J : box_integral.box \u03b9} :\n\tJ \u2208 \u22a4 \u2194 J = I :=", "nl_statement_of_codex": "Let $I$ and $J$ be boxes in $\\mathbb{R}^n$. Then $J\\in\\top$ if and only if $J=I$."}
{"name": "function.injective.of_comp_iff'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.injective.of_comp_iff' {\u03b1 : Sort u_1} {\u03b2 : Sort u_2}\n\t{\u03b3 : Sort u_3} (f : \u03b1 \u2192 \u03b2) {g : \u03b3 \u2192 \u03b1} (hg : function.bijective g) :\n\tfunction.injective (f \u2218 g) \u2194 function.injective f :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:C\\to A$ be functions. If $g$ is bijective, then $f\\circ g$ is injective if and only if $f$ is injective."}
{"name": "algebraic_geometry.Scheme.open_cover.from_glued_open_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/gluing.lean", "formal_statement": "theorem algebraic_geometry.Scheme.open_cover.from_glued_open_map\n\t{X : algebraic_geometry.Scheme} (\ud835\udcb0 : X.open_cover) :\n\tis_open_map \u21d1(\ud835\udcb0.from_glued.val.base) :=", "nl_statement_of_codex": "Let $X$ be a scheme and let $\\mathcal{U}$ be an open cover of $X$. Then the map $\\mathcal{U}\\to X$ is open."}
{"name": "BoundedOrder.coe_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/category/BoundedOrder.lean", "formal_statement": "theorem BoundedOrder.coe_of (\u03b1 : Type*) [partial_order \u03b1] [bounded_order \u03b1] :\n\t\u21a5(BoundedOrder.of \u03b1) = \u03b1 :=", "nl_statement_of_codex": "The underlying type of a bounded order is the same as the original type."}
{"name": "seminorm.le_insert'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/seminorm.lean", "formal_statement": "theorem seminorm.le_insert' {\ud835\udd5c E : Type*} [semi_normed_ring \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] (p : seminorm \ud835\udd5c E) (x y : E) :\n\t\u21d1p x \u2264 \u21d1p y + \u21d1p (x - y) :=", "nl_statement_of_codex": "Let $p$ be a seminorm on a vector space $E$ over a semi-normed ring $R$. Then $p(x)\\leq p(y)+p(x-y)$."}
{"name": "ordinal.deriv_eq_id_of_nfp_eq_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/fixed_point.lean", "formal_statement": "theorem ordinal.deriv_eq_id_of_nfp_eq_id {f : ordinal \u2192 ordinal}\n\t(h : ordinal.nfp f = id) :\n\tordinal.deriv f = id :=", "nl_statement_of_codex": "Let $f$ be an ordinal function. If $f$ is a fixed point of the natural fixed point operator, then $f$ is the identity function."}
{"name": "add_monoid_hom.map_inv\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group_instances.lean", "formal_statement": "theorem add_monoid_hom.map_inv\u2082 {M : Type uM} {N : Type uN} {P : Type uP}\n\t{mM : add_group M} {mN : add_zero_class N} {mP : add_comm_group P}\n\t(f : M \u2192+ N \u2192+ P) (m : M) (n : N) :\n\t\u21d1(\u21d1f (-m)) n = -\u21d1(\u21d1f m) n :=", "nl_statement_of_codex": "Let $M, N, P$ be abelian groups and let $f:M\\times N\\to P$ be a group homomorphism. Then $f(-m,n)=-f(m,n)$."}
{"name": "nhds_Inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order.lean", "formal_statement": "theorem nhds_Inf {\u03b1 : Type u} {s : set (topological_space \u03b1)} {a : \u03b1} :\n\tnhds a = \u2a05 (t : topological_space \u03b1) (H : t \u2208 s), nhds a :=", "nl_statement_of_codex": "Let $s$ be a set of topological spaces. Then the infimum of the set of neighborhoods of $a$ in $s$ is the set of neighborhoods of $a$ in the infimum of $s$."}
{"name": "bool.ff_ne_tt", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/logic.lean", "formal_statement": "theorem bool.ff_ne_tt :\n\tbool.ff = bool.tt \u2192 false :=", "nl_statement_of_codex": "$\\mathtt{false}$ is not equal to $\\mathtt{true}$."}
{"name": "measure_theory.ae_eq_fun.pair_mk_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ae_eq_fun.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.pair_mk_mk {\u03b1 \u03b2 \u03b3 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2] [topological_space \u03b3]\n\t(f : \u03b1 \u2192 \u03b2) (hf : measure_theory.ae_strongly_measurable f \u03bc) (g : \u03b1 \u2192 \u03b3)\n\t(hg : measure_theory.ae_strongly_measurable g \u03bc) :\n\t(measure_theory.ae_eq_fun.mk f hf).pair (measure_theory.ae_eq_fun.mk g hg) = measure_theory.ae_eq_fun.mk (\u03bb (x : \u03b1), (f x, g x)) _ :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be strongly measurable functions. Then the function $(f,g):\\alpha\\to\\beta\\times\\gamma$ is strongly measurable."}
{"name": "prime_spectrum.union_zero_locus", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/prime_spectrum/basic.lean", "formal_statement": "theorem prime_spectrum.union_zero_locus {R : Type u} [comm_ring R]\n\t(s s' : set R) :\n\tprime_spectrum.zero_locus s \u222a prime_spectrum.zero_locus s' = prime_spectrum.zero_locus \u2191(ideal.span s \u2293 ideal.span s') :=", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then the zero locus of $s\\cup s'$ is the zero locus of the ideal generated by $s$ and $s'$."}
{"name": "is_locally_constant.iff_continuous", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/locally_constant/basic.lean", "formal_statement": "theorem is_locally_constant.iff_continuous {X Y : Type*} [topological_space X]\n\t{_x : topological_space Y} [discrete_topology Y] (f : X \u2192 Y) :\n\tis_locally_constant f \u2194 continuous f :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a discrete topological space. Then a function $f:X\\to Y$ is locally constant if and only if $f$ is continuous."}
{"name": "interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/interval_integral.lean", "formal_statement": "theorem interval_integral.integral_sub_integral_sub_linear_is_o_of_tendsto_ae_right\n\t{\u03b9 E : Type*} [normed_group E] [complete_space E] [normed_space \u211d E]\n\t{f : \u211d \u2192 E} { : E} {lb lb' : filter \u211d} {lt : filter \u03b9} {a b : \u211d} {u v : \u03b9 \u2192 \u211d}\n\t[interval_integral.FTC_filter b lb lb']\n\t(hab : interval_integrable f measure_theory.measure_space.volume a b)\n\t(hmeas : strongly_measurable_at_filter f lb' measure_theory.measure_space.volume)\n\t(hf : filter.tendsto f (lb' \u2293 measure_theory.measure_space.volume.ae) (nhds c))\n\t(hu : filter.tendsto u lt lb) (hv : filter.tendsto v lt lb) :\n\t(\u03bb (t : \u03b9), ((\u222b (x : \u211d) in a..v t, f x) - \u222b (x : \u211d) in a..u t, f x) - (v t - u t) \u2022 c) =o[lt] (v - u) :=", "nl_statement_of_codex": "Let $f: \\mathbb{R}\\to E$ be a strongly measurable function. Let $c\\in E$ and let $u,v:\\mathbb{R}\\to \\mathbb{R}$ be two functions such that $u(t)\\leq v(t)$ for all $t\\in \\mathbb{R}$. Suppose that $f$ is integrable on $[a,b]$ and that $f$ converges to $c$ almost everywhere. Then the function $t\\mapsto \\int_a^{v(t)} f(x)dx - \\int_a^{u(t)} f(x)dx - (v("}
{"name": "bdd_below.bdd_above_image2_of_bdd_above", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem bdd_below.bdd_above_image2_of_bdd_above {\u03b1 : Type u} {\u03b2 : Type v}\n\t{\u03b3 : Type w} [preorder \u03b1] [preorder \u03b2] [preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1}\n\t{t : set \u03b2} (h\u2080 : \u2200 (b : \u03b2), antitone (function.swap f b))\n\t(h\u2081 : \u2200 (a : \u03b1), monotone (f a)) :\n\tbdd_below s \u2192 bdd_above t \u2192 bdd_above (set.image2 f s t) :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. If $f$ is antitone in the second variable and monotone in the first variable, then if $A$ is bounded below and $B$ is bounded above, then $f(A\\times B)$ is bounded above."}
{"name": "list.sorted_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/sort.lean", "formal_statement": "theorem list.sorted_nil {\u03b1 : Type uu} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n\tlist.sorted r list.nil :=", "nl_statement_of_codex": "The empty list is sorted."}
{"name": "polynomial.eval\u2082_C_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/eval.lean", "formal_statement": "theorem polynomial.eval\u2082_C_X {R : Type u} [semiring R] {p : polynomial R} :\n\tpolynomial.eval\u2082 polynomial.C polynomial.X p = p :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. Then $p$ is equal to the evaluation of $p$ at $X$."}
{"name": "dfinsupp.subtype_domain_add_monoid_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.subtype_domain_add_monoid_hom_apply {\u03b9 : Type u}\n\t(\u03b2 : \u03b9 \u2192 Type v) [\u03a0 (i : \u03b9), add_zero_class (\u03b2 i)] (p : \u03b9 \u2192 Prop)\n\t[decidable_pred p] (\u1fb0 : \u03a0\u2080 (i : \u03b9), (\u03bb (i : \u03b9), \u03b2 i) i) :\n\t\u21d1(dfinsupp.subtype_domain_add_monoid_hom \u03b2 p) \u1fb0 = dfinsupp.subtype_domain p \u1fb0 :=", "nl_statement_of_codex": "Let $p$ be a predicate on $\\iota$ and let $\\alpha$ be a finitely supported function from $\\iota$ to $\\beta$. Then the image of $\\alpha$ under the map $f$ is equal to the restriction of $\\alpha$ to the subset of $\\iota$ where $p$ is true."}
{"name": "connected_components_preimage_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/connected.lean", "formal_statement": "theorem connected_components_preimage_image {\u03b1 : Type u} [topological_space \u03b1]\n\t(U : set \u03b1) :\n\tcoe \u207b\u00b9' (coe '' U) = \u22c3 (x : \u03b1) (H : x \u2208 U), connected_component x :=", "nl_statement_of_codex": "Let $U$ be a subset of a topological space $X$. Then the preimage of the image of $U$ under the map $\\pi_0$ is the union of the connected components of $U$."}
{"name": "option.get_or_else_of_ne_none", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/option/basic.lean", "formal_statement": "theorem option.get_or_else_of_ne_none {\u03b1 : Type*} {x : option \u03b1}\n\t(hx : x \u2260 option.none) (y : \u03b1) :\n\toption.some (x.get_or_else y) = x :=", "nl_statement_of_codex": "Let $x$ be an option of type $\\alpha$. If $x$ is not none, then $x$ is some $y$."}
{"name": "multiset.length_sort", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/sort.lean", "formal_statement": "theorem multiset.length_sort {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [decidable_rel r]\n\t[is_trans \u03b1 r] [is_antisymm \u03b1 r] [is_total \u03b1 r] {s : multiset \u03b1} :\n\t(multiset.sort r s).length = \u21d1multiset.card s :=", "nl_statement_of_codex": "The length of a sorted multiset is equal to the cardinality of the multiset."}
{"name": "category_theory.limits.fork.is_limit.mk_lift", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean", "formal_statement": "theorem category_theory.limits.fork.is_limit.mk_lift {C : Type u}\n\t[category_theory.category C] {X Y : C} {f g : X \u27f6 Y}\n\t(t : category_theory.limits.fork f g)\n\t(lift : \u03a0 (s : category_theory.limits.fork f g), s.X \u27f6 t.X)\n\t(fac : \u2200 (s : category_theory.limits.fork f g), lift s \u226b t.\u03b9 = s.\u03b9)\n\t(uniq : \u2200 (s : category_theory.limits.fork f g) (m : s.X \u27f6 t.X), m \u226b t.\u03b9 = s.\u03b9 \u2192 m = lift s)\n\t(s : category_theory.limits.fork f g) :\n\t(category_theory.limits.fork.is_limit.mk t lift fac uniq).lift s = lift s :=", "nl_statement_of_codex": "Let $C$ be a category, let $X, Y$ be objects of $C$, and let $f, g:X\\to Y$ be morphisms. Let $t$ be a fork with apex $Y$ and legs $f$ and $g$. Let $lift$ be a function that assigns to each fork $s$ with apex $Y$ and legs $f$ and $g$ a morphism $s.X\\to t.X$ such that $lift(s)\\circ t.\u03b9=s.\u03b9$ for all such forks $s$. Suppose that $lift$ is unique in the sense that if $m:s.X\\to t.X$ is a morph"}
{"name": "part.left_dom_of_inter_dom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.left_dom_of_inter_dom {\u03b1 : Type*} [has_inter \u03b1] {a b : part \u03b1}\n\t(hab : (a \u2229 b).dom) :\n\ta.dom :=", "nl_statement_of_codex": "Let $a$ and $b$ be partitions of a set $X$. If $a\\cap b$ is a partition of $X$, then $a$ is a partition of $X$."}
{"name": "eq_zero_or_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid.lean", "formal_statement": "theorem eq_zero_or_pos {\u03b1 : Type u} [canonically_ordered_add_monoid \u03b1] {a : \u03b1} :\n\ta = 0 \u2228 0 < a :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with unity. Then for any $a\\in R$, either $a=0$ or $a$ is a unit."}
{"name": "representation.of_mul_action_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/representation_theory/basic.lean", "formal_statement": "theorem representation.of_mul_action_def {k : Type*} [comm_semiring k]\n\t{G : Type*} [monoid G] {H : Type*} [mul_action G H] (g : G) :\n\t\u21d1(representation.of_mul_action k G H) g = finsupp.lmap_domain k k (has_smul.smul g) :=", "nl_statement_of_codex": "Let $G$ be a monoid, $H$ a $G$-module, and $k$ a commutative semiring. Then the representation of $G$ on $H$ is given by $g\\mapsto \\rho_g$, where $\\rho_g(h)=gh$."}
{"name": "infinite.false", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem infinite.false {\u03b1 : Type*} [fintype \u03b1] (h : infinite \u03b1) :\n\tfalse :=", "nl_statement_of_codex": "If $X$ is a finite set, then $X$ is not infinite."}
{"name": "set.is_wf.add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/well_founded_set.lean", "formal_statement": "theorem set.is_wf.add {\u03b1 : Type*} {s t : set \u03b1}\n\t[linear_ordered_cancel_add_comm_monoid \u03b1] (hs : s.is_wf) (ht : t.is_wf) :\n\t(s + t).is_wf :=", "nl_statement_of_codex": "Let $s$ and $t$ be well-founded sets. Then $s+t$ is well-founded."}
{"name": "real.sqrt_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/sqrt.lean", "formal_statement": "theorem real.sqrt_pos {x : \u211d} :\n\t0 < real.sqrt x \u2194 0 < x :=", "nl_statement_of_codex": "$\\sqrt{x}>0$ if and only if $x>0$."}
{"name": "mul_opposite.unop_comp_op", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/opposites.lean", "formal_statement": "theorem mul_opposite.unop_comp_op {\u03b1 : Type u} :\n\tmul_opposite.unop \u2218 mul_opposite.op = id :=", "nl_statement_of_codex": "The composition of the unary operation and the binary operation of the opposite group is the identity function."}
{"name": "nat.pow_dvd_pow_iff_pow_le_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/pow.lean", "formal_statement": "theorem nat.pow_dvd_pow_iff_pow_le_pow {k l x : \u2115} (w : 0 < x) :\n\tx ^ k \u2223 x ^ l \u2194 x ^ k \u2264 x ^ l :=", "nl_statement_of_codex": "Let $x$ be a positive integer. Then $x^k$ divides $x^l$ if and only if $k\\leq l$."}
{"name": "subgroup.pointwise_smul_le_pointwise_smul_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/pointwise.lean", "formal_statement": "theorem subgroup.pointwise_smul_le_pointwise_smul_iff {\u03b1 G : Type*} [group G]\n\t[group \u03b1] [mul_distrib_mul_action \u03b1 G] {a : \u03b1} {S T : subgroup G} :\n\ta \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T :=", "nl_statement_of_codex": "Let $G$ be a group and let $S,T$ be subgroups of $G$. Let $a$ be an element of a group $A$. Then $aS\\leq aT$ if and only if $S\\leq T$."}
{"name": "category_theory.functor.initial.limit_cone_of_comp_is_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/final.lean", "formal_statement": "theorem category_theory.functor.initial.limit_cone_of_comp_is_limit {C : Type v}\n\t[category_theory.small_category C] {D : Type v}\n\t[category_theory.small_category D] (F : C \u2964 D) [F.initial] {E : Type u}\n\t[category_theory.category E] {G : D \u2964 E}\n\t(t : category_theory.limits.limit_cone (F \u22d9 G)) :\n\t(category_theory.functor.initial.limit_cone_of_comp F t).is_limit = \u21d1((category_theory.functor.initial.is_limit_extend_cone_equiv F t.cone).symm) t.is_limit :=", "nl_statement_of_codex": "Let $F:C\\to D$ be an initial functor and let $G:D\\to E$ be a functor. Let $t$ be a limit cone of $G\\circ F$. Then the limit cone of $F$ is the limit cone of $G$."}
{"name": "indicator_ae_eq_zero_of_restrict_ae_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem indicator_ae_eq_zero_of_restrict_ae_eq_zero {\u03b1 \u03b2 : Type*}\n\t[measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} {f : \u03b1 \u2192 \u03b2}\n\t[has_zero \u03b2] (hs : measurable_set s) (hf : f =\u1d50[\u03bc.restrict s] 0) :\n\ts.indicator f =\u1d50[\u03bc] 0 :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a measurable function. If $f$ is $\u03bc$-almost everywhere equal to $0$ on $S$, then $f$ is $\u03bc$-almost everywhere equal to $0$."}
{"name": "continuous_at.inner", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem continuous_at.inner {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] {\u03b1 : Type*} [topological_space \u03b1] {f g : \u03b1 \u2192 E}\n\t{x : \u03b1} (hf : continuous_at f x) (hg : continuous_at g x) :\n\tcontinuous_at (\u03bb (t : \u03b1), has_inner.inner (f t) (g t)) x :=", "nl_statement_of_codex": "Let $E$ be an inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $f,g:X\\to E$ be continuous at $x\\in X$. Then the function $t\\mapsto \\langle f(t),g(t)\\rangle$ is continuous at $x$."}
{"name": "with_top.mul_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem with_top.mul_top {\u03b1 : Type u} [decidable_eq \u03b1] [has_zero \u03b1] [has_mul \u03b1]\n\t{a : with_top \u03b1} (h : a \u2260 0) :\n\ta * \u22a4 = \u22a4 :=", "nl_statement_of_codex": "Let $a$ be a nonzero element of the semiring $R$ with top. Then $a\\cdot\\top=\\top$."}
{"name": "summable_geometric_two_encode", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/specific_limits/basic.lean", "formal_statement": "theorem summable_geometric_two_encode {\u03b9 : Type*} [encodable \u03b9] :\n\tsummable (\u03bb (i : \u03b9), (1 / 2) ^ encodable.encode i) :=", "nl_statement_of_codex": "The series $\\sum_{i\\in\\mathbb{N}}\\frac{1}{2^i}$ converges."}
{"name": "multiset.measurable_prod'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem multiset.measurable_prod' {M \u03b1 : Type*} [comm_monoid M]\n\t[measurable_space M] [has_measurable_mul\u2082 M] {m : measurable_space \u03b1}\n\t(l : multiset (\u03b1 \u2192 M)) (hl : \u2200 (f : \u03b1 \u2192 M), f \u2208 l \u2192 measurable f) :\n\tmeasurable l.prod :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid with a measurable space structure. Let $\u03b1$ be a measurable space. Let $l$ be a multiset of measurable functions from $\u03b1$ to $M$. Then the product function $l.prod$ is measurable."}
{"name": "multiset.measurable_sum'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem multiset.measurable_sum' {M \u03b1 : Type*} [add_comm_monoid M]\n\t[measurable_space M] [has_measurable_add\u2082 M] {m : measurable_space \u03b1}\n\t(l : multiset (\u03b1 \u2192 M)) (hl : \u2200 (f : \u03b1 \u2192 M), f \u2208 l \u2192 measurable f) :\n\tmeasurable l.sum :=", "nl_statement_of_codex": "Let $M$ be a measurable space and let $l$ be a multiset of measurable functions from $\u03b1$ to $M$. Then the sum of the functions in $l$ is measurable."}
{"name": "euclidean_domain.div_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/euclidean_domain.lean", "formal_statement": "theorem euclidean_domain.div_one {R : Type u} [euclidean_domain R] (p : R) :\n\tp / 1 = p :=", "nl_statement_of_codex": "In a Euclidean domain, $p/1=p$."}
{"name": "finset.order_emb_of_fin_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/sort.lean", "formal_statement": "theorem finset.order_emb_of_fin_mem {\u03b1 : Type*} [linear_order \u03b1] (s : finset \u03b1)\n\t{k : \u2115} (h : s.card = k) (i : fin k) :\n\t\u21d1(s.order_emb_of_fin h) i \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a finite set of a linear order. Let $k$ be a natural number. Suppose that $s$ has $k$ elements. Let $i$ be an element of $\\{1,\\ldots,k\\}$. Then the $i$-th element of $s$ is in $s$."}
{"name": "ring_equiv.map_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/equiv.lean", "formal_statement": "theorem ring_equiv.map_add {R S : Type*} [has_mul R] [has_add R] [has_mul S]\n\t[has_add S] (e : R \u2243+* S) (x y : R) :\n\t\u21d1e (x + y) = \u21d1e x + \u21d1e y :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $e:R\\to S$ be a ring isomorphism. Then $e(x+y)=e(x)+e(y)$ for all $x,y\\in R$."}
{"name": "measurable_set.coe_inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_set.coe_inter {\u03b1 : Type*} [measurable_space \u03b1]\n\t(s t : subtype measurable_set) :\n\t\u2191(s \u2229 t) = \u2191s \u2229 \u2191t :=", "nl_statement_of_codex": "Let $s$ and $t$ be measurable sets. Then $s\\cap t$ is a measurable set and $s\\cap t=s\\times t$."}
{"name": "continuous_multilinear_map.curry0_uncurry0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/multilinear.lean", "formal_statement": "theorem continuous_multilinear_map.curry0_uncurry0 (\ud835\udd5c : Type u) (G : Type wG)\n\t{G' : Type wG'} [nondiscrete_normed_field \ud835\udd5c] [normed_group G]\n\t[normed_space \ud835\udd5c G] [normed_group G'] [normed_space \ud835\udd5c G'] (x : G') :\n\t(continuous_multilinear_map.curry0 \ud835\udd5c G x).uncurry0 = x :=", "nl_statement_of_codex": "Let $G$ and $G'$ be normed groups over a nondiscrete normed field $K$. Then the uncurrying of the currying of $x\\in G'$ is $x$."}
{"name": "Top.presheaf.pushforward.comp_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sheaves/presheaf.lean", "formal_statement": "theorem Top.presheaf.pushforward.comp_eq {C : Type u}\n\t[category_theory.category C] {X : Top} (\u2131 : Top.presheaf C X) {Y Z : Top}\n\t(f : X \u27f6 Y) (g : Y \u27f6 Z) :\n\t(f \u226b g) _* \u2131 = g _* (f _* \u2131) :=", "nl_statement_of_codex": "Let $C$ be a category, $X, Y, Z$ be topological spaces, and $f:X\\to Y$, $g:Y\\to Z$ be continuous maps. Then the pushforward of a presheaf $\\mathcal{F}$ along $g\\circ f$ is equal to the pushforward of the pushforward of $\\mathcal{F}$ along $f$ along $g$."}
{"name": "right_iff_left_not_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/rel_classes.lean", "formal_statement": "theorem right_iff_left_not_left {\u03b1 : Type u} {r s : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t[is_nonstrict_strict_order \u03b1 r s] {a b : \u03b1} :\n\ts a b \u2194 r a b \u2227 \u00acr b a :=", "nl_statement_of_codex": "Let $r$ and $s$ be nonstrict and strict orders on a set $A$. Then $a<b$ if and only if $a\\leq b$ and $b\\not\\leq a$."}
{"name": "hyperreal.infinite_iff_not_exists_st", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.infinite_iff_not_exists_st {x : \u211d*} :\n\tx.infinite \u2194 \u00ac\u2203 (r : \u211d), x.is_st r :=", "nl_statement_of_codex": "A hyperreal number $x$ is infinite if and only if there is no standard real number $r$ such that $x$ is standard and $x=r$."}
{"name": "metric.sigma.is_open_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/gluing.lean", "formal_statement": "theorem metric.sigma.is_open_iff {\u03b9 E : \u03b9 \u2192 Type*}\n\t[\u03a0 (i : \u03b9), metric_space (E i)] (s : set (\u03a3 (i : \u03b9), E i)) :\n\tis_open s \u2194 \u2200 (x : \u03a3 (i : \u03b9), E i), x \u2208 s \u2192 (\u2203 (\u03b5 : \u211d) (H : \u03b5 > 0), \u2200 (y : \u03a3 (i : \u03b9), E i), has_dist.dist x y < \u03b5 \u2192 y \u2208 s) :=", "nl_statement_of_codex": "Let $E_i$ be metric spaces for $i\\in I$. Then a subset $S$ of $\\prod_{i\\in I}E_i$ is open if and only if for each $x\\in S$ there is an open ball around $x$ contained in $S$."}
{"name": "category_theory.monoidal_category.tensoring_left_obj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/category.lean", "formal_statement": "theorem category_theory.monoidal_category.tensoring_left_obj (C : Type u)\n\t[category_theory.category C] [category_theory.monoidal_category C] (X : C) :\n\t(category_theory.monoidal_category.tensoring_left C).obj X = category_theory.monoidal_category.tensor_left X :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Then the functor $-\\otimes X$ is isomorphic to the functor $-\\otimes_l X$."}
{"name": "measure_theory.vector_measure.of_nonpos_disjoint_union_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/vector_measure.lean", "formal_statement": "theorem measure_theory.vector_measure.of_nonpos_disjoint_union_eq_zero\n\t{\u03b1 : Type*} {m : measurable_space \u03b1} {s : measure_theory.signed_measure \u03b1}\n\t{A B : set \u03b1} (h : disjoint A B) (hA\u2081 : measurable_set A)\n\t(hB\u2081 : measurable_set B) (hA\u2082 : \u21d1s A \u2264 0) (hB\u2082 : \u21d1s B \u2264 0)\n\t(hAB : \u21d1s (A \u222a B) = 0) :\n\t\u21d1s A = 0 :=", "nl_statement_of_codex": "Let $A$ and $B$ be disjoint measurable sets. If $s(A)\\leq 0$ and $s(B)\\leq 0$, then $s(A)=0$."}
{"name": "has_mfderiv_at.has_mfderiv_within_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/mfderiv.lean", "formal_statement": "theorem has_mfderiv_at.has_mfderiv_within_at {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{H : Type*} [topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {f : M \u2192 M'} {x : M} {s : set M}\n\t[Is : smooth_manifold_with_corners I M]\n\t[I's : smooth_manifold_with_corners I' M']\n\t{f' : tangent_space I x \u2192L[\ud835\udd5c] tangent_space I' (f x)}\n\t(h : has_mfderiv_at I I' f x f') :\n\thas_mfderiv_within_at I I' f s x f' :=", "nl_statement_of_codex": "Let $f:M\\to M'$ be a smooth map between smooth manifolds with corners. If $f$ has a derivative at $x$, then $f$ has a derivative at $x$ within $s$."}
{"name": "measure_theory.simple_func.integral_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/bochner.lean", "formal_statement": "theorem measure_theory.simple_func.integral_sub {\u03b1 E : Type*} [normed_group E]\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_space \u211d E]\n\t{f g : measure_theory.simple_func \u03b1 E} (hf : measure_theory.integrable \u21d1f \u03bc)\n\t(hg : measure_theory.integrable \u21d1g \u03bc) :\n\tmeasure_theory.simple_func.integral \u03bc (f - g) = measure_theory.simple_func.integral \u03bc f - measure_theory.simple_func.integral \u03bc g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E$ be simple functions. Then $\\int_\\alpha (f-g)d\\mu=\\int_\\alpha fd\\mu-\\int_\\alpha gd\\mu$."}
{"name": "matrix.smul_cons", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/vec_notation.lean", "formal_statement": "theorem matrix.smul_cons {\u03b1 : Type u} {n : \u2115} {M : Type*} [has_smul M \u03b1] (x : M)\n\t(y : \u03b1) (v : fin n \u2192 \u03b1) :\n\tx \u2022 matrix.vec_cons y v = matrix.vec_cons (x \u2022 y) (x \u2022 v) :=", "nl_statement_of_codex": "Let $M$ be a module over a ring $R$ and let $x\\in M$. Then $x\\cdot (y,v)=(x\\cdot y,x\\cdot v)$."}
{"name": "algebraic_geometry.is_integral_of_is_irreducible_is_reduced", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/properties.lean", "formal_statement": "theorem algebraic_geometry.is_integral_of_is_irreducible_is_reduced\n\t(X : algebraic_geometry.Scheme) [algebraic_geometry.is_reduced X]\n\t[H : irreducible_space \u21a5(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace.carrier)] :\n\talgebraic_geometry.is_integral X :=", "nl_statement_of_codex": "Let $X$ be a reduced scheme. If $X$ is irreducible, then $X$ is integral."}
{"name": "fintype.prod_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/card.lean", "formal_statement": "theorem fintype.prod_eq_one {\u03b1 M : Type*} [fintype \u03b1] [comm_monoid M]\n\t(f : \u03b1 \u2192 M) (h : \u2200 (a : \u03b1), f a = 1) :\n\tfinset.univ.prod (\u03bb (a : \u03b1), f a) = 1 :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid and let $f:A\\to M$ be a function. If $f(a)=1$ for all $a\\in A$, then $\\prod_{a\\in A}f(a)=1$."}
{"name": "uniform_continuous.div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/uniform_group.lean", "formal_statement": "theorem uniform_continuous.div {\u03b1 \u03b2 : Type*} [uniform_space \u03b1] [group \u03b1]\n\t[uniform_group \u03b1] [uniform_space \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : uniform_continuous f)\n\t(hg : uniform_continuous g) :\n\tuniform_continuous (\u03bb (x : \u03b2), f x / g x) :=", "nl_statement_of_codex": "Let $f,g:X\\to G$ be uniformly continuous functions from a uniform space $X$ to a topological group $G$. Then the function $h:X\\to G$ defined by $h(x)=f(x)/g(x)$ is uniformly continuous."}
{"name": "norm_tsum_le_tsum_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/infinite_sum.lean", "formal_statement": "theorem norm_tsum_le_tsum_norm {\u03b9 E : Type*} [semi_normed_group E] {f : \u03b9 \u2192 E}\n\t(hf : summable (\u03bb (i : \u03b9), \u2225f i\u2225)) :\n\t\u2225\u2211' (i : \u03b9), f i\u2225 \u2264 \u2211' (i : \u03b9), \u2225f i\u2225 :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $f:\\mathbb{N}\\to E$. If $f$ is summable, then $\\|\\sum_{i\\in\\mathbb{N}}f(i)\\|\\leq\\sum_{i\\in\\mathbb{N}}\\|f(i)\\|$."}
{"name": "int.exists_strict_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem int.exists_strict_mono (\u03b1 : Type u) [preorder \u03b1] [nonempty \u03b1]\n\t[no_min_order \u03b1] [no_max_order \u03b1] :\n\t\u2203 (f : \u2124 \u2192 \u03b1), strict_mono f :=", "nl_statement_of_codex": "There exists a strict monotone function from $\\mathbb{Z}$ to $\\alpha$."}
{"name": "category_theory.oplax_nat_trans.category_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/natural_transformation.lean", "formal_statement": "theorem category_theory.oplax_nat_trans.category_id {B : Type u\u2081}\n\t[category_theory.bicategory B] {C : Type u\u2082} [category_theory.bicategory C]\n\t(F G : category_theory.oplax_functor B C) (\u03b7 : F \u27f6 G) :\n\t\ud835\udfd9 \u03b7 = category_theory.oplax_nat_trans.modification.id \u03b7 :=", "nl_statement_of_codex": "Let $B$ and $C$ be bicategories and let $F, G:B\\to C$ be oplax functors. Let $\\eta:F\\Rightarrow G$ be a natural transformation. Then $\\eta_{\\mathrm{id}_B}=\\mathrm{id}_{\\eta_B}$."}
{"name": "category_theory.\u03bc_inv_hom_app_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/End.lean", "formal_statement": "theorem category_theory.\u03bc_inv_hom_app_assoc {C : Type u}\n\t[category_theory.category C] {M : Type*} [category_theory.category M]\n\t[category_theory.monoidal_category M]\n\t(F : category_theory.monoidal_functor M (C \u2964 C)) (i j : M) (X : C) {X' : C}\n\t(f' : (F.to_lax_monoidal_functor.to_functor.obj (i \u2297 j)).obj X \u27f6 X') :\n\t(F.\u03bc_iso i j).inv.app X \u226b (F.to_lax_monoidal_functor.\u03bc i j).app X \u226b f' = f' :=", "nl_statement_of_codex": "Let $C$ be a category and $M$ a monoidal category. Let $F:M\\to C\\to C$ be a monoidal functor. Let $i,j$ be objects of $M$ and $X$ an object of $C$. Let $f':F(i\\otimes j)(X)\\to X$ be a morphism in $C$. Then $(F(\\mu_{i,j})^{-1})(X)\\circ (F(\\mu_{i,j}))(X)\\circ f'=f'$."}
{"name": "cau_seq.add_lim_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/cau_seq.lean", "formal_statement": "theorem cau_seq.add_lim_zero {\u03b1 : Type*} [linear_ordered_field \u03b1] {\u03b2 : Type*}\n\t[ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [is_absolute_value abv] {f g : cau_seq \u03b2 abv}\n\t(hf : f.lim_zero) (hg : g.lim_zero) :\n\t(f + g).lim_zero :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be Cauchy sequences. If $f$ and $g$ converge to $0$, then $f+g$ converges to $0$."}
{"name": "part_enat.get_eq_iff_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/part_enat.lean", "formal_statement": "theorem part_enat.get_eq_iff_eq_coe {a : part_enat} {ha : a.dom} {b : \u2115} :\n\ta.get ha = b \u2194 a = \u2191b :=", "nl_statement_of_codex": "Let $a$ be a partial element of $\\mathbb{N}\\cup\\{\\infty\\}$ and let $b$ be a natural number. Then $a=b$ if and only if $a$ is defined and $a=b$."}
{"name": "polynomial.smul_eq_C_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/coeff.lean", "formal_statement": "theorem polynomial.smul_eq_C_mul {R : Type u} [semiring R] {p : polynomial R}\n\t(a : R) :\n\ta \u2022 p = \u21d1polynomial.C a * p :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. Then $ap=a\\cdot p$."}
{"name": "submodule.fg_finset_sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem submodule.fg_finset_sup {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {\u03b9 : Type*} (s : finset \u03b9) (N : \u03b9 \u2192 submodule R M)\n\t(h : \u2200 (i : \u03b9), i \u2208 s \u2192 (N i).fg) :\n\t(s.sup N).fg :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $N_i$ a family of finitely generated submodules of $M$. Then $\\bigoplus_{i\\in I} N_i$ is finitely generated."}
{"name": "ratfunc.num_denom_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/ratfunc.lean", "formal_statement": "theorem ratfunc.num_denom_mul {K : Type u} [hfield : field K] (x y : ratfunc K) :\n\t(x * y).num * (x.denom * y.denom) = x.num * y.num * (x * y).denom :=", "nl_statement_of_codex": "Let $K$ be a field and let $x,y$ be rational functions over $K$. Then $(x*y).num*(x.denom*y.denom)=(x.num*y.num)*(x*y).denom$."}
{"name": "pi_Lp.equiv_symm_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/pi_Lp.lean", "formal_statement": "theorem pi_Lp.equiv_symm_smul {\u03b9 : Type*} {p : \u211d} [fact_one_le_p : fact (1 \u2264 p)]\n\t{\ud835\udd5c : Type*} (\u03b2 : \u03b9 \u2192 Type*) [fintype \u03b9] [normed_field \ud835\udd5c]\n\t[\u03a0 (i : \u03b9), semi_normed_group (\u03b2 i)] [\u03a0 (i : \u03b9), normed_space \ud835\udd5c (\u03b2 i)] ( : \ud835\udd5c)\n\t(x' : \u03a0 (i : \u03b9), \u03b2 i) :\n\t\u21d1((pi_Lp.equiv p \u03b2).symm) (c \u2022 x') = c \u2022 \u21d1((pi_Lp.equiv p \u03b2).symm) x' :=", "nl_statement_of_codex": "Let $p\\in\\mathbb{R}$ be such that $1\\leq p$. Let $\\beta$ be a family of semi-normed groups. Let $c\\in\\mathbb{K}$ and $x'\\in\\prod_{i\\in I}\\beta_i$. Then $(\\pi_{L^p}(\\beta))^{-1}(c\\cdot x')=c\\cdot(\\pi_{L^p}(\\beta))^{-1}(x')$."}
{"name": "algebra.formally_etale.of_unramified_and_smooth", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/etale.lean", "formal_statement": "theorem algebra.formally_etale.of_unramified_and_smooth {R : Type u}\n\t[comm_semiring R] {A : Type u} [semiring A] [algebra R A]\n\t[h\u2081 : algebra.formally_unramified R A] [h\u2082 : algebra.formally_smooth R A] :\n\talgebra.formally_etale R A :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $A$ be an $R$-algebra. If $A$ is formally unramified and formally smooth, then $A$ is formally \u00e9tale."}
{"name": "subalgebra.map_to_submodule", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem subalgebra.map_to_submodule {R : Type u} {A : Type v} {B : Type w}\n\t[comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B]\n\t{S : subalgebra R A} {f : A \u2192\u2090[R] B} :\n\t(S.map f).to_submodule = submodule.map f.to_linear_map S.to_submodule :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be $R$-algebras, and $S$ be a subalgebra of $A$. Then the image of $S$ under the $R$-algebra homomorphism $f:A\\to B$ is a subalgebra of $B$ and the underlying $R$-submodule of this subalgebra is the image of the underlying $R$-submodule of $S$ under the $R$-linear map $f:A\\to B$."}
{"name": "add_tsub_le_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem add_tsub_le_left {\u03b1 : Type*} [preorder \u03b1] [add_comm_semigroup \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1} :\n\ta + b - a \u2264 b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a preordered additive commutative semigroup with subtraction. Then $a+b-a\\leq b$."}
{"name": "seq1.join_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/seq.lean", "formal_statement": "theorem seq1.join_nil {\u03b1 : Type u} (a : \u03b1) (S : seq (seq1 \u03b1)) :\n\tseq1.join ((a, seq.nil \u03b1), S) = (a, S.join) :=", "nl_statement_of_codex": "Let $S$ be a sequence of sequences of elements of $A$. Then $(a,\\emptyset)\\oplus S=(a,S)$."}
{"name": "polynomial.degree_div_by_monic_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/div.lean", "formal_statement": "theorem polynomial.degree_div_by_monic_le {R : Type u} [comm_ring R]\n\t(p q : polynomial R) :\n\t(p /\u2098 q).degree \u2264 p.degree :=", "nl_statement_of_codex": "Let $p$ and $q$ be polynomials over a commutative ring $R$. Then the degree of $p/q$ is less than or equal to the degree of $p$."}
{"name": "linear_pmap.mem_graph_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/linear_pmap.lean", "formal_statement": "theorem linear_pmap.mem_graph_iff {R : Type*} [ring R] {E : Type*}\n\t[add_comm_group E] [module R E] {F : Type*} [add_comm_group F] [module R F]\n\t(f : linear_pmap R E F) {x : E \u00d7 F} :\n\tx \u2208 f.graph \u2194 \u2203 (y : \u21a5(f.domain)), \u2191y = x.fst \u2227 \u21d1f y = x.snd :=", "nl_statement_of_codex": "Let $R$ be a ring, $E$ and $F$ be $R$-modules. Let $f:E\\to F$ be a linear map. Then $(x,y)\\in\\operatorname{graph}(f)$ if and only if there is $y\\in E$ such that $x=y$ and $f(y)=y$."}
{"name": "lie_hom.mem_ideal_range_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/submodule.lean", "formal_statement": "theorem lie_hom.mem_ideal_range_iff {R : Type u} {L : Type v} {L' : Type w\u2082}\n\t[comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L']\n\t(f : L \u2192\u2097\u2045R\u2046 L') (h : f.is_ideal_morphism) {y : L'} :\n\ty \u2208 f.ideal_range \u2194 \u2203 (x : L), \u21d1f x = y :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ and $L'$ be Lie algebras over $R$. Let $f:L\\to L'$ be a Lie algebra homomorphism. Then $y\\in f(L)$ if and only if there exists $x\\in L$ such that $f(x)=y$."}
{"name": "is_smul_regular.not_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/regular/smul.lean", "formal_statement": "theorem is_smul_regular.not_zero {R M : Type*} [monoid_with_zero R] [has_zero M]\n\t[mul_action_with_zero R M] [nM : nontrivial M] :\n\t\u00acis_smul_regular M 0 :=", "nl_statement_of_codex": "Let $R$ be a monoid with zero and let $M$ be a nontrivial $R$-module. Then $0$ is not a regular element of $M$."}
{"name": "measurable_equiv.inv_to_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/measurable_equiv.lean", "formal_statement": "theorem measurable_equiv.inv_to_equiv (G : Type*) [measurable_space G]\n\t[has_involutive_inv G] [has_measurable_inv G] :\n\t(measurable_equiv.inv G).to_equiv = equiv.inv G :=", "nl_statement_of_codex": "The inverse of a measurable equivalence is a measurable equivalence."}
{"name": "submodule.subtype\u2097\u1d62_to_linear_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem submodule.subtype\u2097\u1d62_to_linear_map {E : Type*} [semi_normed_group E]\n\t{R' : Type*0} [ring R'] [module R' E] (p : submodule R' E) :\n\tp.subtype\u2097\u1d62.to_linear_map = p.subtype :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $R'$ be a ring. Let $p$ be a submodule of $E$ over $R'$. Then the linear map $p.subtype\u2097\u1d62.to_linear_map$ is equal to $p.subtype$."}
{"name": "real.Sup_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/basic.lean", "formal_statement": "theorem real.Sup_def (S : set \u211d) :\n\thas_Sup.Sup S = dite (S.nonempty \u2227 bdd_above S) (\u03bb (h : S.nonempty \u2227 bdd_above S), classical.some _) (\u03bb (h : \u00ac(S.nonempty \u2227 bdd_above S)), 0) :=", "nl_statement_of_codex": "The supremum of a set $S$ of real numbers is the least upper bound of $S$ if $S$ is nonempty and bounded above, and $0$ otherwise."}
{"name": "line_map_lt_right_iff_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/ordered.lean", "formal_statement": "theorem line_map_lt_right_iff_lt {k E : Type*} [ordered_ring k]\n\t[ordered_add_comm_group E] [module k E] [ordered_smul k E] {a b : E} {r : k}\n\t(h : r < 1) :\n\t\u21d1(affine_map.line_map a b) r < b \u2194 a < b :=", "nl_statement_of_codex": "Let $a, b\\in E$ and $r\\in k$. Then $a<b$ if and only if $r<1$ and $\\frac{1-r}{1}a+\\frac{r}{1}b<b$."}
{"name": "list.next_ne_head_ne_last", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/cycle.lean", "formal_statement": "theorem list.next_ne_head_ne_last {\u03b1 : Type*} [decidable_eq \u03b1] (l : list \u03b1)\n\t(x y : \u03b1) (h : x \u2208 y :: l) (hy : x \u2260 y) (hx : x \u2260 (y :: l).last _) :\n\t(y :: l).next x h = l.next x _ :=", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b1$ with decidable equality. Let $x,y\\in l$. If $x\\neq y$ and $x\\neq l.last$, then $l.next(x)=l.next(y)$."}
{"name": "linear_map.coe_finsupp_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_map.coe_finsupp_sum {R R\u2082 M M\u2082 \u03b9 : Type*7} [semiring R]\n\t[semiring R\u2082] [add_comm_monoid M] [add_comm_monoid M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t[module R M] [module R\u2082 M\u2082] {\u03b3 : Type*0} [has_zero \u03b3] (t : \u03b9 \u2192\u2080 \u03b3)\n\t(g : \u03b9 \u2192 \u03b3 \u2192 (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)) :\n\t\u21d1(t.sum g) = t.sum (\u03bb (i : \u03b9) (d : \u03b3), \u21d1(g i d)) :=", "nl_statement_of_codex": "Let $R$ and $R_2$ be semirings, $M$ and $M_2$ be commutative monoids, $\\sigma_{12}:R\\to R_2$ be a semiring homomorphism, $M$ and $M_2$ be $R$-modules and $R_2$-modules, respectively, and $\\gamma$ be a set with zero element. Let $t:\\gamma\\to\\mathbb{N}$ be a function, and let $g:\\gamma\\to M\\to M_2$ be a function. Then $\\sum_{\\gamma}t(x)g(x)=\\sum_{\\"}
{"name": "category_theory.limits.cones.postcompose_equivalence_unit_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.limits.cones.postcompose_equivalence_unit_iso\n\t{J : Type u\u2081} [category_theory.category J] {C : Type u\u2083}\n\t[category_theory.category C] {F G : J \u2964 C} (\u03b1 : F \u2245 G) :\n\t(category_theory.limits.cones.postcompose_equivalence \u03b1).unit_iso = category_theory.nat_iso.of_components (\u03bb (s : category_theory.limits.cone F), category_theory.limits.cones.ext (category_theory.iso.refl ((\ud835\udfed (category_theory.limits.cone F)).obj s).X) _) _ :=", "nl_statement_of_codex": "Let $F,G:J\\to C$ be functors. If $\\alpha:F\\to G$ is an equivalence, then the unit of the adjunction $(\\alpha_!,\\alpha^*)$ is the identity."}
{"name": "submodule.span_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/span.lean", "formal_statement": "theorem submodule.span_mono {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {s t : set M} (h : s \u2286 t) :\n\tsubmodule.span R s \u2264 submodule.span R t :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $s,t\\subset M$. If $s\\subset t$, then $\\langle s\\rangle\\subset\\langle t\\rangle$."}
{"name": "asymptotics.is_Theta.norm_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/theta.lean", "formal_statement": "theorem asymptotics.is_Theta.norm_right {\u03b1 E F' : Type*} [has_norm E]\n\t[semi_normed_group F'] {f : \u03b1 \u2192 E} {g' : \u03b1 \u2192 F'} {l : filter \u03b1} :\n\tf =\u0398[l] g' \u2192 (f =\u0398[l] \u03bb (x : \u03b1), \u2225g' x\u2225) :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E$ be functions. If $f=\\Theta(g)$, then $f=\\Theta(\\|g\\|)$."}
{"name": "upper_half_plane.im_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/upper_half_plane/basic.lean", "formal_statement": "theorem upper_half_plane.im_ne_zero (z : upper_half_plane) :\n\tz.im \u2260 0 :=", "nl_statement_of_codex": "The imaginary part of a point in the upper half plane is nonzero."}
{"name": "div_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_with_zero/basic.lean", "formal_statement": "theorem div_self {G\u2080 : Type*} [group_with_zero G\u2080] {a : G\u2080} (h : a \u2260 0) :\n\ta / a = 1 :=", "nl_statement_of_codex": "Let $G$ be a group with zero. If $a\\in G$ is nonzero, then $a/a=1$."}
{"name": "pgame.fuzzy_congr_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.fuzzy_congr_left {x\u2081 x\u2082 y : pgame} (hx : x\u2081.equiv x\u2082) :\n\tx\u2081.fuzzy y \u2194 x\u2082.fuzzy y :=", "nl_statement_of_codex": "Let $x_1, x_2, y$ be positional games. If $x_1$ and $x_2$ are equivalent, then $x_1$ is fuzzy to $y$ if and only if $x_2$ is fuzzy to $y$."}
{"name": "basis.orientation_neg_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/orientation.lean", "formal_statement": "theorem basis.orientation_neg_single {R : Type*} [linear_ordered_comm_ring R]\n\t{M : Type*} [add_comm_group M] [module R M] {\u03b9 : Type*} [decidable_eq \u03b9]\n\t[fintype \u03b9] [nontrivial R] (e : basis \u03b9 R M) (i : \u03b9) :\n\t(e.units_smul (function.update 1 i (-1))).orientation = -e.orientation :=", "nl_statement_of_codex": "Let $R$ be a linear ordered commutative ring with $1\\neq 0$. Let $M$ be a $R$-module. Let $e$ be a basis of $M$. Let $i$ be an element of the index set of $e$. Then the orientation of $e$ is the negative of the orientation of $e$ with the $i$-th basis vector multiplied by $-1$."}
{"name": "continuous.div_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group_with_zero.lean", "formal_statement": "theorem continuous.div_const {\u03b1 G\u2080 : Type*} [group_with_zero G\u2080]\n\t[topological_space G\u2080] [has_continuous_mul G\u2080] {f : \u03b1 \u2192 G\u2080}\n\t[topological_space \u03b1] (hf : continuous f) {y : G\u2080} :\n\tcontinuous (\u03bb (x : \u03b1), f x / y) :=", "nl_statement_of_codex": "Let $G$ be a topological group with continuous multiplication. Let $f:X\\to G$ be a continuous function. Then the function $g:X\\to G$ defined by $g(x)=f(x)/y$ is continuous."}
{"name": "real.volume_pi_Ico_to_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/lebesgue.lean", "formal_statement": "theorem real.volume_pi_Ico_to_real {\u03b9 : Type*} [fintype \u03b9] {a b : \u03b9 \u2192 \u211d}\n\t(h : a \u2264 b) :\n\t(\u21d1measure_theory.measure_space.volume (set.univ.pi (\u03bb (i : \u03b9), set.Ico (a i) (b i)))).to_real = finset.univ.prod (\u03bb (i : \u03b9), b i - a i) :=", "nl_statement_of_codex": "The volume of the product of intervals $[a_i,b_i]$ is the product of the lengths of the intervals."}
{"name": "add_action.mem_stabilizer_add_submonoid_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/basic.lean", "formal_statement": "theorem add_action.mem_stabilizer_add_submonoid_iff (\u03b1 : Type u) {\u03b2 : Type v}\n\t[add_monoid \u03b1] [add_action \u03b1 \u03b2] {b : \u03b2} {a : \u03b1} :\n\ta \u2208 add_action.stabilizer.add_submonoid \u03b1 b \u2194 a +\u1d65 b = b :=", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then $a\\in G$ stabilizes $x\\in X$ if and only if $a+x=x$."}
{"name": "equiv.perm.is_conj_of_cycle_type_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/type.lean", "formal_statement": "theorem equiv.perm.is_conj_of_cycle_type_eq {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] {\u03c3 \u03c4 : equiv.perm \u03b1} (h : \u03c3.cycle_type = \u03c4.cycle_type) :\n\tis_conj \u03c3 \u03c4 :=", "nl_statement_of_codex": "Let $\\sigma$ and $\\tau$ be permutations of a finite set $X$. If $\\sigma$ and $\\tau$ have the same cycle type, then $\\sigma$ and $\\tau$ are conjugate."}
{"name": "linear_equiv.map_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_equiv.map_sub {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082]\n\t[add_comm_group M] [add_comm_group M\u2082] {module_M : module R M}\n\t{module_M\u2082 : module R\u2082 M\u2082} {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}\n\t{re\u2081\u2082 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2081 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082}\n\t(e : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (a b : M) :\n\t\u21d1e (a - b) = \u21d1e a - \u21d1e b :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, $M$ and $M'$ be $R$-modules and $R'$-modules, respectively. Let $\\sigma:R\\to R'$ be a ring homomorphism. Then $\\sigma$ induces a linear equivalence $e:M\\to M'$ such that $e(a-b)=e(a)-e(b)$ for all $a,b\\in M$."}
{"name": "linear_map.convex_hull_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/hull.lean", "formal_statement": "theorem linear_map.convex_hull_image {\ud835\udd5c E F : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [add_comm_monoid F] [module \ud835\udd5c E] [module \ud835\udd5c F]\n\t(f : E \u2192\u2097[\ud835\udd5c] F) (s : set E) :\n\t\u21d1(convex_hull \ud835\udd5c) (\u21d1f '' s) = \u21d1f '' \u21d1(convex_hull \ud835\udd5c) s :=", "nl_statement_of_codex": "Let $f:E\\to F$ be a linear map between two vector spaces over a field $K$. Then $f(conv(S))=conv(f(S))$ for any subset $S$ of $E$."}
{"name": "mem_subalgebra_equiv_intermediate_field", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/intermediate_field.lean", "formal_statement": "theorem mem_subalgebra_equiv_intermediate_field {K L : Type*} [field K]\n\t[field L] [algebra K L] (alg : algebra.is_algebraic K L) {S : subalgebra K L}\n\t{x : L} :\n\tx \u2208 \u21d1(subalgebra_equiv_intermediate_field alg) S \u2194 x \u2208 S :=", "nl_statement_of_codex": "Let $K$ be a field and let $L$ be an algebraic extension of $K$. Let $S$ be a subalgebra of $L$. Then $x\\in S$ if and only if $x$ is in the image of the subalgebra equivalence $S\\to L$."}
{"name": "ideal.torsion_of_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/torsion.lean", "formal_statement": "theorem ideal.torsion_of_zero (R M : Type*) [semiring R] [add_comm_monoid M]\n\t[module R M] :\n\tideal.torsion_of R M 0 = \u22a4 :=", "nl_statement_of_codex": "The torsion submodule of the trivial module is the whole module."}
{"name": "empty_wf", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/wf.lean", "formal_statement": "theorem empty_wf {\u03b1 : Sort u} :\n\twell_founded empty_relation :=", "nl_statement_of_codex": "The empty relation is well-founded."}
{"name": "multiset.filter_map_some", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.filter_map_some {\u03b1 : Type*} (s : multiset \u03b1) :\n\tmultiset.filter_map option.some s = s :=", "nl_statement_of_codex": "The multiset $s$ is equal to the multiset obtained by applying the function $x\\mapsto \\mathrm{some}(x)$ to $s$."}
{"name": "cau_seq.mul_lim_zero_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/cau_seq.lean", "formal_statement": "theorem cau_seq.mul_lim_zero_right {\u03b1 : Type*} [linear_ordered_field \u03b1]\n\t{\u03b2 : Type*} [ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [is_absolute_value abv] (f : cau_seq \u03b2 abv)\n\t{g : cau_seq \u03b2 abv} (hg : g.lim_zero) :\n\t(f * g).lim_zero :=", "nl_statement_of_codex": "Let $f$ be a Cauchy sequence in a ring $R$ and let $g$ be a Cauchy sequence in $R$ such that $g$ converges to $0$. Then $f\\cdot g$ converges to $0$."}
{"name": "bornology.is_bounded.compl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bornology/basic.lean", "formal_statement": "theorem bornology.is_bounded.compl {\u03b1 : Type*} [bornology \u03b1] {s : set \u03b1} :\n\tbornology.is_bounded s \u2192 bornology.is_cobounded s\u1d9c :=", "nl_statement_of_codex": "Let $X$ be a bornological space. If $A\\subset X$ is bounded, then $A^c$ is cobounded."}
{"name": "sq_eq_sq_iff_eq_or_eq_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/ring.lean", "formal_statement": "theorem sq_eq_sq_iff_eq_or_eq_neg {R : Type*} [comm_ring R] [no_zero_divisors R]\n\t{a b : R} :\n\ta ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with no zero divisors. Then $a^2=b^2$ if and only if $a=b$ or $a=-b$."}
{"name": "algebraic_geometry.LocallyRingedSpace.to_\u0393_Spec_preim_basic_open_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/Gamma_Spec_adjunction.lean", "formal_statement": "theorem algebraic_geometry.LocallyRingedSpace.to_\u0393_Spec_preim_basic_open_eq\n\t(X : algebraic_geometry.LocallyRingedSpace)\n\t(r : \u21a5(algebraic_geometry.LocallyRingedSpace.\u0393.obj (opposite.op X))) :\n\tX.to_\u0393_Spec_fun \u207b\u00b9' (prime_spectrum.basic_open r).val = (X.to_RingedSpace.basic_open r).val :=", "nl_statement_of_codex": "Let $X$ be a locally ringed space. Then the preimage of the basic open set $D(f)$ in $\\operatorname{Spec}(X)$ is the basic open set $D(f)$ in $X$."}
{"name": "localization.alg_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/basic.lean", "formal_statement": "theorem localization.alg_equiv_apply {R : Type*} [comm_semiring R]\n\t(M : submonoid R) (S : Type*) [comm_semiring S] [algebra R S]\n\t[is_localization M S] (\u1fb0 : localization M) :\n\t\u21d1(localization.alg_equiv M S) \u1fb0 = \u21d1(is_localization.map S \u2191(ring_equiv.refl R) _) \u1fb0 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ a submonoid of $R$, $S$ a commutative semiring, and $f:R\\to S$ a ring homomorphism. If $S$ is a localization of $R$ at $M$, then $f$ is a localization of $R$ at $M$."}
{"name": "linear_map.is_compl_of_proj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/projection.lean", "formal_statement": "theorem linear_map.is_compl_of_proj {R : Type*} [ring R] {E : Type*}\n\t[add_comm_group E] [module R E] {p : submodule R E} {f : E \u2192\u2097[R] \u21a5p}\n\t(hf : \u2200 (x : \u21a5p), \u21d1f \u2191x = x) :\n\tis_compl p f.ker :=", "nl_statement_of_codex": "Let $R$ be a ring, $E$ an $R$-module, and $p$ a submodule of $E$. Let $f:E\\to p$ be a linear map. If $f$ is the identity on $p$, then $f$ is a complement of $p$."}
{"name": "ereal.zero_ne_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ereal.lean", "formal_statement": "theorem ereal.zero_ne_bot :\n\t0 \u2260 \u22a5 :=", "nl_statement_of_codex": "$0\\neq\\bot$."}
{"name": "mvqpf.recF_eq_of_Wequiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/qpf/multivariate/constructions/fix.lean", "formal_statement": "theorem mvqpf.recF_eq_of_Wequiv {n : \u2115} {F : typevec (n + 1) \u2192 Type u}\n\t[mvfunctor F] [q : mvqpf F] (\u03b1 : typevec n) {\u03b2 : Type u} (u : F (\u03b1 ::: \u03b2) \u2192 \u03b2)\n\t(x y : (mvqpf.P F).W \u03b1) :\n\tmvqpf.Wequiv x y \u2192 mvqpf.recF u x = mvqpf.recF u y :=", "nl_statement_of_codex": "Let $F$ be a multivariate functor and let $q$ be a multivariate quotient preserving functor. Let $\u03b1$ be a type vector of length $n$ and let $\u03b2$ be a type. Let $u:F(\u03b1:::\u03b2)\\to \u03b2$ be a function. Let $x,y$ be elements of the set $W_\u03b1$ of equivalence classes of $\u03b1$-tuples. If $x$ and $y$ are equivalent, then the recursion function $u$ applied to $x$ and $y$ are equal."}
{"name": "div_mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_with_zero/basic.lean", "formal_statement": "theorem div_mul_left {G\u2080 : Type*} [group_with_zero G\u2080] {a b : G\u2080} (hb : b \u2260 0) :\n\tb / (a * b) = 1 / a :=", "nl_statement_of_codex": "Let $G$ be a group with zero. Let $a, b\\in G$ with $b\\neq 0$. Then $b/(ab)=1/a$."}
{"name": "pfun.dom_of_mem_fix", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pfun.lean", "formal_statement": "theorem pfun.dom_of_mem_fix {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192. \u03b2 \u2295 \u03b1} {a : \u03b1} {b : \u03b2}\n\t(h : b \u2208 f.fix a) :\n\t(f a).dom :=", "nl_statement_of_codex": "Let $f:A\\to A\\cup B$ be a partial function. If $b\\in f^\\infty(a)$, then $f(a)$ is defined."}
{"name": "bilin_form.to_matrix'_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/bilinear_form.lean", "formal_statement": "theorem bilin_form.to_matrix'_comp {R\u2082 : Type*} [comm_semiring R\u2082]\n\t{n o : Type*2} [fintype n] [fintype o] [decidable_eq n] [decidable_eq o]\n\t(B : bilin_form R\u2082 (n \u2192 R\u2082)) (l r : (o \u2192 R\u2082) \u2192\u2097[R\u2082] n \u2192 R\u2082) :\n\t\u21d1bilin_form.to_matrix' (B.comp l r) = ((\u21d1linear_map.to_matrix' l).transpose.mul (\u21d1bilin_form.to_matrix' B)).mul (\u21d1linear_map.to_matrix' r) :=", "nl_statement_of_codex": "Let $B$ be a bilinear form on $n\\times o$ and let $l,r:o\\to n$ be linear maps. Then the matrix of $B\\circ(l,r)$ is the product of the transpose of the matrix of $l$ with the matrix of $B$ and the matrix of $r$."}
{"name": "perfect_closure.frobenius_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/perfect_closure.lean", "formal_statement": "theorem perfect_closure.frobenius_mk (K : Type u) [comm_ring K] (p : \u2115)\n\t[fact (nat.prime p)] [char_p K p] (x : \u2115 \u00d7 K) :\n\t\u21d1(frobenius (perfect_closure K p) p) (perfect_closure.mk K p x) = perfect_closure.mk K p (x.fst, x.snd ^ p) :=", "nl_statement_of_codex": "Let $K$ be a commutative ring of characteristic $p$. Then the Frobenius map on the perfect closure of $K$ is given by $x\\mapsto x^p$."}
{"name": "filter.le_limsup_of_frequently_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/liminf_limsup.lean", "formal_statement": "theorem filter.le_limsup_of_frequently_le {\u03b1 \u03b2 : Type*}\n\t[conditionally_complete_linear_order \u03b2] {f : filter \u03b1} {u : \u03b1 \u2192 \u03b2} {b : \u03b2}\n\t(hu_le : \u2203\u1da0 (x : \u03b1) in f, b \u2264 u x)\n\t(hu : filter.is_bounded_under has_le.le f u . \"is_bounded_default\") :\n\tb \u2264 f.limsup u :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$ and let $u:X\\to \\mathbb{R}$. If $u$ is bounded above by $b$ and $u$ is frequently above $b$, then $\\limsup u\\leq b$."}
{"name": "lower_bounds_smul_of_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/module.lean", "formal_statement": "theorem lower_bounds_smul_of_neg {k M : Type*} [linear_ordered_field k]\n\t[ordered_add_comm_group M] [module k M] [ordered_smul k M] {s : set M} { : k}\n\t(hc : c < 0) :\n\tlower_bounds (c \u2022 s) = c \u2022 upper_bounds s :=", "nl_statement_of_codex": "Let $k$ be a linearly ordered field, $M$ a linearly ordered $k$-module, and $s$ a subset of $M$. If $c<0$, then the lower bounds of $c\\cdot s$ are the scalar multiples of the upper bounds of $s$."}
{"name": "part.mem_mk_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.mem_mk_iff {\u03b1 : Type*} {p : Prop} {o : p \u2192 \u03b1} {a : \u03b1} :\n\ta \u2208 {dom := p, get := o} \u2194 \u2203 (h : p), o h = a :=", "nl_statement_of_codex": "An element $a$ of the partial function $\\{dom:=p, get:=o\\}$ is of the form $o(h)$ for some $h$ such that $p$ holds."}
{"name": "real.eq_zero_rpow_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem real.eq_zero_rpow_iff {x a : \u211d} :\n\ta = 0 ^ x \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1 :=", "nl_statement_of_codex": "For $a, x\\in\\mathbb{R}$, $a=0^x$ if and only if $x\\neq 0$ and $a=0$ or $x=0$ and $a=1$."}
{"name": "polynomial.coeff_C_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.coeff_C_zero {R : Type u} {a : R} [semiring R] :\n\t(\u21d1polynomial.C a).coeff 0 = a :=", "nl_statement_of_codex": "The constant polynomial $f(x)=a$ has $f(0)=a$."}
{"name": "category_theory.limits.is_colimit.comp_cocone_points_iso_of_nat_iso_inv_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/is_limit.lean", "formal_statement": "theorem category_theory.limits.is_colimit.comp_cocone_points_iso_of_nat_iso_inv_assoc\n\t{J : Type u\u2081} [category_theory.category J] {C : Type u\u2083}\n\t[category_theory.category C] {F G : J \u2964 C}\n\t{s : category_theory.limits.cocone F} {t : category_theory.limits.cocone G}\n\t(P : category_theory.limits.is_colimit s)\n\t(Q : category_theory.limits.is_colimit t) (w : F \u2245 G) (j : J) {X' : C}\n\t(f' : s.X \u27f6 X') :\n\tt.\u03b9.app j \u226b (P.cocone_points_iso_of_nat_iso Q w).inv \u226b f' = w.inv.app j \u226b s.\u03b9.app j \u226b f' :=", "nl_statement_of_codex": "Let $F,G:J\\to C$ be functors and let $s,t$ be cocones over $F$ and $G$ respectively. Suppose that $s$ and $t$ are colimits. Let $w:F\\to G$ be a natural isomorphism. Then the induced isomorphism $w_*:F(j)\\to G(j)$ is the inverse of the isomorphism $P_{j,f'}:F(j)\\to t.X$."}
{"name": "nat.coprime.coprime_dvd_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.coprime.coprime_dvd_right {m k n : \u2115} (H1 : n \u2223 m)\n\t(H2 : k.coprime m) :\n\tk.coprime n :=", "nl_statement_of_codex": "If $n$ divides $m$ and $k$ is coprime to $m$, then $k$ is coprime to $n$."}
{"name": "set.pow_subset_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.pow_subset_pow {\u03b1 : Type*} [monoid \u03b1] {s t : set \u03b1} (hst : s \u2286 t)\n\t(n : \u2115) :\n\ts ^ n \u2286 t ^ n :=", "nl_statement_of_codex": "Let $s$ and $t$ be subsets of a monoid $M$. If $s\\subset t$, then $s^n\\subset t^n$ for all $n\\in\\mathbb{N}$."}
{"name": "first_order.language.Theory.is_satisfiable.is_finitely_satisfiable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/satisfiability.lean", "formal_statement": "theorem first_order.language.Theory.is_satisfiable.is_finitely_satisfiable\n\t{L : first_order.language} {T : L.Theory} (h : T.is_satisfiable) :\n\tT.is_finitely_satisfiable :=", "nl_statement_of_codex": "If a theory $T$ is satisfiable, then it is finitely satisfiable."}
{"name": "mv_polynomial.derivation_C_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/derivation.lean", "formal_statement": "theorem mv_polynomial.derivation_C_mul {\u03c3 R A : Type*} [comm_semiring R]\n\t[add_comm_monoid A] [module R A] [module (mv_polynomial \u03c3 R) A]\n\t(D : derivation R (mv_polynomial \u03c3 R) A) (a : R) (f : mv_polynomial \u03c3 R) :\n\t\u21d1D (\u21d1mv_polynomial.C a * f) = a \u2022 \u21d1D f :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a module over $R$, and $D$ a derivation from $R$ to $A$. Then $D(af)=aD(f)$ for all $a\\in R$ and $f\\in R[x_1,\\ldots,x_n]$."}
{"name": "continuous_within_at_update_same", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_on.lean", "formal_statement": "theorem continuous_within_at_update_same {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [decidable_eq \u03b1] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {x : \u03b1} {y : \u03b2} :\n\tcontinuous_within_at (function.update f x y) s x \u2194 filter.tendsto f (nhds_within x (s \\ {x})) (nhds y) :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces, let $f:X\\to Y$, let $s\\subset X$, and let $x\\in X$. Then $f$ is continuous at $x$ if and only if the function $f$ is continuous at $x$ on $s\\setminus\\{x\\}$."}
{"name": "category_theory.left_unitor_inv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/types.lean", "formal_statement": "theorem category_theory.left_unitor_inv_apply {X : Type u} {x : X} :\n\t(\u03bb_ X).inv x = (punit.star, x) :=", "nl_statement_of_codex": "The inverse of the left unitor is given by $(\\star,x)$."}
{"name": "measure_theory.signed_measure.to_jordan_decomposition_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/decomposition/jordan.lean", "formal_statement": "theorem measure_theory.signed_measure.to_jordan_decomposition_zero {\u03b1 : Type*}\n\t[measurable_space \u03b1] :\n\t0.to_jordan_decomposition = 0 :=", "nl_statement_of_codex": "The Jordan decomposition of the zero measure is the zero measure."}
{"name": "pgame.mk_mul_move_left_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/basic.lean", "formal_statement": "theorem pgame.mk_mul_move_left_inr {xl xr yl yr : Type*} {xL : xl \u2192 pgame}\n\t{xR : xr \u2192 pgame} {yL : yl \u2192 pgame} {yR : yr \u2192 pgame} {i : xr} {j : yr} :\n\t(pgame.mk xl xr xL xR * pgame.mk yl yr yL yR).move_left (sum.inr (i, j)) = xR i * pgame.mk yl yr yL yR + pgame.mk xl xr xL xR * yR j - xR i * yR j :=", "nl_statement_of_codex": "Let $x_L, x_R, y_L, y_R$ be functions from $x_l, x_r, y_l, y_r$ to $\\mathbb{N}$. Then the left move of the sum of the games $x_L(i)$ and $y_L(j)$ is equal to the sum of the games $x_R(i)$ and $y_R(j)$ minus the product of the games $x_R(i)$ and $y_R(j)$."}
{"name": "subgroup.is_open_of_one_mem_interior", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/open_subgroup.lean", "formal_statement": "theorem subgroup.is_open_of_one_mem_interior {G : Type*} [group G]\n\t[topological_space G] [topological_group G] {H : subgroup G}\n\t(h_1_int : 1 \u2208 interior \u2191H) :\n\tis_open \u2191H :=", "nl_statement_of_codex": "Let $G$ be a topological group. If $1\\in H$, then $H$ is open."}
{"name": "hyperreal.infinitesimal_inv_of_infinite", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.infinitesimal_inv_of_infinite {x : \u211d*} :\n\tx.infinite \u2192 x\u207b\u00b9.infinitesimal :=", "nl_statement_of_codex": "If $x$ is infinite, then $1/x$ is infinitesimal."}
{"name": "asymptotics.is_O_with.norm_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_with.norm_right {\u03b1 E F' : Type*} [has_norm E]\n\t[semi_normed_group F'] { : \u211d} {f : \u03b1 \u2192 E} {g' : \u03b1 \u2192 F'} {l : filter \u03b1} :\n\tasymptotics.is_O_with c l f g' \u2192 asymptotics.is_O_with c l f (\u03bb (x : \u03b1), \u2225g' x\u2225) :=", "nl_statement_of_codex": "Let $E$ be a normed space and let $F'$ be a semi-normed group. Let $f,g':X\\to E$ be functions. Then $f$ is $O(g')$ if and only if $f$ is $O(\\|g'\\|)$."}
{"name": "matrix.rank_unit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/rank.lean", "formal_statement": "theorem matrix.rank_unit {n K : Type*} [fintype n] [decidable_eq n] [field K]\n\t(A : (matrix n n K)\u02e3) :\n\t\u2191A.rank = fintype.card n :=", "nl_statement_of_codex": "The rank of a unit matrix is the number of rows."}
{"name": "gaussian_int.to_complex_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/gaussian_int.lean", "formal_statement": "theorem gaussian_int.to_complex_sub (x y : gaussian_int) :\n\t\u2191(x - y) = \u2191x - \u2191y :=", "nl_statement_of_codex": "The map $\\mathbb{Z}[i]\\to\\mathbb{C}$ is a group homomorphism."}
{"name": "measurable_set.exists_is_open_diff_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/regular.lean", "formal_statement": "theorem measurable_set.exists_is_open_diff_lt {\u03b1 : Type*} [measurable_space \u03b1]\n\t[topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [\u03bc.outer_regular]\n\t{A : set \u03b1} (hA : measurable_set A) (hA' : \u21d1\u03bc A \u2260 \u22a4) {\u03b5 : ennreal} (h\u03b5 : \u03b5 \u2260 0) :\n\t\u2203 (U : set \u03b1) (H : U \u2287 A), is_open U \u2227 \u21d1\u03bc U < \u22a4 \u2227 \u21d1\u03bc (U \\ A) < \u03b5 :=", "nl_statement_of_codex": "Let $A$ be a measurable set in a topological space $X$ with a measure $\\mu$. If $\\mu(A)<\\infty$, then there is an open set $U$ containing $A$ such that $\\mu(U)<\\infty$ and $\\mu(U\\setminus A)<\\epsilon$."}
{"name": "set.eq_on.symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/function.lean", "formal_statement": "theorem set.eq_on.symm {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2}\n\t(h : set.eq_on f\u2081 f\u2082 s) :\n\tset.eq_on f\u2082 f\u2081 s :=", "nl_statement_of_codex": "Let $f_1, f_2:A\\to B$ be functions. If $f_1(x)=f_2(x)$ for all $x\\in S$, then $f_2(x)=f_1(x)$ for all $x\\in S$."}
{"name": "eventually_maps_to_of_is_compact_absorbing_of_is_open_of_omega_limit_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/omega_limit.lean", "formal_statement": "theorem eventually_maps_to_of_is_compact_absorbing_of_is_open_of_omega_limit_subset\n\t{\u03c4 \u03b1 \u03b2 : Type*} [topological_space \u03b2] (f : filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2)\n\t(s : set \u03b1) [t2_space \u03b2] { : set \u03b2} (hc\u2081 : is_compact c)\n\t(hc\u2082 : \u2200\u1da0 (t : \u03c4) in f, set.maps_to (\u03d5 t) s c) {n : set \u03b2} (hn\u2081 : is_open n)\n\t(hn\u2082 : omega_limit f \u03d5 s \u2286 n) :\n\t\u2200\u1da0 (t : \u03c4) in f, set.maps_to (\u03d5 t) s n :=", "nl_statement_of_codex": "Let $f$ be a filter on $\\tau$, let $\\phi:\\tau\\times\\alpha\\to\\beta$ be a function, let $s$ be a subset of $\\alpha$, let $c$ be a compact subset of $\\beta$, and let $n$ be an open subset of $\\beta$. Suppose that for every $t\\in\\tau$ in the filter $f$, the image of $\\phi(t,\\cdot)$ is contained in $c$, and that the $\\omega$-limit set of $\\phi$ is contained in $n$. Then for every $t\\in\\tau$ in the filter $f$, the image of $\\phi(t,"}
{"name": "mul_finsum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem mul_finsum {\u03b1 R : Type*} [semiring R] (f : \u03b1 \u2192 R) (r : R)\n\t(h : (function.support f).finite) :\n\tr * finsum (\u03bb (a : \u03b1), f a) = finsum (\u03bb (a : \u03b1), r * f a) :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $f:\\alpha\\to R$. Then $r\\cdot\\sum_{a\\in\\alpha}f(a)=\\sum_{a\\in\\alpha}r\\cdot f(a)$."}
{"name": "hyperreal.infinite_mul_of_infinite_not_infinitesimal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.infinite_mul_of_infinite_not_infinitesimal {x y : \u211d*} :\n\tx.infinite \u2192 \u00acy.infinitesimal \u2192 (x * y).infinite :=", "nl_statement_of_codex": "If $x$ is infinite and $y$ is not infinitesimal, then $xy$ is infinite."}
{"name": "list.form_perm_disjoint_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/concrete.lean", "formal_statement": "theorem list.form_perm_disjoint_iff {\u03b1 : Type*} [decidable_eq \u03b1] {l l' : list \u03b1}\n\t(hl : l.nodup) (hl' : l'.nodup) (hn : 2 \u2264 l.length) (hn' : 2 \u2264 l'.length) :\n\tl.form_perm.disjoint l'.form_perm \u2194 l.disjoint l' :=", "nl_statement_of_codex": "Let $l$ and $l'$ be lists of length at least $2$ with no duplicates. Then $l$ and $l'$ are disjoint if and only if $l$ and $l'$ form disjoint permutations."}
{"name": "int.mul_pos_of_neg_of_neg", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.mul_pos_of_neg_of_neg {a b : \u2124} (ha : a < 0) (hb : b < 0) :\n\t0 < a * b :=", "nl_statement_of_codex": "If $a,b\\in\\mathbb{Z}$ are negative, then $ab>0$."}
{"name": "list.nth_le_zip_with", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/zip.lean", "formal_statement": "theorem list.nth_le_zip_with {\u03b1 : Type u} {\u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n\t{l : list \u03b1} {l' : list \u03b2} {i : \u2115} {h : i < (list.zip_with f l l').length} :\n\t(list.zip_with f l l').nth_le i h = f (l.nth_le i _) (l'.nth_le i _) :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. Let $l$ be a list of elements of $A$ and $l'$ a list of elements of $B$. Then the $i$-th element of the list $l\\otimes l'$ is $f(l_i,l'_i)$."}
{"name": "measure_theory.mem_\u2112p.restrict", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/lp_space.lean", "formal_statement": "theorem measure_theory.mem_\u2112p.restrict {\u03b1 E : Type*} {m0 : measurable_space \u03b1}\n\t{p : ennreal} {\u03bc : measure_theory.measure \u03b1} [normed_group E] (s : set \u03b1)\n\t{f : \u03b1 \u2192 E} (hf : measure_theory.mem_\u2112p f p \u03bc) :\n\tmeasure_theory.mem_\u2112p f p (\u03bc.restrict s) :=", "nl_statement_of_codex": "Let $E$ be a normed group, let $p\\in [1,\\infty]$, let $\\mu$ be a measure on a measurable space $(X,\\mathcal{A})$, and let $f:X\\to E$. If $f\\in L^p(\\mu)$, then $f\\in L^p(\\mu\\restriction A)$ for any $A\\in\\mathcal{A}$."}
{"name": "num.cast_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem num.cast_pos {\u03b1 : Type*} [has_zero \u03b1] [has_one \u03b1] [has_add \u03b1]\n\t(n : pos_num) :\n\t\u2191(num.pos n) = \u2191n :=", "nl_statement_of_codex": "The cast from positive numbers to numbers is the identity."}
{"name": "function.right_inverse.left_inverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.right_inverse.left_inverse {\u03b1 : Sort u_1} {\u03b2 : Sort u_2}\n\t{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : function.right_inverse g f) :\n\tfunction.left_inverse f g :=", "nl_statement_of_codex": "If $g$ is a right inverse of $f$, then $f$ is a left inverse of $g$."}
{"name": "smul_inv\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/smul_with_zero.lean", "formal_statement": "theorem smul_inv\u2080 {\u03b1 \u03b2 : Type*} [group_with_zero \u03b1] [group_with_zero \u03b2]\n\t[mul_action_with_zero \u03b1 \u03b2] [smul_comm_class \u03b1 \u03b2 \u03b2] [is_scalar_tower \u03b1 \u03b2 \u03b2]\n\t( : \u03b1) (x : \u03b2) :\n\t(c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9 :=", "nl_statement_of_codex": "Let $G$ be a group with zero and let $V$ be a $G$-module. Then for all $g\\in G$ and $v\\in V$, $(gv)^{-1}=g^{-1}v^{-1}$."}
{"name": "mvqpf.liftp_preservation_iff_uniform", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/qpf/multivariate/basic.lean", "formal_statement": "theorem mvqpf.liftp_preservation_iff_uniform {n : \u2115} {F : typevec n \u2192 Type*}\n\t[mvfunctor F] [q : mvqpf F] :\n\tq.liftp_preservation \u2194 q.is_uniform :=", "nl_statement_of_codex": "Let $F$ be a multivariate functor. Then $F$ is a quasi-polynomial functor if and only if $F$ is uniform."}
{"name": "onote.oadd_lt_oadd_1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/notation.lean", "formal_statement": "theorem onote.oadd_lt_oadd_1 {e\u2081 : onote} {n\u2081 : \u2115+} {o\u2081 e\u2082 : onote} {n\u2082 : \u2115+}\n\t{o\u2082 : onote} (h\u2081 : onote.NF (e\u2081.oadd n\u2081 o\u2081)) (h : e\u2081 < e\u2082) :\n\te\u2081.oadd n\u2081 o\u2081 < e\u2082.oadd n\u2082 o\u2082 :=", "nl_statement_of_codex": "Let $e_1, e_2, o_1, o_2$ be ordinal notes and $n_1, n_2$ be natural numbers. If $e_1<e_2$ and $e_1+n_1o_1$ is normal form, then $e_1+n_1o_1<e_2+n_2o_2$."}
{"name": "plift.rec.constant", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/control/ulift.lean", "formal_statement": "theorem plift.rec.constant {\u03b1 : Sort u} {\u03b2 : Type v} (b : \u03b2) :\n\tplift.rec (\u03bb (_x : \u03b1), b) = \u03bb (_x : plift \u03b1), b :=", "nl_statement_of_codex": "The function $f: \\mathrm{plift}(A)\\to B$ defined by $f(x)=b$ for all $x\\in \\mathrm{plift}(A)$ is equal to the constant function $g:\\mathrm{plift}(A)\\to B$ defined by $g(x)=b$ for all $x\\in \\mathrm{plift}(A)$."}
{"name": "asymptotics.is_o_iff_nat_mul_le'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_o_iff_nat_mul_le' {\u03b1 F E' : Type*} [has_norm F]\n\t[semi_normed_group E'] {g : \u03b1 \u2192 F} {f' : \u03b1 \u2192 E'} {l : filter \u03b1} :\n\tf' =o[l] g \u2194 \u2200 (n : \u2115), \u2200\u1da0 (x : \u03b1) in l, \u2191n * \u2225f' x\u2225 \u2264 \u2225g x\u2225 :=", "nl_statement_of_codex": "Let $F$ be a normed group and let $E'$ be a semi-normed group. Let $f':X\\to E'$ and $g:X\\to F$ be functions. Then $f'=o_l(g)$ if and only if for all $n\\in\\mathbb{N}$ and all $x\\in X$ in the filter $l$, $n\\cdot\\|f'(x)\\|\\leq\\|g(x)\\|$."}
{"name": "list.take_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.take_left {\u03b1 : Type u} (l\u2081 l\u2082 : list \u03b1) :\n\tlist.take l\u2081.length (l\u2081 ++ l\u2082) = l\u2081 :=", "nl_statement_of_codex": "The first $n$ elements of the concatenation of two lists $l_1$ and $l_2$ is $l_1$."}
{"name": "fin.prod_congr'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/fin.lean", "formal_statement": "theorem fin.prod_congr' {M : Type*} [comm_monoid M] {a b : \u2115} (f : fin b \u2192 M)\n\t(h : a = b) :\n\tfinset.univ.prod (\u03bb (i : fin a), f (\u21d1(fin.cast h) i)) = finset.univ.prod (\u03bb (i : fin b), f i) :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid. Let $a, b\\in\\mathbb{N}$ and let $f: \\{0,\\ldots,b-1\\}\\to M$. Then $\\prod_{i=0}^{a-1} f(i)=\\prod_{i=0}^{b-1} f(i)$."}
{"name": "cmp_le_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/compare.lean", "formal_statement": "theorem cmp_le_swap {\u03b1 : Type*} [has_le \u03b1] [is_total \u03b1 has_le.le]\n\t[decidable_rel has_le.le] (x y : \u03b1) :\n\t(cmp_le x y).swap = cmp_le y x :=", "nl_statement_of_codex": "Let $x,y$ be elements of a totally ordered set. Then $x\\leq y$ if and only if $y\\leq x$."}
{"name": "local_homeomorph.subtype_restr_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/local_homeomorph.lean", "formal_statement": "theorem local_homeomorph.subtype_restr_def {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2)\n\t(s : topological_space.opens \u03b1) [nonempty \u21a5s] :\n\te.subtype_restr s = s.local_homeomorph_subtype_coe.trans e :=", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Let $U$ be an open subset of $X$. Then $e|_U:U\\to e(U)$ is a local homeomorphism."}
{"name": "category_theory.limits.pullback.lift_snd_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/pullbacks.lean", "formal_statement": "theorem category_theory.limits.pullback.lift_snd_assoc {C : Type u}\n\t[category_theory.category C] {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z}\n\t[category_theory.limits.has_pullback f g] (h : W \u27f6 X) (k : W \u27f6 Y)\n\t(w : h \u226b f = k \u226b g) {X' : C} (f' : Y \u27f6 X') :\n\tcategory_theory.limits.pullback.lift h k w \u226b category_theory.limits.pullback.snd \u226b f' = k \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category. Let $f:X\\to Z$ and $g:Y\\to Z$ be morphisms in $C$. Suppose that $f$ and $g$ have a pullback. Let $h:W\\to X$ and $k:W\\to Y$ be morphisms in $C$ such that $h\\circ f=k\\circ g$. Let $f':Y\\to X'$ be a morphism in $C$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nW & \\xrightarrow{\\text{lift}} & X\\times_Z Y \\\\\n\\downarrow{h} & &"}
{"name": "list.sublists_len_aux_append", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/sublists.lean", "formal_statement": "theorem list.sublists_len_aux_append {\u03b1 \u03b2 \u03b3 : Type*} (n : \u2115) (l : list \u03b1)\n\t(f : list \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (r : list \u03b2) (s : list \u03b3) :\n\tlist.sublists_len_aux n l (g \u2218 f) (list.map g r ++ s) = list.map g (list.sublists_len_aux n l f r) ++ s :=", "nl_statement_of_codex": "Let $n$ be a natural number, let $l$ be a list of elements of type $\\alpha$, let $f$ be a function from lists of elements of type $\\alpha$ to elements of type $\\beta$, let $g$ be a function from elements of type $\\beta$ to elements of type $\\gamma$, let $r$ be a list of elements of type $\\beta$, and let $s$ be a list of elements of type $\\gamma$. Then the list of all sublists of $l$ of length $n$ obtained by applying $g$ to the list of all sublists of $l$ of length $n$ obtained by applying $f$ to $l$ is equal to"}
{"name": "nat.lcm_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.lcm_self (m : \u2115) :\n\tm.lcm m = m :=", "nl_statement_of_codex": "The least common multiple of $m$ and $m$ is $m$."}
{"name": "real.exp_log_eq_abs", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/log/basic.lean", "formal_statement": "theorem real.exp_log_eq_abs {x : \u211d} (hx : x \u2260 0) :\n\treal.exp (real.log x) = |x| :=", "nl_statement_of_codex": "For $x\\in\\mathbb{R}$, $x\\neq 0$, we have $\\exp(\\log(x))=|x|$."}
{"name": "pequiv.mem_of_set_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pequiv.lean", "formal_statement": "theorem pequiv.mem_of_set_iff {\u03b1 : Type u} {s : set \u03b1}\n\t[decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)] {a b : \u03b1} :\n\ta \u2208 \u21d1(pequiv.of_set s) b \u2194 a = b \u2227 a \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a set. Then $a\\in\\equiv_s b$ if and only if $a=b$ and $a\\in s$."}
{"name": "normalizer_condition_iff_only_full_group_self_normalizing", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem normalizer_condition_iff_only_full_group_self_normalizing {G : Type*}\n\t[group G] :\n\tnormalizer_condition G \u2194 \u2200 (H : subgroup G), H.normalizer = H \u2192 H = \u22a4 :=", "nl_statement_of_codex": "Let $G$ be a group. Then $G$ is self-normalizing if and only if every subgroup of $G$ is normal."}
{"name": "int.preimage_closed_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/int.lean", "formal_statement": "theorem int.preimage_closed_ball (x : \u2124) (r : \u211d) :\n\tcoe \u207b\u00b9' metric.closed_ball \u2191x r = metric.closed_ball x r :=", "nl_statement_of_codex": "The preimage of the closed ball of radius $r$ centered at $x$ under the map $x\\mapsto \\lfloor x\\rfloor$ is the closed ball of radius $r$ centered at $\\lfloor x\\rfloor$."}
{"name": "is_min.Iic_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem is_min.Iic_eq {\u03b1 : Type*} [partial_order \u03b1] {a : \u03b1} (h : is_min a) :\n\tset.Iic a = {a} :=", "nl_statement_of_codex": "Let $a$ be a minimal element of a partially ordered set $X$. Then $\\{x\\in X:x\\leq a\\}=\\{a\\}$."}
{"name": "uniform_embedding_iff'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean", "formal_statement": "theorem uniform_embedding_iff' {\u03b2 : Type v} {\u03b3 : Type w} [emetric_space \u03b3]\n\t[emetric_space \u03b2] {f : \u03b3 \u2192 \u03b2} :\n\tuniform_embedding f \u2194 (\u2200 (\u03b5 : ennreal), \u03b5 > 0 \u2192 (\u2203 (\u03b4 : ennreal) (H : \u03b4 > 0), \u2200 {a b : \u03b3}, has_edist.edist a b < \u03b4 \u2192 has_edist.edist (f a) (f b) < \u03b5)) \u2227 \u2200 (\u03b4 : ennreal), \u03b4 > 0 \u2192 (\u2203 (\u03b5 : ennreal) (H : \u03b5 > 0), \u2200 {a b : \u03b3}, has_edist.edist (f a) (f b) < \u03b5 \u2192 has_edist.edist a b < \u03b4) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between two extended metric spaces. Then $f$ is a uniform embedding if and only if for every $\\epsilon>0$ there is a $\\delta>0$ such that $d_Y(f(x),f(y))<\\epsilon$ whenever $d_X(x,y)<\\delta$ and for every $\\delta>0$ there is an $\\epsilon>0$ such that $d_X(x,y)<\\delta$ whenever $d_Y(f(x),f(y))<\\epsilon$."}
{"name": "set.preimage_const_sub_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/image_preimage.lean", "formal_statement": "theorem set.preimage_const_sub_Ico {G : Type u} [ordered_add_comm_group G]\n\t(a b c : G) :\n\t(\u03bb (x : G), a - x) \u207b\u00b9' set.Ico b c = set.Ioc (a - c) (a - b) :=", "nl_statement_of_codex": "Let $G$ be an ordered abelian group. Let $a, b, c\\in G$. Then $(a-x)^{-1}[b,c]=[a-c,a-b]$."}
{"name": "is_glb.of_subset_of_superset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem is_glb.of_subset_of_superset {\u03b1 : Type u} [preorder \u03b1] {a : \u03b1}\n\t{s t p : set \u03b1} (hs : is_glb s a) (hp : is_glb p a) (hst : s \u2286 t) (htp : t \u2286 p) :\n\tis_glb t a :=", "nl_statement_of_codex": "Let $s, t, p$ be subsets of a preordered set $X$ and let $a\\in X$. If $a$ is the greatest lower bound of $s$ and $a$ is the greatest lower bound of $p$, then $a$ is the greatest lower bound of $t$."}
{"name": "set.ord_connected_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/ord_connected.lean", "formal_statement": "theorem set.ord_connected_univ {\u03b1 : Type*} [preorder \u03b1] :\n\tset.univ.ord_connected :=", "nl_statement_of_codex": "The set $\\mathbb{R}$ is order connected."}
{"name": "lt_of_le_of_lt'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/basic.lean", "formal_statement": "theorem lt_of_le_of_lt' {\u03b1 : Type u} [preorder \u03b1] {a b c : \u03b1} :\n\tb \u2264 c \u2192 a < b \u2192 a < c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a preorder. If $b\\leq c$ and $a<b$, then $a<c$."}
{"name": "ae_measurable.add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem ae_measurable.add {M \u03b1 : Type*} [measurable_space M] [has_add M]\n\t{m : measurable_space \u03b1} {f g : \u03b1 \u2192 M} {\u03bc : measure_theory.measure \u03b1}\n\t[has_measurable_add\u2082 M] (hf : ae_measurable f \u03bc) (hg : ae_measurable g \u03bc) :\n\tae_measurable (\u03bb (a : \u03b1), f a + g a) \u03bc :=", "nl_statement_of_codex": "Let $M$ be a measurable space and let $f,g:\\alpha\\to M$ be measurable functions. Then $f+g$ is measurable."}
{"name": "add_localization.mk_eq_add_monoid_of_mk'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem add_localization.mk_eq_add_monoid_of_mk' {M : Type*} [add_comm_monoid M]\n\t{S : add_submonoid M} :\n\tadd_localization.mk = (add_localization.add_monoid_of S).mk' :=", "nl_statement_of_codex": "The map $M\\to S^{-1}M$ is the same as the map $M\\to (S^{-1}M)^+$."}
{"name": "category_theory.limits.prod_comparison_fst_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/binary_products.lean", "formal_statement": "theorem category_theory.limits.prod_comparison_fst_assoc {C : Type u}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t(F : C \u2964 D) {A B : C} [category_theory.limits.has_binary_product A B]\n\t[category_theory.limits.has_binary_product (F.obj A) (F.obj B)] {X' : D}\n\t(f' : F.obj A \u27f6 X') :\n\tcategory_theory.limits.prod_comparison F A B \u226b category_theory.limits.prod.fst \u226b f' = F.map category_theory.limits.prod.fst \u226b f' :=", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor between categories $C$ and $D$. Let $A$ and $B$ be objects of $C$ and let $X'$ be an object of $D$. Let $f':F(A)\\to X'$ be a morphism in $D$. Then the following diagram commutes:\n\\begin{tikzcd}\nF(A\\times B) \\arrow[r, "}
{"name": "category_theory.oplax_nat_trans.whisker_right_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/functor_bicategory.lean", "formal_statement": "theorem category_theory.oplax_nat_trans.whisker_right_app {B : Type u\u2081}\n\t[category_theory.bicategory B] {C : Type u\u2082} [category_theory.bicategory C]\n\t{F G H : category_theory.oplax_functor B C} {\u03b7 \u03b8 : F \u27f6 G} (\u0393 : \u03b7 \u27f6 \u03b8)\n\t(\u03b9 : G \u27f6 H) (a : B) :\n\t(category_theory.oplax_nat_trans.whisker_right \u0393 \u03b9).app a = category_theory.bicategory.whisker_right (\u0393.app a) (\u03b9.app a) :=", "nl_statement_of_codex": "Let $B$ and $C$ be bicategories. Let $F, G, H:B\\to C$ be oplax functors. Let $\\eta, \\theta:F\\to G$ be oplax natural transformations. Let $\\Gamma:\\eta\\to\\theta$ be a 2-cell. Let $\\iota:G\\to H$ be a lax natural transformation. Let $a$ be an object of $B$. Then the 2-cell $(\\Gamma\\cdot\\iota)_a:F(a)\\to H(a)$ is the composite of the 2-cell $\\Gamma_a:F(a)\\to G(a"}
{"name": "topological_semiring_of_smooth", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/algebra/structures.lean", "formal_statement": "theorem topological_semiring_of_smooth {\ud835\udd5c R E H : Type*} [topological_space R]\n\t[topological_space H] [nondiscrete_normed_field \ud835\udd5c] [normed_group E]\n\t[normed_space \ud835\udd5c E] [charted_space H R] (I : model_with_corners \ud835\udd5c E H)\n\t[semiring R] [smooth_ring I R] :\n\ttopological_semiring R :=", "nl_statement_of_codex": "Let $R$ be a smooth ring over a model with corners $I$. Then $R$ is a topological semiring."}
{"name": "topological_fiber_bundle.pretrivialization.symm_apply_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/fiber_bundle.lean", "formal_statement": "theorem topological_fiber_bundle.pretrivialization.symm_apply_apply\n\t{B F Z : Type*} [topological_space B] [topological_space F] {proj : Z \u2192 B}\n\t(e : topological_fiber_bundle.pretrivialization F proj) {x : Z}\n\t(hx : x \u2208 e.to_local_equiv.source) :\n\t\u21d1(e.to_local_equiv.symm) (\u21d1e x) = x :=", "nl_statement_of_codex": "Let $B$ be a topological space, let $F$ be a topological space, and let $Z$ be a topological space. Let $p:Z\\to B$ be a continuous map. Let $e$ be a pretrivialization of $p$. Let $x\\in Z$. Then $e^{-1}(e(x))=x$."}
{"name": "has_sum.unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean", "formal_statement": "theorem has_sum.unique {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} {a\u2081 a\u2082 : \u03b1} [t2_space \u03b1] :\n\thas_sum f a\u2081 \u2192 has_sum f a\u2082 \u2192 a\u2081 = a\u2082 :=", "nl_statement_of_codex": "Let $f:B\\to A$ be a function from a set $B$ to an abelian topological group $A$. If $f$ has two sums $a_1$ and $a_2$, then $a_1=a_2$."}
{"name": "finset.image\u2082_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/n_ary.lean", "formal_statement": "theorem finset.image\u2082_subset {\u03b1 \u03b2 \u03b3 : Type*} [decidable_eq \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n\t{s s' : finset \u03b1} {t t' : finset \u03b2} (hs : s \u2286 s') (ht : t \u2286 t') :\n\tfinset.image\u2082 f s t \u2286 finset.image\u2082 f s' t' :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. If $A'\\subset A$ and $B'\\subset B$, then $f(A'\\times B')\\subset f(A\\times B)$."}
{"name": "finset.card_nsmul_le_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/order.lean", "formal_statement": "theorem finset.card_nsmul_le_sum {\u03b9 N : Type*} [ordered_add_comm_monoid N]\n\t(s : finset \u03b9) (f : \u03b9 \u2192 N) (n : N) (h : \u2200 (x : \u03b9), x \u2208 s \u2192 n \u2264 f x) :\n\ts.card \u2022 n \u2264 s.sum f :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to N$ be a function. Then $\\sum_{x\\in s}f(x)\\geq |s|\\cdot \\min_{x\\in s}f(x)$."}
{"name": "poly.coe_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/dioph.lean", "formal_statement": "theorem poly.coe_neg {\u03b1 : Type*} (f : poly \u03b1) :\n\t\u21d1-f = -\u21d1f :=", "nl_statement_of_codex": "The polynomial $-f$ is the negation of the polynomial $f$."}
{"name": "ordinal.mod_eq_zero_of_dvd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.mod_eq_zero_of_dvd {a b : ordinal} (H : b \u2223 a) :\n\ta % b = 0 :=", "nl_statement_of_codex": "Let $a$ and $b$ be ordinals. If $b$ divides $a$, then $a\\bmod b=0$."}
{"name": "circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/circle/rotation_number/translation_number.lean", "formal_statement": "theorem circle_deg1_lift.semiconj_of_is_unit_of_translation_number_eq\n\t{f\u2081 f\u2082 : circle_deg1_lift} (h\u2081 : is_unit f\u2081) (h\u2082 : is_unit f\u2082)\n\t(h : f\u2081.translation_number = f\u2082.translation_number) :\n\t\u2203 (F : circle_deg1_lift), function.semiconj \u21d1F \u21d1f\u2081 \u21d1f\u2082 :=", "nl_statement_of_codex": "Let $f_1, f_2$ be two circle homeomorphisms with degree $1$. If $f_1$ and $f_2$ are both orientation-preserving and have the same translation number, then there is a circle homeomorphism $F$ such that $F\\circ f_1\\circ F^{-1}=f_2$."}
{"name": "dense_range.dense_of_maps_to", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem dense_range.dense_of_maps_to {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf' : dense_range f) (hf : continuous f)\n\t{s : set \u03b1} (hs : dense s) {t : set \u03b2} (ht : set.maps_to f s t) :\n\tdense t :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous function. If $f$ has dense range and $S\\subset X$ is dense, then $f(S)$ is dense in $Y$."}
{"name": "affine_map.vector_span_image_eq_submodule_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_subspace.lean", "formal_statement": "theorem affine_map.vector_span_image_eq_submodule_map {k V\u2081 P\u2081 V\u2082 P\u2082 : Type*}\n\t[ring k] [add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081]\n\t[add_comm_group V\u2082] [module k V\u2082] [add_torsor V\u2082 P\u2082] (f : P\u2081 \u2192\u1d43[k] P\u2082)\n\t{s : set P\u2081} :\n\tsubmodule.map f.linear (vector_span k s) = vector_span k (\u21d1f '' s) :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ and $V_2$ be $k$-modules, and $P_1$ and $P_2$ be $k$-affine spaces. Let $f:P_1\\to P_2$ be an affine map. Then the image of the linear map $f_\\ast:V_1\\to V_2$ is equal to the vector span of the image of $f$."}
{"name": "Top.adj\u2082_unit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Top/adjunctions.lean", "formal_statement": "theorem Top.adj\u2082_unit :\n\tTop.adj\u2082.unit = {app := \u03bb (X : Top), {to_fun := id \u21a5X, continuous_to_fun := _}, naturality' := Top.adj\u2082._proof_2} :=", "nl_statement_of_codex": "The unit of the adjunction between the category of topological spaces and the category of continuous functions is the identity functor."}
{"name": "cont_mdiff_on.congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem cont_mdiff_on.congr {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M]\n\t[charted_space H M] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{H' : Type*} [topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'}\n\t{M' : Type*} [topological_space M'] [charted_space H' M'] {f f\u2081 : M \u2192 M'}\n\t{s : set M} {n : with_top \u2115} (h : cont_mdiff_on I I' n f s)\n\t(h\u2081 : \u2200 (y : M), y \u2208 s \u2192 f\u2081 y = f y) :\n\tcont_mdiff_on I I' n f\u2081 s :=", "nl_statement_of_codex": "Let $f,f_1:M\\to M'$ be $n$-times continuously differentiable maps between manifolds with corners. If $f$ and $f_1$ agree on a set $S$, then $f_1$ is $n$-times continuously differentiable on $S$."}
{"name": "smooth_bump_function.le_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/bump_function.lean", "formal_statement": "theorem smooth_bump_function.le_one {E : Type uE} [normed_group E]\n\t[normed_space \u211d E] [finite_dimensional \u211d E] {H : Type uH} [topological_space H]\n\t{I : model_with_corners \u211d E H} {M : Type uM} [topological_space M]\n\t[charted_space H M] [smooth_manifold_with_corners I M] { : M}\n\t(f : smooth_bump_function I c) {x : M} :\n\t\u21d1f x \u2264 1 :=", "nl_statement_of_codex": "Let $M$ be a smooth manifold with corners. Let $f$ be a smooth bump function on $M$. Then $f(x)\\leq 1$ for all $x\\in M$."}
{"name": "polynomial.nat_degree_add_eq_left_of_nat_degree_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.nat_degree_add_eq_left_of_nat_degree_lt {R : Type u}\n\t[semiring R] {p q : polynomial R} (h : q.nat_degree < p.nat_degree) :\n\t(p + q).nat_degree = p.nat_degree :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p, q\\in R[x]$. If $\\deg(q)<\\deg(p)$, then $\\deg(p+q)=\\deg(p)$."}
{"name": "multiset.coe_pmap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.coe_pmap {\u03b1 \u03b2 : Type*} {p : \u03b1 \u2192 Prop} (f : \u03a0 (a : \u03b1), p a \u2192 \u03b2)\n\t(l : list \u03b1) (H : \u2200 (a : \u03b1), a \u2208 l \u2192 p a) :\n\tmultiset.pmap f \u2191l H = \u2191(list.pmap f l H) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $l$ be a list of elements of $A$. Then the multiset of $f$ applied to the elements of $l$ is equal to the list of $f$ applied to the elements of $l$."}
{"name": "finset.Ioo_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/locally_finite.lean", "formal_statement": "theorem finset.Ioo_self {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1]\n\t(a : \u03b1) :\n\tfinset.Ioo a a = \u2205 :=", "nl_statement_of_codex": "Let $a$ be an element of a locally finite preorder. Then the interval $[a,a]$ is empty."}
{"name": "filter.is_countably_generated_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/bases.lean", "formal_statement": "theorem filter.is_countably_generated_top {\u03b1 : Type*} :\n\t\u22a4.is_countably_generated :=", "nl_statement_of_codex": "The top filter on a set $X$ is countably generated."}
{"name": "min_pow_dvd_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/ring.lean", "formal_statement": "theorem min_pow_dvd_add {R : Type*} [semiring R] {n m : \u2115} {a b c : R}\n\t(ha : c ^ n \u2223 a) (hb : c ^ m \u2223 b) :\n\tc ^ linear_order.min n m \u2223 a + b :=", "nl_statement_of_codex": "Let $R$ be a semiring, $n,m\\in\\mathbb{N}$, and $a,b,c\\in R$. If $c^n\\mid a$ and $c^m\\mid b$, then $c^{\\min(n,m)}\\mid a+b$."}
{"name": "set.infinite_of_not_bdd_above", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/finite.lean", "formal_statement": "theorem set.infinite_of_not_bdd_above {\u03b1 : Type u} [semilattice_sup \u03b1]\n\t[nonempty \u03b1] {s : set \u03b1} :\n\t\u00acbdd_above s \u2192 s.infinite :=", "nl_statement_of_codex": "Let $S$ be a nonempty set with a partial order. If $S$ is not bounded above, then $S$ is infinite."}
{"name": "tsum_op", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean", "formal_statement": "theorem tsum_op {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t[t2_space \u03b1] {f : \u03b2 \u2192 \u03b1} :\n\t\u2211' (x : \u03b2), mul_opposite.op (f x) = mul_opposite.op (\u2211' (x : \u03b2), f x) :=", "nl_statement_of_codex": "Let $f:B\\to A$ be a function. Then $\\sum_{x\\in B}-f(x)=-\\sum_{x\\in B}f(x)$."}
{"name": "complex.cos_sq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/exponential.lean", "formal_statement": "theorem complex.cos_sq (x : \u2102) :\n\tcomplex.cos x ^ 2 = 1 / 2 + complex.cos (2 * x) / 2 :=", "nl_statement_of_codex": "$\\cos^2(x)=\\frac{1}{2}+\\frac{1}{2}\\cos(2x)$."}
{"name": "filter.has_basis.bInter_bUnion_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem filter.has_basis.bInter_bUnion_ball {\u03b1 : Type*} {\u03b9 : Sort u_5}\n\t[uniform_space \u03b1] {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 set (\u03b1 \u00d7 \u03b1)}\n\t(h : (uniformity \u03b1).has_basis p U) (s : set \u03b1) :\n\t(\u22c2 (i : \u03b9) (hi : p i), \u22c3 (x : \u03b1) (H : x \u2208 s), uniform_space.ball x (U i)) = closure s :=", "nl_statement_of_codex": "Let $X$ be a uniform space. Let $p$ be a property of indices and let $U$ be a family of subsets of $X\\times X$. Suppose that the uniformity of $X$ has a basis consisting of the sets $U_i$ for which $p(i)$ holds. Then the closure of a subset $S$ of $X$ is the intersection of the unions of the balls of radius $U_i$ centered at points of $S$ for which $p(i)$ holds."}
{"name": "function.right_inverse.injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.right_inverse.injective {\u03b1 : Sort u_1} {\u03b2 : Sort u_2}\n\t{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : function.right_inverse f g) :\n\tfunction.injective f :=", "nl_statement_of_codex": "If $f:A\\to B$ and $g:B\\to A$ are functions such that $g\\circ f=\\mathrm{id}_A$, then $f$ is injective."}
{"name": "bounded_continuous_function.tendsto_iff_tendsto_uniformly", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/bounded.lean", "formal_statement": "theorem bounded_continuous_function.tendsto_iff_tendsto_uniformly {\u03b1 : Type u}\n\t{\u03b2 : Type v} [topological_space \u03b1] [pseudo_metric_space \u03b2] {\u03b9 : Type*}\n\t{F : \u03b9 \u2192 bounded_continuous_function \u03b1 \u03b2} {f : bounded_continuous_function \u03b1 \u03b2}\n\t{l : filter \u03b9} :\n\tfilter.tendsto F l (nhds f) \u2194 tendsto_uniformly (\u03bb (i : \u03b9), \u21d1(F i)) \u21d1f l :=", "nl_statement_of_codex": "Let $X$ be a topological space and $Y$ a pseudo-metric space. Let $F_i:X\\to Y$ be a sequence of bounded continuous functions. Then $F_i$ converges uniformly to $f:X\\to Y$ if and only if $F_i$ converges to $f$ in the topology of bounded continuous functions."}
{"name": "category_theory.limits.cocones.functoriality_equivalence_counit_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.limits.cocones.functoriality_equivalence_counit_iso\n\t{J : Type u\u2081} [category_theory.category J] {C : Type u\u2083}\n\t[category_theory.category C] {D : Type u\u2084} [category_theory.category D]\n\t(F : J \u2964 C) (e : C \u224c D) :\n\t(category_theory.limits.cocones.functoriality_equivalence F e).counit_iso = category_theory.nat_iso.of_components (\u03bb (c : category_theory.limits.cocone (F \u22d9 e.functor)), category_theory.limits.cocones.ext (e.counit_iso.app c.X) _) _ :=", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor and let $e:C\\to D$ be an equivalence. Then the counit of the adjunction $F\\dashv e\\circ F$ is the natural isomorphism given by the components $e_{F(j)}$."}
{"name": "disjoint_disjointed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/disjointed.lean", "formal_statement": "theorem disjoint_disjointed {\u03b1 : Type*} [generalized_boolean_algebra \u03b1]\n\t(f : \u2115 \u2192 \u03b1) :\n\tpairwise (disjoint on disjointed f) :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\alpha$ be a sequence of elements of a generalized boolean algebra. Then the sets $f(n)$ are pairwise disjoint."}
{"name": "is_coatom.Ici", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/atoms.lean", "formal_statement": "theorem is_coatom.Ici {\u03b1 : Type*} [preorder \u03b1] [order_top \u03b1] {a x : \u03b1}\n\t(ha : is_coatom a) (hax : x \u2264 a) :\n\tis_coatom \u27e8a, hax\u27e9 :=", "nl_statement_of_codex": "Let $a$ be a coatom in a preorder $X$. Then $a$ is a coatom in the interval $[x,a]$."}
{"name": "int.is_unit_add_is_unit_eq_is_unit_add_is_unit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.is_unit_add_is_unit_eq_is_unit_add_is_unit {a b c d : \u2124}\n\t(ha : is_unit a) (hb : is_unit b) (hc : is_unit c) (hd : is_unit d) :\n\ta + b = c + d \u2194 a = c \u2227 b = d \u2228 a = d \u2227 b = c :=", "nl_statement_of_codex": "Let $a,b,c,d$ be units in $\\mathbb{Z}$. Then $a+b=c+d$ if and only if $a=c$ and $b=d$ or $a=d$ and $b=c$."}
{"name": "computation.lift_rel_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.lift_rel_of_mem {\u03b1 : Type u} {\u03b2 : Type v} {R : \u03b1 \u2192 \u03b2 \u2192 Prop}\n\t{a : \u03b1} {b : \u03b2} {ca : computation \u03b1} {cb : computation \u03b2} (ma : a \u2208 ca)\n\t(mb : b \u2208 cb) (ab : R a b) :\n\tcomputation.lift_rel R ca cb :=", "nl_statement_of_codex": "Let $R$ be a relation between two types $\u03b1$ and $\u03b2$. Let $a$ be an element of $\u03b1$ and $b$ be an element of $\u03b2$. Let $ca$ be a computation of $\u03b1$ and $cb$ be a computation of $\u03b2$. If $a$ is an element of $ca$ and $b$ is an element of $cb$ and $R(a,b)$ holds, then $ca$ and $cb$ are related by $R$."}
{"name": "mv_polynomial.prime_rename_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.prime_rename_iff {R : Type u} {\u03c3 : Type v} [comm_ring R]\n\t(s : set \u03c3) {p : mv_polynomial \u21a5s R} :\n\tprime (\u21d1(mv_polynomial.rename coe) p) \u2194 prime p :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $s$ be a set. Let $p$ be a multivariate polynomial over $R$ with variables in $s$. Then $p$ is prime if and only if $p$ is prime."}
{"name": "is_local_extr_on.closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/extr_closure.lean", "formal_statement": "theorem is_local_extr_on.closure {X Y : Type*} [topological_space X]\n\t[topological_space Y] [preorder Y] [order_closed_topology Y] {f : X \u2192 Y}\n\t{s : set X} {a : X} (h : is_local_extr_on f s a)\n\t(hc : continuous_on f (closure s)) :\n\tis_local_extr_on f (closure s) a :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces, and let $f:X\\to Y$ be a function. Let $s$ be a subset of $X$ and let $a\\in X$. If $f$ has a local extremum at $a$ on $s$, and $f$ is continuous on the closure of $s$, then $f$ has a local extremum at $a$ on the closure of $s$."}
{"name": "ctop.of_equiv_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/analysis/topology.lean", "formal_statement": "theorem ctop.of_equiv_val {\u03b1 \u03c3 \u03c4 : Type*} (E : \u03c3 \u2243 \u03c4) (F : ctop \u03b1 \u03c3) (a : \u03c4) :\n\t\u21d1(ctop.of_equiv E F) a = \u21d1F (\u21d1(E.symm) a) :=", "nl_statement_of_codex": "Let $E:\\sigma\\to\\tau$ be an equivalence. Let $F:\\alpha\\to\\sigma$ be a continuous function. Then the function $G:\\alpha\\to\\tau$ defined by $G(x)=E(F(x))$ is continuous."}
{"name": "submodule.neg_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/submodule/pointwise.lean", "formal_statement": "theorem submodule.neg_top {R M : Type*} [semiring R] [add_comm_group M]\n\t[module R M] :\n\t-\u22a4 = \u22a4 :=", "nl_statement_of_codex": "The negative of the top submodule of a module is the top submodule."}
{"name": "power_series.zero_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_series/basic.lean", "formal_statement": "theorem power_series.zero_inv {k : Type*} [field k] :\n\t0\u207b\u00b9 = 0 :=", "nl_statement_of_codex": "The inverse of the zero power series is the zero power series."}
{"name": "Class.iota_ex", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/zfc.lean", "formal_statement": "theorem Class.iota_ex (p : Set \u2192 Prop) :\n\tClass.iota p \u2208 Class.univ :=", "nl_statement_of_codex": "The class $\\iota p$ is a member of the class $\\mathcal{U}$."}
{"name": "category_theory.sites.pushforward_map_val_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/cover_preserving.lean", "formal_statement": "theorem category_theory.sites.pushforward_map_val_app {C : Type v\u2081}\n\t[category_theory.small_category C] {D : Type v\u2081}\n\t[category_theory.small_category D] (A : Type u\u2082) [category_theory.category A]\n\t(J : category_theory.grothendieck_topology C)\n\t(K : category_theory.grothendieck_topology D)\n\t[category_theory.concrete_category A]\n\t[category_theory.limits.preserves_limits (category_theory.forget A)]\n\t[category_theory.limits.has_colimits A] [category_theory.limits.has_limits A]\n\t[category_theory.limits.preserves_filtered_colimits (category_theory.forget A)]\n\t[category_theory.reflects_isomorphisms (category_theory.forget A)] (G : C \u2964 D)\n\t(_x _x_1 : category_theory.Sheaf J A) (f : _x \u27f6 _x_1) (X : D\u1d52\u1d56) :\n\t((category_theory.sites.pushforward A J K G).map f).val.app X = category_theory.limits.colim_map (K.diagram_nat_trans (K.plus_map ((category_theory.Lan G.op).map f.val)) (opposite.unop X)) :=", "nl_statement_of_codex": "Let $C$ and $D$ be small categories, let $A$ be a category, let $J$ and $K$ be Grothendieck topologies on $C$ and $D$, respectively, and let $G:C\\to D$ be a functor. Let $F$ and $G$ be sheaves on $C$ with respect to $J$, and let $f:F\\to G$ be a morphism of sheaves. Then the pushforward of $f$ is the colimit of the diagram $K(G,X)$."}
{"name": "finprod_mem_congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finprod_mem_congr {\u03b1 M : Type*} [comm_monoid M] {f g : \u03b1 \u2192 M}\n\t{s t : set \u03b1} (h\u2080 : s = t) (h\u2081 : \u2200 (x : \u03b1), x \u2208 t \u2192 f x = g x) :\n\tfinprod (\u03bb (i : \u03b1), finprod (\u03bb (H : i \u2208 s), f i)) = finprod (\u03bb (i : \u03b1), finprod (\u03bb (H : i \u2208 t), g i)) :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid. Let $f,g:A\\to M$ be functions. Let $s,t\\subset A$. If $s=t$ and $f(x)=g(x)$ for all $x\\in t$, then $\\prod_{i\\in s}f(i)=\\prod_{i\\in t}g(i)$."}
{"name": "rat.num_denom_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/defs.lean", "formal_statement": "theorem rat.num_denom_mk {q : \u211a} {n d : \u2124} (hd : d \u2260 0) (qdf : q = rat.mk n d) :\n\t\u2203 (c : \u2124), n = c * q.num \u2227 d = c * \u2191(q.denom) :=", "nl_statement_of_codex": "Let $q=n/d$ be a rational number. Then there is an integer $c$ such that $n=cq.num$ and $d=cq.denom$."}
{"name": "dist_midpoint_midpoint_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/add_torsor.lean", "formal_statement": "theorem dist_midpoint_midpoint_le {V : Type*} [semi_normed_group V]\n\t[normed_space \u211d V] (p\u2081 p\u2082 p\u2083 p\u2084 : V) :\n\thas_dist.dist (midpoint \u211d p\u2081 p\u2082) (midpoint \u211d p\u2083 p\u2084) \u2264 (has_dist.dist p\u2081 p\u2083 + has_dist.dist p\u2082 p\u2084) / 2 :=", "nl_statement_of_codex": "Let $V$ be a normed space over $\\mathbb{R}$. Then the distance between the midpoints of two line segments is less than or equal to half the sum of the lengths of the two line segments."}
{"name": "equiv.perm.parts_partition", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/type.lean", "formal_statement": "theorem equiv.perm.parts_partition {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1]\n\t{\u03c3 : equiv.perm \u03b1} :\n\t\u03c3.partition.parts = \u03c3.cycle_type + multiset.repeat 1 (fintype.card \u03b1 - \u03c3.support.card) :=", "nl_statement_of_codex": "Let $\\sigma$ be a permutation of a finite set $X$. Then the cycle type of $\\sigma$ is the multiset of lengths of the cycles of $\\sigma$."}
{"name": "pmf.to_outer_measure_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/probability_mass_function/basic.lean", "formal_statement": "theorem pmf.to_outer_measure_mono {\u03b1 : Type*} (p : pmf \u03b1) {s t : set \u03b1}\n\t(h : s \u2229 p.support \u2286 t) :\n\t\u21d1(p.to_outer_measure) s \u2264 \u21d1(p.to_outer_measure) t :=", "nl_statement_of_codex": "Let $p$ be a probability measure on a set $X$. Let $s,t\\subset X$. If $s\\cap supp(p)\\subset t$, then $p(s)\\leq p(t)$."}
{"name": "add_subgroup.le_normalizer", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.le_normalizer {G : Type*} [add_group G]\n\t{H : add_subgroup G} :\n\tH \u2264 H.normalizer :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $H$ be an additive subgroup of $G$. Then $H$ is contained in the normalizer of $H$."}
{"name": "add_monoid_hom.is_add_group_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/group.lean", "formal_statement": "theorem add_monoid_hom.is_add_group_hom {G H : Type*} {_x : add_group G}\n\t{_x_1 : add_group H} (f : G \u2192+ H) :\n\tis_add_group_hom \u21d1f :=", "nl_statement_of_codex": "Let $G$ and $H$ be additive groups and let $f:G\\to H$ be an additive group homomorphism. Then $f$ is a group homomorphism."}
{"name": "set.unbounded_le_of_forall_exists_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded.lean", "formal_statement": "theorem set.unbounded_le_of_forall_exists_lt {\u03b1 : Type*} {s : set \u03b1}\n\t[preorder \u03b1] (h : \u2200 (a : \u03b1), \u2203 (b : \u03b1) (H : b \u2208 s), a < b) :\n\tset.unbounded has_le.le s :=", "nl_statement_of_codex": "Let $s$ be a set of elements of a preorder $P$. If for each $a\\in P$ there is an element $b\\in s$ such that $a<b$, then $s$ is unbounded in $P$."}
{"name": "set.image_op_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.image_op_neg {\u03b1 : Type*} [has_involutive_neg \u03b1] {s : set \u03b1} :\n\tadd_opposite.op '' -s = -add_opposite.op '' s :=", "nl_statement_of_codex": "Let $s$ be a set of elements of a group with involution. Then the image of $s$ under the involution is equal to the image of the image of $s$ under the involution under the involution."}
{"name": "interior_mem_uniformity", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/basic.lean", "formal_statement": "theorem interior_mem_uniformity {\u03b1 : Type*} [uniform_space \u03b1] {s : set (\u03b1 \u00d7 \u03b1)}\n\t(hs : s \u2208 uniformity \u03b1) :\n\tinterior s \u2208 uniformity \u03b1 :=", "nl_statement_of_codex": "Let $X$ be a uniform space. If $s\\in\\mathcal{U}(X)$, then $\\operatorname{int}(s)\\in\\mathcal{U}(X)$."}
{"name": "finset.sum_bij", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_bij {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w}\n\t[add_comm_monoid \u03b2] {s : finset \u03b1} {t : finset \u03b3} {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b2}\n\t(i : \u03a0 (a : \u03b1), a \u2208 s \u2192 \u03b3) (hi : \u2200 (a : \u03b1) (ha : a \u2208 s), i a ha \u2208 t)\n\t(h : \u2200 (a : \u03b1) (ha : a \u2208 s), f a = g (i a ha))\n\t(i_inj : \u2200 (a\u2081 a\u2082 : \u03b1) (ha\u2081 : a\u2081 \u2208 s) (ha\u2082 : a\u2082 \u2208 s), i a\u2081 ha\u2081 = i a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082)\n\t(i_surj : \u2200 (b : \u03b3), b \u2208 t \u2192 (\u2203 (a : \u03b1) (ha : a \u2208 s), b = i a ha)) :\n\ts.sum (\u03bb (x : \u03b1), f x) = t.sum (\u03bb (x : \u03b3), g x) :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets and let $f:s\\to\\mathbb{N}$ and $g:t\\to\\mathbb{N}$ be functions. Suppose that there is a bijection $i:s\\to t$ such that $f(x)=g(i(x))$ for all $x\\in s$. Then $\\sum_{x\\in s}f(x)=\\sum_{x\\in t}g(x)$."}
{"name": "set.vadd_set_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.vadd_set_mono {\u03b1 \u03b2 : Type*} [has_vadd \u03b1 \u03b2] {s t : set \u03b2} {a : \u03b1} :\n\ts \u2286 t \u2192 a +\u1d65 s \u2286 a +\u1d65 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be subsets of a vector space $V$ over a field $F$. If $s\\subset t$, then $s+a\\subset t+a$."}
{"name": "set.subsingleton.minimals_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/minimal.lean", "formal_statement": "theorem set.subsingleton.minimals_eq {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : set \u03b1}\n\t(h : s.subsingleton) :\n\tminimals r s = s :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $S$. If $S$ is a singleton, then the set of minimal elements of $S$ is $S$."}
{"name": "set.bij_on.inj_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/function.lean", "formal_statement": "theorem set.bij_on.inj_on {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} (h : set.bij_on f s t) :\n\tset.inj_on f s :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a bijection between subsets $A$ and $B$ of sets $X$ and $Y$, respectively. Then $f$ is injective on $A$."}
{"name": "basis.constr_basis", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basis.lean", "formal_statement": "theorem basis.constr_basis {\u03b9 R M M' : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] [add_comm_monoid M'] [module R M'] (b : basis \u03b9 R M) (S : Type*)\n\t[semiring S] [module S M'] [smul_comm_class R S M'] (f : \u03b9 \u2192 M') (i : \u03b9) :\n\t\u21d1(\u21d1(b.constr S) f) (\u21d1b i) = f i :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, $M'$ an $S$-module, and $b$ a basis of $M$. Then the map $f:b\\to M'$ is the same as the map $f:M\\to M'$ defined by $f(x)=\\sum_{i\\in b}f(i)\\cdot x_i$."}
{"name": "finset.lt_inf'_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.lt_inf'_iff {\u03b1 \u03b9 : Type*} [linear_order \u03b1] {s : finset \u03b9}\n\t(H : s.nonempty) {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n\ta < s.inf' H f \u2194 \u2200 (i : \u03b9), i \u2208 s \u2192 a < f i :=", "nl_statement_of_codex": "Let $s$ be a nonempty finite set and let $f:s\\to\\mathbb{R}$. Then $a<\\inf_{i\\in s}f(i)$ if and only if $a<f(i)$ for all $i\\in s$."}
{"name": "measure_theory.ae_restrict_interval_oc_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.ae_restrict_interval_oc_eq {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [linear_order \u03b1]\n\t(a b : \u03b1) :\n\t(\u03bc.restrict (set.interval_oc a b)).ae = (\u03bc.restrict (set.Ioc a b)).ae \u2294 (\u03bc.restrict (set.Ioc b a)).ae :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $a,b\\in X$ be such that $a<b$. Then the set of points $x\\in X$ such that $\\mu$ is not absolutely continuous on $(a,b)$ is equal to the union of the sets of points $x\\in X$ such that $\\mu$ is not absolutely continuous on $(a,x)$ and the set of points $x\\in X$ such that $\\mu$ is not absolutely continuous on $(x,b)$."}
{"name": "box_integral.tagged_prepartition.is_subordinate_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/partition/tagged.lean", "formal_statement": "theorem box_integral.tagged_prepartition.is_subordinate_single {\u03b9 : Type*}\n\t{I J : box_integral.box \u03b9} {x : \u03b9 \u2192 \u211d} {r : (\u03b9 \u2192 \u211d) \u2192 \u21a5(set.Ioi 0)} [fintype \u03b9]\n\t(hJ : J \u2264 I) (h : x \u2208 \u21d1box_integral.box.Icc I) :\n\t(box_integral.tagged_prepartition.single I J hJ x h).is_subordinate r \u2194 \u21d1box_integral.box.Icc J \u2286 metric.closed_ball x \u2191(r x) :=", "nl_statement_of_codex": "Let $I$ and $J$ be boxes in $\\mathbb{R}^n$ and let $x\\in I$. Then the singleton partition of $I$ with respect to $J$ is subordinate to $r$ if and only if $J\\subset B(x,r(x))$."}
{"name": "is_add_subgroup.add_center_normal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_subgroup.add_center_normal {G : Type*} [add_group G] :\n\tis_normal_add_subgroup (is_add_subgroup.add_center G) :=", "nl_statement_of_codex": "The center of an additive group is a normal subgroup."}
{"name": "polynomial.comp_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/eval.lean", "formal_statement": "theorem polynomial.comp_one {R : Type u} [semiring R] {p : polynomial R} :\n\tp.comp 1 = \u21d1polynomial.C (polynomial.eval 1 p) :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. Then $p(1)=p(1)$."}
{"name": "ennreal.top_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.top_mul {a : ennreal} :\n\t\u22a4 * a = ite (a = 0) 0 \u22a4 :=", "nl_statement_of_codex": "The product of $\\infty$ and $a$ is $\\infty$ if $a\\neq 0$ and $0$ if $a=0$."}
{"name": "is_compact.is_glb_Inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/compact.lean", "formal_statement": "theorem is_compact.is_glb_Inf {\u03b1 : Type*}\n\t[conditionally_complete_linear_order \u03b1] [topological_space \u03b1]\n\t[order_topology \u03b1] {s : set \u03b1} (hs : is_compact s) (ne_s : s.nonempty) :\n\tis_glb s (has_Inf.Inf s) :=", "nl_statement_of_codex": "Let $s$ be a compact subset of a conditionally complete linear order $X$. Then $\\inf s$ is the greatest lower bound of $s$."}
{"name": "list.kreplace_nodupkeys", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/sigma.lean", "formal_statement": "theorem list.kreplace_nodupkeys {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1]\n\t(a : \u03b1) (b : \u03b2 a) {l : list (sigma \u03b2)} :\n\t(list.kreplace a b l).nodupkeys \u2194 l.nodupkeys :=", "nl_statement_of_codex": "Let $a$ be an element of a list $l$ of type $\\sigma\\beta$. Then $l$ has no duplicate keys if and only if the list $l$ with $a$ replaced by $b$ has no duplicate keys."}
{"name": "is_unit_of_pow_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/lemmas.lean", "formal_statement": "theorem is_unit_of_pow_eq_one {M : Type u} [monoid M] (x : M) (n : \u2115)\n\t(hx : x ^ n = 1) (hn : 0 < n) :\n\tis_unit x :=", "nl_statement_of_codex": "Let $M$ be a monoid and let $x\\in M$. If $x^n=1$ and $n>0$, then $x$ is a unit."}
{"name": "localization.lift_on_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem localization.lift_on_mk {M : Type*} [comm_monoid M] {S : submonoid M}\n\t{p : Sort u} (f : M \u2192 \u21a5S \u2192 p)\n\t(H : \u2200 {a c : M} {b d : \u21a5S}, \u21d1(localization.r S) (a, b) (c, d) \u2192 f a b = f c d)\n\t(a : M) (b : \u21a5S) :\n\t(localization.mk a b).lift_on f H = f a b :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, and let $f:M\\to S\\to p$ be a function. Then $f(a,b)=f(c,d)$ if and only if $a/b=c/d$."}
{"name": "padic_seq.eq_zero_iff_equiv_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_numbers.lean", "formal_statement": "theorem padic_seq.eq_zero_iff_equiv_zero {p : \u2115} [hp : fact (nat.prime p)]\n\t(f : padic_seq p) :\n\tcau_seq.completion.mk f = 0 \u2194 f \u2248 0 :=", "nl_statement_of_codex": "Let $p$ be a prime number. Let $f$ be a $p$-adic sequence. Then $f$ is equal to $0$ if and only if $f$ is equivalent to $0$."}
{"name": "right_ord_continuous.map_is_least", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/ord_continuous.lean", "formal_statement": "theorem right_ord_continuous.map_is_least {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : right_ord_continuous f) {s : set \u03b1} {x : \u03b1}\n\t(h : is_least s x) :\n\tis_least (f '' s) (f x) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a right-order continuous function between preordered sets. Let $s\\subset X$ and let $x\\in X$ be the least element of $s$. Then $f(x)$ is the least element of $f(s)$."}
{"name": "category_theory.limits.trident.is_limit.hom_ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/wide_equalizers.lean", "formal_statement": "theorem category_theory.limits.trident.is_limit.hom_ext {J : Type w}\n\t{C : Type u} [category_theory.category C] {X Y : C} {f : J \u2192 (X \u27f6 Y)}\n\t[nonempty J] {s : category_theory.limits.trident f}\n\t(hs : category_theory.limits.is_limit s) {W : C} {k l : W \u27f6 s.X}\n\t(h : k \u226b s.\u03b9 = l \u226b s.\u03b9) :\n\tk = l :=", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y$ be objects of $C$. Let $f:J\\to X\\to Y$ be a diagram of morphisms. Suppose that $f$ has a limit $s$. Then if two morphisms $k, l:W\\to X$ satisfy $k\\circ s.\u03b9=l\\circ s.\u03b9$, then $k=l$."}
{"name": "bounded_continuous_function.dist_le_two_norm'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/bounded.lean", "formal_statement": "theorem bounded_continuous_function.dist_le_two_norm' {\u03b2 : Type v} {\u03b3 : Type w}\n\t[semi_normed_group \u03b2] {f : \u03b3 \u2192 \u03b2} {C : \u211d} (hC : \u2200 (x : \u03b3), \u2225f x\u2225 \u2264 C) (x y : \u03b3) :\n\thas_dist.dist (f x) (f y) \u2264 2 * C :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous function between normed spaces. If $f$ is bounded, then $f$ is Lipschitz continuous."}
{"name": "asymptotics.is_Theta.trans_is_o", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/theta.lean", "formal_statement": "theorem asymptotics.is_Theta.trans_is_o {\u03b1 E G F' : Type*} [has_norm E]\n\t[has_norm G] [semi_normed_group F'] {l : filter \u03b1} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'}\n\t{k : \u03b1 \u2192 G} (h\u2081 : f =\u0398[l] g) (h\u2082 : g =o[l] k) :\n\tf =o[l] k :=", "nl_statement_of_codex": "Let $f, g, k:\\alpha\\to E$ be functions. If $f=\\Theta(g)$ and $g=o(k)$, then $f=o(k)$."}
{"name": "measure_theory.mem_\u21121_to_real_of_lintegral_ne_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l1_space.lean", "formal_statement": "theorem measure_theory.mem_\u21121_to_real_of_lintegral_ne_top {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 ennreal}\n\t(hfm : ae_measurable f \u03bc) (hfi : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4) :\n\tmeasure_theory.mem_\u2112p (\u03bb (x : \u03b1), (f x).to_real) 1 \u03bc :=", "nl_statement_of_codex": "Let $f:X\\to\\overline{\\mathbb{R}}$ be a measurable function on a measure space $(X,\\mathcal{A},\\mu)$. If $\\int_X f\\,d\\mu\\neq\\infty$, then $f$ is in $L^1(\\mu)$."}
{"name": "category_theory.center.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/center.lean", "formal_statement": "theorem category_theory.center.ext {C : Type u\u2081} [category_theory.category C]\n\t[category_theory.monoidal_category C] {X Y : category_theory.center C}\n\t(f g : X \u27f6 Y) (w : f.f = g.f) :\n\tf = g :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X$ and $Y$ be objects in the center of $C$. Let $f,g:X\\to Y$ be morphisms in the center of $C$. If $f$ and $g$ are equal as morphisms in $C$, then $f=g$."}
{"name": "group_cohomology.resolution.of_tensor_aux_comm_of_mul_action", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/representation_theory/group_cohomology_resolution.lean", "formal_statement": "theorem group_cohomology.resolution.of_tensor_aux_comm_of_mul_action\n\t{k G : Type u} [comm_ring k] {n : \u2115} [group G] (g h : G) (x : fin n \u2192 G) :\n\t\u21d1(group_cohomology.resolution.of_tensor_aux k G n) (\u21d1(tensor_product.map (\u21d1(representation.of_mul_action k G G) g) 1) (finsupp.single h 1 \u2297\u209c[k] finsupp.single x 1)) = \u21d1(\u21d1(representation.of_mul_action k G (fin (n + 1) \u2192 G)) g) (\u21d1(group_cohomology.resolution.of_tensor_aux k G n) (finsupp.single h 1 \u2297\u209c[k] finsupp.single x 1)) :=", "nl_statement_of_codex": "Let $k$ be a commutative ring, $G$ a group, $n$ a natural number, $g, h\\in G$, and $x\\in G^n$. Then the following equality holds:\n$\\begin{align}\n\\begin{pmatrix}\ng & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\nh & x \\\\\n0 & 1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ngh & gx \\\\\n0 & 1\n\\end{pmatrix}\n\\end{align}$"}
{"name": "bilin_form_of_real_inner_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem bilin_form_of_real_inner_apply {F : Type*} [inner_product_space \u211d F]\n\t(\u1fb0 \u1fb0_1 : F) :\n\t\u21d1bilin_form_of_real_inner \u1fb0 \u1fb0_1 = has_inner.inner \u1fb0 \u1fb0_1 :=", "nl_statement_of_codex": "Let $F$ be a real inner product space. Then the bilinear form associated to the inner product is the inner product itself."}
{"name": "has_sum_fourier_series", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/fourier.lean", "formal_statement": "theorem has_sum_fourier_series (f : \u21a5(measure_theory.Lp \u2102 2 haar_circle)) :\n\thas_sum (\u03bb (i : \u2124), \u21d1(\u21d1(fourier_series.repr) f) i \u2022 fourier_Lp 2 i) f :=", "nl_statement_of_codex": "The Fourier series of a function $f$ in $L^2(\\mathbb{T})$ converges to $f$ in $L^2(\\mathbb{T})$."}
{"name": "cSup_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/pointwise.lean", "formal_statement": "theorem cSup_add {\u03b1 : Type*} [conditionally_complete_lattice \u03b1] [add_group \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {s t : set \u03b1}\n\t(hs\u2080 : s.nonempty) (hs\u2081 : bdd_above s) (ht\u2080 : t.nonempty) (ht\u2081 : bdd_above t) :\n\thas_Sup.Sup (s + t) = has_Sup.Sup s + has_Sup.Sup t :=", "nl_statement_of_codex": "Let $s$ and $t$ be nonempty subsets of a conditionally complete lattice $L$ such that $s$ and $t$ are bounded above. Then $\\sup(s+t)=\\sup(s)+\\sup(t)$."}
{"name": "factorization_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/unique_factorization_domain.lean", "formal_statement": "theorem factorization_pow {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1]\n\t[unique_factorization_monoid \u03b1] [normalization_monoid \u03b1] [decidable_eq \u03b1]\n\t{x : \u03b1} {n : \u2115} :\n\tfactorization (x ^ n) = n \u2022 factorization x :=", "nl_statement_of_codex": "Let $R$ be a unique factorization domain. Then the factorization of $x^n$ is $n$ times the factorization of $x$."}
{"name": "prime_spectrum.as_ideal_lt_as_ideal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/prime_spectrum/basic.lean", "formal_statement": "theorem prime_spectrum.as_ideal_lt_as_ideal {R : Type u} [comm_ring R]\n\t(x y : prime_spectrum R) :\n\tx.as_ideal < y.as_ideal \u2194 x < y :=", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then the prime ideals of $R$ are linearly ordered by inclusion."}
{"name": "antitone_on.map_bdd_below", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem antitone_on.map_bdd_below {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : set \u03b1} (Hf : antitone_on f t) (Hst : s \u2286 t) :\n\t(lower_bounds s \u2229 t).nonempty \u2192 bdd_above (f '' s) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between partially ordered sets. If $f$ is antitone on $T$ and $S\\subset T$, then if $S$ has a lower bound in $T$, then $f(S)$ is bounded above."}
{"name": "measure_theory.measure.inv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/measure.lean", "formal_statement": "theorem measure_theory.measure.inv_apply {G : Type*} [measurable_space G]\n\t[has_involutive_inv G] [has_measurable_inv G] (\u03bc : measure_theory.measure G)\n\t(s : set G) :\n\t\u21d1(\u03bc.inv) s = \u21d1\u03bc s\u207b\u00b9 :=", "nl_statement_of_codex": "Let $G$ be a measurable space and let $\\mu$ be a measure on $G$. Then $\\mu(s^{-1})=\\mu(s)$ for all $s\\subset G$."}
{"name": "fourier_subalgebra_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/fourier.lean", "formal_statement": "theorem fourier_subalgebra_coe :\n\tfourier_subalgebra.to_submodule = submodule.span \u2102 (set.range fourier) :=", "nl_statement_of_codex": "The Fourier subalgebra of $L^1(G)$ is the span of the Fourier transform."}
{"name": "affine_equiv.map_vadd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_equiv.lean", "formal_statement": "theorem affine_equiv.map_vadd {k P\u2081 P\u2082 V\u2081 V\u2082 : Type*} [ring k]\n\t[add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081] [add_comm_group V\u2082]\n\t[module k V\u2082] [add_torsor V\u2082 P\u2082] (e : P\u2081 \u2243\u1d43[k] P\u2082) (p : P\u2081) (v : V\u2081) :\n\t\u21d1e (v +\u1d65 p) = \u21d1(e.linear) v +\u1d65 \u21d1e p :=", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ and $V_2$ be $k$-modules, and $P_1$ and $P_2$ be $k$-affine spaces. Let $e:P_1\\to P_2$ be an affine map. Then $e(v+p)=e(v)+e(p)$ for all $v\\in V_1$ and $p\\in P_1$."}
{"name": "real.rpow_logb_eq_abs", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/log/base.lean", "formal_statement": "theorem real.rpow_logb_eq_abs {b x : \u211d} (b_pos : 0 < b) (b_ne_one : b \u2260 1)\n\t(hx : x \u2260 0) :\n\tb ^ real.logb b x = |x| :=", "nl_statement_of_codex": "Let $b$ and $x$ be real numbers such that $b>0$, $b\\neq 1$, and $x\\neq 0$. Then $b^{\\log_b x}=|x|$."}
{"name": "add_monoid_algebra.fg_of_finite_type", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/finiteness.lean", "formal_statement": "theorem add_monoid_algebra.fg_of_finite_type {R M : Type*} [add_comm_monoid M]\n\t[comm_ring R] [nontrivial R]\n\t[h : algebra.finite_type R (add_monoid_algebra R M)] :\n\tadd_monoid.fg M :=", "nl_statement_of_codex": "Let $R$ be a nontrivial commutative ring and let $M$ be an abelian monoid. If the $R$-algebra $R\\oplus M$ is finitely generated, then $M$ is finitely generated."}
{"name": "set.union_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.union_singleton {\u03b1 : Type u} {a : \u03b1} {s : set \u03b1} :\n\ts \u222a {a} = has_insert.insert a s :=", "nl_statement_of_codex": "Let $s$ be a set and let $a$ be an element. Then $s\\cup\\{a\\}=s\\cup\\{a\\}$."}
{"name": "category_theory.limits.is_colimit.cocone_points_iso_of_nat_iso_inv_desc_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/is_limit.lean", "formal_statement": "theorem category_theory.limits.is_colimit.cocone_points_iso_of_nat_iso_inv_desc_assoc\n\t{J : Type u\u2081} [category_theory.category J] {C : Type u\u2083}\n\t[category_theory.category C] {F G : J \u2964 C}\n\t{s : category_theory.limits.cocone G} {r t : category_theory.limits.cocone F}\n\t(P : category_theory.limits.is_colimit t)\n\t(Q : category_theory.limits.is_colimit s) (w : F \u2245 G) {X' : C} (f' : r.X \u27f6 X') :\n\t(P.cocone_points_iso_of_nat_iso Q w).inv \u226b P.desc r \u226b f' = Q.map r w.inv \u226b f' :=", "nl_statement_of_codex": "Let $F, G:J\\to C$ be functors and let $s, r, t$ be cocones over $F$ and $G$. Suppose that $t$ is a colimit of $F$ and $s$ is a colimit of $G$. Suppose that $w:F\\to G$ is a natural isomorphism. Then the inverse of the isomorphism $t\\to s$ induced by $w$ is equal to the composition of the morphism $r\\to t$ with the morphism $t\\to s$ induced by $w^{-1}$."}
{"name": "category_theory.monad.algebra_mono_of_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/algebra.lean", "formal_statement": "theorem category_theory.monad.algebra_mono_of_mono {C : Type u\u2081}\n\t[category_theory.category C] (T : category_theory.monad C) {X Y : T.algebra}\n\t(f : X \u27f6 Y) [h : category_theory.mono f.f] :\n\tcategory_theory.mono f :=", "nl_statement_of_codex": "Let $T$ be a monad on a category $C$. If $f:X\\to Y$ is a morphism of $T$-algebras and $f$ is a monomorphism, then $f$ is a monomorphism of $T$-algebras."}
{"name": "submonoid.localization_map.mk'_spec'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.mk'_spec' {M : Type*} [comm_monoid M]\n\t{S : submonoid M} {N : Type*} [comm_monoid N] (f : S.localization_map N)\n\t(x : M) (y : \u21a5S) :\n\t\u21d1(f.to_map) \u2191y * f.mk' x y = \u21d1(f.to_map) x :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, and let $f:S\\to N$ be a map of monoids. Let $x\\in M$ and $y\\in S$. Then $f(y)f(x)=f(xy)$."}
{"name": "measure_theory.finite_measure.coe_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/finite_measure_weak_convergence.lean", "formal_statement": "theorem measure_theory.finite_measure.coe_injective {\u03b1 : Type*}\n\t[measurable_space \u03b1] :\n\tfunction.injective coe :=", "nl_statement_of_codex": "The function $\\mu\\mapsto\\mu(A)$ is injective."}
{"name": "equiv.perm.is_cycle.cycle_type", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/type.lean", "formal_statement": "theorem equiv.perm.is_cycle.cycle_type {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1]\n\t{\u03c3 : equiv.perm \u03b1} (h\u03c3 : \u03c3.is_cycle) :\n\t\u03c3.cycle_type = \u2191[\u03c3.support.card] :=", "nl_statement_of_codex": "Let $\\sigma$ be a permutation of a finite set $X$. Then the cycle type of $\\sigma$ is the partition of $|X|$ into a single part."}
{"name": "ess_inf_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ess_sup.lean", "formal_statement": "theorem ess_inf_const {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [complete_lattice \u03b2] ( : \u03b2) (h\u03bc : \u03bc \u2260 0) :\n\tess_inf (\u03bb (x : \u03b1), c) \u03bc = c :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $c$ be a constant. Then $\\inf_{\\mu}c=c$."}
{"name": "asymptotics.is_o.add_is_O_with", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_o.add_is_O_with {\u03b1 F E' : Type*} [has_norm F]\n\t[semi_normed_group E'] {c\u2081 c\u2082 : \u211d} {g : \u03b1 \u2192 F} {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'}\n\t(h\u2081 : f\u2081 =o[l] g) (h\u2082 : asymptotics.is_O_with c\u2081 l f\u2082 g) (hc : c\u2081 < c\u2082) :\n\tasymptotics.is_O_with c\u2082 l (\u03bb (x : \u03b1), f\u2081 x + f\u2082 x) g :=", "nl_statement_of_codex": "Let $f_1, f_2: \\alpha \\to E'$ be functions and let $g:\\alpha \\to F$ be a function. Suppose that $f_1$ is $o(g)$ and that $f_2$ is $O(g)$. Then $f_1+f_2$ is $O(g)$."}
{"name": "list.chain'.rel_head'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/chain.lean", "formal_statement": "theorem list.chain'.rel_head' {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {x : \u03b1}\n\t{l : list \u03b1} (h : list.chain' R (x :: l)) \u2983y : \u03b1\u2984 (hy : y \u2208 l.head') :\n\tR x y :=", "nl_statement_of_codex": "Let $R$ be a relation on a type $\u03b1$. Let $x$ be an element of $\u03b1$ and let $l$ be a list of elements of $\u03b1$. Suppose that $R$ is a chain on $x::l$. Let $y$ be an element of the head of $l$. Then $R$ holds between $x$ and $y$."}
{"name": "add_hom.op_symm_apply_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/opposite.lean", "formal_statement": "theorem add_hom.op_symm_apply_apply {M N : Type*} [has_add M] [has_add N]\n\t(f : add_hom M\u1d43\u1d52\u1d56 N\u1d43\u1d52\u1d56) (\u1fb0 : M) :\n\t\u21d1(\u21d1(add_hom.op.symm) f) \u1fb0 = (add_opposite.unop \u2218 \u21d1f \u2218 add_opposite.op) \u1fb0 :=", "nl_statement_of_codex": "Let $M$ and $N$ be additive groups. Let $f:M\\to N$ be an additive homomorphism. Then $f(-x)=-f(x)$."}
{"name": "lp.has_sum_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lp_space.lean", "formal_statement": "theorem lp.has_sum_norm {\u03b1 E : \u03b1 \u2192 Type*} {p : ennreal}\n\t[\u03a0 (i : \u03b1), normed_group (E i)] (hp : 0 < p.to_real) (f : \u21a5(lp E p)) :\n\thas_sum (\u03bb (i : \u03b1), \u2225\u21d1f i\u2225 ^ p.to_real) (\u2225f\u2225 ^ p.to_real) :=", "nl_statement_of_codex": "Let $E$ be a family of normed groups indexed by $\u03b1$. Let $p$ be a positive real number. Then the $p$-norm of a $p$-summable family $f$ is equal to the $p$-th power of the $p$-norm of the $p$-summable family $f$."}
{"name": "with_top.image_coe_Icc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/with_bot_top.lean", "formal_statement": "theorem with_top.image_coe_Icc {\u03b1 : Type*} [partial_order \u03b1] {a b : \u03b1} :\n\tcoe '' set.Icc a b = set.Icc \u2191a \u2191b :=", "nl_statement_of_codex": "The image of the interval $[a,b]$ under the coe function is the interval $[\\uparrow a,\\uparrow b]$."}
{"name": "ae_measurable.mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem ae_measurable.mul {M \u03b1 : Type*} [measurable_space M] [has_mul M]\n\t{m : measurable_space \u03b1} {f g : \u03b1 \u2192 M} {\u03bc : measure_theory.measure \u03b1}\n\t[has_measurable_mul\u2082 M] (hf : ae_measurable f \u03bc) (hg : ae_measurable g \u03bc) :\n\tae_measurable (\u03bb (a : \u03b1), f a * g a) \u03bc :=", "nl_statement_of_codex": "Let $M$ be a measurable space and let $f,g:M\\to\\mathbb{R}$ be measurable functions. Then $f\\cdot g$ is measurable."}
{"name": "nat.count_succ_eq_succ_count", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/count.lean", "formal_statement": "theorem nat.count_succ_eq_succ_count {p : \u2115 \u2192 Prop} [decidable_pred p] {n : \u2115} :\n\tp n \u2192 nat.count p (n + 1) = nat.count p n + 1 :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on $\\mathbb{N}$. Then $\\#\\{n\\in\\mathbb{N}:p(n)\\}=\\#\\{n\\in\\mathbb{N}:p(n+1)\\}+1$."}
{"name": "is_compact.closed_ball_zero_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/pointwise.lean", "formal_statement": "theorem is_compact.closed_ball_zero_add {E : Type*} [semi_normed_group E]\n\t{\u03b4 : \u211d} {s : set E} (hs : is_compact s) (h\u03b4 : 0 \u2264 \u03b4) :\n\tmetric.closed_ball 0 \u03b4 + s = metric.cthickening \u03b4 s :=", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $s$ be a compact subset of $E$. Then the closed ball of radius $\\delta$ around $0$ is equal to the $\\delta$-thickening of $s$."}
{"name": "category_theory.prelax_functor.comp_map\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/functor.lean", "formal_statement": "theorem category_theory.prelax_functor.comp_map\u2082 {B : Type u\u2081} [quiver B]\n\t[\u03a0 (a b : B), quiver (a \u27f6 b)] {C : Type u\u2082} [quiver C]\n\t[\u03a0 (a b : C), quiver (a \u27f6 b)] {D : Type u\u2083} [quiver D]\n\t[\u03a0 (a b : D), quiver (a \u27f6 b)] (F : category_theory.prelax_functor B C)\n\t(G : category_theory.prelax_functor C D) (a b : B) (f g : a \u27f6 b) (\u03b7 : f \u27f6 g) :\n\t(F.comp G).map\u2082 \u03b7 = G.map\u2082 (F.map\u2082 \u03b7) :=", "nl_statement_of_codex": "Let $F:B\\to C$ and $G:C\\to D$ be pre-relaxed functors. Then for any morphisms $f,g:a\\to b$ in $B$ and any morphism $\\eta:f\\to g$ in $B$, we have $(F\\circ G)(\\eta)=(G\\circ F)(\\eta)$."}
{"name": "normed_group_hom.completion_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/hom_completion.lean", "formal_statement": "theorem normed_group_hom.completion_comp {G : Type*} [semi_normed_group G]\n\t{H : Type*} [semi_normed_group H] {K : Type*} [semi_normed_group K]\n\t(f : normed_group_hom G H) (g : normed_group_hom H K) :\n\tg.completion.comp f.completion = (g.comp f).completion :=", "nl_statement_of_codex": "Let $G, H, K$ be semi-normed groups and let $f:G\\to H$ and $g:H\\to K$ be normed group homomorphisms. Then the completion of $g\\circ f$ is equal to the composition of the completions of $f$ and $g$."}
{"name": "polynomial.sup_ker_aeval_le_ker_aeval_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/basic.lean", "formal_statement": "theorem polynomial.sup_ker_aeval_le_ker_aeval_mul {R : Type u} {M : Type w}\n\t[comm_ring R] [add_comm_group M] [module R M] {f : M \u2192\u2097[R] M}\n\t{p q : polynomial R} :\n\t(\u21d1(polynomial.aeval f) p).ker \u2294 (\u21d1(polynomial.aeval f) q).ker \u2264 (\u21d1(polynomial.aeval f) (p * q)).ker :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ an $R$-module, and $f:M\\to M$ an $R$-linear map. Then the kernel of the map $p\\mapsto f^p$ is a submodule of $M$."}
{"name": "list.split_on_intercalate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.split_on_intercalate {\u03b1 : Type u} (ls : list (list \u03b1))\n\t[decidable_eq \u03b1] (x : \u03b1) (hx : \u2200 (l : list \u03b1), l \u2208 ls \u2192 x \u2209 l)\n\t(hls : ls \u2260 list.nil) :\n\tlist.split_on x ([x].intercalate ls) = ls :=", "nl_statement_of_codex": "Let $x$ be an element of a list $L$ of lists of elements of type $\\alpha$. Then $L$ is the list of lists obtained by splitting $L$ on $x$."}
{"name": "is_alg_closed.exists_aeval_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/is_alg_closed/basic.lean", "formal_statement": "theorem is_alg_closed.exists_aeval_eq_zero (k : Type u) [field k] {R : Type*}\n\t[field R] [is_alg_closed k] [algebra R k] (p : polynomial R)\n\t(hp : p.degree \u2260 0) :\n\t\u2203 (x : k), \u21d1(polynomial.aeval x) p = 0 :=", "nl_statement_of_codex": "Let $k$ be a field and let $R$ be a field extension of $k$. If $R$ is algebraically closed, then every non-zero polynomial $p\\in R[x]$ has a root in $R$."}
{"name": "function.extend_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.extend_injective {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {\u03b3 : Sort u_3}\n\t{f : \u03b1 \u2192 \u03b2} (hf : function.injective f) (e' : \u03b2 \u2192 \u03b3) :\n\tfunction.injective (\u03bb (g : \u03b1 \u2192 \u03b3), function.extend f g e') :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then the function $g\\mapsto f\\circ g$ is injective."}
{"name": "submodule.add_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/submodule/basic.lean", "formal_statement": "theorem submodule.add_mem {R : Type u} {M : Type v} [semiring R]\n\t[add_comm_monoid M] {module_M : module R M} (p : submodule R M) {x y : M}\n\t(h\u2081 : x \u2208 p) (h\u2082 : y \u2208 p) :\n\tx + y \u2208 p :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ be an $R$-module. Let $p$ be a submodule of $M$. Then $x+y\\in p$ for all $x,y\\in p$."}
{"name": "category_theory.functor.ess_image.of_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/essential_image.lean", "formal_statement": "theorem category_theory.functor.ess_image.of_iso {C : Type u\u2081} {D : Type u\u2082}\n\t[category_theory.category C] [category_theory.category D] {F : C \u2964 D}\n\t{Y Y' : D} (h : Y \u2245 Y') (hY : Y \u2208 F.ess_image) :\n\tY' \u2208 F.ess_image :=", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor. If $Y$ is isomorphic to $Y'$ and $Y$ is in the essential image of $F$, then $Y'$ is in the essential image of $F$."}
{"name": "category_theory.bicategory.left_unitor_whisker_right_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/basic.lean", "formal_statement": "theorem category_theory.bicategory.left_unitor_whisker_right_assoc {B : Type u}\n\t[category_theory.bicategory B] {a b c : B} (f : a \u27f6 b) (g : b \u27f6 c) {X' : a \u27f6 c}\n\t(f' : f \u226b g \u27f6 X') :\n\tcategory_theory.bicategory.whisker_right (category_theory.bicategory.left_unitor f).hom g \u226b f' = (category_theory.bicategory.associator (\ud835\udfd9 a) f g).hom \u226b (category_theory.bicategory.left_unitor (f \u226b g)).hom \u226b f' :=", "nl_statement_of_codex": "Let $B$ be a bicategory. Let $f:a\\to b$ and $g:b\\to c$ be morphisms in $B$. Let $X':f\\circ g\\to c$ be a morphism in $B$. Then the following diagram commutes:\n\\begin{tikzcd}\na\\ar[r,"}
{"name": "pgame.left_response_spec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.left_response_spec {x : pgame} (h : 0 \u2264 x) (j : x.right_moves) :\n\t0 \u2264 (x.move_right j).move_left (pgame.left_response h j) :=", "nl_statement_of_codex": "Let $x$ be a position in a two-player game. If $x$ is a non-negative position, then the position obtained by moving right from $x$ and then moving left from the resulting position is non-negative."}
{"name": "and.exists", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem and.exists {p q : Prop} {f : p \u2227 q \u2192 Prop} :\n\t(\u2203 (h : p \u2227 q), f h) \u2194 \u2203 (hp : p) (hq : q), f _ :=", "nl_statement_of_codex": "Let $p$ and $q$ be propositions. Then there exists a proof of $p\\wedge q$ if and only if there exist proofs of $p$ and $q$."}
{"name": "category_theory.simplicial_object.augmented.whiskering_obj_2", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_topology/simplicial_object.lean", "formal_statement": "theorem category_theory.simplicial_object.augmented.whiskering_obj_2\n\t(C : Type u) [category_theory.category C] (D : Type u')\n\t[category_theory.category D] (F : C \u2964 D) :\n\t(category_theory.simplicial_object.augmented.whiskering C D).obj F = category_theory.simplicial_object.augmented.whiskering_obj C D F :=", "nl_statement_of_codex": "The whiskering functor $F$ is equal to the whiskering functor $F$."}
{"name": "is_min_on_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/extr.lean", "formal_statement": "theorem is_min_on_iff {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t{s : set \u03b1} {a : \u03b1} :\n\tis_min_on f s a \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 f a \u2264 f x :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $s\\subset A$. Then $a\\in A$ is a minimum of $f$ on $s$ if and only if $f(a)\\leq f(x)$ for all $x\\in s$."}
{"name": "witt_vector.ghost_component_frobenius_fun", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/frobenius.lean", "formal_statement": "theorem witt_vector.ghost_component_frobenius_fun {p : \u2115} {R : Type*}\n\t[hp : fact (nat.prime p)] [comm_ring R] (n : \u2115) (x : witt_vector p R) :\n\t\u21d1(witt_vector.ghost_component n) x.frobenius_fun = \u21d1(witt_vector.ghost_component (n + 1)) x :=", "nl_statement_of_codex": "Let $p$ be a prime, let $R$ be a commutative ring, and let $n$ be a natural number. Then the $n$-th ghost component of the Frobenius function of a Witt vector $x$ is equal to the $(n+1)$-th ghost component of $x$."}
{"name": "finset.card_le_card_bUnion_add_card_fiber", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/order.lean", "formal_statement": "theorem finset.card_le_card_bUnion_add_card_fiber {\u03b9 \u03b1 : Type*} [decidable_eq \u03b1]\n\t{s : finset \u03b9} {f : \u03b9 \u2192 finset \u03b1} (hs : \u2191s.pairwise_disjoint f) :\n\ts.card \u2264 (s.bUnion f).card + (finset.filter (\u03bb (i : \u03b9), f i = \u2205) s).card :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to 2^s$ be a function. Then $|s|\\leq |\\bigcup_{i\\in s} f(i)|+|\\{i\\in s: f(i)=\\emptyset\\}|$."}
{"name": "bounded_order_hom.id_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/bounded.lean", "formal_statement": "theorem bounded_order_hom.id_apply {\u03b1 : Type*} [preorder \u03b1] [bounded_order \u03b1]\n\t(a : \u03b1) :\n\t\u21d1(bounded_order_hom.id \u03b1) a = a :=", "nl_statement_of_codex": "The identity function on a bounded preorder is a bounded order homomorphism."}
{"name": "basis.adjust_to_orientation_apply_eq_or_eq_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/orientation.lean", "formal_statement": "theorem basis.adjust_to_orientation_apply_eq_or_eq_neg {R : Type*}\n\t[linear_ordered_comm_ring R] {M : Type*} [add_comm_group M] [module R M]\n\t{\u03b9 : Type*} [decidable_eq \u03b9] [fintype \u03b9] [nontrivial R] [nonempty \u03b9]\n\t(e : basis \u03b9 R M) (x : orientation R M \u03b9) (i : \u03b9) :\n\t\u21d1(e.adjust_to_orientation x) i = \u21d1e i \u2228 \u21d1(e.adjust_to_orientation x) i = -\u21d1e i :=", "nl_statement_of_codex": "Let $R$ be a linear ordered commutative ring, $M$ an $R$-module, and $e$ a basis of $M$. Let $x$ be an orientation of $M$. Then for each $i\\in\\mathrm{index}(e)$, either $\\mathrm{sign}(e,x)(i)=\\mathrm{sign}(e)(i)$ or $\\mathrm{sign}(e,x)(i)=-\\mathrm{sign}(e)(i)$."}
{"name": "set.surj_on_sUnion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.surj_on_sUnion {\u03b1 \u03b2 : Type*} {s : set \u03b1} {T : set (set \u03b2)}\n\t{f : \u03b1 \u2192 \u03b2} (H : \u2200 (t : set \u03b2), t \u2208 T \u2192 set.surj_on f s t) :\n\tset.surj_on f s (\u22c3\u2080 T) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. If $f$ is surjective on each $B_i\\subset B$, then $f$ is surjective on $\\bigcup B_i$."}
{"name": "add_commute.semiconj_by", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/commute.lean", "formal_statement": "theorem add_commute.semiconj_by {S : Type*} [has_add S] {a b : S}\n\t(h : add_commute a b) :\n\tadd_semiconj_by a b b :=", "nl_statement_of_codex": "If $a$ and $b$ commute, then $a+b$ is semiconjugate to $b$."}
{"name": "cardinal.powerlt_aleph_0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/ordinal.lean", "formal_statement": "theorem cardinal.powerlt_aleph_0 { : cardinal} (h : cardinal.aleph_0 \u2264 c) :\n\tc ^< cardinal.aleph_0 = c :=", "nl_statement_of_codex": "If $c$ is a cardinal such that $c\\leq\\aleph_0$, then $c^{\\aleph_0}=c$."}
{"name": "measurable_equiv.refl_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_equiv.refl_apply (\u03b1 : Type*) [measurable_space \u03b1] (a : \u03b1) :\n\t\u21d1(measurable_equiv.refl \u03b1) a = a :=", "nl_statement_of_codex": "The identity function on a measurable space is measurable."}
{"name": "ext_chart_at_source_mem_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/smooth_manifold_with_corners.lean", "formal_statement": "theorem ext_chart_at_source_mem_nhds {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*}\n\t[topological_space H] (I : model_with_corners \ud835\udd5c E H) {M : Type*}\n\t[topological_space M] [charted_space H M] (x : M) :\n\t(ext_chart_at I x).source \u2208 nhds x :=", "nl_statement_of_codex": "Let $I$ be a model with corners on $E$ and let $M$ be a charted space over $H$. Then the source of the extended chart at $x$ is a neighborhood of $x$."}
{"name": "measure_theory.outer_measure.comap_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.comap_map {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.injective f) (m : measure_theory.outer_measure \u03b1) :\n\t\u21d1(measure_theory.outer_measure.comap f) (\u21d1(measure_theory.outer_measure.map f) m) = m :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be an injective function. Then the outer measure of $f(A)$ is equal to the outer measure of $A$."}
{"name": "simple_graph.subgraph.spanning_coe_equiv_coe_of_spanning_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/subgraph.lean", "formal_statement": "theorem simple_graph.subgraph.spanning_coe_equiv_coe_of_spanning_symm_apply\n\t{V : Type u} {G : simple_graph V} (G' : G.subgraph) (h : G'.is_spanning)\n\t(v : \u21a5(G'.verts)) :\n\t\u21d1(rel_iso.symm (G'.spanning_coe_equiv_coe_of_spanning h)) v = \u2191v :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $G'$ be a subgraph of $G$. If $G'$ is spanning, then the identity map on the vertices of $G'$ is an isomorphism from $G'$ to $G$."}
{"name": "zero_lt.mul_right_cancel_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas_zero_lt.lean", "formal_statement": "theorem zero_lt.mul_right_cancel_iff {\u03b1 : Type u} {a b c : \u03b1} [mul_zero_class \u03b1]\n\t[partial_order \u03b1] [zero_lt.mul_pos_mono_rev \u03b1] (b0 : 0 < b) :\n\ta * b = c * b \u2194 a = c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a partially ordered set $X$ with $0<b$. Then $a\\cdot b=c\\cdot b$ if and only if $a=c$."}
{"name": "ennreal.has_sum_iff_tendsto_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.has_sum_iff_tendsto_nat {f : \u2115 \u2192 ennreal} (r : ennreal) :\n\thas_sum f r \u2194 filter.tendsto (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (i : \u2115), f i)) filter.at_top (nhds r) :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\overline{\\mathbb{R}}$. Then $\\sum_{n=1}^\\infty f(n)$ exists if and only if $\\sum_{i=1}^n f(i)$ converges to a real number."}
{"name": "truncated_witt_vector.commutes", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/compare.lean", "formal_statement": "theorem truncated_witt_vector.commutes (p : \u2115) [hp : fact (nat.prime p)] (n : \u2115)\n\t{m : \u2115} (hm : n \u2264 m) :\n\t(truncated_witt_vector.truncate hm).comp (truncated_witt_vector.zmod_equiv_trunc p m).to_ring_hom = (truncated_witt_vector.zmod_equiv_trunc p n).to_ring_hom.comp (zmod.cast_hom _ (zmod (p ^ n))) :=", "nl_statement_of_codex": "Let $p$ be a prime and let $n, m$ be natural numbers with $n\\leq m$. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\n\\mathbb{Z}/p^m\\mathbb{Z} \\arrow[r, "}
{"name": "measurable.inf_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/lattice.lean", "formal_statement": "theorem measurable.inf_const {M : Type*} [measurable_space M] {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {f : \u03b1 \u2192 M} [has_inf M] [has_measurable_inf M]\n\t(hf : measurable f) ( : M) :\n\tmeasurable (\u03bb (x : \u03b1), f x \u2293 c) :=", "nl_statement_of_codex": "Let $M$ be a measurable space and let $f:X\\to M$ be a measurable function. Then the function $g:X\\to M$ defined by $g(x)=f(x)\\wedge c$ is measurable."}
{"name": "stream.nil_append_stream", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/stream/init.lean", "formal_statement": "theorem stream.nil_append_stream {\u03b1 : Type u} (s : stream \u03b1) :\n\tlist.nil ++\u209b s = s :=", "nl_statement_of_codex": "The stream obtained by appending the empty list to a stream $s$ is $s$."}
{"name": "tendsto_ceil_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/floor.lean", "formal_statement": "theorem tendsto_ceil_right {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t[topological_space \u03b1] [order_closed_topology \u03b1] (n : \u2124) :\n\tfilter.tendsto (\u03bb (x : \u03b1), \u2191\u2308x\u2309) (nhds_within \u2191n (set.Ioi \u2191n)) (nhds_within (\u2191n + 1) (set.Ici (\u2191n + 1))) :=", "nl_statement_of_codex": "The function $x\\mapsto \\lceil x\\rceil$ tends to $n+1$ from the right at $n$."}
{"name": "zorn_superset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/zorn.lean", "formal_statement": "theorem zorn_superset {\u03b1 : Type*} (S : set (set \u03b1))\n\t(h : \u2200 (c : set (set \u03b1)), c \u2286 S \u2192 is_chain has_subset.subset c \u2192 (\u2203 (lb : set \u03b1) (H : lb \u2208 S), \u2200 (s : set \u03b1), s \u2208 c \u2192 lb \u2286 s)) :\n\t\u2203 (m : set \u03b1) (H : m \u2208 S), \u2200 (a : set \u03b1), a \u2208 S \u2192 a \u2286 m \u2192 a = m :=", "nl_statement_of_codex": "Let $S$ be a set of sets. Suppose that for each chain $c$ of sets in $S$, there is a lower bound $lb$ in $S$ for $c$. Then there is a maximal element in $S$."}
{"name": "set.Inter\u2082_sub_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.Inter\u2082_sub_subset {\u03b1 : Type*} {\u03b9 : Sort u_5} {\u03ba : \u03b9 \u2192 Sort u_6}\n\t[has_sub \u03b1] (s : \u03a0 (i : \u03b9), \u03ba i \u2192 set \u03b1) (t : set \u03b1) :\n\t(\u22c2 (i : \u03b9) (j : \u03ba i), s i j) - t \u2286 \u22c2 (i : \u03b9) (j : \u03ba i), s i j - t :=", "nl_statement_of_codex": "Let $s$ be a family of sets indexed by $i\\in I$ and $j\\in J_i$. Then $(\\bigcap_{i\\in I, j\\in J_i} s_{i,j})-t\\subseteq \\bigcap_{i\\in I, j\\in J_i} (s_{i,j}-t)$."}
{"name": "module.free.finrank_pi_fintype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/free_module/finite/rank.lean", "formal_statement": "theorem module.free.finrank_pi_fintype (R : Type u) [ring R]\n\t[strong_rank_condition R] {\u03b9 : Type v} [fintype \u03b9] {M : \u03b9 \u2192 Type w}\n\t[\u03a0 (i : \u03b9), add_comm_group (M i)] [\u03a0 (i : \u03b9), module R (M i)]\n\t[\u2200 (i : \u03b9), module.free R (M i)] [\u2200 (i : \u03b9), module.finite R (M i)] :\n\tfinite_dimensional.finrank R (\u03a0 (i : \u03b9), M i) = finset.univ.sum (\u03bb (i : \u03b9), finite_dimensional.finrank R (M i)) :=", "nl_statement_of_codex": "Let $R$ be a ring with strong rank condition. Let $\\{M_i\\}_{i\\in I}$ be a family of finitely generated free $R$-modules. Then $\\prod_{i\\in I}M_i$ is a finitely generated free $R$-module and its rank is the sum of the ranks of the $M_i$."}
{"name": "filter.principal_eq_iff_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.principal_eq_iff_eq {\u03b1 : Type u} {s t : set \u03b1} :\n\tfilter.principal s = filter.principal t \u2194 s = t :=", "nl_statement_of_codex": "The principal filter generated by a set $S$ is equal to the principal filter generated by a set $T$ if and only if $S=T$."}
{"name": "convex_on.add_strict_convex_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/function.lean", "formal_statement": "theorem convex_on.add_strict_convex_on {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [ordered_cancel_add_comm_monoid \u03b2] [has_smul \ud835\udd5c E]\n\t[distrib_mul_action \ud835\udd5c \u03b2] {s : set E} {f g : E \u2192 \u03b2} (hf : convex_on \ud835\udd5c s f)\n\t(hg : strict_convex_on \ud835\udd5c s g) :\n\tstrict_convex_on \ud835\udd5c s (f + g) :=", "nl_statement_of_codex": "Let $E$ be a vector space over a field $K$ and let $f,g:E\\to K$ be convex functions. Then $f+g$ is strictly convex."}
{"name": "topological_vector_bundle.trivialization.linear_equiv_at_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/vector_bundle/basic.lean", "formal_statement": "theorem topological_vector_bundle.trivialization.linear_equiv_at_symm_apply\n\t{R B F E : B \u2192 Type*} [semiring R] [\u03a0 (x : B), add_comm_monoid (E x)]\n\t[\u03a0 (x : B), module R (E x)] [topological_space F] [add_comm_monoid F]\n\t[module R F] [topological_space B] [topological_space (bundle.total_space E)]\n\t(e : topological_vector_bundle.trivialization R F E) (b : B)\n\t(hb : b \u2208 e.to_fiber_bundle_trivialization.base_set) (v : F) :\n\t\u21d1((e.linear_equiv_at b hb).symm) v = e.symm b v :=", "nl_statement_of_codex": "Let $E$ be a topological vector bundle over $B$ with fiber $F$. Let $e$ be a trivialization of $E$. Then the inverse of the linear equivalence $e_b$ at $b$ is equal to the inverse of $e$ at $b$."}
{"name": "Group.surjective_of_epi_auxs.g_apply_from_coset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Group/epi_mono.lean", "formal_statement": "theorem Group.surjective_of_epi_auxs.g_apply_from_coset {A B : Group}\n\t(f : A \u27f6 B) (x : \u21a5B)\n\t(y : \u21a5(set.range (function.swap left_coset (monoid_hom.range f).carrier))) :\n\t\u21d1(\u21d1(Group.surjective_of_epi_auxs.G f) x) (Group.surjective_of_epi_auxs.X_with_infinity.from_coset y) = Group.surjective_of_epi_auxs.X_with_infinity.from_coset \u27e8left_coset x \u2191y, _\u27e9 :=", "nl_statement_of_codex": "Let $A$ and $B$ be groups and let $f:A\\to B$ be a homomorphism. Let $x\\in B$ and let $y\\in B/f(A)$. Then $f^{-1}(x)y=f^{-1}(xy)$."}
{"name": "distrib_mul_action_hom.coe_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group_action.lean", "formal_statement": "theorem distrib_mul_action_hom.coe_one {M : Type*} [monoid M] {A : Type*}\n\t[add_monoid A] [distrib_mul_action M A] :\n\t\u21d11 = id :=", "nl_statement_of_codex": "The identity map is the multiplicative action of the identity element of the monoid $M$ on the additive monoid $A$."}
{"name": "category_theory.differential_object.iso_app_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/differential_object.lean", "formal_statement": "theorem category_theory.differential_object.iso_app_hom {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t[category_theory.has_shift C \u2124] {X Y : category_theory.differential_object C}\n\t(f : X \u2245 Y) :\n\t(category_theory.differential_object.iso_app f).hom = f.hom.f :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms and a shift functor. Let $X$ and $Y$ be differential objects in $C$. Then the homomorphism of the differential object $X\\oplus Y$ is the same as the homomorphism of the differential object $X$."}
{"name": "polynomial.degree_pow'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.degree_pow' {R : Type u} [semiring R] {p : polynomial R}\n\t{n : \u2115} :\n\tp.leading_coeff ^ n \u2260 0 \u2192 (p ^ n).degree = n \u2022 p.degree :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. If $p$ has nonzero leading coefficient, then the degree of $p^n$ is $n$ times the degree of $p$."}
{"name": "turing.partrec_to_TM2.supports_bUnion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/tm_to_partrec.lean", "formal_statement": "theorem turing.partrec_to_TM2.supports_bUnion\n\t{K : option turing.partrec_to_TM2.\u0393' \u2192 finset turing.partrec_to_TM2.\u039b'}\n\t{S : finset turing.partrec_to_TM2.\u039b'} :\n\tturing.partrec_to_TM2.supports (finset.univ.bUnion K) S \u2194 \u2200 (a : option turing.partrec_to_TM2.\u0393'), turing.partrec_to_TM2.supports (K a) S :=", "nl_statement_of_codex": "Let $K$ be a function from $\\{0,1\\}$ to the set of finite subsets of $\\{0,1\\}$. Then the set of all finite subsets of $\\{0,1\\}$ is supported by $K$ if and only if the set of all finite subsets of $\\{0,1\\}$ is supported by $K(0)$ and $K(1)$."}
{"name": "equiv.perm.subtype_congr.symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/basic.lean", "formal_statement": "theorem equiv.perm.subtype_congr.symm {\u03b5 : Type*} {p : \u03b5 \u2192 Prop}\n\t[decidable_pred p] (ep : equiv.perm {a // p a}) (en : equiv.perm {a // \u00acp a}) :\n\tequiv.symm (ep.subtype_congr en) = equiv.perm.subtype_congr (equiv.symm ep) (equiv.symm en) :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a type $\u03b5$. Let $ep$ and $en$ be permutations of the subtypes $\\{a\\in \u03b5\\mid p(a)\\}$ and $\\{a\\in \u03b5\\mid \\lnot p(a)\\}$, respectively. Then the permutation of $\u03b5$ that sends $a$ to $ep(a)$ if $p(a)$ and to $en(a)$ if $\\lnot p(a)$ is the inverse of the permutation that sends $a$ to $ep^{-1}(a)$ if $p(a)$ and to $en^{-1}("}
{"name": "multiset.powerset_len_aux_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/powerset.lean", "formal_statement": "theorem multiset.powerset_len_aux_nil {\u03b1 : Type*} (n : \u2115) :\n\tmultiset.powerset_len_aux (n + 1) list.nil = list.nil :=", "nl_statement_of_codex": "The powerset of the empty list is the empty list."}
{"name": "znum.cast_to_int", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem znum.cast_to_int {\u03b1 : Type*} [add_group_with_one \u03b1] (n : znum) :\n\t\u2191\u2191n = \u2191n :=", "nl_statement_of_codex": "The natural number $n$ is equal to the integer $n$."}
{"name": "ratfunc.of_fraction_ring_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/ratfunc.lean", "formal_statement": "theorem ratfunc.of_fraction_ring_eq {K : Type u} [hring : comm_ring K]\n\t[hdomain : is_domain K] :\n\tratfunc.of_fraction_ring = \u21d1(is_localization.alg_equiv (non_zero_divisors (polynomial K)) (fraction_ring (polynomial K)) (ratfunc K)) :=", "nl_statement_of_codex": "The map $f:R[x]\\to R(x)$ defined by $f(p(x))=p(x)$ is an isomorphism of rings."}
{"name": "filter.eventually.set_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.eventually.set_eq {\u03b1 : Type u} {s t : set \u03b1} {l : filter \u03b1} :\n\t(\u2200\u1da0 (x : \u03b1) in l, x \u2208 s \u2194 x \u2208 t) \u2192 s =\u1da0[l] t :=", "nl_statement_of_codex": "Let $s$ and $t$ be sets and let $l$ be a filter on $s$. Then $s$ and $t$ are equal up to $l$ if and only if for all $x$ in $l$, $x$ is in $s$ if and only if $x$ is in $t$."}
{"name": "category_theory.functor.to_oplax_functor_map_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/locally_discrete.lean", "formal_statement": "theorem category_theory.functor.to_oplax_functor_map_id {I : Type u\u2081}\n\t[category_theory.category I] {B : Type u\u2082} [category_theory.bicategory B]\n\t[category_theory.bicategory.strict B] (F : I \u2964 B)\n\t(i : category_theory.locally_discrete I) :\n\tF.to_oplax_functor.map_id i = category_theory.eq_to_hom _ :=", "nl_statement_of_codex": "Let $I$ be a category and $B$ a bicategory. Let $F:I\\to B$ be a functor. Then the identity map on $F$ is equal to the identity map on $F$."}
{"name": "is_localization.smul_to_inv_submonoid", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/inv_submonoid.lean", "formal_statement": "theorem is_localization.smul_to_inv_submonoid {R : Type*} [comm_ring R]\n\t(M : submonoid R) (S : Type*) [comm_ring S] [algebra R S] [is_localization M S]\n\t(m : \u21a5M) :\n\tm \u2022 \u2191(\u21d1(is_localization.to_inv_submonoid M S) m) = 1 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ a submonoid of $R$, $S$ a commutative ring, and $f:R\\to S$ a ring homomorphism such that $f(M)$ is a submonoid of $S$ and $f(M)$ is a localization of $M$. Then $f(m)f(m^{-1})=1$ for all $m\\in M$."}
{"name": "int.cast_of_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/cast/defs.lean", "formal_statement": "theorem int.cast_of_nat {R : Type u} [add_group_with_one R] (n : \u2115) :\n\t\u2191(int.of_nat n) = \u2191n :=", "nl_statement_of_codex": "The natural number $n$ is equal to the integer $n$."}
{"name": "is_cau_geo_series", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/exponential.lean", "formal_statement": "theorem is_cau_geo_series {\u03b1 : Type*} [linear_ordered_field \u03b1] [archimedean \u03b1]\n\t{\u03b2 : Type*} [ring \u03b2] [nontrivial \u03b2] {abv : \u03b2 \u2192 \u03b1} [is_absolute_value abv]\n\t(x : \u03b2) (hx1 : abv x < 1) :\n\tis_cau_seq abv (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (m : \u2115), x ^ m)) :=", "nl_statement_of_codex": "Let $x$ be an element of a ring $R$ such that $|x|<1$. Then the sequence $(\\sum_{m=0}^n x^m)_{n\\in\\mathbb{N}}$ is Cauchy."}
{"name": "equiv_equiv_iso_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/types.lean", "formal_statement": "theorem equiv_equiv_iso_inv {X Y : Type u} (e : X \u2245 Y) :\n\t\u21d1(equiv_equiv_iso.symm) e = e.to_equiv :=", "nl_statement_of_codex": "Let $X$ and $Y$ be types and let $e:X\\to Y$ be an equivalence. Then the inverse of the equivalence $e$ is equal to the inverse of the isomorphism $e$."}
{"name": "linear_isometry_equiv.has_fderiv_at", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/fderiv.lean", "formal_statement": "theorem linear_isometry_equiv.has_fderiv_at {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {x : E} (iso : E \u2243\u2097\u1d62[\ud835\udd5c] F) :\n\thas_fderiv_at \u21d1iso \u2191iso x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $x\\in E$. Then the linear isometry $E\\to F$ has a derivative at $x$."}
{"name": "cauchy_seq_bdd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem cauchy_seq_bdd {\u03b1 : Type u} [pseudo_metric_space \u03b1] {u : \u2115 \u2192 \u03b1}\n\t(hu : cauchy_seq u) :\n\t\u2203 (R : \u211d) (H : R > 0), \u2200 (m n : \u2115), has_dist.dist (u m) (u n) < R :=", "nl_statement_of_codex": "Let $(u_n)$ be a Cauchy sequence in a pseudo-metric space $X$. Then there is a real number $R>0$ such that $d(u_m,u_n)<R$ for all $m,n\\in\\mathbb{N}$."}
{"name": "inner_product_space.of_core.inner_self_re_to_K", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/basic.lean", "formal_statement": "theorem inner_product_space.of_core.inner_self_re_to_K {\ud835\udd5c F : Type*}\n\t[is_R_or_C \ud835\udd5c] [add_comm_group F] [module \ud835\udd5c F] [ : inner_product_space.core \ud835\udd5c F]\n\t{x : F} :\n\t\u2191(\u21d1is_R_or_C.re (has_inner.inner x x)) = has_inner.inner x x :=", "nl_statement_of_codex": "Let $F$ be a complex inner product space. Then the real part of the inner product of $x$ with itself is equal to the inner product of $x$ with itself."}
{"name": "list.range'_concat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/range.lean", "formal_statement": "theorem list.range'_concat (s n : \u2115) :\n\tlist.range' s (n + 1) = list.range' s n ++ [s + n] :=", "nl_statement_of_codex": "The list $[s, s+1, \\ldots, s+n]$ is the concatenation of the list $[s, s+1, \\ldots, s+n-1]$ and the list $[s+n]$."}
{"name": "add_submonoid.bot_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/pointwise.lean", "formal_statement": "theorem add_submonoid.bot_mul {R : Type*} [non_unital_non_assoc_semiring R]\n\t(S : add_submonoid R) :\n\t\u22a5 * S = \u22a5 :=", "nl_statement_of_codex": "Let $R$ be a non-unital non-associative semiring and let $S$ be an additive submonoid of $R$. Then $0\\cdot S=0$."}
{"name": "subsemigroup.monotone_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem subsemigroup.monotone_map {M N : Type*} [has_mul M] [has_mul N]\n\t{f : M \u2192\u2099* N} :\n\tmonotone (subsemigroup.map f) :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids and let $f:M\\to N$ be a monoid homomorphism. Then $f$ induces a monotone map from the submonoids of $M$ to the submonoids of $N$."}
{"name": "qpf.supp_preservation_iff_liftp_preservation", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/qpf/univariate/basic.lean", "formal_statement": "theorem qpf.supp_preservation_iff_liftp_preservation {F : Type u \u2192 Type u}\n\t[functor F] [q : qpf F] :\n\tq.supp_preservation \u2194 q.liftp_preservation :=", "nl_statement_of_codex": "Let $F$ be a functor. Then $F$ preserves supports if and only if $F$ preserves liftings."}
{"name": "is_coprime.of_prod_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/coprime/lemmas.lean", "formal_statement": "theorem is_coprime.of_prod_right {R : Type u} {I : Type v} [comm_semiring R]\n\t{x : R} {s : I \u2192 R} {t : finset I}\n\t(H1 : is_coprime x (t.prod (\u03bb (i : I), s i))) (i : I) (hit : i \u2208 t) :\n\tis_coprime x (s i) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $x\\in R$, and let $s:I\\to R$ be a function. If $x$ is coprime to $\\prod_{i\\in t}s(i)$ for all finite subsets $t$ of $I$, then $x$ is coprime to $s(i)$ for all $i\\in I$."}
{"name": "orthonormal_basis.repr_symm_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/pi_L2.lean", "formal_statement": "theorem orthonormal_basis.repr_symm_single {\u03b9 \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c]\n\t{E : Type*} [inner_product_space \ud835\udd5c E] [fintype \u03b9] [decidable_eq \u03b9]\n\t(b : orthonormal_basis \u03b9 \ud835\udd5c E) (i : \u03b9) :\n\t\u21d1(b.repr.symm) (euclidean_space.single i 1) = \u21d1b i :=", "nl_statement_of_codex": "Let $E$ be a finite-dimensional inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $b$ be an orthonormal basis of $E$. Then the representation of the symmetric bilinear form associated to $b$ is the same as the representation of $b$."}
{"name": "ideal.mem_of_one_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/over.lean", "formal_statement": "theorem ideal.mem_of_one_mem {S : Type*} [comm_ring S] {I : ideal S} (h : 1 \u2208 I)\n\t(x : S) :\n\tx \u2208 I :=", "nl_statement_of_codex": "Let $S$ be a commutative ring and let $I$ be an ideal of $S$. If $1\\in I$, then $I=S$."}
{"name": "continuous_Sup_dom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order.lean", "formal_statement": "theorem continuous_Sup_dom {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}\n\t{t\u2081 : set (topological_space \u03b1)} {t\u2082 : topological_space \u03b2}\n\t(h : \u2200 (t : topological_space \u03b1), t \u2208 t\u2081 \u2192 continuous f) :\n\tcontinuous f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f$ is continuous on each $U\\in\\mathcal{U}$, then $f$ is continuous."}
{"name": "galois_coinsertion.u_inf_l", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/galois_connection.lean", "formal_statement": "theorem galois_coinsertion.u_inf_l {\u03b1 : Type u} {\u03b2 : Type v} {l : \u03b1 \u2192 \u03b2}\n\t{u : \u03b2 \u2192 \u03b1} [semilattice_inf \u03b1] [semilattice_inf \u03b2]\n\t(gi : galois_coinsertion l u) (a b : \u03b1) :\n\tu (l a \u2293 l b) = a \u2293 b :=", "nl_statement_of_codex": "Let $l:A\\to B$ and $u:B\\to A$ be a Galois insertion. Then $u(l(a)\\wedge l(b))=a\\wedge b$."}
{"name": "is_glb.cInf_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/conditionally_complete_lattice.lean", "formal_statement": "theorem is_glb.cInf_eq {\u03b1 : Type*} [conditionally_complete_lattice \u03b1]\n\t{s : set \u03b1} {a : \u03b1} (H : is_glb s a) (ne : s.nonempty) :\n\thas_Inf.Inf s = a :=", "nl_statement_of_codex": "Let $s$ be a nonempty subset of a conditionally complete lattice $L$. If $a$ is the greatest lower bound of $s$, then $a=\\inf s$."}
{"name": "zsqrtd.smul_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.smul_val {d : \u2124} (n x y : \u2124) :\n\t\u2191n * {re := x, im := y} = {re := n * x, im := n * y} :=", "nl_statement_of_codex": "For all $n\\in\\mathbb{Z}$, $x,y\\in\\mathbb{Z}$, $n\\cdot(x+y\\sqrt{d})=nx+ny\\sqrt{d}$."}
{"name": "measurable_set_Ioc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/borel_space.lean", "formal_statement": "theorem measurable_set_Ioc {\u03b1 : Type*} [topological_space \u03b1]\n\t[measurable_space \u03b1] [opens_measurable_space \u03b1] [linear_order \u03b1]\n\t[order_closed_topology \u03b1] {a b : \u03b1} :\n\tmeasurable_set (set.Ioc a b) :=", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and the order topology. Then the open interval $(a,b)$ is measurable."}
{"name": "add_subsemigroup.monotone_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem add_subsemigroup.monotone_map {M N : Type*} [has_add M] [has_add N]\n\t{f : add_hom M N} :\n\tmonotone (add_subsemigroup.map f) :=", "nl_statement_of_codex": "Let $M$ and $N$ be additive semigroups and let $f:M\\to N$ be an additive homomorphism. Then $f$ is monotone."}
{"name": "measure_theory.strongly_measurable.ennnorm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem measure_theory.strongly_measurable.ennnorm {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03b2 : Type*} [normed_group \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : measure_theory.strongly_measurable f) :\n\tmeasurable (\u03bb (a : \u03b1), \u2191\u2225f a\u2225\u208a) :=", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{R}$ be a strongly measurable function. Then the function $a\\mapsto \\|f(a)\\|$ is measurable."}
{"name": "list.length_rotate'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/rotate.lean", "formal_statement": "theorem list.length_rotate' {\u03b1 : Type u} (l : list \u03b1) (n : \u2115) :\n\t(l.rotate' n).length = l.length :=", "nl_statement_of_codex": "The length of a list $l$ is equal to the length of $l$ rotated by $n$."}
{"name": "orientation.fin_orthonormal_basis_orthonormal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/orientation.lean", "formal_statement": "theorem orientation.fin_orthonormal_basis_orthonormal {E : Type*}\n\t[inner_product_space \u211d E] {n : \u2115} (hn : 0 < n)\n\t(h : finite_dimensional.finrank \u211d E = n) (x : orientation \u211d E (fin n)) :\n\torthonormal \u211d \u21d1(orientation.fin_orthonormal_basis hn h x) :=", "nl_statement_of_codex": "Let $E$ be a real inner product space. Let $n$ be a positive integer. Suppose that $\\dim E=n$. Let $x$ be an orientation of $E$. Then the basis $\\{e_1,\\ldots,e_n\\}$ of $E$ given by $x$ is orthonormal."}
{"name": "complex.arg_div_coe_angle", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/arg.lean", "formal_statement": "theorem complex.arg_div_coe_angle {x y : \u2102} (hx : x \u2260 0) (hy : y \u2260 0) :\n\t\u2191((x / y).arg) = \u2191(x.arg) - \u2191(y.arg) :=", "nl_statement_of_codex": "The argument of $x/y$ is the argument of $x$ minus the argument of $y$."}
{"name": "circle_deg1_lift.le_iterate_pos_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/circle/rotation_number/translation_number.lean", "formal_statement": "theorem circle_deg1_lift.le_iterate_pos_iff (f : circle_deg1_lift) {x : \u211d}\n\t{m : \u2124} {n : \u2115} (hn : 0 < n) :\n\tx + \u2191n * \u2191m \u2264 \u21d1f^[n] x \u2194 x + \u2191m \u2264 \u21d1f x :=", "nl_statement_of_codex": "Let $f$ be a circle degree 1 lift. Then for all $x\\in\\mathbb{R}$, $m\\in\\mathbb{Z}$, and $n\\in\\mathbb{N}$, $x+n\\cdot m\\leq f^n(x)$ if and only if $x+m\\leq f(x)$."}
{"name": "mul_rotate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem mul_rotate {G : Type*} [comm_semigroup G] (a b c : G) :\n\ta * b * c = b * c * a :=", "nl_statement_of_codex": "In a commutative semigroup, $a\\cdot b\\cdot c=b\\cdot c\\cdot a$."}
{"name": "ennreal.eq_top_of_forall_nnreal_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.eq_top_of_forall_nnreal_le {x : ennreal}\n\t(h : \u2200 (r : nnreal), \u2191r \u2264 x) :\n\tx = \u22a4 :=", "nl_statement_of_codex": "Let $x$ be an extended nonnegative real number. If $x$ is greater than or equal to every nonnegative real number, then $x=\\infty$."}
{"name": "submonoid.left_inv_left_inv_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/inverses.lean", "formal_statement": "theorem submonoid.left_inv_left_inv_eq {M : Type*} [monoid M] (S : submonoid M)\n\t(hS : S \u2264 is_unit.submonoid M) :\n\tS.left_inv.left_inv = S :=", "nl_statement_of_codex": "Let $M$ be a monoid and let $S$ be a submonoid of $M$ such that $S$ contains the units of $M$. Then $S$ is equal to the set of left inverses of $S$."}
{"name": "matrix.is_hermitian_diagonal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/hermitian.lean", "formal_statement": "theorem matrix.is_hermitian_diagonal {n : Type*} [decidable_eq n] (v : n \u2192 \u211d) :\n\t(matrix.diagonal v).is_hermitian :=", "nl_statement_of_codex": "The diagonal matrix with diagonal entries $v$ is Hermitian."}
{"name": "set.interval_subset_interval_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean", "formal_statement": "theorem set.interval_subset_interval_left {\u03b1 : Type u} [linear_order \u03b1]\n\t{a b x : \u03b1} (h : x \u2208 set.interval a b) :\n\tset.interval a x \u2286 set.interval a b :=", "nl_statement_of_codex": "Let $a,b,x$ be elements of a linear order. If $x\\in [a,b]$, then $[a,x]\\subset [a,b]$."}
{"name": "ordinal.fp_bfamily_unbounded", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/fixed_point.lean", "formal_statement": "theorem ordinal.fp_bfamily_unbounded {o : ordinal}\n\t{f : \u03a0 (b : ordinal), b < o \u2192 ordinal \u2192 ordinal}\n\t(H : \u2200 (i : ordinal) (hi : i < o), ordinal.is_normal (f i hi)) :\n\tset.unbounded has_lt.lt (\u22c2 (i : ordinal) (hi : i < o), function.fixed_points (f i hi)) :=", "nl_statement_of_codex": "Let $o$ be an ordinal and let $f:o\\times o\\to o$ be a function such that $f(i,j)$ is normal for all $i<o$ and $j<o$. Then the set of fixed points of $f$ is unbounded."}
{"name": "category_theory.monoidal_category.comp_tensor_id_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/category.lean", "formal_statement": "theorem category_theory.monoidal_category.comp_tensor_id_assoc {C : Type u}\n\t[category_theory.category C] [category_theory.monoidal_category C]\n\t{W X Y Z : C} (f : W \u27f6 X) (g : X \u27f6 Y) {X' : C} (f' : Y \u2297 Z \u27f6 X') :\n\t(f \u226b g \u2297 \ud835\udfd9 Z) \u226b f' = (f \u2297 \ud835\udfd9 Z) \u226b (g \u2297 \ud835\udfd9 Z) \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $f:W\\to X$, $g:X\\to Y$, $f':Y\\otimes Z\\to X'$. Then $(f\\circ g\\otimes id_Z)\\circ f'=(f\\otimes id_Z)\\circ (g\\otimes id_Z)\\circ f'$."}
{"name": "add_subgroup.vadd_opposite_image_add_preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem add_subgroup.vadd_opposite_image_add_preimage {G : Type*} [add_group G]\n\t{H : add_subgroup G} (g : G) (h : \u21a5(H.opposite)) (s : set G) :\n\t(\u03bb (y : G), h +\u1d65 y) '' (has_add.add g \u207b\u00b9' s) = has_add.add g \u207b\u00b9' ((\u03bb (y : G), h +\u1d65 y) '' s) :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $H$ be an additive subgroup of $G$. Let $g\\in G$ and let $s$ be a subset of $G$. Then $(-H+g)^{-1}(s)=g+(-H)^{-1}(s)$."}
{"name": "finset.Ico_union_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/locally_finite.lean", "formal_statement": "theorem finset.Ico_union_Ico {\u03b1 : Type*} [linear_order \u03b1]\n\t[locally_finite_order \u03b1] {a b c d : \u03b1}\n\t(h\u2081 : linear_order.min a b \u2264 linear_order.max c d)\n\t(h\u2082 : linear_order.min c d \u2264 linear_order.max a b) :\n\tfinset.Ico a b \u222a finset.Ico c d = finset.Ico (linear_order.min a c) (linear_order.max b d) :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a linear order. Then the union of the intervals $[a,b]$ and $[c,d]$ is equal to the interval $[\\min(a,c),\\max(b,d)]$."}
{"name": "has_deriv_within_at_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_within_at_pow {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t(n : \u2115) (x : \ud835\udd5c) (s : set \ud835\udd5c) :\n\thas_deriv_within_at (\u03bb (x : \ud835\udd5c), x ^ n) (\u2191n * x ^ (n - 1)) s x :=", "nl_statement_of_codex": "The function $f(x)=x^n$ has derivative $f'(x)=nx^{n-1}$ at $x$."}
{"name": "is_alg_closure_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/is_alg_closed/basic.lean", "formal_statement": "theorem is_alg_closure_iff (k : Type u) [field k] (K : Type v) [field K]\n\t[algebra k K] :\n\tis_alg_closure k K \u2194 is_alg_closed K \u2227 algebra.is_algebraic k K :=", "nl_statement_of_codex": "Let $k$ be a field and let $K$ be a field extension of $k$. Then $K$ is an algebraic closure of $k$ if and only if $K$ is algebraically closed and $k$ is algebraically closed in $K$."}
{"name": "separated.union_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/separation.lean", "formal_statement": "theorem separated.union_right {\u03b1 : Type u} [topological_space \u03b1] {a b c : set \u03b1}\n\t(ab : separated a b) (ac : separated a c) :\n\tseparated a (b \u222a c) :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A, B, C$ be subsets of $X$. If $A$ and $B$ are separated and $A$ and $C$ are separated, then $A$ and $B\\cup C$ are separated."}
{"name": "pgame.add_congr_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.add_congr_left {x y z : pgame} (h : x.equiv y) :\n\t(x + z).equiv (y + z) :=", "nl_statement_of_codex": "If $x$ and $y$ are equivalent games, then $x+z$ and $y+z$ are equivalent games."}
{"name": "metric.closed_ball_diff_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.closed_ball_diff_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{x : \u03b1} {\u03b5 : \u211d} :\n\tmetric.closed_ball x \u03b5 \\ metric.ball x \u03b5 = metric.sphere x \u03b5 :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x\\in X$. Then the closed ball of radius $\\epsilon$ centered at $x$ is the union of the open ball of radius $\\epsilon$ centered at $x$ and the sphere of radius $\\epsilon$ centered at $x$."}
{"name": "is_torsion_free.not_torsion", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/torsion.lean", "formal_statement": "theorem is_torsion_free.not_torsion {G : Type*} [group G] [hN : nontrivial G] :\n\tmonoid.is_torsion_free G \u2192 \u00acmonoid.is_torsion G :=", "nl_statement_of_codex": "Let $G$ be a nontrivial group. Then $G$ is torsion-free if and only if $G$ is not torsion."}
{"name": "tensor_algebra.induction", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/tensor_algebra/basic.lean", "formal_statement": "theorem tensor_algebra.induction {R : Type*} [comm_semiring R] {M : Type*}\n\t[add_comm_monoid M] [module R M] {C : tensor_algebra R M \u2192 Prop}\n\t(h_grade0 : \u2200 (r : R), C (\u21d1(algebra_map R (tensor_algebra R M)) r))\n\t(h_grade1 : \u2200 (x : M), C (\u21d1(tensor_algebra.\u03b9 R) x))\n\t(h_mul : \u2200 (a b : tensor_algebra R M), C a \u2192 C b \u2192 C (a * b))\n\t(h_add : \u2200 (a b : tensor_algebra R M), C a \u2192 C b \u2192 C (a + b))\n\t(a : tensor_algebra R M) :\n\tC a :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, and $C$ a property of elements of the tensor algebra $T(M)$. Suppose that $C$ holds for elements of grade $0$, grade $1$, and that $C$ is closed under addition and multiplication. Then $C$ holds for all elements of $T(M)$."}
{"name": "ring_equiv.map_ne_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/equiv.lean", "formal_statement": "theorem ring_equiv.map_ne_zero_iff {R S : Type*}\n\t[non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S]\n\t(f : R \u2243+* S) {x : R} :\n\t\u21d1f x \u2260 0 \u2194 x \u2260 0 :=", "nl_statement_of_codex": "Let $R$ and $S$ be non-unital non-associative semirings and let $f:R\\to S$ be a ring isomorphism. Then $f(x)\\neq 0$ if and only if $x\\neq 0$."}
{"name": "nat.cast_finsupp_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem nat.cast_finsupp_sum {\u03b1 M R : Type*1} [has_zero M] (f : \u03b1 \u2192\u2080 M)\n\t[comm_semiring R] (g : \u03b1 \u2192 M \u2192 \u2115) :\n\t\u2191(f.sum g) = f.sum (\u03bb (a : \u03b1) (b : M), \u2191(g a b)) :=", "nl_statement_of_codex": "Let $f$ be a finitely supported function from $\\alpha$ to $M$ and let $g$ be a function from $\\alpha\\times M$ to $\\mathbb{N}$. Then $\\sum_{a\\in\\alpha}f(a)\\sum_{b\\in M}g(a,b)=\\sum_{a\\in\\alpha}f(a)\\sum_{b\\in M}g(a,b)$."}
{"name": "turing.eval_maximal\u2081", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/turing_machine.lean", "formal_statement": "theorem turing.eval_maximal\u2081 {\u03c3 : Type*} {f : \u03c3 \u2192 option \u03c3} {a b : \u03c3}\n\t(h : b \u2208 turing.eval f a) ( : \u03c3) :\n\t\u00acturing.reaches\u2081 f b c :=", "nl_statement_of_codex": "Let $f:\\Sigma\\to\\Sigma$ be a Turing machine. If $b$ is reachable from $a$ by $f$, then $b$ is not reachable from $c$ by $f$."}
{"name": "real.norm_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/field/basic.lean", "formal_statement": "theorem real.norm_two :\n\t\u22252\u2225 = 2 :=", "nl_statement_of_codex": "The norm of $2$ is $2$."}
{"name": "monoid_algebra.lift_magma_apply_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/monoid_algebra/basic.lean", "formal_statement": "theorem monoid_algebra.lift_magma_apply_apply (k : Type u\u2081) {G : Type u\u2082}\n\t[semiring k] [has_mul G] {A : Type u\u2083} [non_unital_non_assoc_semiring A]\n\t[module k A] [is_scalar_tower k A A] [smul_comm_class k A A] (f : G \u2192\u2099* A)\n\t(a : monoid_algebra k G) :\n\t\u21d1(\u21d1(monoid_algebra.lift_magma k) f) a = finsupp.sum a (\u03bb (m : G) (t : k), t \u2022 \u21d1f m) :=", "nl_statement_of_codex": "Let $k$ be a semiring, $G$ a monoid, $A$ a non-unital non-associative $k$-algebra. Let $f:G\\to A$ be a monoid homomorphism. Then the map $G\\to A$ given by $g\\mapsto \\sum_{m\\in G} f(m)$ is a monoid homomorphism."}
{"name": "is_Lprojection.coe_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/M_structure.lean", "formal_statement": "theorem is_Lprojection.coe_bot {X : Type*} [normed_group X] {M : Type} [ring M]\n\t[module M X] [has_faithful_smul M X] :\n\t\u2191bounded_order.bot = 0 :=", "nl_statement_of_codex": "The lower projection of the zero ideal is zero."}
{"name": "exp_series_sum_eq_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/exponential.lean", "formal_statement": "theorem exp_series_sum_eq_div {\ud835\udd42 \ud835\udd38 : Type*} [field \ud835\udd42] [division_ring \ud835\udd38]\n\t[algebra \ud835\udd42 \ud835\udd38] [topological_space \ud835\udd38] [topological_ring \ud835\udd38] (x : \ud835\udd38) :\n\t(exp_series \ud835\udd42 \ud835\udd38).sum x = \u2211' (n : \u2115), x ^ n / \u2191(n.factorial) :=", "nl_statement_of_codex": "The sum of the exponential series is equal to the sum of the terms of the series divided by the factorial of the index."}
{"name": "zero_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/defs.lean", "formal_statement": "theorem zero_add {M : Type u} [add_zero_class M] (a : M) :\n\t0 + a = a :=", "nl_statement_of_codex": "Let $M$ be an additive monoid with zero. Then $0+a=a$ for all $a\\in M$."}
{"name": "Sup_hom.dual_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/complete_lattice.lean", "formal_statement": "theorem Sup_hom.dual_id {\u03b1 : Type*} [has_Sup \u03b1] :\n\t\u21d1Sup_hom.dual (Sup_hom.id \u03b1) = Inf_hom.id \u03b1\u1d52\u1d48 :=", "nl_statement_of_codex": "The dual of the supremum homomorphism is the infimum homomorphism."}
{"name": "ideal.comap_le_map_of_inv_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.comap_le_map_of_inv_on {R : Type u} {S : Type v} {F : Type*}\n\t[semiring R] [semiring S] [rc : ring_hom_class F R S] (f : F) {G : Type*}\n\t[rcg : ring_hom_class G S R] (g : G) (I : ideal S)\n\t(hf : set.left_inv_on \u21d1g \u21d1f (\u21d1f \u207b\u00b9' \u2191I)) :\n\tideal.comap f I \u2264 ideal.map g I :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f:R\\to S$ and $g:S\\to R$ be ring homomorphisms. Let $I$ be an ideal of $S$. If $g$ is a left inverse of $f$ on $f^{-1}(I)$, then $f^{-1}(I)$ is contained in $g(I)$."}
{"name": "int.modeq.add_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/modeq.lean", "formal_statement": "theorem int.modeq.add_left {n a b : \u2124} ( : \u2124) (h : a \u2261 b [ZMOD n]) :\n\tc + a \u2261 c + b [ZMOD n] :=", "nl_statement_of_codex": "Let $n$ be a positive integer and let $a, b, c$ be integers. If $a\\equiv b\\pmod{n}$, then $c+a\\equiv c+b\\pmod{n}$."}
{"name": "commutator_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/abelianization.lean", "formal_statement": "theorem commutator_def (G : Type u) [group G] :\n\tcommutator G = \u2045\u22a4,\u22a4\u2046 :=", "nl_statement_of_codex": "The commutator of a group $G$ is the subgroup generated by all commutators."}
{"name": "ordinal.opow_is_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.opow_is_limit {a b : ordinal} (a1 : 1 < a) :\n\tb.is_limit \u2192 (a ^ b).is_limit :=", "nl_statement_of_codex": "If $a$ is an ordinal greater than $1$ and $b$ is a limit ordinal, then $a^b$ is a limit ordinal."}
{"name": "polynomial.factorial_smul_hasse_deriv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/hasse_deriv.lean", "formal_statement": "theorem polynomial.factorial_smul_hasse_deriv {R : Type*} [semiring R] (k : \u2115) :\n\t\u21d1(k.factorial \u2022 polynomial.hasse_deriv k) = (\u21d1polynomial.derivative^[k]) :=", "nl_statement_of_codex": "The $k$-th derivative of the $k$-th factorial is the $k$-th derivative of the $k$-th Hasse derivative."}
{"name": "edist_le_tsum_of_edist_le_of_tendsto\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem edist_le_tsum_of_edist_le_of_tendsto\u2080 {\u03b1 : Type*}\n\t[pseudo_emetric_space \u03b1] {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 ennreal)\n\t(hf : \u2200 (n : \u2115), has_edist.edist (f n) (f n.succ) \u2264 d n) {a : \u03b1}\n\t(ha : filter.tendsto f filter.at_top (nhds a)) :\n\thas_edist.edist (f 0) a \u2264 \u2211' (m : \u2115), d m :=", "nl_statement_of_codex": "Let $(X,d)$ be a pseudo-metric space and let $f:\\mathbb{N}\\to X$. Suppose that $d(f(n),f(n+1))\\leq d_n$ for all $n\\in\\mathbb{N}$ and that $f$ converges to $a\\in X$. Then $d(f(0),a)\\leq \\sum_{n=0}^\\infty d_n$."}
{"name": "wcovby.le_of_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/cover.lean", "formal_statement": "theorem wcovby.le_of_lt {\u03b1 : Type*} [linear_order \u03b1] {a b c : \u03b1} (hab : a \u2a7f b)\n\t(hcb : c < b) :\n\tc \u2264 a :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order. If $a\\geq b$ and $c<b$, then $c\\leq a$."}
{"name": "polynomial.content_X_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/content.lean", "formal_statement": "theorem polynomial.content_X_pow {R : Type*} [comm_ring R] [is_domain R]\n\t[normalized_gcd_monoid R] {k : \u2115} :\n\t(polynomial.X ^ k).content = 1 :=", "nl_statement_of_codex": "The content of $X^k$ is $1$."}
{"name": "continuous_linear_equiv.comp_cont_diff_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem continuous_linear_equiv.comp_cont_diff_iff {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {G : Type*} [normed_group G]\n\t[normed_space \ud835\udd5c G] {f : E \u2192 F} {n : with_top \u2115} (e : F \u2243L[\ud835\udd5c] G) :\n\tcont_diff \ud835\udd5c n (\u21d1e \u2218 f) \u2194 cont_diff \ud835\udd5c n f :=", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over $\\mathbb{K}$ and let $f:E\\to F$. Then $f$ is $n$-times continuously differentiable if and only if $f\\circ e$ is $n$-times continuously differentiable."}
{"name": "eq_Icc_cInf_cSup_of_connected_bdd_closed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/intermediate_value.lean", "formal_statement": "theorem eq_Icc_cInf_cSup_of_connected_bdd_closed {\u03b1 : Type u}\n\t[conditionally_complete_linear_order \u03b1] [topological_space \u03b1]\n\t[order_topology \u03b1] {s : set \u03b1} (hc : is_connected s) (hb : bdd_below s)\n\t(ha : bdd_above s) (hcl : is_closed s) :\n\ts = set.Icc (has_Inf.Inf s) (has_Sup.Sup s) :=", "nl_statement_of_codex": "Let $s$ be a connected, bounded, closed subset of a conditionally complete linear order. Then $s$ is an interval."}
{"name": "category_theory.limits.preserves_pushout.inl_iso_inv_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/preserves/shapes/pullbacks.lean", "formal_statement": "theorem category_theory.limits.preserves_pushout.inl_iso_inv_assoc {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t(G : C \u2964 D) {W X Y : C} (f : W \u27f6 X) (g : W \u27f6 Y)\n\t[category_theory.limits.preserves_colimit (category_theory.limits.span f g) G]\n\t[category_theory.limits.has_pushout f g]\n\t[category_theory.limits.has_pushout (G.map f) (G.map g)] {X' : D}\n\t(f' : category_theory.limits.pushout (G.map f) (G.map g) \u27f6 X') :\n\tG.map category_theory.limits.pushout.inl \u226b (category_theory.limits.preserves_pushout.iso G f g).inv \u226b f' = category_theory.limits.pushout.inl \u226b f' :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $G:C\\to D$ be a functor. Let $f,g:W\\to X$ be morphisms in $C$ and let $f':X'\\to Y$ be a morphism in $D$. Suppose that $G$ preserves the pushout of $f$ and $g$. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\nW \\arrow[r, "}
{"name": "urysohns.CU.left_U_subset_right_C", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/urysohns_lemma.lean", "formal_statement": "theorem urysohns.CU.left_U_subset_right_C {X : Type*} [topological_space X]\n\t[normal_space X] ( : urysohns.CU X) :\n\tc.left.U \u2286 c.right.C :=", "nl_statement_of_codex": "Let $X$ be a normal topological space. Then the left Urysohn function $f$ is constant on the right closed set $C$."}
{"name": "add_monoid_algebra.decompose_aux_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/monoid_algebra/grading.lean", "formal_statement": "theorem add_monoid_algebra.decompose_aux_coe {M \u03b9 R : Type*} [decidable_eq M]\n\t[add_monoid M] [decidable_eq \u03b9] [add_monoid \u03b9] [comm_semiring R] (f : M \u2192+ \u03b9)\n\t{i : \u03b9} (x : \u21a5(add_monoid_algebra.grade_by R \u21d1f i)) :\n\t\u21d1(add_monoid_algebra.decompose_aux f) \u2191x = \u21d1(direct_sum.of (\u03bb (i : \u03b9), \u21a5(add_monoid_algebra.grade_by R \u21d1f i)) i) x :=", "nl_statement_of_codex": "Let $M$ be a set, let $\\iota$ be a set, let $R$ be a commutative ring, let $f:M\\to\\iota$ be a function, let $i\\in\\iota$, and let $x\\in\\mathrm{grade}_i(M,\\iota,R)$. Then the $i$-th component of the decomposition of $x$ is $x$."}
{"name": "is_metric_separated.symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/metric_separated.lean", "formal_statement": "theorem is_metric_separated.symm {X : Type*} [emetric_space X] {s t : set X}\n\t(h : is_metric_separated s t) :\n\tis_metric_separated t s :=", "nl_statement_of_codex": "Let $X$ be a metric space. If $s$ and $t$ are separated, then $t$ and $s$ are separated."}
{"name": "nat.rec_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.rec_zero {C : \u2115 \u2192 Sort u} (h0 : C 0)\n\t(h : \u03a0 (n : \u2115), C n \u2192 C (n + 1)) :\n\tnat.rec h0 h 0 = h0 :=", "nl_statement_of_codex": "The recursion principle for natural numbers is true for $0$."}
{"name": "pnat.eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pnat/basic.lean", "formal_statement": "theorem pnat.eq {m n : \u2115+} :\n\t\u2191m = \u2191n \u2192 m = n :=", "nl_statement_of_codex": "Two positive natural numbers are equal if and only if they are equal as natural numbers."}
{"name": "seminorm.ball_add_ball_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/seminorm.lean", "formal_statement": "theorem seminorm.ball_add_ball_subset {\ud835\udd5c E : Type*} [semi_normed_ring \ud835\udd5c]\n\t[add_comm_group E] [has_smul \ud835\udd5c E] (p : seminorm \ud835\udd5c E) (r\u2081 r\u2082 : \u211d) (x\u2081 x\u2082 : E) :\n\tp.ball x\u2081 r\u2081 + p.ball x\u2082 r\u2082 \u2286 p.ball (x\u2081 + x\u2082) (r\u2081 + r\u2082) :=", "nl_statement_of_codex": "Let $p$ be a seminorm on a vector space $E$ over a semi-normed ring $R$. Then the sum of the balls of radius $r_1$ and $r_2$ around $x_1$ and $x_2$ is contained in the ball of radius $r_1+r_2$ around $x_1+x_2$."}
{"name": "measure_theory.measure.haar.le_index_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/haar.lean", "formal_statement": "theorem measure_theory.measure.haar.le_index_mul {G : Type*} [group G]\n\t[topological_space G] [topological_group G]\n\t(K\u2080 : topological_space.positive_compacts G) (K : topological_space.compacts G)\n\t{V : set G} (hV : (interior V).nonempty) :\n\tmeasure_theory.measure.haar.index \u2191K V \u2264 measure_theory.measure.haar.index \u2191K \u2191K\u2080 * measure_theory.measure.haar.index \u2191K\u2080 V :=", "nl_statement_of_codex": "Let $G$ be a topological group. Let $K_0$ be a positive compact subset of $G$ and let $K$ be a compact subset of $G$. Let $V$ be a subset of $G$ with nonempty interior. Then the index of $V$ in $K$ is less than or equal to the product of the index of $K_0$ in $K$ and the index of $V$ in $K_0$."}
{"name": "finsupp.mem_supported_support", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finsupp.lean", "formal_statement": "theorem finsupp.mem_supported_support {\u03b1 M : Type*} (R : Type*) [semiring R]\n\t[add_comm_monoid M] [module R M] (p : \u03b1 \u2192\u2080 M) :\n\tp \u2208 finsupp.supported M R \u2191(p.support) :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ be an $R$-module, and $p:\\alpha\\to M$ be a finitely supported function. Then $p$ is in the set of finitely supported functions with support contained in the support of $p$."}
{"name": "real.uniform_continuous_mul_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/real.lean", "formal_statement": "theorem real.uniform_continuous_mul_const {x : \u211d} :\n\tuniform_continuous (has_mul.mul x) :=", "nl_statement_of_codex": "The function $f(y)=xy$ is uniformly continuous on $\\mathbb{R}$."}
{"name": "equiv.perm.same_cycle.trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/basic.lean", "formal_statement": "theorem equiv.perm.same_cycle.trans {\u03b2 : Type*} {f : equiv.perm \u03b2} {x y z : \u03b2} :\n\tf.same_cycle x y \u2192 f.same_cycle y z \u2192 f.same_cycle x z :=", "nl_statement_of_codex": "Let $f$ be a permutation of a set $X$. If $x$ and $y$ are in the same cycle of $f$, and $y$ and $z$ are in the same cycle of $f$, then $x$ and $z$ are in the same cycle of $f$."}
{"name": "dfinsupp.mk_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.mk_neg {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} [dec : decidable_eq \u03b9]\n\t[\u03a0 (i : \u03b9), add_group (\u03b2 i)] {s : finset \u03b9} {x : \u03a0 (i : \u21a5\u2191s), \u03b2 i.val} :\n\tdfinsupp.mk s (-x) = -dfinsupp.mk s x :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $x$ be a function from $s$ to an additive group $G$. Then the function $-x$ is the negative of the function $x$."}
{"name": "decidable.imp_iff_not_or", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem decidable.imp_iff_not_or {a b : Prop} [decidable a] :\n\ta \u2192 b \u2194 \u00aca \u2228 b :=", "nl_statement_of_codex": "If $a$ is decidable, then $a\\to b$ if and only if $\\lnot a\\lor b$."}
{"name": "nat.pow_le_iff_le_log", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/log.lean", "formal_statement": "theorem nat.pow_le_iff_le_log {b : \u2115} (hb : 1 < b) {x y : \u2115} (hy : 0 < y) :\n\tb ^ x \u2264 y \u2194 x \u2264 nat.log b y :=", "nl_statement_of_codex": "Let $b$ be a natural number greater than $1$. Then $b^x\\leq y$ if and only if $x\\leq \\log_b y$."}
{"name": "linear_map.iterate_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem linear_map.iterate_surjective {R M : Type*} [semiring R]\n\t[add_comm_monoid M] [module R M] {f' : M \u2192\u2097[R] M} (h : function.surjective \u21d1f')\n\t(n : \u2115) :\n\tfunction.surjective \u21d1(f' ^ n) :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $f':M\\to M$ a linear map. If $f'$ is surjective, then $f'^n$ is surjective for all $n\\in\\mathbb{N}$."}
{"name": "local_homeomorph.trans_equiv_eq_trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/local_homeomorph.lean", "formal_statement": "theorem local_homeomorph.trans_equiv_eq_trans {\u03b1 \u03b2 \u03b3 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b2] [topological_space \u03b3]\n\t(e : local_homeomorph \u03b1 \u03b2) (e' : \u03b2 \u2243\u209c \u03b3) :\n\te.trans_homeomorph e' = e.trans e'.to_local_homeomorph :=", "nl_statement_of_codex": "Let $e:X\\to Y$ and $e':Y\\to Z$ be local homeomorphisms. Then $e'\\circ e$ is a local homeomorphism if and only if $e$ and $e'$ are local homeomorphisms."}
{"name": "set.image2_empty_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.image2_empty_right {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1} :\n\tset.image2 f s \u2205 = \u2205 :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. Then $f(A,\\emptyset)=\\emptyset$."}
{"name": "fractional_ideal.is_fractional", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.is_fractional {R : Type*} [comm_ring R]\n\t{S : submonoid R} {P : Type*} [comm_ring P] [algebra R P]\n\t(I : fractional_ideal S P) :\n\tis_fractional S \u2191I :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a submonoid of $R$, $P$ a commutative ring, and $I$ a fractional ideal of $S$. Then $I$ is a fractional ideal of $R$."}
{"name": "matrix.is_symm.apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/symmetric.lean", "formal_statement": "theorem matrix.is_symm.apply {\u03b1 n : Type*} {A : matrix n n \u03b1} (h : A.is_symm)\n\t(i j : n) :\n\tA j i = A i j :=", "nl_statement_of_codex": "Let $A$ be a symmetric matrix. Then $A_{ij}=A_{ji}$ for all $i,j$."}
{"name": "set.union_distrib_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.union_distrib_left {\u03b1 : Type u} (s t u : set \u03b1) :\n\ts \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u) :=", "nl_statement_of_codex": "$(A\\cup B)\\cap (A\\cup C)=(A\\cup (B\\cap C))$."}
{"name": "submonoid.comap_sup_map_of_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem submonoid.comap_sup_map_of_injective {M N : Type*} [mul_one_class M]\n\t[mul_one_class N] {F : Type*} [mc : monoid_hom_class F M N] {f : F}\n\t(hf : function.injective \u21d1f) (S T : submonoid M) :\n\tsubmonoid.comap f (submonoid.map f S \u2294 submonoid.map f T) = S \u2294 T :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids and let $f:M\\to N$ be a monoid homomorphism. If $f$ is injective, then $f(S\\cup T)=f(S)\\cup f(T)$ for all submonoids $S,T$ of $M$."}
{"name": "finset.ssubset_singleton_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.ssubset_singleton_iff {\u03b1 : Type*} {s : finset \u03b1} {a : \u03b1} :\n\ts \u2282 {a} \u2194 s = \u2205 :=", "nl_statement_of_codex": "A finite set $s$ is a subset of the singleton set $\\{a\\}$ if and only if $s$ is empty."}
{"name": "submonoid.localization_map.mul_equiv_of_localizations_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.mul_equiv_of_localizations_apply {M : Type*}\n\t[comm_monoid M] {S : submonoid M} {N : Type*} [comm_monoid N] {P : Type*}\n\t[comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} {x : N} :\n\t\u21d1(f.mul_equiv_of_localizations k) x = \u21d1(f.lift _) x :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, let $P$ be a commutative monoid, let $f:S\\to N$ be a localization map, let $k:S\\to P$ be a localization map, and let $x\\in N$. Then $f(k(x))=f(x)$."}
{"name": "subsemiring.map_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subsemiring/basic.lean", "formal_statement": "theorem subsemiring.map_id {R : Type u} [non_assoc_semiring R]\n\t(s : subsemiring R) :\n\tsubsemiring.map (ring_hom.id R) s = s :=", "nl_statement_of_codex": "Let $R$ be a non-associative semiring and let $s$ be a subsemiring of $R$. Then the image of $s$ under the identity map on $R$ is $s$."}
{"name": "fin.zero_succ_above", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.zero_succ_above {n : \u2115} (i : fin n) :\n\t\u21d1(0.succ_above) i = i.succ :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $i$ be an element of $n$. Then the successor of $i$ in $n+1$ is $i+1$."}
{"name": "metric.Union_ball_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.Union_ball_nat {\u03b1 : Type u} [pseudo_metric_space \u03b1] (x : \u03b1) :\n\t(\u22c3 (n : \u2115), metric.ball x \u2191n) = set.univ :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. Then $\\bigcup_{n\\in\\mathbb{N}}B(x,n)=X$."}
{"name": "is_lub_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem is_lub_prod {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{s : set (\u03b1 \u00d7 \u03b2)} (p : \u03b1 \u00d7 \u03b2) :\n\tis_lub s p \u2194 is_lub (prod.fst '' s) p.fst \u2227 is_lub (prod.snd '' s) p.snd :=", "nl_statement_of_codex": "Let $s$ be a subset of $\\alpha\\times\\beta$. Then $(\\alpha,\\beta)$ is the least upper bound of $s$ if and only if $\\alpha$ is the least upper bound of the projection of $s$ onto $\\alpha$ and $\\beta$ is the least upper bound of the projection of $s$ onto $\\beta$."}
{"name": "category_theory.category_of_elements.id_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/elements.lean", "formal_statement": "theorem category_theory.category_of_elements.id_val {C : Type u}\n\t[category_theory.category C] {F : C \u2964 Type w} {p : F.elements} :\n\t(\ud835\udfd9 p).val = \ud835\udfd9 p.fst :=", "nl_statement_of_codex": "Let $C$ be a category and let $F:C\\to\\mathbf{Set}$ be a functor. Then the identity morphism of $F$ is the identity morphism of $F(c)$ for each object $c$ of $C$."}
{"name": "complex.I_mul_im", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/basic.lean", "formal_statement": "theorem complex.I_mul_im (z : \u2102) :\n\t(complex.I * z).im = z.re :=", "nl_statement_of_codex": "The imaginary part of $i\\cdot z$ is the real part of $z$."}
{"name": "polynomial.coeff_div_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/inductions.lean", "formal_statement": "theorem polynomial.coeff_div_X {R : Type u} {n : \u2115} [semiring R]\n\t{p : polynomial R} :\n\tp.div_X.coeff n = p.coeff (n + 1) :=", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$. Then the coefficient of $X^n$ in $p$ is equal to the coefficient of $X^{n+1}$ in $p$ divided by $X$."}
{"name": "cochain_complex.mk_d_2_0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/homological_complex.lean", "formal_statement": "theorem cochain_complex.mk_d_2_0 {V : Type u} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] (X\u2080 X\u2081 X\u2082 : V) (d\u2080 : X\u2080 \u27f6 X\u2081)\n\t(d\u2081 : X\u2081 \u27f6 X\u2082) (s : d\u2080 \u226b d\u2081 = 0)\n\t(succ : \u03a0 (t : \u03a3' (X\u2080 X\u2081 X\u2082 : V) (d\u2080 : X\u2080 \u27f6 X\u2081) (d\u2081 : X\u2081 \u27f6 X\u2082), d\u2080 \u226b d\u2081 = 0), \u03a3' (X\u2083 : V) (d\u2082 : t.snd.snd.fst \u27f6 X\u2083), t.snd.snd.snd.snd.fst \u226b d\u2082 = 0) :\n\t(cochain_complex.mk X\u2080 X\u2081 X\u2082 d\u2080 d\u2081 s succ).d 1 2 = d\u2081 :=", "nl_statement_of_codex": "Let $X_0, X_1, X_2$ be objects in a category $V$ with zero morphisms. Let $d_0:X_0\\to X_1$ and $d_1:X_1\\to X_2$ be morphisms in $V$ such that $d_0\\circ d_1=0$. Let $succ$ be a function that takes a triple $(X_0, X_1, X_2, d_0, d_1, d_0\\circ d_1=0)$ and returns a pair $(X_3, d_2)$ such that $d_1\\circ d_2="}
{"name": "fin.coe_fin_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.coe_fin_lt {n : \u2115} {a b : fin n} :\n\t\u2191a < \u2191b \u2194 a < b :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $a, b$ be elements of $\\mathbb{F}_n$. Then $a<b$ if and only if $a<b$."}
{"name": "add_submonoid.topological_closure_minimal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/monoid.lean", "formal_statement": "theorem add_submonoid.topological_closure_minimal {M : Type*}\n\t[topological_space M] [add_monoid M] [has_continuous_add M]\n\t(s : add_submonoid M) {t : add_submonoid M} (h : s \u2264 t) (ht : is_closed \u2191t) :\n\ts.topological_closure \u2264 t :=", "nl_statement_of_codex": "Let $M$ be a topological space with a continuous addition. Let $s$ and $t$ be submonoids of $M$. If $s\\subseteq t$ and $t$ is closed, then the closure of $s$ is contained in $t$."}
{"name": "sym.coe_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sym/basic.lean", "formal_statement": "theorem sym.coe_injective {\u03b1 : Type*} {n : \u2115} :\n\tfunction.injective coe :=", "nl_statement_of_codex": "The map $\\mathrm{Sym}_n\\to\\mathrm{Sym}_n$ given by $f\\mapsto f^{-1}$ is injective."}
{"name": "or.intro_right", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/core.lean", "formal_statement": "theorem or.intro_right (a : Prop) {b : Prop} (hb : b) :\n\ta \u2228 b :=", "nl_statement_of_codex": "If $b$ is true, then $a\\lor b$ is true."}
{"name": "simple_graph.sum_inc_matrix_apply_of_not_mem_edge_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/inc_matrix.lean", "formal_statement": "theorem simple_graph.sum_inc_matrix_apply_of_not_mem_edge_set {R \u03b1 : Type*}\n\t(G : simple_graph \u03b1) [fintype \u03b1] [non_assoc_semiring R] {e : sym2 \u03b1}\n\t(h : e \u2209 G.edge_set) :\n\tfinset.univ.sum (\u03bb (a : \u03b1), simple_graph.inc_matrix R G a e) = 0 :=", "nl_statement_of_codex": "Let $G$ be a simple graph on a finite set $V$. Let $e$ be an edge of $G$. Then the sum of the entries of the $e$-th column of the incidence matrix of $G$ is zero."}
{"name": "continuous_within_at.const_cpow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem continuous_within_at.const_cpow {\u03b1 : Type*} [topological_space \u03b1]\n\t{f : \u03b1 \u2192 \u2102} {s : set \u03b1} {a : \u03b1} {b : \u2102} (hf : continuous_within_at f s a)\n\t(h : b \u2260 0 \u2228 f a \u2260 0) :\n\tcontinuous_within_at (\u03bb (x : \u03b1), b ^ f x) s a :=", "nl_statement_of_codex": "Let $f:X\\to\\mathbb{C}$ be a continuous function on a topological space $X$. Then the function $g:X\\to\\mathbb{C}$ defined by $g(x)=b^{f(x)}$ is continuous for any $b\\in\\mathbb{C}$ with $b\\neq 0$ or $f(x)\\neq 0$."}
{"name": "local_equiv.piecewise_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/local_equiv.lean", "formal_statement": "theorem local_equiv.piecewise_apply {\u03b1 \u03b2 : Type*} (e e' : local_equiv \u03b1 \u03b2)\n\t(s : set \u03b1) (t : set \u03b2) [\u03a0 (x : \u03b1), decidable (x \u2208 s)]\n\t[\u03a0 (y : \u03b2), decidable (y \u2208 t)] (H : e.is_image s t) (H' : e'.is_image s t) :\n\t\u21d1(e.piecewise e' s t H H') = s.piecewise \u21d1e \u21d1e' :=", "nl_statement_of_codex": "Let $e$ and $e'$ be local homeomorphisms from $X$ to $Y$. Let $s$ and $t$ be subsets of $X$ and $Y$, respectively. Suppose that $e$ and $e'$ are images of $s$ and $t$, respectively. Then the image of the piecewise function $e\\circ e'^{-1}$ is the piecewise function $e(e')^{-1}$."}
{"name": "function.surjective.nonempty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/nonempty.lean", "formal_statement": "theorem function.surjective.nonempty {\u03b1 \u03b2 : Type*} [h : nonempty \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : function.surjective f) :\n\tnonempty \u03b1 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a surjective function. Then $A$ is nonempty."}
{"name": "deriv_neg''", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem deriv_neg'' {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] (x : \ud835\udd5c) :\n\tderiv (\u03bb (x : \ud835\udd5c), -x) x = -1 :=", "nl_statement_of_codex": "The derivative of the function $f(x)=-x$ at $x$ is $-1$."}
{"name": "finset.piecewise_insert", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.piecewise_insert {\u03b1 : Type*} {\u03b4 : \u03b1 \u2192 Sort u_4} (s : finset \u03b1)\n\t(f g : \u03a0 (i : \u03b1), \u03b4 i) [\u03a0 (j : \u03b1), decidable (j \u2208 s)] [decidable_eq \u03b1] (j : \u03b1)\n\t[\u03a0 (i : \u03b1), decidable (i \u2208 has_insert.insert j s)] :\n\t(has_insert.insert j s).piecewise f g = function.update (s.piecewise f g) j (f j) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f,g:s\\to R$ be functions. Then the function $f$ updated at $j$ is equal to the function $g$ updated at $j$."}
{"name": "hyperreal.epsilon_eq_inv_omega", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.epsilon_eq_inv_omega :\n\thyperreal.epsilon = hyperreal.omega\u207b\u00b9 :=", "nl_statement_of_codex": "The hyperreal number $\\epsilon$ is equal to the reciprocal of $\\omega$."}
{"name": "finset.prod_image'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.prod_image' {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} {f : \u03b1 \u2192 \u03b2}\n\t[comm_monoid \u03b2] [decidable_eq \u03b1] {s : finset \u03b3} {g : \u03b3 \u2192 \u03b1} (h : \u03b3 \u2192 \u03b2)\n\t(eq : \u2200 (c : \u03b3), c \u2208 s \u2192 f (g c) = (finset.filter (\u03bb (c' : \u03b3), g c' = g c) s).prod (\u03bb (x : \u03b3), h x)) :\n\t(finset.image g s).prod (\u03bb (x : \u03b1), f x) = s.prod (\u03bb (x : \u03b3), h x) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $g:C\\to A$ be a function. Let $h:C\\to B$ be a function. Suppose that for each $c\\in C$ we have $f(g(c))=\\prod_{x\\in C, g(x)=g(c)}h(x)$. Then $\\prod_{a\\in A}f(a)=\\prod_{c\\in C}h(c)$."}
{"name": "dfinsupp.ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.ext_iff {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v}\n\t[\u03a0 (i : \u03b9), has_zero (\u03b2 i)] {f g : \u03a0\u2080 (i : \u03b9), \u03b2 i} :\n\tf = g \u2194 \u2200 (i : \u03b9), \u21d1f i = \u21d1g i :=", "nl_statement_of_codex": "Two finitely supported functions $f, g:\\mathbb{N}\\to R$ are equal if and only if $f(i)=f(g)$ for all $i$."}
{"name": "commute.add_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/basic.lean", "formal_statement": "theorem commute.add_right {R : Type x} [distrib R] {a b c : R} :\n\tcommute a b \u2192 commute a c \u2192 commute a (b + c) :=", "nl_statement_of_codex": "Let $R$ be a ring. If $a$ and $b$ commute and $a$ and $c$ commute, then $a$ and $b+c$ commute."}
{"name": "set.sigma_to_Union_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.sigma_to_Union_injective {\u03b1 \u03b2 : Type*} (t : \u03b1 \u2192 set \u03b2)\n\t(h : \u2200 (i j : \u03b1), i \u2260 j \u2192 disjoint (t i) (t j)) :\n\tfunction.injective (set.sigma_to_Union t) :=", "nl_statement_of_codex": "Let $t:A\\to \\mathcal{P}(B)$ be a function. Then the function $\\bigcup_{a\\in A}t(a)\\to A$ defined by $b\\mapsto a$ if $b\\in t(a)$ is injective."}
{"name": "linear_map.lift_dim_le_of_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/dimension.lean", "formal_statement": "theorem linear_map.lift_dim_le_of_injective {R : Type u} [ring R] {M : Type v}\n\t[add_comm_group M] [module R M] {M' : Type v'} [add_comm_group M']\n\t[module R M'] (f : M \u2192\u2097[R] M') (i : function.injective \u21d1f) :\n\t(module.rank R M).lift \u2264 (module.rank R M').lift :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ and $M'$ be $R$-modules. Let $f:M\\to M'$ be a linear map. If $f$ is injective, then $\\dim_R M\\leq \\dim_R M'$."}
{"name": "category_theory.limits.cocone_of_diagram_terminal_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/terminal.lean", "formal_statement": "theorem category_theory.limits.cocone_of_diagram_terminal_X {C : Type u\u2081}\n\t[category_theory.category C] {J : Type u} [category_theory.category J] {X : J}\n\t(tX : category_theory.limits.is_terminal X) (F : J \u2964 C) :\n\t(category_theory.limits.cocone_of_diagram_terminal tX F).X = F.obj X :=", "nl_statement_of_codex": "Let $C$ be a category and let $J$ be a category. Let $X$ be a terminal object of $J$ and let $F:J\\to C$ be a functor. Then the cocone of $F$ over $X$ is the terminal object of $C$."}
{"name": "list.subset_append_of_subset_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.subset_append_of_subset_right {\u03b1 : Type u} (l l\u2081 l\u2082 : list \u03b1) :\n\tl \u2286 l\u2082 \u2192 l \u2286 l\u2081 ++ l\u2082 :=", "nl_statement_of_codex": "Let $l, l_1, l_2$ be lists. If $l$ is a subset of $l_2$, then $l$ is a subset of $l_1\\cup l_2$."}
{"name": "category_theory.presieve.is_sheaf_of_yoneda", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sheaf_of_types.lean", "formal_statement": "theorem category_theory.presieve.is_sheaf_of_yoneda {C : Type u\u2081}\n\t[category_theory.category C] (J : category_theory.grothendieck_topology C)\n\t{P : C\u1d52\u1d56 \u2964 Type v\u2081}\n\t(h : \u2200 {X : C} (S : category_theory.sieve X), S \u2208 \u21d1J X \u2192 category_theory.presieve.yoneda_sheaf_condition P S) :\n\tcategory_theory.presieve.is_sheaf J P :=", "nl_statement_of_codex": "Let $C$ be a category and let $J$ be a Grothendieck topology on $C$. Let $P$ be a presheaf on $C$. Then $P$ is a sheaf if and only if for each sieve $S$ on $X$ in $J$, the presheaf condition holds."}
{"name": "filter.univ_mem'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.univ_mem' {\u03b1 : Type u} {f : filter \u03b1} {s : set \u03b1}\n\t(h : \u2200 (a : \u03b1), a \u2208 s) :\n\ts \u2208 f :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$. Then $X$ is in $f$."}
{"name": "sym_alg.unsym_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/symmetrized.lean", "formal_statement": "theorem sym_alg.unsym_one {\u03b1 : Type*} [has_one \u03b1] :\n\tsym_alg.unsym 1 = 1 :=", "nl_statement_of_codex": "The unsymmetrization of $1$ is $1$."}
{"name": "circle_deg1_lift.translation_number_eq_of_semiconj_by", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/circle/rotation_number/translation_number.lean", "formal_statement": "theorem circle_deg1_lift.translation_number_eq_of_semiconj_by\n\t{f g\u2081 g\u2082 : circle_deg1_lift} (H : semiconj_by f g\u2081 g\u2082) :\n\tg\u2081.translation_number = g\u2082.translation_number :=", "nl_statement_of_codex": "Let $f, g_1, g_2$ be circle degree 1 lifts. If $g_1$ is semiconjugate to $g_2$ by $f$, then $g_1$ and $g_2$ have the same translation number."}
{"name": "is_countably_spanning_measurable_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem is_countably_spanning_measurable_set {\u03b1 : Type*} [measurable_space \u03b1] :\n\tis_countably_spanning {s : set \u03b1 | measurable_set s} :=", "nl_statement_of_codex": "The collection of measurable sets is countably spanning."}
{"name": "add_comm_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem add_comm_sub {\u03b1 : Type*} [subtraction_comm_monoid \u03b1] (a b c : \u03b1) :\n\ta - b + c = a + (c - b) :=", "nl_statement_of_codex": "Let $a, b, c$ be elements of a subtraction commutative monoid. Then $a-b+c=a+(c-b)$."}
{"name": "real.arctan_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/arctan.lean", "formal_statement": "theorem real.arctan_zero :\n\treal.arctan 0 = 0 :=", "nl_statement_of_codex": "$\\arctan(0)=0$."}
{"name": "complex.tan_pi_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem complex.tan_pi_sub (x : \u2102) :\n\tcomplex.tan (\u2191real.pi - x) = -complex.tan x :=", "nl_statement_of_codex": "$\\tan(\\pi-x)=-\\tan(x)$."}
{"name": "hindman.exists_FS_of_large", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/hindman.lean", "formal_statement": "theorem hindman.exists_FS_of_large {M : Type*} [add_semigroup M]\n\t(U : ultrafilter M) (U_idem : U + U = U) (s\u2080 : set M) (sU : s\u2080 \u2208 U) :\n\t\u2203 (a : stream M), hindman.FS a \u2286 s\u2080 :=", "nl_statement_of_codex": "Let $M$ be an additive semigroup and let $U$ be an ultrafilter on $M$. Suppose that $U$ is idempotent and that $s_0\\in U$. Then there is a Hindman sequence $a$ such that $FS(a)\\subset s_0$."}
{"name": "finsupp.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.ext {\u03b1 M : Type*} [has_zero M] {f g : \u03b1 \u2192\u2080 M}\n\t(h : \u2200 (a : \u03b1), \u21d1f a = \u21d1g a) :\n\tf = g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to M$ be finitely supported functions. Then $f=g$ if and only if $f(a)=g(a)$ for all $a\\in\\alpha$."}
{"name": "submodule.liftq_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/quotient.lean", "formal_statement": "theorem submodule.liftq_apply {R M : Type*} [ring R] [add_comm_group M]\n\t[module R M] (p : submodule R M) {R\u2082 M\u2082 : Type*} [ring R\u2082] [add_comm_group M\u2082]\n\t[module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {h : p \u2264 f.ker} (x : M) :\n\t\u21d1(p.liftq f h) (submodule.quotient.mk x) = \u21d1f x :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, $p$ a submodule of $M$. Let $R_2$, $M_2$ be rings and $M_2$ an $R_2$-module. Let $\\tau_{12}:R\\to R_2$ be a ring homomorphism. Let $f:M\\to M_2$ be a linear map such that $\\ker f\\subset p$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nM & \\xrightarrow{f} & M_2 \\\\\n\\downarrow & & \\downarrow \\\\\nM/p &"}
{"name": "list.permutations_aux_append", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/permutation.lean", "formal_statement": "theorem list.permutations_aux_append {\u03b1 : Type*} (is is' ts : list \u03b1) :\n\t(is ++ ts).permutations_aux is' = list.map (\u03bb (_x : list \u03b1), _x ++ ts) (is.permutations_aux is') ++ ts.permutations_aux (is.reverse ++ is') :=", "nl_statement_of_codex": "Let $A$ be a set and let $a_1,\\ldots,a_n,b_1,\\ldots,b_m$ be elements of $A$. Then the permutations of $a_1,\\ldots,a_n,b_1,\\ldots,b_m$ are the permutations of $a_1,\\ldots,a_n$ with $b_1,\\ldots,b_m$ appended to the end, together with the permutations of $b_1,\\ldots,b_m$ with $a_1,\\ldots,a_n$ appended to the end."}
{"name": "galois_connection.u_cinfi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/conditionally_complete_lattice.lean", "formal_statement": "theorem galois_connection.u_cinfi {\u03b1 \u03b2 : Type*} {\u03b9 : Sort u_4}\n\t[conditionally_complete_lattice \u03b1] [conditionally_complete_lattice \u03b2]\n\t[nonempty \u03b9] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : galois_connection l u) {f : \u03b9 \u2192 \u03b2}\n\t(hf : bdd_below (set.range f)) :\n\tu (\u2a05 (i : \u03b9), f i) = \u2a05 (i : \u03b9), u (f i) :=", "nl_statement_of_codex": "Let $l:A\\to B$ and $u:B\\to A$ be a Galois connection between two complete lattices $A$ and $B$. Let $f:I\\to B$ be a function with bounded range. Then $u(\\inf_{i\\in I}f(i))=\\inf_{i\\in I}u(f(i))$."}
{"name": "concave_on.ge_on_segment'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/function.lean", "formal_statement": "theorem concave_on.ge_on_segment' {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [linear_ordered_add_comm_monoid \u03b2] [has_smul \ud835\udd5c E]\n\t[module \ud835\udd5c \u03b2] [ordered_smul \ud835\udd5c \u03b2] {s : set E} {f : E \u2192 \u03b2} (hf : concave_on \ud835\udd5c s f)\n\t{x y : E} (hx : x \u2208 s) (hy : y \u2208 s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 \u2264 b)\n\t(hab : a + b = 1) :\n\tlinear_order.min (f x) (f y) \u2264 f (a \u2022 x + b \u2022 y) :=", "nl_statement_of_codex": "Let $E$ be a set, let $f:E\\to\\mathbb{R}$ be a concave function, and let $x,y\\in E$. Then $f(x)\\leq f(y)$ if and only if $f(tx+(1-t)y)\\leq f(y)$ for all $t\\in[0,1]$."}
{"name": "structure_groupoid.local_invariant_prop.lift_prop_within_at_inter'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/local_invariant_properties.lean", "formal_statement": "theorem structure_groupoid.local_invariant_prop.lift_prop_within_at_inter'\n\t{H M : Type*} [topological_space H] [topological_space M] [charted_space H M]\n\t{H' M' : Type*} [topological_space H'] [topological_space M']\n\t[charted_space H' M'] {G : structure_groupoid H} {G' : structure_groupoid H'}\n\t{P : (H \u2192 H') \u2192 set H \u2192 H \u2192 Prop} {g : M \u2192 M'} {s t : set M} {x : M}\n\t(hG : G.local_invariant_prop G' P) (ht : t \u2208 nhds_within x s) :\n\tcharted_space.lift_prop_within_at P g (s \u2229 t) x \u2194 charted_space.lift_prop_within_at P g s x :=", "nl_statement_of_codex": "Let $H,M$ be topological spaces and let $G$ be a structure groupoid on $H$. Let $P$ be a property of $G$-bundles. Let $g:M\\to M'$ be a map. Let $s,t$ be subsets of $M$ and let $x\\in M$. Suppose that $P$ is a local invariant of $G$. Then $g$ lifts $P$ on $s\\cap t$ at $x$ if and only if $g$ lifts $P$ on $s$ at $x$."}
{"name": "add_subgroup.index_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/index.lean", "formal_statement": "theorem add_subgroup.index_map {G : Type*} [add_group G] (H : add_subgroup G)\n\t{G' : Type*} [add_group G'] (f : G \u2192+ G') :\n\t(add_subgroup.map f H).index = (H \u2294 f.ker).index * f.range.index :=", "nl_statement_of_codex": "Let $G$ and $G'$ be additive groups and let $f:G\\to G'$ be a group homomorphism. Then the index of the image of $H$ under $f$ is the product of the index of $H$ and the index of the image of $f$."}
{"name": "pfun.core_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pfun.lean", "formal_statement": "theorem pfun.core_mono {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192. \u03b2) {s t : set \u03b2} (h : s \u2286 t) :\n\tf.core s \u2286 f.core t :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a partial function. If $S\\subset T$ then $f^{-1}(S)\\subset f^{-1}(T)$."}
{"name": "list.insert_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.insert_nil {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) :\n\thas_insert.insert a list.nil = [a] :=", "nl_statement_of_codex": "The list obtained by inserting an element $a$ into the empty list is the list containing only $a$."}
{"name": "except_t.run_pure", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/control/lawful.lean", "formal_statement": "theorem except_t.run_pure {\u03b1 \u03b5 : Type u} {m : Type u \u2192 Type v} [monad m] (a : \u03b1) :\n\t(has_pure.pure a).run = has_pure.pure (except.ok a) :=", "nl_statement_of_codex": "The run function applied to a pure value is the pure value."}
{"name": "alternating_map.dom_coprod.summand_eq_zero_of_smul_invariant", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/alternating.lean", "formal_statement": "theorem alternating_map.dom_coprod.summand_eq_zero_of_smul_invariant\n\t{\u03b9a \u03b9b : Type*0} [decidable_eq \u03b9a] [decidable_eq \u03b9b] [fintype \u03b9a] [fintype \u03b9b]\n\t{R' M\u1d62 N\u2081 N\u2082 : Type*4} [comm_semiring R'] [add_comm_group N\u2081] [module R' N\u2081]\n\t[add_comm_group N\u2082] [module R' N\u2082] [add_comm_monoid M\u1d62] [module R' M\u1d62]\n\t(a : alternating_map R' M\u1d62 N\u2081 \u03b9a) (b : alternating_map R' M\u1d62 N\u2082 \u03b9b)\n\t(\u03c3 : equiv.perm.mod_sum_congr \u03b9a \u03b9b) {v : \u03b9a \u2295 \u03b9b \u2192 M\u1d62} {i j : \u03b9a \u2295 \u03b9b}\n\t(hv : v i = v j) (hij : i \u2260 j) :\n\tequiv.swap i j \u2022 \u03c3 = \u03c3 \u2192 \u21d1(alternating_map.dom_coprod.summand a b \u03c3) v = 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $M_i$ be an $R$-module, let $N_1$ and $N_2$ be $R$-modules, and let $a$ and $b$ be alternating maps from $M_i$ to $N_1$ and $N_2$, respectively. Let $\\sigma$ be a permutation of the disjoint union of the domains of $a$ and $b$. Let $v$ be a function from the disjoint union of the domains of $a$ and $b$ to $M_i$. If $v(i)=v(j)$ for some $i$"}
{"name": "le_of_sub_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem le_of_sub_nonneg {\u03b1 : Type u} [add_group \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b : \u03b1} :\n\t0 \u2264 a - b \u2192 b \u2264 a :=", "nl_statement_of_codex": "Let $a, b$ be elements of an ordered additive group. If $a-b\\geq 0$, then $b\\leq a$."}
{"name": "has_deriv_at_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_at_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] (x : \ud835\udd5c) ( : F) :\n\thas_deriv_at (\u03bb (x : \ud835\udd5c), c) 0 x :=", "nl_statement_of_codex": "The constant function $f(x)=c$ has derivative $0$ at $x$."}
{"name": "is_closed.compl_mem_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem is_closed.compl_mem_nhds {\u03b1 : Type u} [topological_space \u03b1] {a : \u03b1}\n\t{s : set \u03b1} (hs : is_closed s) (ha : a \u2209 s) :\n\ts\u1d9c \u2208 nhds a :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a closed subset of $X$. Then $X\\setminus A$ is a neighborhood of each point of $X\\setminus A$."}
{"name": "nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg {\u03b1 : Type u}\n\t[linear_ordered_semiring \u03b1] {a b : \u03b1} (hab : 0 \u2264 a * b) :\n\t0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0 :=", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring. If $ab\\geq 0$, then either $a\\geq 0$ and $b\\geq 0$ or $a\\leq 0$ and $b\\leq 0$."}
{"name": "freiman_hom.inv_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/freiman.lean", "formal_statement": "theorem freiman_hom.inv_comp {\u03b1 \u03b2 G : Type*} [comm_monoid \u03b1] [comm_monoid \u03b2]\n\t[comm_group G] {A : set \u03b1} {B : set \u03b2} {n : \u2115} (f : B \u2192*[n] G) (g : A \u2192*[n] \u03b2)\n\t{hf hf' : set.maps_to \u21d1g A B} :\n\tf\u207b\u00b9.comp g hf = (f.comp g hf')\u207b\u00b9 :=", "nl_statement_of_codex": "Let $A, B$ be sets, $G$ a group, and $f:B\\to G$, $g:A\\to B$ be maps. Then $f^{-1}\\circ g$ is the inverse of $f\\circ g$."}
{"name": "dense_bInter_of_open", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/baire.lean", "formal_statement": "theorem dense_bInter_of_open {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [baire_space \u03b1]\n\t{S : set \u03b2} {f : \u03b2 \u2192 set \u03b1} (ho : \u2200 (s : \u03b2), s \u2208 S \u2192 is_open (f s))\n\t(hS : S.countable) (hd : \u2200 (s : \u03b2), s \u2208 S \u2192 dense (f s)) :\n\tdense (\u22c2 (s : \u03b2) (H : s \u2208 S), f s) :=", "nl_statement_of_codex": "Let $X$ be a Baire space and let $S$ be a countable set. Let $f:S\\to\\mathcal{P}(X)$ be a function such that $f(s)$ is open and dense for each $s\\in S$. Then $\\bigcap_{s\\in S}f(s)$ is dense in $X$."}
{"name": "set.sup_eq_union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.sup_eq_union {\u03b1 : Type*} :\n\thas_sup.sup = has_union.union :=", "nl_statement_of_codex": "The supremum of a set is equal to the union of the set."}
{"name": "nat.primrec'.idv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/primrec.lean", "formal_statement": "theorem nat.primrec'.idv {n : \u2115} :\n\tnat.primrec'.vec id :=", "nl_statement_of_codex": "The identity function is a vector of primitive recursion."}
{"name": "first_order.language.bounded_formula.encoding_encode", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/encoding.lean", "formal_statement": "theorem first_order.language.bounded_formula.encoding_encode\n\t{L : first_order.language} {\u03b1 : Type u'} (\u03c6 : \u03a3 (n : \u2115), L.bounded_formula \u03b1 n) :\n\tfirst_order.language.bounded_formula.encoding.encode \u03c6 = first_order.language.bounded_formula.list_encode \u03c6.snd :=", "nl_statement_of_codex": "The encoding of a bounded formula is the same as the encoding of its list of free variables."}
{"name": "monoid_with_zero_hom.map_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem monoid_with_zero_hom.map_one {M N : Type*} [mul_zero_one_class M]\n\t[mul_zero_one_class N] (f : M \u2192*\u2080 N) :\n\t\u21d1f 1 = 1 :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with zero and let $f:M\\to N$ be a monoid homomorphism. Then $f(1)=1$."}
{"name": "list.ae_strongly_measurable_sum'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem list.ae_strongly_measurable_sum' {\u03b1 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {M : Type*} [add_monoid M] [topological_space M]\n\t[has_continuous_add M] (l : list (\u03b1 \u2192 M))\n\t(hl : \u2200 (f : \u03b1 \u2192 M), f \u2208 l \u2192 measure_theory.ae_strongly_measurable f \u03bc) :\n\tmeasure_theory.ae_strongly_measurable l.sum \u03bc :=", "nl_statement_of_codex": "Let $M$ be a topological space with continuous addition. Let $l$ be a list of functions $f:\\alpha\\to M$ such that each $f$ is strongly measurable. Then the sum of the functions in $l$ is strongly measurable."}
{"name": "real.of_cauchy_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/basic.lean", "formal_statement": "theorem real.of_cauchy_add (a b : cau_seq.completion.Cauchy) :\n\t\u27e8a + b\u27e9 = \u27e8a\u27e9 + \u27e8b\u27e9 :=", "nl_statement_of_codex": "The sum of two Cauchy sequences is a Cauchy sequence."}
{"name": "continuous_map.nullhomotopic.comp_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homotopy/contractible.lean", "formal_statement": "theorem continuous_map.nullhomotopic.comp_left {X Y Z : Type*}\n\t[topological_space X] [topological_space Y] [topological_space Z] {f : C(Y, Z)}\n\t(hf : f.nullhomotopic) (g : C(X, Y)) :\n\t(f.comp g).nullhomotopic :=", "nl_statement_of_codex": "Let $X, Y, Z$ be topological spaces and let $f:Y\\to Z$ and $g:X\\to Y$. If $f$ is nullhomotopic, then $f\\circ g$ is nullhomotopic."}
{"name": "summable_op", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean", "formal_statement": "theorem summable_op {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} :\n\tsummable (\u03bb (a : \u03b2), mul_opposite.op (f a)) \u2194 summable f :=", "nl_statement_of_codex": "Let $f:B\\to A$ be a function. Then $f$ is summable if and only if $-f$ is summable."}
{"name": "linear_map.coe_comp_alternating_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/alternating.lean", "formal_statement": "theorem linear_map.coe_comp_alternating_map {R : Type*} [semiring R] {M : Type*}\n\t[add_comm_monoid M] [module R M] {N : Type*} [add_comm_monoid N] [module R N]\n\t{\u03b9 : Type*} [decidable_eq \u03b9] {N\u2082 : Type*} [add_comm_monoid N\u2082] [module R N\u2082]\n\t(g : N \u2192\u2097[R] N\u2082) (f : alternating_map R M N \u03b9) :\n\t\u21d1(\u21d1(g.comp_alternating_map) f) = \u21d1g \u2218 \u21d1f :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $N$ be $R$-modules, $N_2$ be an $R$-module, and $g:N\\to N_2$ be a linear map. Let $f:M^{\\otimes \\iota}\\to N$ be an alternating map. Then the linear map $g\\circ f:M^{\\otimes \\iota}\\to N_2$ is equal to the linear map $g\\otimes f:M^{\\otimes \\iota}\\to N_2\\otimes N$ composed with the linear map $N_2\\otimes N\\to N_2$."}
{"name": "category_theory.bicategory.pentagon_inv_hom_hom_hom_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/basic.lean", "formal_statement": "theorem category_theory.bicategory.pentagon_inv_hom_hom_hom_inv {B : Type u}\n\t[category_theory.bicategory B] {a b c d e : B} (f : a \u27f6 b) (g : b \u27f6 c)\n\t(h : c \u27f6 d) (i : d \u27f6 e) :\n\t(category_theory.bicategory.associator (f \u226b g) h i).inv \u226b category_theory.bicategory.whisker_right (category_theory.bicategory.associator f g h).hom i \u226b (category_theory.bicategory.associator f (g \u226b h) i).hom = (category_theory.bicategory.associator f g (h \u226b i)).hom \u226b category_theory.bicategory.whisker_left f (category_theory.bicategory.associator g h i).inv :=", "nl_statement_of_codex": "The pentagon diagram commutes."}
{"name": "measure_theory.integral_eq_zero_of_add_right_eq_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/integration.lean", "formal_statement": "theorem measure_theory.integral_eq_zero_of_add_right_eq_neg {G E : Type*}\n\t[measurable_space G] [normed_group E] [normed_space \u211d E] [complete_space E]\n\t{\u03bc : measure_theory.measure G} {f : G \u2192 E} {g : G} [add_group G]\n\t[has_measurable_add G] [\u03bc.is_add_right_invariant]\n\t(hf' : \u2200 (x : G), f (x + g) = -f x) :\n\t\u222b (x : G), f x \u2202\u03bc = 0 :=", "nl_statement_of_codex": "Let $G$ be a measurable space, $E$ a normed group, and $\u03bc$ a measure on $G$. Let $f:G\\to E$ be a function such that $f(x+g)=-f(x)$ for all $x\\in G$. Then $\\int_G f(x)d\\mu=0$."}
{"name": "infinite.order_of_eq_zero_of_forall_mem_zpowers", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/specific_groups/cyclic.lean", "formal_statement": "theorem infinite.order_of_eq_zero_of_forall_mem_zpowers {\u03b1 : Type u} [group \u03b1]\n\t[infinite \u03b1] {g : \u03b1} (h : \u2200 (x : \u03b1), x \u2208 subgroup.zpowers g) :\n\torder_of g = 0 :=", "nl_statement_of_codex": "Let $G$ be an infinite group and let $g\\in G$. If $g$ is a power of every element of $G$, then $g$ has infinite order."}
{"name": "dfinsupp.erase_add_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.erase_add_hom_apply {\u03b9 : Type u} (\u03b2 : \u03b9 \u2192 Type v)\n\t[dec : decidable_eq \u03b9] [\u03a0 (i : \u03b9), add_zero_class (\u03b2 i)] (i : \u03b9)\n\t(\u1fb0 : \u03a0\u2080 (i : \u03b9), (\u03bb (i : \u03b9), \u03b2 i) i) :\n\t\u21d1(dfinsupp.erase_add_hom \u03b2 i) \u1fb0 = dfinsupp.erase i \u1fb0 :=", "nl_statement_of_codex": "Let $A$ be a set and let $\\beta:A\\to R$ be a function. Then the function $\\beta$ induces a function $\\beta':A\\setminus\\{a\\}\\to R$ by $\\beta'(x)=\\beta(x)$ for $x\\neq a$ and $\\beta'(a)=0$. Then $\\beta'$ is a function from $A\\setminus\\{a\\}$ to $R$."}
{"name": "mul_lt_mul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem mul_lt_mul_right {\u03b1 : Type u} [linear_ordered_semiring \u03b1] {a b c : \u03b1}\n\t(h : 0 < c) :\n\ta * c < b * c \u2194 a < b :=", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring. Then $a<b$ if and only if $ac<bc$ for all $a,b,c\\in R$ with $c>0$."}
{"name": "list.init_append_of_ne_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.init_append_of_ne_nil {\u03b1 : Type*} {l : list \u03b1} (l' : list \u03b1)\n\t(h : l \u2260 list.nil) :\n\t(l' ++ l).init = l' ++ l.init :=", "nl_statement_of_codex": "Let $l$ and $l'$ be lists. If $l$ is not empty, then the initial segment of $l'++l$ is $l'++$ the initial segment of $l$."}
{"name": "function.cantor_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/function/basic.lean", "formal_statement": "theorem function.cantor_injective {\u03b1 : Type*} (f : set \u03b1 \u2192 \u03b1) :\n\t\u00acfunction.injective f :=", "nl_statement_of_codex": "The Cantor function is not injective."}
{"name": "parser.and_then_eq_bind", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/buffer/parser/basic.lean", "formal_statement": "theorem parser.and_then_eq_bind {\u03b1 \u03b2 : Type} {m : Type \u2192 Type} [monad m]\n\t(a : m \u03b1) (b : m \u03b2) :\n\ta >> b = a >>= \u03bb (_x : \u03b1), b :=", "nl_statement_of_codex": "Let $m$ be a monad. Then $a\\bind b=a\\bind (\\lambda x.b)$."}
{"name": "category_theory.transfer_nat_trans_self_symm_of_iso", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/mates.lean", "formal_statement": "theorem category_theory.transfer_nat_trans_self_symm_of_iso {C : Type u\u2081}\n\t{D : Type u\u2082} [category_theory.category C] [category_theory.category D]\n\t{L\u2081 L\u2082 : C \u2964 D} {R\u2081 R\u2082 : D \u2964 C} (adj\u2081 : L\u2081 \u22a3 R\u2081) (adj\u2082 : L\u2082 \u22a3 R\u2082) (f : R\u2081 \u27f6 R\u2082)\n\t[category_theory.is_iso (\u21d1((category_theory.transfer_nat_trans_self adj\u2081 adj\u2082).symm) f)] :\n\tcategory_theory.is_iso f :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $L_1, L_2:C\\to D$ and $R_1, R_2:D\\to C$ be adjoint functors. If $f:R_1\\to R_2$ is an isomorphism, then $f$ is an isomorphism."}
{"name": "asymptotics.is_o.of_const_mul_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_o.of_const_mul_right {\u03b1 E R : Type*2} [has_norm E]\n\t[semi_normed_ring R] {f : \u03b1 \u2192 E} {l : filter \u03b1} {g : \u03b1 \u2192 R} { : R}\n\t(h : f =o[l] \u03bb (x : \u03b1), c * g x) :\n\tf =o[l] g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E$ be functions and let $c\\in R$. If $f=o(g)$, then $f=o(g)$."}
{"name": "witt_vector.ghost_component_frobenius", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/frobenius.lean", "formal_statement": "theorem witt_vector.ghost_component_frobenius {p : \u2115} {R : Type*}\n\t[hp : fact (nat.prime p)] [comm_ring R] (n : \u2115) (x : witt_vector p R) :\n\t\u21d1(witt_vector.ghost_component n) (\u21d1witt_vector.frobenius x) = \u21d1(witt_vector.ghost_component (n + 1)) x :=", "nl_statement_of_codex": "Let $p$ be a prime number, let $R$ be a commutative ring, and let $n$ be a natural number. Then the ghost component of the Frobenius of a Witt vector $x$ is the ghost component of $x$ shifted by one."}
{"name": "polynomial.scale_roots_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/scale_roots.lean", "formal_statement": "theorem polynomial.scale_roots_ne_zero {R : Type*} [comm_ring R]\n\t{p : polynomial R} (hp : p \u2260 0) (s : R) :\n\tp.scale_roots s \u2260 0 :=", "nl_statement_of_codex": "Let $p$ be a polynomial over a commutative ring $R$ and let $s\\in R$. If $p$ is not the zero polynomial, then $p(sx)$ is not the zero polynomial."}
{"name": "ideal.map_prod_comm_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/prod.lean", "formal_statement": "theorem ideal.map_prod_comm_prod {R : Type u} {S : Type v} [ring R] [ring S]\n\t(I : ideal R) (J : ideal S) :\n\tideal.map \u2191ring_equiv.prod_comm (I.prod J) = J.prod I :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $I$ and $J$ be ideals of $R$ and $S$, respectively. Then the ideal of $S\\times R$ generated by $I\\times J$ is equal to the ideal of $R\\times S$ generated by $J\\times I$."}
{"name": "submodule.span_sup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/span.lean", "formal_statement": "theorem submodule.span_sup {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] (p : submodule R M) {s : set M} :\n\tsubmodule.span R s \u2294 p = submodule.span R (s \u222a \u2191p) :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $p$ a submodule of $M$. Then $\\langle s\\rangle\\oplus p=\\langle s\\cup p\\rangle$."}
{"name": "is_clopen.diff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/subset_properties.lean", "formal_statement": "theorem is_clopen.diff {\u03b1 : Type u} [topological_space \u03b1] {s t : set \u03b1}\n\t(hs : is_clopen s) (ht : is_clopen t) :\n\tis_clopen (s \\ t) :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A, B\\subset X$. If $A$ and $B$ are clopen, then $A\\setminus B$ is clopen."}
{"name": "le_tsub_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem le_tsub_mul {R : Type*} [comm_semiring R] [preorder R] [has_sub R]\n\t[has_ordered_sub R] [covariant_class R R has_mul.mul has_le.le] {a b c : R} :\n\ta * c - b * c \u2264 (a - b) * c :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring with a preorder. Then $a\\cdot c-b\\cdot c\\leq (a-b)\\cdot c$."}
{"name": "finset.sup_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.sup_of_mem {\u03b1 \u03b2 : Type*} [semilattice_sup \u03b1] {s : finset \u03b2}\n\t(f : \u03b2 \u2192 \u03b1) {b : \u03b2} (h : b \u2208 s) :\n\t\u2203 (a : \u03b1), s.sup (coe \u2218 f) = \u2191a :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\alpha$ be a function. Then there exists $a\\in \\alpha$ such that $s.sup(f)=a$."}
{"name": "category_theory.monoidal_of_chosen_finite_products.symmetry", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/of_chosen_finite_products.lean", "formal_statement": "theorem category_theory.monoidal_of_chosen_finite_products.symmetry {C : Type u}\n\t[category_theory.category C]\n\t(\u212c : \u03a0 (X Y : C), category_theory.limits.limit_cone (category_theory.limits.pair X Y))\n\t(X Y : C) :\n\t(category_theory.limits.binary_fan.braiding (\u212c X Y).is_limit (\u212c Y X).is_limit).hom \u226b (category_theory.limits.binary_fan.braiding (\u212c Y X).is_limit (\u212c X Y).is_limit).hom = \ud835\udfd9 (category_theory.monoidal_of_chosen_finite_products.tensor_obj \u212c X Y) :=", "nl_statement_of_codex": "Let $C$ be a category with chosen finite products. Then the braiding is an isomorphism."}
{"name": "list.Ico.filter_le_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/intervals.lean", "formal_statement": "theorem list.Ico.filter_le_of_le {n m l : \u2115} (hnl : n \u2264 l) :\n\tlist.filter (\u03bb (x : \u2115), l \u2264 x) (list.Ico n m) = list.Ico l m :=", "nl_statement_of_codex": "Let $n,m,l$ be natural numbers with $n\\leq l$. Then the list of all natural numbers $x$ with $n\\leq x\\leq m$ and $l\\leq x$ is the list of all natural numbers $x$ with $l\\leq x\\leq m$."}
{"name": "modular_group.T_inv_mul_apply_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/modular.lean", "formal_statement": "theorem modular_group.T_inv_mul_apply_one\n\t(g : matrix.special_linear_group (fin 2) \u2124) :\n\t\u2191(modular_group.T\u207b\u00b9 * g) 1 = \u2191g 1 :=", "nl_statement_of_codex": "Let $g$ be an element of the modular group. Then the first row of $T^{-1}g$ is the same as the first row of $g$."}
{"name": "homeomorph.set.univ_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homeomorph.lean", "formal_statement": "theorem homeomorph.set.univ_apply (\u03b1 : Type*) [topological_space \u03b1] :\n\t\u21d1(homeomorph.set.univ \u03b1) = coe :=", "nl_statement_of_codex": "The homeomorphism from $\\alpha$ to $\\alpha$ that is the identity on $\\alpha$ is the identity on $\\alpha$."}
{"name": "pi.zero_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pi/algebra.lean", "formal_statement": "theorem pi.zero_apply {I : Type u} {f : I \u2192 Type v\u2081} (i : I)\n\t[\u03a0 (i : I), has_zero (f i)] :\n\t0 i = 0 :=", "nl_statement_of_codex": "Let $f:I\\to R$ be a family of sets with zero element. Then $0_i=0$ for all $i\\in I$."}
{"name": "finset.sym2_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/sym.lean", "formal_statement": "theorem finset.sym2_singleton {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) :\n\t{a}.sym2 = {sym2.diag a} :=", "nl_statement_of_codex": "The symmetric square of a singleton set is the set of all pairs of the form $(a,a)$."}
{"name": "coe_tt", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/bool/lemmas.lean", "formal_statement": "theorem coe_tt :\n\t\u2191bool.tt = true :=", "nl_statement_of_codex": "The coercion from the type of booleans to the type of propositions is given by $b\\mapsto b=true$."}
{"name": "tensor_product.smul.aux_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/tensor_product.lean", "formal_statement": "theorem tensor_product.smul.aux_of {R : Type*} [comm_semiring R] {M N : Type*}\n\t[add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] {R' : Type*}\n\t[has_smul R' M] (r : R') (m : M) (n : N) :\n\t\u21d1(tensor_product.smul.aux r) (free_add_monoid.of (m, n)) = (r \u2022 m) \u2297\u209c[R] n :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ and $N$ be $R$-modules, and $R'$ be a ring. Then the tensor product of $R'$-modules $M$ and $N$ is an $R'$-module."}
{"name": "algebraic_geometry.Spec.SheafedSpace_map_c_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/Spec.lean", "formal_statement": "theorem algebraic_geometry.Spec.SheafedSpace_map_c_app {R S : CommRing}\n\t(f : R \u27f6 S)\n\t(U : (topological_space.opens \u21a5((algebraic_geometry.Spec.SheafedSpace_obj R).to_PresheafedSpace.carrier))\u1d52\u1d56) :\n\t(algebraic_geometry.Spec.SheafedSpace_map f).c.app U = algebraic_geometry.structure_sheaf.comap f (opposite.unop U) ((topological_space.opens.map (algebraic_geometry.Spec.Top_map f)).obj (opposite.unop U)) _ :=", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings and let $f:R\\to S$ be a ring homomorphism. Then the map $f^\\sharp:Spec(S)\\to Spec(R)$ is given by $f^\\sharp(U)=f^{-1}(U)$."}
{"name": "tactic.abel.term_add_term", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/abel.lean", "formal_statement": "theorem tactic.abel.term_add_term {\u03b1 : Type*} [add_comm_monoid \u03b1] (n\u2081 : \u2115)\n\t(x a\u2081 : \u03b1) (n\u2082 : \u2115) (a\u2082 : \u03b1) (n' : \u2115) (a' : \u03b1) (h\u2081 : n\u2081 + n\u2082 = n')\n\t(h\u2082 : a\u2081 + a\u2082 = a') :\n\ttactic.abel.term n\u2081 x a\u2081 + tactic.abel.term n\u2082 x a\u2082 = tactic.abel.term n' x a' :=", "nl_statement_of_codex": "Let $x$ be an element of an additive commutative monoid $A$. Then for any $n_1, n_2, n'\\in\\mathbb{N}$ and $a_1, a_2, a'\\in A$ such that $n_1+n_2=n'$ and $a_1+a_2=a'$, we have $x^{n_1}a_1+x^{n_2}a_2=x^{n'}a'$."}
{"name": "category_theory.limits.wide_pushout.hom_eq_desc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/wide_pullbacks.lean", "formal_statement": "theorem category_theory.limits.wide_pushout.hom_eq_desc {J : Type w}\n\t{C : Type u} [category_theory.category C] {B : C} {objs : J \u2192 C}\n\t(arrows : \u03a0 (j : J), B \u27f6 objs j)\n\t[category_theory.limits.has_wide_pushout B objs arrows] {X : C}\n\t(g : category_theory.limits.wide_pushout B (\u03bb (j : J), objs j) arrows \u27f6 X) :\n\tg = category_theory.limits.wide_pushout.desc (category_theory.limits.wide_pushout.head arrows \u226b g) (\u03bb (j : J), category_theory.limits.wide_pushout.\u03b9 arrows j \u226b g) _ :=", "nl_statement_of_codex": "Let $J$ be a type, $C$ a category, $B$ an object of $C$, and $objs:J\\to C$ a functor. Let $arrows:J\\to C$ be a functor such that $arrows(j):B\\to objs(j)$ for each $j\\in J$. Let $X$ be an object of $C$. Let $g:B\\to X$ be a morphism. Then $g$ is equal to the morphism $g:B\\to X$ such that $g\\circ arrows(j)=g$ for each $j\\in J$."}
{"name": "topological_fiber_bundle_core.local_triv_at_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/fiber_bundle.lean", "formal_statement": "theorem topological_fiber_bundle_core.local_triv_at_def {\u03b9 B F : Type*}\n\t[topological_space B] [topological_space F]\n\t(Z : topological_fiber_bundle_core \u03b9 B F) (b : B) :\n\tZ.local_triv (Z.index_at b) = Z.local_triv_at b :=", "nl_statement_of_codex": "Let $Z$ be a topological fiber bundle over $B$ with fiber $F$. Then the local trivialization of $Z$ at $b\\in B$ is the same as the local trivialization of $Z$ at the index of $b$."}
{"name": "unitization.inl_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/unitization.lean", "formal_statement": "theorem unitization.inl_neg {R : Type*} (A : Type*) [has_neg R] [add_group A]\n\t(r : R) :\n\tunitization.inl (-r) = -unitization.inl r :=", "nl_statement_of_codex": "Let $R$ be a ring with a negation map. Then the negation map on $R$ extends to a negation map on the unitization of $R$."}
{"name": "mul_equiv.to_fun_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/equiv.lean", "formal_statement": "theorem mul_equiv.to_fun_eq_coe {M N : Type*} [has_mul M] [has_mul N]\n\t{f : M \u2243* N} :\n\tf.to_fun = \u21d1f :=", "nl_statement_of_codex": "Let $M$ and $N$ be two types with multiplication. Let $f:M\\to N$ be a multiplicative equivalence. Then $f$ is equal to the coe of $f$."}
{"name": "category_theory.monad.forget_obj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/algebra.lean", "formal_statement": "theorem category_theory.monad.forget_obj {C : Type u\u2081}\n\t[category_theory.category C] (T : category_theory.monad C) (A : T.algebra) :\n\tT.forget.obj A = A.A :=", "nl_statement_of_codex": "Let $T$ be a monad on a category $C$. Let $A$ be a $T$-algebra. Then the underlying object of $A$ is $A$."}
{"name": "measurable.const_vadd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem measurable.const_vadd {M \u03b2 \u03b1 : Type*} [measurable_space M]\n\t[measurable_space \u03b2] [has_vadd M \u03b2] {m : measurable_space \u03b1} {g : \u03b1 \u2192 \u03b2}\n\t[has_measurable_vadd M \u03b2] (hg : measurable g) ( : M) :\n\tmeasurable (c +\u1d65 g) :=", "nl_statement_of_codex": "Let $M$ be a measurable space and let $\u03b2$ be a measurable space with a vector space structure. Let $\u03b1$ be a measurable space and let $g:\u03b1\\to \u03b2$ be measurable. Then the function $c+g:\u03b1\\to \u03b2$ is measurable."}
{"name": "finset.prod_erase_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.prod_erase_mul {\u03b2 : Type u} {\u03b1 : Type v} [comm_monoid \u03b2]\n\t[decidable_eq \u03b1] (s : finset \u03b1) (f : \u03b1 \u2192 \u03b2) {a : \u03b1} (h : a \u2208 s) :\n\t(s.erase a).prod (\u03bb (x : \u03b1), f x) * f a = s.prod (\u03bb (x : \u03b1), f x) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\beta$ be a function. Then $\\prod_{x\\in s\\setminus\\{a\\}}f(x)\\cdot f(a)=\\prod_{x\\in s}f(x)$."}
{"name": "derivation.ext_of_adjoin_eq_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/derivation.lean", "formal_statement": "theorem derivation.ext_of_adjoin_eq_top {R : Type*} [comm_semiring R]\n\t{A : Type*} [comm_semiring A] [algebra R A] {M : Type*} [add_comm_monoid M]\n\t[module A M] [module R M] {D1 D2 : derivation R A M} (s : set A)\n\t(hs : algebra.adjoin R s = \u22a4) (h : set.eq_on \u21d1D1 \u21d1D2 s) :\n\tD1 = D2 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a commutative semiring, $M$ an $A$-module, and $D_1, D_2$ derivations from $R$ to $M$. If $D_1$ and $D_2$ agree on a set $S$ such that $R[S]$ is the whole of $A$, then $D_1=D_2$."}
{"name": "and_congr_left'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem and_congr_left' {a b c : Prop} (h : a \u2194 b) :\n\ta \u2227 c \u2194 b \u2227 c :=", "nl_statement_of_codex": "If $a$ and $b$ are equivalent, then $a\\land c$ and $b\\land c$ are equivalent."}
{"name": "strict_mono_int_of_lt_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem strict_mono_int_of_lt_succ {\u03b1 : Type u} [preorder \u03b1] {f : \u2124 \u2192 \u03b1}\n\t(hf : \u2200 (n : \u2124), f n < f (n + 1)) :\n\tstrict_mono f :=", "nl_statement_of_codex": "Let $f:\\mathbb{Z}\\to\\alpha$ be a function. If $f(n)<f(n+1)$ for all $n\\in\\mathbb{Z}$, then $f$ is strictly monotone."}
{"name": "subring.prod_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/basic.lean", "formal_statement": "theorem subring.prod_top {R : Type u} {S : Type v} [ring R] [ring S]\n\t(s : subring R) :\n\ts.prod \u22a4 = subring.comap (ring_hom.fst R S) s :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $s$ be a subring of $R$. Then $s\\times S$ is a subring of $R\\times S$."}
{"name": "list.zip_map_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/zip.lean", "formal_statement": "theorem list.zip_map_right {\u03b1 : Type u} {\u03b2 \u03b3 : Type*} (f : \u03b2 \u2192 \u03b3) (l\u2081 : list \u03b1)\n\t(l\u2082 : list \u03b2) :\n\tl\u2081.zip (list.map f l\u2082) = list.map (prod.map id f) (l\u2081.zip l\u2082) :=", "nl_statement_of_codex": "Let $f:B\\to C$ be a function. Then the list $(a_1,f(b_1)),\\ldots,(a_n,f(b_n))$ is equal to the list $(a_1,b_1),\\ldots,(a_n,b_n)$ with the function $f$ applied to the second component."}
{"name": "category_theory.limits.types.limit_ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/types.lean", "formal_statement": "theorem category_theory.limits.types.limit_ext_iff {J : Type v}\n\t[category_theory.small_category J] (F : J \u2964 Type (max v u))\n\t(x y : category_theory.limits.limit F) :\n\tx = y \u2194 \u2200 (j : J), category_theory.limits.limit.\u03c0 F j x = category_theory.limits.limit.\u03c0 F j y :=", "nl_statement_of_codex": "Let $F:J\\to\\mathbf{Type}$ be a functor. Then two limits of $F$ are equal if and only if their projections to each $F(j)$ are equal."}
{"name": "lie_submodule.mem_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/submodule.lean", "formal_statement": "theorem lie_submodule.mem_map {R : Type u} {L : Type v} {M : Type w}\n\t{M' : Type w\u2081} [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M]\n\t[module R M] [lie_ring_module L M] [lie_module R L M] [add_comm_group M']\n\t[module R M'] [lie_ring_module L M'] [lie_module R L M'] {f : M \u2192\u2097\u2045R,L\u2046 M'}\n\t{N : lie_submodule R L M} (m' : M') :\n\tm' \u2208 lie_submodule.map f N \u2194 \u2203 (m : M), m \u2208 N \u2227 \u21d1f m = m' :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ and $M'$ $R$-modules, and $f:M\\to M'$ a Lie $R$-module homomorphism. Let $N$ be a Lie submodule of $M$. Then $m'\\in f(N)$ if and only if there exists $m\\in N$ such that $f(m)=m'$."}
{"name": "category_theory.triangulated.triangle.mk_obj\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/triangulated/basic.lean", "formal_statement": "theorem category_theory.triangulated.triangle.mk_obj\u2082 (C : Type u)\n\t[category_theory.category C] [category_theory.has_shift C \u2124] {X Y Z : C}\n\t(f : X \u27f6 Y) (g : Y \u27f6 Z) (h : Z \u27f6 (category_theory.shift_functor C 1).obj X) :\n\t(category_theory.triangulated.triangle.mk C f g h).obj\u2082 = Y :=", "nl_statement_of_codex": "Let $C$ be a triangulated category. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$, $g:Y\\to Z$, and $h:Z\\to X[1]$ be morphisms in $C$. Then the second object of the triangle $(X, Y, Z, f, g, h)$ is $Y$."}
{"name": "measure_theory.measure.haar.chaar_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/haar.lean", "formal_statement": "theorem measure_theory.measure.haar.chaar_self {G : Type*} [group G]\n\t[topological_space G] [topological_group G]\n\t(K\u2080 : topological_space.positive_compacts G) :\n\tmeasure_theory.measure.haar.chaar K\u2080 K\u2080.to_compacts = 1 :=", "nl_statement_of_codex": "The Haar measure of a compact group is 1."}
{"name": "subfield.sum_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/subfield.lean", "formal_statement": "theorem subfield.sum_mem {K : Type u} [field K] (s : subfield K) {\u03b9 : Type*}\n\t{t : finset \u03b9} {f : \u03b9 \u2192 K} (h : \u2200 (c : \u03b9), c \u2208 t \u2192 f c \u2208 s) :\n\tt.sum (\u03bb (i : \u03b9), f i) \u2208 s :=", "nl_statement_of_codex": "Let $K$ be a field and let $s$ be a subfield of $K$. Let $t$ be a finite set and let $f:t\\to K$. If $f(c)\\in s$ for all $c\\in t$, then $\\sum_{c\\in t}f(c)\\in s$."}
{"name": "add_submonoid.multiples_eq_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/membership.lean", "formal_statement": "theorem add_submonoid.multiples_eq_closure {A : Type*} [add_monoid A] (x : A) :\n\tadd_submonoid.multiples x = add_submonoid.closure {x} :=", "nl_statement_of_codex": "The set of multiples of $x$ is equal to the closure of $\\{x\\}$."}
{"name": "measurable_equiv.coe_to_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_equiv.coe_to_equiv {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[measurable_space \u03b2] (e : \u03b1 \u2243\u1d50 \u03b2) :\n\t\u21d1(e.to_equiv) = \u21d1e :=", "nl_statement_of_codex": "Let $e:\u03b1\\to \u03b2$ be a measurable equivalence. Then $e$ is a measurable function."}
{"name": "category_theory.limits.is_colimit_cone_unop_desc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/opposites.lean", "formal_statement": "theorem category_theory.limits.is_colimit_cone_unop_desc {C : Type u\u2081}\n\t[category_theory.category C] {J : Type u\u2082} [category_theory.category J]\n\t(F : J \u2964 C) { : category_theory.limits.cone F.op}\n\t(hc : category_theory.limits.is_limit c) (s : category_theory.limits.cocone F) :\n\t(category_theory.limits.is_colimit_cone_unop F hc).desc s = (hc.lift s.op).unop :=", "nl_statement_of_codex": "Let $C$ and $J$ be categories and let $F:J\\to C$ be a functor. Let $c$ be a cone over $F$ and let $s$ be a cocone over $F$. Then the description of the colimit of $F$ is the unop of the lift of $s$."}
{"name": "first_order.language.substructure.gc_map_comap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/substructures.lean", "formal_statement": "theorem first_order.language.substructure.gc_map_comap\n\t{L : first_order.language} {M : Type w} {N : Type*} [L.Structure M]\n\t[L.Structure N] (f : L.hom M N) :\n\tgalois_connection (first_order.language.substructure.map f) (first_order.language.substructure.comap f) :=", "nl_statement_of_codex": "Let $L$ be a first-order language, let $M$ and $N$ be $L$-structures, and let $f:M\\to N$ be an $L$-homomorphism. Then the map $f$ induces a Galois connection between the set of $L$-substructures of $M$ and the set of $L$-substructures of $N$."}
{"name": "measure_theory.lintegral_eq_zero_of_is_mul_left_invariant", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/integration.lean", "formal_statement": "theorem measure_theory.lintegral_eq_zero_of_is_mul_left_invariant {G : Type*}\n\t[measurable_space G] {\u03bc : measure_theory.measure G} [topological_space G]\n\t[group G] [topological_group G] [borel_space G] [\u03bc.is_mul_left_invariant]\n\t[\u03bc.regular] (h\u03bc : \u03bc \u2260 0) {f : G \u2192 ennreal} (hf : continuous f) :\n\t\u222b\u207b (x : G), f x \u2202\u03bc = 0 \u2194 f = 0 :=", "nl_statement_of_codex": "Let $G$ be a topological group with a left-invariant measure $\\mu$. Let $f:G\\to\\mathbb{R}$ be a continuous function. Then $\\int_G f(x)d\\mu(x)=0$ if and only if $f=0$."}
{"name": "asymptotics.is_O_with.abs_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_with.abs_right {\u03b1 E : Type*} [has_norm E] { : \u211d}\n\t{f : \u03b1 \u2192 E} {l : filter \u03b1} {u : \u03b1 \u2192 \u211d} :\n\tasymptotics.is_O_with c l f u \u2192 asymptotics.is_O_with c l f (\u03bb (x : \u03b1), |u x|) :=", "nl_statement_of_codex": "Let $f:\\alpha\\to E$ be a function and let $u:\\alpha\\to\\mathbb{R}$ be a function. If $f$ is $O(u)$, then $f$ is $O(|u|)$."}
{"name": "polynomial.map_nat_degree_eq_nat_degree", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/erase_lead.lean", "formal_statement": "theorem polynomial.map_nat_degree_eq_nat_degree {R : Type*} [semiring R]\n\t{S F : Type*} [semiring S]\n\t[add_monoid_hom_class F (polynomial R) (polynomial S)] {\u03c6 : F}\n\t(p : polynomial R)\n\t(\u03c6_mon_nat : \u2200 (n : \u2115) (c : R), c \u2260 0 \u2192 (\u21d1\u03c6 (\u21d1(polynomial.monomial n) c)).nat_degree = n) :\n\t(\u21d1\u03c6 p).nat_degree = p.nat_degree :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings, let $F$ be a type, and let $\\phi:F\\to\\mathrm{Hom}_{\\mathbb{Z}}(\\mathbb{N},R)$ be a function. Suppose that $\\phi$ is a monoid homomorphism from $F$ to the monoid of monic polynomials over $R$ with coefficients in $S$. Then $\\phi(p)$ has the same degree as $p$."}
{"name": "card_eq_pow_finrank", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/finite/basic.lean", "formal_statement": "theorem card_eq_pow_finrank {K V : Type*} [fintype K] [division_ring K]\n\t[add_comm_group V] [module K V] [fintype V] :\n\tfintype.card V = fintype.card K ^ finite_dimensional.finrank K V :=", "nl_statement_of_codex": "Let $K$ be a field and $V$ a $K$-vector space. Then $\\dim_K V=\\dim_K K^{\\dim_K V}$."}
{"name": "ideal.quotient.mk\u2090_ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.quotient.mk\u2090_ker (R\u2081 : Type*) {A : Type*} [comm_semiring R\u2081]\n\t[comm_ring A] [algebra R\u2081 A] (I : ideal A) :\n\tring_hom.ker \u2191(ideal.quotient.mk\u2090 R\u2081 I) = I :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $A$ be an $R$-algebra, and let $I$ be an ideal of $A$. Then the kernel of the canonical map $A\\to A/I$ is $I$."}
{"name": "primrec.sum_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/primrec.lean", "formal_statement": "theorem primrec.sum_inr {\u03b1 \u03b2 : Type*} [primcodable \u03b1] [primcodable \u03b2] :\n\tprimrec sum.inr :=", "nl_statement_of_codex": "The function $sum.inr:\\alpha+\\beta\\to\\beta$ is primitive recursive."}
{"name": "tensor_product.dual_distrib_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/dual.lean", "formal_statement": "theorem tensor_product.dual_distrib_apply {R M N : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N]\n\t(f : module.dual R M) (g : module.dual R N) (m : M) (n : N) :\n\t\u21d1(\u21d1(tensor_product.dual_distrib R M N) (f \u2297\u209c[R] g)) (m \u2297\u209c[R] n) = \u21d1f m * \u21d1g n :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ and $N$ be $R$-modules. Then the map $f\\otimes g\\mapsto f\\cdot g$ is a linear map from $(M\\otimes N)^*$ to $M^*\\otimes N^*$."}
{"name": "diff_cont_on_cl_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/diff_on_int_cont.lean", "formal_statement": "theorem diff_cont_on_cl_const {\ud835\udd5c E F : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_group E] [normed_group F] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c F]\n\t{s : set E} { : F} :\n\tdiff_cont_on_cl \ud835\udd5c (\u03bb (x : E), c) s :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Then the constant function $f:E\\to F$ defined by $f(x)=c$ is differentiable on $E$."}
{"name": "nat.modeq_nine_digits_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/digits.lean", "formal_statement": "theorem nat.modeq_nine_digits_sum (n : \u2115) :\n\tn \u2261 (10.digits n).sum [MOD 9] :=", "nl_statement_of_codex": "The sum of the digits of a natural number $n$ is congruent to $n$ modulo $9$."}
{"name": "set.diff_subset_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.diff_subset_iff {\u03b1 : Type u} {s t u : set \u03b1} :\n\ts \\ t \u2286 u \u2194 s \u2286 t \u222a u :=", "nl_statement_of_codex": "$A\\setminus B\\subseteq C$ if and only if $A\\subseteq B\\cup C$."}
{"name": "monoid.closure_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/submonoid.lean", "formal_statement": "theorem monoid.closure_subset {M : Type*} [monoid M] {s t : set M}\n\t(ht : is_submonoid t) (h : s \u2286 t) :\n\tmonoid.closure s \u2286 t :=", "nl_statement_of_codex": "Let $M$ be a monoid and let $s, t\\subset M$ such that $t$ is a submonoid of $M$. If $s\\subset t$, then the closure of $s$ is contained in $t$."}
{"name": "add_commute.add_order_of_add_dvd_mul_add_order_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/order_of_element.lean", "formal_statement": "theorem add_commute.add_order_of_add_dvd_mul_add_order_of {G : Type u}\n\t[add_monoid G] {x y : G} (h : add_commute x y) :\n\tadd_order_of (x + y) \u2223 add_order_of x * add_order_of y :=", "nl_statement_of_codex": "Let $G$ be an additive monoid and let $x,y\\in G$. If $x+y=y+x$, then the order of $x+y$ divides the product of the orders of $x$ and $y$."}
{"name": "monoid.exponent_min'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/exponent.lean", "formal_statement": "theorem monoid.exponent_min' {G : Type u} [monoid G] (n : \u2115) (hpos : 0 < n)\n\t(hG : \u2200 (g : G), g ^ n = 1) :\n\tmonoid.exponent G \u2264 n :=", "nl_statement_of_codex": "Let $G$ be a monoid. If $n$ is a positive integer such that $g^n=1$ for all $g\\in G$, then the exponent of $G$ is at most $n$."}
{"name": "decidable.not_iff_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem decidable.not_iff_comm {a b : Prop} [decidable a] [decidable b] :\n\t\u00aca \u2194 b \u2194 (\u00acb \u2194 a) :=", "nl_statement_of_codex": "If $a$ and $b$ are decidable propositions, then $\\neg a$ if and only if $b$ if and only if $\\neg b$ if and only if $a$."}
{"name": "lie_module.mem_pre_weight_space", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/weights.lean", "formal_statement": "theorem lie_module.mem_pre_weight_space {R : Type u} {L : Type v} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] (M : Type w) [add_comm_group M] [module R M]\n\t[lie_ring_module L M] [lie_module R L M] (\u03c7 : L \u2192 R) (m : M) :\n\tm \u2208 lie_module.pre_weight_space M \u03c7 \u2194 \u2200 (x : L), \u2203 (k : \u2115), \u21d1((\u21d1(lie_module.to_endomorphism R L M) x - \u03c7 x \u2022 1) ^ k) m = 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a Lie $R$-module. Then $m\\in M$ is in the pre-weight space of $M$ with respect to $\\chi$ if and only if for all $x\\in L$ there is a natural number $k$ such that $(\\rho(x)-\\chi(x)1)^k(m)=0$."}
{"name": "is_glb_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem is_glb_Ico {\u03b1 : Type u} [preorder \u03b1] {a b : \u03b1} (h : a < b) :\n\tis_glb (set.Ico a b) a :=", "nl_statement_of_codex": "Let $a,b\\in\\alpha$ with $a<b$. Then $a$ is the greatest lower bound of the interval $[a,b]$."}
{"name": "complex_shape.next_eq_some", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/complex_shape.lean", "formal_statement": "theorem complex_shape.next_eq_some {\u03b9 : Type*} ( : complex_shape \u03b9) {i j : \u03b9}\n\t(h : c.rel i j) :\n\tc.next i = option.some \u27e8j, h\u27e9 :=", "nl_statement_of_codex": "Let $c$ be a complex shape. If $c$ has a relation $i\\sim j$, then $c$ has a next element $j$ after $i$."}
{"name": "cardinal.ord_card_unbounded", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/ordinal.lean", "formal_statement": "theorem cardinal.ord_card_unbounded :\n\tset.unbounded has_lt.lt {b : ordinal | b.card.ord = b} :=", "nl_statement_of_codex": "The set of ordinals $\\alpha$ such that $\\alpha$ is the cardinality of $\\alpha$ is unbounded."}
{"name": "finsum_mem_eq_sum_of_inter_support_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/finprod.lean", "formal_statement": "theorem finsum_mem_eq_sum_of_inter_support_eq {\u03b1 M : Type*} [add_comm_monoid M]\n\t(f : \u03b1 \u2192 M) {s : set \u03b1} {t : finset \u03b1}\n\t(h : s \u2229 function.support f = \u2191t \u2229 function.support f) :\n\tfinsum (\u03bb (i : \u03b1), finsum (\u03bb (H : i \u2208 s), f i)) = t.sum (\u03bb (i : \u03b1), f i) :=", "nl_statement_of_codex": "Let $f:A\\to M$ be a function with finite support. Let $s$ and $t$ be subsets of $A$ such that $s\\cap supp(f)=t\\cap supp(f)$. Then $\\sum_{i\\in s}f(i)=\\sum_{i\\in t}f(i)$."}
{"name": "ordinal.one_CNF", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/cantor_normal_form.lean", "formal_statement": "theorem ordinal.one_CNF {o : ordinal} (o0 : o \u2260 0) :\n\tordinal.CNF 1 o = [(0, o)] :=", "nl_statement_of_codex": "The Cantor normal form of $1$ is $[(0,o)]$."}
{"name": "multiset.inf_cons", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/lattice.lean", "formal_statement": "theorem multiset.inf_cons {\u03b1 : Type*} [semilattice_inf \u03b1] [order_top \u03b1] (a : \u03b1)\n\t(s : multiset \u03b1) :\n\t(a ::\u2098 s).inf = a \u2293 s.inf :=", "nl_statement_of_codex": "Let $a$ be an element of a semilattice with top. Then the infimum of the multiset $a::s$ is $a\\wedge\\inf s$."}
{"name": "submodule.le_one_to_add_submonoid", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/operations.lean", "formal_statement": "theorem submodule.le_one_to_add_submonoid {R : Type u} [comm_semiring R]\n\t{A : Type v} [semiring A] [algebra R A] :\n\t1 \u2264 1.to_add_submonoid :=", "nl_statement_of_codex": "The multiplicative identity of an algebra is contained in the multiplicative submonoid generated by the multiplicative identity."}
{"name": "simple_graph.is_clique.subsingleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/clique.lean", "formal_statement": "theorem simple_graph.is_clique.subsingleton {\u03b1 : Type*} {s : set \u03b1} :\n\t\u22a5.is_clique s \u2192 s.subsingleton :=", "nl_statement_of_codex": "If $s$ is a clique in the empty graph, then $s$ is a singleton."}
{"name": "uniform_embedding_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/uniform_embedding.lean", "formal_statement": "theorem uniform_embedding_inr {\u03b1 \u03b2 : Type*} [uniform_space \u03b1] [uniform_space \u03b2] :\n\tuniform_embedding sum.inr :=", "nl_statement_of_codex": "The map $x\\mapsto (0,x)$ is a uniform embedding from $\\beta$ to $\\alpha+\\beta$."}
{"name": "measurable.edist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/borel_space.lean", "formal_statement": "theorem measurable.edist {\u03b1 \u03b2 : Type*} [pseudo_emetric_space \u03b1]\n\t[measurable_space \u03b1] [opens_measurable_space \u03b1] [measurable_space \u03b2]\n\t[topological_space.second_countable_topology \u03b1] {f g : \u03b2 \u2192 \u03b1}\n\t(hf : measurable f) (hg : measurable g) :\n\tmeasurable (\u03bb (b : \u03b2), has_edist.edist (f b) (g b)) :=", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be measurable functions between measurable spaces $X$ and $Y$. Then the function $b\\mapsto d(f(b),g(b))$ is measurable."}
{"name": "local_homeomorph.tendsto_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/local_homeomorph.lean", "formal_statement": "theorem local_homeomorph.tendsto_symm {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) {x : \u03b1}\n\t(hx : x \u2208 e.to_local_equiv.source) :\n\tfilter.tendsto \u21d1(e.symm) (nhds (\u21d1e x)) (nhds x) :=", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Then the inverse map $e^{-1}:Y\\to X$ is continuous at $e(x)$ for each $x\\in X$."}
{"name": "measure_theory.strongly_measurable_stopped_value_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/stopping.lean", "formal_statement": "theorem measure_theory.strongly_measurable_stopped_value_of_le {\u03b1 \u03b2 \u03b9 : Type*}\n\t{m : measurable_space \u03b1} [linear_order \u03b9] [measurable_space \u03b9]\n\t[topological_space \u03b9] [order_topology \u03b9]\n\t[topological_space.second_countable_topology \u03b9] [borel_space \u03b9]\n\t[topological_space \u03b2] {u : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {\u03c4 : \u03b1 \u2192 \u03b9}\n\t{f : measure_theory.filtration \u03b9 m} (h : measure_theory.prog_measurable f u)\n\t(h\u03c4 : measure_theory.is_stopping_time f \u03c4) {n : \u03b9} (h\u03c4_le : \u2200 (x : \u03b1), \u03c4 x \u2264 n) :\n\tmeasure_theory.strongly_measurable (measure_theory.stopped_value u \u03c4) :=", "nl_statement_of_codex": "Let $X$ be a measurable space, let $T$ be a topological space, let $u:T\\times X\\to Y$ be a measurable function, and let $\\tau:X\\to T$ be a stopping time. Then the function $x\\mapsto u(\\tau(x),x)$ is measurable."}
{"name": "pos_num.nat_size_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem pos_num.nat_size_pos (n : pos_num) :\n\t0 < n.nat_size :=", "nl_statement_of_codex": "The number of positive integers less than or equal to $n$ is positive."}
{"name": "add_abs_nonneg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem add_abs_nonneg {\u03b1 : Type u} [add_group \u03b1] [linear_order \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] (a : \u03b1) :\n\t0 \u2264 a + |a| :=", "nl_statement_of_codex": "Let $a$ be an element of an ordered additive group. Then $0\\leq a+|a|$."}
{"name": "multiset.rel_flip", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/basic.lean", "formal_statement": "theorem multiset.rel_flip {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {s : multiset \u03b2}\n\t{t : multiset \u03b1} :\n\tmultiset.rel (flip r) s t \u2194 multiset.rel r t s :=", "nl_statement_of_codex": "Let $r$ be a relation on $A$ and $B$. Then $s$ is related to $t$ by $r$ if and only if $t$ is related to $s$ by the relation $r^{-1}$."}
{"name": "direct_sum.to_add_monoid.unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/basic.lean", "formal_statement": "theorem direct_sum.to_add_monoid.unique {\u03b9 : Type v} [dec_\u03b9 : decidable_eq \u03b9]\n\t{\u03b2 : \u03b9 \u2192 Type w} [\u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)] {\u03b3 : Type u\u2081}\n\t[add_comm_monoid \u03b3] (\u03c8 : direct_sum \u03b9 (\u03bb (i : \u03b9), \u03b2 i) \u2192+ \u03b3)\n\t(f : direct_sum \u03b9 (\u03bb (i : \u03b9), \u03b2 i)) :\n\t\u21d1\u03c8 f = \u21d1(direct_sum.to_add_monoid (\u03bb (i : \u03b9), \u03c8.comp (direct_sum.of \u03b2 i))) f :=", "nl_statement_of_codex": "Let $\u03b2_i$ be a family of abelian groups indexed by a set $I$. Let $\\gamma$ be an abelian group. Let $\\psi: \\bigoplus_{i\\in I} \u03b2_i\\to \\gamma$ be a homomorphism. Then $\\psi$ is uniquely determined by its restriction to each $\u03b2_i$."}
{"name": "equiv.perm.support_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/support.lean", "formal_statement": "theorem equiv.perm.support_inv {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1]\n\t(\u03c3 : equiv.perm \u03b1) :\n\t\u03c3\u207b\u00b9.support = \u03c3.support :=", "nl_statement_of_codex": "Let $\\sigma$ be a permutation of a finite set $X$. Then the support of $\\sigma^{-1}$ is equal to the support of $\\sigma$."}
{"name": "simple_graph.compl_eq_delete_edges", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/basic.lean", "formal_statement": "theorem simple_graph.compl_eq_delete_edges {V : Type u} (G : simple_graph V) :\n\tG\u1d9c = \u22a4.delete_edges G.edge_set :=", "nl_statement_of_codex": "The complement of a simple graph $G$ is the complete graph on the same vertex set with the edges of $G$ deleted."}
{"name": "smul_comm_class.of_mul_smul_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/defs.lean", "formal_statement": "theorem smul_comm_class.of_mul_smul_one {M N : Type*} [monoid N] [has_smul M N]\n\t(H : \u2200 (x : M) (y : N), y * x \u2022 1 = x \u2022 y) :\n\tsmul_comm_class M N N :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids and let $M$ have a scalar multiplication by $N$. If $y*x\\cdot 1=x\\cdot y$ for all $x\\in M$ and $y\\in N$, then $M$ is a scalar commutative monoid."}
{"name": "dite_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem dite_apply {\u03b1 : Sort u_1} {\u03c3 : \u03b1 \u2192 Sort u_4} (P : Prop) [decidable P]\n\t(f : P \u2192 \u03a0 (a : \u03b1), \u03c3 a) (g : \u00acP \u2192 \u03a0 (a : \u03b1), \u03c3 a) (a : \u03b1) :\n\tdite P f g a = dite P (\u03bb (h : P), f h a) (\u03bb (h : \u00acP), g h a) :=", "nl_statement_of_codex": "Let $P$ be a proposition and let $f,g:\\alpha\\to\\sigma$ be functions. Then $dite(P,f,g,a)=dite(P,\\lambda h:P.f(h)(a),\\lambda h:\\lnot P.g(h)(a))$."}
{"name": "cont_diff_at_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff_at_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {x : E} {n : with_top \u2115} { : F} :\n\tcont_diff_at \ud835\udd5c n (\u03bb (x : E), c) x :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Then the function $f:E\\to F$ defined by $f(x)=c$ is $n$-times continuously differentiable at $x$ for all $n\\in\\mathbb{N}\\cup\\{\\infty\\}$."}
{"name": "is_Lprojection.mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/M_structure.lean", "formal_statement": "theorem is_Lprojection.mul {X : Type*} [normed_group X] {M : Type} [ring M]\n\t[module M X] [has_faithful_smul M X] {P Q : M} (h\u2081 : is_Lprojection X P)\n\t(h\u2082 : is_Lprojection X Q) :\n\tis_Lprojection X (P * Q) :=", "nl_statement_of_codex": "Let $X$ be a normed group and let $M$ be a ring with a module structure on $X$. Let $P$ and $Q$ be two left projections on $X$. Then $PQ$ is a left projection on $X$."}
{"name": "submodule.span_insert_eq_span", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/span.lean", "formal_statement": "theorem submodule.span_insert_eq_span {R M : Type*} [semiring R]\n\t[add_comm_monoid M] [module R M] {x : M} {s : set M}\n\t(h : x \u2208 submodule.span R s) :\n\tsubmodule.span R (has_insert.insert x s) = submodule.span R s :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $s$ a subset of $M$. Then $\\langle s\\cup\\{x\\}\\rangle=\\langle s\\rangle$ if and only if $x\\in\\langle s\\rangle$."}
{"name": "function.antiperiodic.eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/periodic.lean", "formal_statement": "theorem function.antiperiodic.eq {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} { : \u03b1}\n\t[add_zero_class \u03b1] [has_neg \u03b2] (h : function.antiperiodic f c) :\n\tf c = -f 0 :=", "nl_statement_of_codex": "Let $f: \\alpha \\to \\beta$ be an antiperiodic function with period $c$. Then $f(c)=-f(0)$."}
{"name": "mul_lt_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem mul_lt_mul {\u03b1 : Type u} [ordered_semiring \u03b1] {a b c d : \u03b1} :\n\ta < c \u2192 b \u2264 d \u2192 0 < b \u2192 0 \u2264 c \u2192 a * b < c * d :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of an ordered semiring. If $a<c$ and $b\\leq d$ and $b>0$ and $c\\geq 0$, then $ab<cd$."}
{"name": "polynomial.integral_normalization_coeff_ne_nat_degree", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/integral_normalization.lean", "formal_statement": "theorem polynomial.integral_normalization_coeff_ne_nat_degree {R : Type u}\n\t[semiring R] {f : polynomial R} {i : \u2115} (hi : i \u2260 f.nat_degree) :\n\tf.integral_normalization.coeff i = f.coeff i * f.leading_coeff ^ (f.nat_degree - 1 - i) :=", "nl_statement_of_codex": "Let $f$ be a polynomial over a semiring $R$. Then the coefficient of $x^i$ in the integral normalization of $f$ is $f(i)f(n)^{n-1-i}$ if $i\\neq n$."}
{"name": "polynomial.eq_C_of_nat_degree_le_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.eq_C_of_nat_degree_le_zero {R : Type u} [semiring R]\n\t{p : polynomial R} (h : p.nat_degree \u2264 0) :\n\tp = \u21d1polynomial.C (p.coeff 0) :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. If the degree of $p$ is at most $0$, then $p$ is a constant polynomial."}
{"name": "generalized_continued_fraction.of_correctness_of_terminates", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/continued_fractions/computation/correctness_terminating.lean", "formal_statement": "theorem generalized_continued_fraction.of_correctness_of_terminates {K : Type*}\n\t[linear_ordered_field K] {v : K} [floor_ring K]\n\t(terminates : (generalized_continued_fraction.of v).terminates) :\n\t\u2203 (n : \u2115), v = (generalized_continued_fraction.of v).convergents n :=", "nl_statement_of_codex": "Let $v$ be a real number. If the generalized continued fraction of $v$ terminates, then $v$ is equal to one of its convergents."}
{"name": "algebra.power_basis.norm_gen_eq_coeff_zero_minpoly", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/norm.lean", "formal_statement": "theorem algebra.power_basis.norm_gen_eq_coeff_zero_minpoly {S : Type*}\n\t[comm_ring S] {K : Type*} [field K] [algebra K S] (pb : power_basis K S) :\n\t\u21d1(algebra.norm K) pb.gen = (-1) ^ pb.dim * (minpoly K pb.gen).coeff 0 :=", "nl_statement_of_codex": "Let $K$ be a field and $S$ a commutative ring. Let $K$ be an algebra over $S$. Let $pb$ be a power basis of $K$ over $S$. Then the norm of the generator of $pb$ is equal to the coefficient of the minimal polynomial of the generator of $pb$."}
{"name": "set.mem_Union\u2082_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.mem_Union\u2082_of_mem {\u03b1 : Type*} {\u03b9 : Sort u_4} {\u03ba : \u03b9 \u2192 Sort u_7}\n\t{s : \u03a0 (i : \u03b9), \u03ba i \u2192 set \u03b1} {a : \u03b1} {i : \u03b9} (j : \u03ba i) (ha : a \u2208 s i j) :\n\ta \u2208 \u22c3 (i : \u03b9) (j : \u03ba i), s i j :=", "nl_statement_of_codex": "Let $s$ be a family of sets indexed by a family of sets $\\kappa_i$ indexed by $i\\in I$. Then $a\\in s_{i,j}$ implies $a\\in \\bigcup_{i\\in I, j\\in \\kappa_i} s_{i,j}$."}
{"name": "simple_graph.walk.reverse_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/connectivity.lean", "formal_statement": "theorem simple_graph.walk.reverse_singleton {V : Type u} {G : simple_graph V}\n\t{u v : V} (h : G.adj u v) :\n\t(simple_graph.walk.cons h simple_graph.walk.nil).reverse = simple_graph.walk.cons _ simple_graph.walk.nil :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $u,v$ be vertices of $G$. If $u$ and $v$ are adjacent, then the reverse of the walk $u\\to v$ is the walk $v\\to u$."}
{"name": "with_zero.inv_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/with_one.lean", "formal_statement": "theorem with_zero.inv_zero {\u03b1 : Type u} [has_inv \u03b1] :\n\t0\u207b\u00b9 = 0 :=", "nl_statement_of_codex": "The inverse of $0$ is $0$."}
{"name": "set.compl_Inter\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.compl_Inter\u2082 {\u03b1 : Type*} {\u03b9 : Sort u_4} {\u03ba : \u03b9 \u2192 Sort u_7}\n\t(s : \u03a0 (i : \u03b9), \u03ba i \u2192 set \u03b1) :\n\t(\u22c2 (i : \u03b9) (j : \u03ba i), s i j)\u1d9c = \u22c3 (i : \u03b9) (j : \u03ba i), (s i j)\u1d9c :=", "nl_statement_of_codex": "Let $s$ be a family of sets indexed by $i\\in I$ and $j\\in J_i$. Then the complement of the intersection of the $s_{i,j}$ is the union of the complements of the $s_{i,j}$."}
{"name": "finset.sup'_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.sup'_apply {\u03b1 \u03b2 C : \u03b2 \u2192 Type*} [\u03a0 (b : \u03b2), semilattice_sup (C b)]\n\t{s : finset \u03b1} (H : s.nonempty) (f : \u03b1 \u2192 \u03a0 (b : \u03b2), C b) (b : \u03b2) :\n\ts.sup' H f b = s.sup' H (\u03bb (a : \u03b1), f a b) :=", "nl_statement_of_codex": "Let $s$ be a nonempty finite set, let $f:s\\to \\Pi_{b\\in B} C(b)$ be a function, and let $b\\in B$. Then $\\sup_{a\\in s} f(a)(b) = \\sup_{a\\in s} f(a,b)$."}
{"name": "has_deriv_within_at.sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_within_at.sub {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f g : \ud835\udd5c \u2192 F} {f' g' : F}\n\t{x : \ud835\udd5c} {s : set \ud835\udd5c} (hf : has_deriv_within_at f f' s x)\n\t(hg : has_deriv_within_at g g' s x) :\n\thas_deriv_within_at (\u03bb (x : \ud835\udd5c), f x - g x) (f' - g') s x :=", "nl_statement_of_codex": "Let $f,g:U\\to V$ be differentiable at $x\\in U$. Then $f-g:U\\to V$ is differentiable at $x$."}
{"name": "continuous_fst", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem continuous_fst {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] :\n\tcontinuous prod.fst :=", "nl_statement_of_codex": "The projection map $\\pi_1:X\\times Y\\to X$ is continuous."}
{"name": "subalgebra.subsingleton_of_subsingleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem subalgebra.subsingleton_of_subsingleton {R : Type u} {A : Type v}\n\t[comm_semiring R] [semiring A] [algebra R A] [subsingleton A] :\n\tsubsingleton (subalgebra R A) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $A$ be a semiring. Suppose that $A$ is a $R$-algebra and that $A$ is a singleton. Then the set of $R$-subalgebras of $A$ is a singleton."}
{"name": "category_theory.subobject.factors_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/factor_thru.lean", "formal_statement": "theorem category_theory.subobject.factors_add {C : Type u\u2081}\n\t[category_theory.category C] [category_theory.preadditive C] {X Y : C}\n\t{P : category_theory.subobject Y} (f g : X \u27f6 Y) (wf : P.factors f)\n\t(wg : P.factors g) :\n\tP.factors (f + g) :=", "nl_statement_of_codex": "Let $C$ be a preadditive category. Let $X, Y$ be objects of $C$ and let $P$ be a subobject of $Y$. Let $f, g:X\\to Y$ be morphisms such that $f$ factors through $P$ and $g$ factors through $P$. Then $f+g$ factors through $P$."}
{"name": "norm_num.sle_bit1_bit1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/norm_num.lean", "formal_statement": "theorem norm_num.sle_bit1_bit1 {\u03b1 : Type*} [linear_ordered_semiring \u03b1] (a b : \u03b1)\n\t(h : a + 1 \u2264 b) :\n\tbit1 a + 1 \u2264 bit1 b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a linear ordered semiring $R$. If $a+1\\leq b$, then $2a+1\\leq 2b$."}
{"name": "lp.sum_rpow_le_of_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lp_space.lean", "formal_statement": "theorem lp.sum_rpow_le_of_tendsto {\u03b1 E : \u03b1 \u2192 Type*} {p : ennreal}\n\t[\u03a0 (i : \u03b1), normed_group (E i)] {\u03b9 : Type*} {l : filter \u03b9} [l.ne_bot]\n\t[fact (1 \u2264 p)] (hp : p \u2260 \u22a4) {C : \u211d} {F : \u03b9 \u2192 \u21a5(lp E p)}\n\t(hCF : \u2200\u1da0 (k : \u03b9) in l, \u2225F k\u2225 \u2264 C) {f : \u03a0 (a : \u03b1), E a}\n\t(hf : filter.tendsto (id (\u03bb (i : \u03b9), \u21d1(F i))) l (nhds f)) (s : finset \u03b1) :\n\ts.sum (\u03bb (i : \u03b1), \u2225f i\u2225 ^ p.to_real) \u2264 C ^ p.to_real :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $p$ be an extended nonnegative real number. Let $l$ be a filter on a set $I$ and let $F:I\\to l^p(E)$ be a function such that $\\|F(i)\\|\\leq C$ for all $i\\in I$. Let $f:A\\to E$ be a function such that $F(i)\\to f$ in $l^p(E)$. Then $\\sum_{a\\in A}\\|f(a)\\|^p\\leq C^p$."}
{"name": "function.bij_on_fixed_pts_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/fixed_points/basic.lean", "formal_statement": "theorem function.bij_on_fixed_pts_comp {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2)\n\t(g : \u03b2 \u2192 \u03b1) :\n\tset.bij_on g (function.fixed_points (f \u2218 g)) (function.fixed_points (g \u2218 f)) :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to A$ be functions. Then $g$ is a bijection from the set of fixed points of $f\\circ g$ to the set of fixed points of $g\\circ f$."}
{"name": "mem_lower_bounds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem mem_lower_bounds {\u03b1 : Type u} [preorder \u03b1] {s : set \u03b1} {a : \u03b1} :\n\ta \u2208 lower_bounds s \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 a \u2264 x :=", "nl_statement_of_codex": "Let $s$ be a set of elements of a preorder $P$. Then $a\\in P$ is a lower bound of $s$ if and only if $a\\leq x$ for all $x\\in s$."}
{"name": "star_div'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/star/basic.lean", "formal_statement": "theorem star_div' {R : Type u} [field R] [star_ring R] (x y : R) :\n\thas_star.star (x / y) = has_star.star x / has_star.star y :=", "nl_statement_of_codex": "Let $R$ be a field with a star operation. Then the star operation is multiplicative on $R$."}
{"name": "free_abelian_group.map_of_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/free_abelian_group.lean", "formal_statement": "theorem free_abelian_group.map_of_apply {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}\n\t(a : \u03b1) :\n\t\u21d1(free_abelian_group.map f) (free_abelian_group.of a) = free_abelian_group.of (f a) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then the induced map $f_*:\\mathbb{Z}[A]\\to\\mathbb{Z}[B]$ satisfies $f_*([a])=[f(a)]$."}
{"name": "hyperreal.is_st_of_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.is_st_of_tendsto {f : \u2115 \u2192 \u211d} {r : \u211d}\n\t(hf : filter.tendsto f filter.at_top (nhds r)) :\n\t(hyperreal.of_seq f).is_st r :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\mathbb{R}$ be a sequence. If $f$ tends to $r$, then the hyperreal number $[f]$ is standard and equal to $r$."}
{"name": "submonoid.prod_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem submonoid.prod_top {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t(s : submonoid M) :\n\ts.prod \u22a4 = submonoid.comap (monoid_hom.fst M N) s :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids. Let $s$ be a submonoid of $M$. Then the product of $s$ and the trivial submonoid of $N$ is the submonoid of $M\\times N$ consisting of all pairs $(m,n)$ such that $m\\in s$."}
{"name": "measure_theory.has_sum_integral_measure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/bochner.lean", "formal_statement": "theorem measure_theory.has_sum_integral_measure {\u03b1 E : Type*} [normed_group E]\n\t[normed_space \u211d E] [complete_space E] {\u03b9 : Type*} {m : measurable_space \u03b1}\n\t{f : \u03b1 \u2192 E} {\u03bc : \u03b9 \u2192 measure_theory.measure \u03b1}\n\t(hf : measure_theory.integrable f (measure_theory.measure.sum \u03bc)) :\n\thas_sum (\u03bb (i : \u03b9), \u222b (a : \u03b1), f a \u2202\u03bc i) (\u222b (a : \u03b1), f a \u2202measure_theory.measure.sum \u03bc) :=", "nl_statement_of_codex": "Let $E$ be a normed group and a complete space. Let $f:X\\to E$ be a measurable function. Let $\\mu$ be a measure on $X$. Then $\\int f\\,d\\mu$ is the sum of the integrals $\\int f\\,d\\mu_i$."}
{"name": "add_le_cancellable.le_add_tsub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem add_le_cancellable.le_add_tsub {\u03b1 : Type*} [preorder \u03b1]\n\t[add_comm_semigroup \u03b1] [has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1}\n\t(hb : add_le_cancellable b) :\n\ta \u2264 a + b - b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a preordered additive commutative semigroup with a subtraction operation. If $b$ is cancellable, then $a\\leq a+b-b$."}
{"name": "inf_top_hom.coe_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/lattice.lean", "formal_statement": "theorem inf_top_hom.coe_top {\u03b1 \u03b2 : Type*} [has_inf \u03b1] [has_top \u03b1]\n\t[semilattice_inf \u03b2] [order_top \u03b2] :\n\t\u21d1\u22a4 = \u22a4 :=", "nl_statement_of_codex": "The function $\\inf_\\top:\\mathbb{R}\\to\\mathbb{R}$ is the identity function."}
{"name": "antitone.map_min", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/min_max.lean", "formal_statement": "theorem antitone.map_min {\u03b1 : Type u} {\u03b2 : Type v} [linear_order \u03b1]\n\t[linear_order \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1} (hf : antitone f) :\n\tf (linear_order.min a b) = linear_order.max (f a) (f b) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an antitone function between two linear orders $A$ and $B$. Then $f(\\min(a,b))=\\max(f(a),f(b))$."}
{"name": "equiv.prod_assoc_symm_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/set.lean", "formal_statement": "theorem equiv.prod_assoc_symm_image {\u03b1 \u03b2 \u03b3 : Type*} {s : set \u03b1} {t : set \u03b2}\n\t{u : set \u03b3} :\n\t\u21d1((equiv.prod_assoc \u03b1 \u03b2 \u03b3).symm) '' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u :=", "nl_statement_of_codex": "Let $s, t, u$ be sets. Then $(s\\times t)\\times u$ is equal to the image of $s\\times (t\\times u)$ under the map $(\\alpha, (\\beta, \\gamma))\\mapsto (\\alpha, \\beta, \\gamma)$."}
{"name": "subsemigroup.mem_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subsemigroup/operations.lean", "formal_statement": "theorem subsemigroup.mem_prod {M N : Type*} [has_mul M] [has_mul N]\n\t{s : subsemigroup M} {t : subsemigroup N} {p : M \u00d7 N} :\n\tp \u2208 s.prod t \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t :=", "nl_statement_of_codex": "Let $M$ and $N$ be sets with a multiplication. Let $s$ be a subsemigroup of $M$ and $t$ be a subsemigroup of $N$. Then $(x,y)\\in s\\times t$ if and only if $x\\in s$ and $y\\in t$."}
{"name": "nat.triangle_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/choose/basic.lean", "formal_statement": "theorem nat.triangle_succ (n : \u2115) :\n\t(n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n :=", "nl_statement_of_codex": "$(n+1)^2/2=n^2/2+n$."}
{"name": "nat.gcd_pos_of_pos_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.gcd_pos_of_pos_left {m : \u2115} (n : \u2115) (mpos : 0 < m) :\n\t0 < m.gcd n :=", "nl_statement_of_codex": "If $m$ is a positive integer, then $\\gcd(m,n)$ is a positive integer."}
{"name": "linear_ordered_field.smul_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/pointwise.lean", "formal_statement": "theorem linear_ordered_field.smul_Ico {K : Type*} [linear_ordered_field K]\n\t{a b r : K} (hr : 0 < r) :\n\tr \u2022 set.Ico a b = set.Ico (r \u2022 a) (r \u2022 b) :=", "nl_statement_of_codex": "Let $K$ be a linear ordered field and let $a,b,r\\in K$ with $r>0$. Then $r\\cdot [a,b]=[ra,rb]$."}
{"name": "has_fderiv_at.arsinh", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/arsinh.lean", "formal_statement": "theorem has_fderiv_at.arsinh {E : Type*} [normed_group E] [normed_space \u211d E]\n\t{f : E \u2192 \u211d} {a : E} {f' : E \u2192L[\u211d] \u211d} (hf : has_fderiv_at f f' a) :\n\thas_fderiv_at (\u03bb (x : E), real.arsinh (f x)) ((real.sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') a :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ and let $f:E\\to\\mathbb{R}$. If $f$ is differentiable at $a$, then $\\operatorname{arsinh}(f)$ is differentiable at $a$ and its derivative at $a$ is $\\frac{f'(a)}{\\sqrt{1+f(a)^2}}$."}
{"name": "commute.inv_of_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/invertible.lean", "formal_statement": "theorem commute.inv_of_right {\u03b1 : Type u} [monoid \u03b1] {a b : \u03b1} [invertible b]\n\t(h : commute a b) :\n\tcommute a (\u215f b) :=", "nl_statement_of_codex": "Let $a,b$ be elements of a monoid $M$ such that $b$ is invertible. If $a$ and $b$ commute, then $a$ and $b^{-1}$ commute."}
{"name": "ordinal.lsub_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.lsub_pos {\u03b9 : Type*} [h : nonempty \u03b9] (f : \u03b9 \u2192 ordinal) :\n\t0 < ordinal.lsub f :=", "nl_statement_of_codex": "Let $f:\\iota\\to\\mathrm{Ord}$ be a function. Then $\\mathrm{lsub}(f)>0$."}
{"name": "int.neg_mod_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.neg_mod_two (i : \u2124) :\n\t-i % 2 = i % 2 :=", "nl_statement_of_codex": "For any integer $i$, $-i\\equiv i\\pmod{2}$."}
{"name": "weak_dual.character_space.map_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/module/character_space.lean", "formal_statement": "theorem weak_dual.character_space.map_one {\ud835\udd5c A : Type*} [comm_ring \ud835\udd5c]\n\t[no_zero_divisors \ud835\udd5c] [topological_space \ud835\udd5c] [has_continuous_add \ud835\udd5c]\n\t[has_continuous_const_smul \ud835\udd5c \ud835\udd5c] [topological_space A] [semiring A]\n\t[algebra \ud835\udd5c A] (\u03c6 : \u21a5(weak_dual.character_space \ud835\udd5c A)) :\n\t\u21d1\u03c6 1 = 1 :=", "nl_statement_of_codex": "Let $A$ be an algebra over a commutative ring $R$. Then the map $\\phi:R\\to A$ defined by $\\phi(r)=r\\cdot 1$ is a character."}
{"name": "category_theory.non_preadditive_abelian.neg_sub'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/non_preadditive.lean", "formal_statement": "theorem category_theory.non_preadditive_abelian.neg_sub' {C : Type u}\n\t[category_theory.category C] [category_theory.non_preadditive_abelian C]\n\t{X Y : C} (a b : X \u27f6 Y) :\n\t-(a - b) = -a + b :=", "nl_statement_of_codex": "Let $C$ be a category with a non-preadditive abelian structure. Then for morphisms $a,b:X\\to Y$ we have $-(a-b)=-a+b$."}
{"name": "nat.min_fac_eq_two_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/prime.lean", "formal_statement": "theorem nat.min_fac_eq_two_iff (n : \u2115) :\n\tn.min_fac = 2 \u2194 2 \u2223 n :=", "nl_statement_of_codex": "The smallest factor of $n$ is $2$ if and only if $2$ divides $n$."}
{"name": "submodule.smul_coe_torsion_by", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/torsion.lean", "formal_statement": "theorem submodule.smul_coe_torsion_by {R M : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [module R M] (a : R) (x : \u21a5(submodule.torsion_by R M a)) :\n\ta \u2022 \u2191x = 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, and $a\\in R$. Then $a\\cdot x=0$ for all $x\\in M$ such that $a\\cdot x=0$."}
{"name": "concept.top_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/concept.lean", "formal_statement": "theorem concept.top_snd {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n\t\u22a4.to_prod.snd = intent_closure r set.univ :=", "nl_statement_of_codex": "The second component of the top concept is the closure of the intent of the relation $r$."}
{"name": "function.mem_fixed_points_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/fixed_points/basic.lean", "formal_statement": "theorem function.mem_fixed_points_iff {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} :\n\tx \u2208 function.fixed_points f \u2194 f x = x :=", "nl_statement_of_codex": "$x$ is a fixed point of $f$ if and only if $f(x)=x$."}
{"name": "symm_of", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/algebra/classes.lean", "formal_statement": "theorem symm_of {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [is_symm \u03b1 r] {a b : \u03b1} :\n\tr a b \u2192 r b a :=", "nl_statement_of_codex": "If $r$ is a symmetric relation on $A$, then $r(a,b)$ implies $r(b,a)$."}
{"name": "Group.surjective_of_epi_auxs.h_apply_from_coset_nin_range", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Group/epi_mono.lean", "formal_statement": "theorem Group.surjective_of_epi_auxs.h_apply_from_coset_nin_range {A B : Group}\n\t(f : A \u27f6 B) (x : \u21a5B) (hx : x \u2208 monoid_hom.range f) (b : \u21a5B)\n\t(hb : b \u2209 monoid_hom.range f) :\n\t\u21d1(\u21d1(Group.surjective_of_epi_auxs.H f) x) (Group.surjective_of_epi_auxs.X_with_infinity.from_coset \u27e8left_coset b (monoid_hom.range f).carrier, _\u27e9) = Group.surjective_of_epi_auxs.X_with_infinity.from_coset \u27e8left_coset (x * b) (monoid_hom.range f).carrier, _\u27e9 :=", "nl_statement_of_codex": "Let $A$ and $B$ be groups and let $f:A\\to B$ be a homomorphism. Let $x\\in B$ and $b\\in B$ such that $x\\in f(A)$ and $b\\notin f(A)$. Then $f^{-1}(x)$ is a coset of $f^{-1}(B)$ in $A$ and $f^{-1}(x*b)$ is a coset of $f^{-1}(B)$ in $A$."}
{"name": "seminorm.smul_ball_preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/seminorm.lean", "formal_statement": "theorem seminorm.smul_ball_preimage {\ud835\udd5c E : Type*} [normed_field \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] (p : seminorm \ud835\udd5c E) (y : E) (r : \u211d) (a : \ud835\udd5c)\n\t(ha : a \u2260 0) :\n\thas_smul.smul a \u207b\u00b9' p.ball y r = p.ball (a\u207b\u00b9 \u2022 y) (r / \u2225a\u2225) :=", "nl_statement_of_codex": "Let $E$ be a normed vector space over a normed field $K$. Let $p$ be a seminorm on $E$. Let $y\\in E$ and $r\\in\\mathbb{R}$. Let $a\\in K$ be nonzero. Then $a^{-1}p^{-1}(B(y,r))=p^{-1}(B(a^{-1}y,r/\\|a\\|))$."}
{"name": "cardinal.bit1_le_bit0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/ordinal.lean", "formal_statement": "theorem cardinal.bit1_le_bit0 {a b : cardinal} :\n\tbit1 a \u2264 bit0 b \u2194 a < b \u2228 a \u2264 b \u2227 cardinal.aleph_0 \u2264 a :=", "nl_statement_of_codex": "$2^a\\leq 2^{b+1}$ if and only if $a<b$ or $a\\leq b$ and $\\aleph_0\\leq a$."}
{"name": "algebraic_geometry.projective_spectrum.structure_sheaf.section_subring.add_mem'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/projective_spectrum/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.projective_spectrum.structure_sheaf.section_subring.add_mem'\n\t{R A : Type*} [comm_ring R] [comm_ring A] [algebra R A] {\ud835\udc9c : \u2115 \u2192 submodule R A}\n\t[graded_algebra \ud835\udc9c]\n\t(U : (topological_space.opens \u21a5(projective_spectrum.Top \ud835\udc9c))\u1d52\u1d56)\n\t(a b : \u03a0 (x : \u21a5(opposite.unop U)), homogeneous_localization \ud835\udc9c (projective_spectrum.as_homogeneous_ideal x.val).to_ideal)\n\t(ha : (algebraic_geometry.projective_spectrum.structure_sheaf.is_locally_fraction \ud835\udc9c).to_prelocal_predicate.pred a)\n\t(hb : (algebraic_geometry.projective_spectrum.structure_sheaf.is_locally_fraction \ud835\udc9c).to_prelocal_predicate.pred b) :\n\t(algebraic_geometry.projective_spectrum.structure_sheaf.is_locally_fraction \ud835\udc9c).to_prelocal_predicate.pred (a + b) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $A$ an $R$-algebra, and $\\mathcal{A}$ a graded $R$-algebra. Let $U$ be an open subset of the projective spectrum of $\\mathcal{A}$. Let $a, b$ be sections of the structure sheaf of $U$ such that $a$ and $b$ are locally fractions. Then $a+b$ is a locally fraction."}
{"name": "linear_equiv.surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/module/equiv.lean", "formal_statement": "theorem linear_equiv.surjective {R S M M\u2082 : Type*} [semiring R] [semiring S]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] {module_M : module R M}\n\t{module_S_M\u2082 : module S M\u2082} {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}\n\t{re\u2081 : ring_hom_inv_pair \u03c3 \u03c3'} {re\u2082 : ring_hom_inv_pair \u03c3' \u03c3} (e : M \u2243\u209b\u2097[\u03c3] M\u2082) :\n\tfunction.surjective \u21d1e :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings, let $M$ and $M_2$ be $R$-modules, and let $\\sigma:R\\to S$ be a ring homomorphism. If $e:M\\to M_2$ is a linear equivalence, then $e$ is surjective."}
{"name": "category_theory.Monad.to_Mon_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/equiv_mon.lean", "formal_statement": "theorem category_theory.Monad.to_Mon_X {C : Type u} [category_theory.category C]\n\t(\u1fb0 : category_theory.monad C) :\n\t(category_theory.Monad.to_Mon \u1fb0).X = \u2191\u1fb0 :=", "nl_statement_of_codex": "Let $C$ be a category and let $\\mathcal{A}$ be a monad on $C$. Then the underlying functor of the monad $\\mathcal{A}$ is $\\mathcal{A}$."}
{"name": "padic.of_rat_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_numbers.lean", "formal_statement": "theorem padic.of_rat_sub (p : \u2115) [fact (nat.prime p)] (x y : \u211a) :\n\tpadic.of_rat p (x - y) = padic.of_rat p x - padic.of_rat p y :=", "nl_statement_of_codex": "Let $p$ be a prime. Then the $p$-adic valuation of $x-y$ is the $p$-adic valuation of $x$ minus the $p$-adic valuation of $y$."}
{"name": "category_theory.functor.cones_map_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.functor.cones_map_app {J : Type u\u2081}\n\t[category_theory.category J] {C : Type u\u2083} [category_theory.category C]\n\t(F : J \u2964 C) (_x _x_1 : C\u1d52\u1d56) (f : _x \u27f6 _x_1)\n\t(\u1fb0 : (category_theory.yoneda.obj F).obj ((category_theory.functor.const J).op.obj _x))\n\t(X : J) :\n\t(F.cones.map f \u1fb0).app X = f.unop \u226b \u1fb0.app X :=", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor. Let $x,y$ be objects of $C$. Let $f:x\\to y$ be a morphism. Let $\\alpha:F(x)\\to y$ be a cone over $F$. Then the morphism $\\alpha_X:F(X)\\to y$ is the composition of $F(X)\\to F(x)$ with $\\alpha$."}
{"name": "tendsto_norm_nhds_within_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem tendsto_norm_nhds_within_zero {E : Type*} [normed_group E] :\n\tfilter.tendsto has_norm.norm (nhds_within 0 {0}\u1d9c) (nhds_within 0 (set.Ioi 0)) :=", "nl_statement_of_codex": "The function $x\\mapsto \\|x\\|$ tends to $0$ as $x$ tends to $0$ in the complement of the origin."}
{"name": "dfinsupp_prod_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp_prod_mem {\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v}\n\t[dec : decidable_eq \u03b9] [\u03a0 (i : \u03b9), has_zero (\u03b2 i)]\n\t[\u03a0 (i : \u03b9) (x : \u03b2 i), decidable (x \u2260 0)] [comm_monoid \u03b3] {S : Type*}\n\t[set_like S \u03b3] [submonoid_class S \u03b3] (s : S) (f : \u03a0\u2080 (i : \u03b9), \u03b2 i)\n\t(g : \u03a0 (i : \u03b9), \u03b2 i \u2192 \u03b3) (h : \u2200 (c : \u03b9), \u21d1f c \u2260 0 \u2192 g c (\u21d1f c) \u2208 s) :\n\tf.prod g \u2208 s :=", "nl_statement_of_codex": "Let $S$ be a submonoid of a commutative monoid $\\gamma$. Let $f:\\mathbb{N}\\to\\gamma$ be a finitely supported function. Then $\\prod_{i\\in\\mathbb{N}}f(i)$ is in $S$."}
{"name": "alternating_map.curry_left_comp_linear_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/alternating.lean", "formal_statement": "theorem alternating_map.curry_left_comp_linear_map {R' M'' M\u2082'' N'' : Type*2}\n\t[comm_semiring R'] [add_comm_monoid M''] [add_comm_monoid M\u2082'']\n\t[add_comm_monoid N''] [module R' M''] [module R' M\u2082''] [module R' N''] {n : \u2115}\n\t(g : M\u2082'' \u2192\u2097[R'] M'') (f : alternating_map R' M'' N'' (fin n.succ)) (m : M\u2082'') :\n\t\u21d1((f.comp_linear_map g).curry_left) m = (\u21d1(f.curry_left) (\u21d1g m)).comp_linear_map g :=", "nl_statement_of_codex": "Let $R'$ be a commutative semiring, $M''$, $M_2''$, $N''$ be add commutative monoids, and $R'$-modules. Let $n$ be a natural number, $g:M_2''\\to M''$ be a linear map, $f:M''^n\\to N''$ be an alternating map, and $m\\in M_2''$. Then the map $M_2''\\to N''$ given by $m\\mapsto f(gm)$ is equal to the composition of the map $M_2''\\to N''$ given by $m\\mapsto f"}
{"name": "category_theory.limits.colimit_iso_flip_comp_colim_hom_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/functor_category.lean", "formal_statement": "theorem category_theory.limits.colimit_iso_flip_comp_colim_hom_app {C : Type u}\n\t[category_theory.category C] {J : Type u\u2081} [category_theory.category J]\n\t{K : Type u\u2082} [category_theory.category K]\n\t[category_theory.limits.has_colimits_of_shape J C] (F : J \u2964 K \u2964 C) (X : K) :\n\t(category_theory.limits.colimit_iso_flip_comp_colim F).hom.app X = (category_theory.limits.colimit_obj_iso_colimit_comp_evaluation F X).hom :=", "nl_statement_of_codex": "Let $C$ be a category, $J$ and $K$ be categories, and $F:J\\to K\\to C$ be a functor. Then the morphism $(\\mathrm{colim}_J F)\\to (\\mathrm{colim}_K F)$ is equal to the morphism $(\\mathrm{colim}_J F)\\to X$."}
{"name": "finset.not_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.not_subset {\u03b1 : Type*} (s t : finset \u03b1) :\n\t\u00acs \u2286 t \u2194 \u2203 (x : \u03b1) (H : x \u2208 s), x \u2209 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets. Then $s$ is not a subset of $t$ if and only if there is an element $x$ of $s$ that is not an element of $t$."}
{"name": "continuous_linear_map.map_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/module/basic.lean", "formal_statement": "theorem continuous_linear_map.map_zero {R\u2081 R\u2082 : Type*} [semiring R\u2081]\n\t[semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {M\u2081 : Type*} [topological_space M\u2081]\n\t[add_comm_monoid M\u2081] {M\u2082 : Type*} [topological_space M\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2081 M\u2081] [module R\u2082 M\u2082] (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n\t\u21d1f 0 = 0 :=", "nl_statement_of_codex": "Let $R_1, R_2$ be semirings, $\\sigma_{12}:R_1\\to R_2$ a semiring homomorphism, $M_1, M_2$ topological abelian groups, and $f:M_1\\to M_2$ a continuous linear map. Then $f(0)=0$."}
{"name": "finset.filter_le_eq_Ici", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/locally_finite.lean", "formal_statement": "theorem finset.filter_le_eq_Ici {\u03b1 : Type*} [preorder \u03b1]\n\t[locally_finite_order_top \u03b1] {a : \u03b1} [fintype \u03b1] [decidable_pred (has_le.le a)] :\n\tfinset.filter (has_le.le a) finset.univ = finset.Ici a :=", "nl_statement_of_codex": "Let $A$ be a finite set with a preorder $\\leq$ such that the set of elements less than or equal to $a$ is finite for each $a\\in A$. Then the set of elements less than or equal to $a$ is equal to the set of elements less than or equal to $a$."}
{"name": "balanced_core_aux_balanced", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/balanced_core_hull.lean", "formal_statement": "theorem balanced_core_aux_balanced {\ud835\udd5c E : Type*} [normed_field \ud835\udd5c]\n\t[add_comm_group E] [module \ud835\udd5c E] {s : set E} (h0 : 0 \u2208 balanced_core_aux \ud835\udd5c s) :\n\tbalanced \ud835\udd5c (balanced_core_aux \ud835\udd5c s) :=", "nl_statement_of_codex": "Let $E$ be a normed vector space over a normed field $K$. Let $s$ be a subset of $E$. If $0\\in\\text{balanced-core}(s)$, then $\\text{balanced-core}(s)$ is balanced."}
{"name": "finset.vsub_subset_vsub_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/pointwise.lean", "formal_statement": "theorem finset.vsub_subset_vsub_right {\u03b1 \u03b2 : Type*} [decidable_eq \u03b1]\n\t[has_vsub \u03b1 \u03b2] {s\u2081 s\u2082 t : finset \u03b2} :\n\ts\u2081 \u2286 s\u2082 \u2192 s\u2081 -\u1d65 t \u2286 s\u2082 -\u1d65 t :=", "nl_statement_of_codex": "Let $s_1, s_2, t$ be finite sets. If $s_1\\subset s_2$, then $s_1-t\\subset s_2-t$."}
{"name": "box_integral.integrable.to_subbox_aux", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/basic.lean", "formal_statement": "theorem box_integral.integrable.to_subbox_aux {\u03b9 : Type u} {E : Type v}\n\t{F : Type w} [normed_group E] [normed_space \u211d E] [normed_group F]\n\t[normed_space \u211d F] {I J : box_integral.box \u03b9} [fintype \u03b9]\n\t{l : box_integral.integration_params} {f : (\u03b9 \u2192 \u211d) \u2192 E}\n\t{vol : box_integral.box_additive_map \u03b9 (E \u2192L[\u211d] F) \u22a4} [complete_space F]\n\t(h : box_integral.integrable I l f vol) (hJ : J \u2264 I) :\n\t\u2203 (y : F), box_integral.has_integral J l f vol y \u2227 filter.tendsto (box_integral.integral_sum f vol) (l.to_filter_Union I (box_integral.prepartition.single I J hJ)) (nhds y) :=", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $f:I\\to\\mathbb{R}^m$ be a function. Suppose that $f$ is integrable over $I$. Then there is a point $y\\in\\mathbb{R}^m$ such that the integral of $f$ over $I$ converges to $y$."}
{"name": "category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/finite_limits.lean", "formal_statement": "theorem category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits\n\t(C : Type u) [category_theory.category C]\n\t[category_theory.limits.has_finite_colimits C] :\n\tcategory_theory.limits.has_finite_wide_pushouts C :=", "nl_statement_of_codex": "If $C$ has finite colimits, then $C$ has finite wide pushouts."}
{"name": "matrix.to_lin_alg_equiv_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/to_lin.lean", "formal_statement": "theorem matrix.to_lin_alg_equiv_apply {R : Type*} [comm_semiring R] {n : Type*}\n\t[fintype n] [decidable_eq n] {M\u2081 : Type*} [add_comm_monoid M\u2081] [module R M\u2081]\n\t(v\u2081 : basis n R M\u2081) (M : matrix n n R) (v : M\u2081) :\n\t\u21d1(\u21d1(matrix.to_lin_alg_equiv v\u2081) M) v = finset.univ.sum (\u03bb (j : n), M.mul_vec \u21d1(\u21d1(v\u2081.repr) v) j \u2022 \u21d1v\u2081 j) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $n$ a finite type, $M_1$ an $R$-module, $v_1$ a basis of $M_1$, $M$ a matrix over $R$ and $v\\in M_1$. Then the matrix $M$ applied to $v$ is the sum of the vectors $M\\cdot v_i$."}
{"name": "finset.choose_property", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.choose_property {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t(l : finset \u03b1) (hp : \u2203! (a : \u03b1), a \u2208 l \u2227 p a) :\n\tp (finset.choose p l hp) :=", "nl_statement_of_codex": "Let $l$ be a finite set and let $p$ be a property on the elements of $l$. Suppose that there is a unique element $a$ of $l$ such that $p(a)$ holds. Then $p(a)$ holds."}
{"name": "pgame.lt_iff_le_and_lf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/pgame.lean", "formal_statement": "theorem pgame.lt_iff_le_and_lf {x y : pgame} :\n\tx < y \u2194 x \u2264 y \u2227 x.lf y :=", "nl_statement_of_codex": "Let $x$ and $y$ be partial games. Then $x<y$ if and only if $x\\leq y$ and $x$ is left-favorable to $y$."}
{"name": "measure_theory.measure.inner_regular.trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/regular.lean", "formal_statement": "theorem measure_theory.measure.inner_regular.trans {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {p q q' : set \u03b1 \u2192 Prop}\n\t(H : \u03bc.inner_regular p q) (H' : \u03bc.inner_regular q q') :\n\t\u03bc.inner_regular p q' :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $p, q, q'$ be subsets of $X$. If $\\mu$ is inner regular on $p$ and $q$, then $\\mu$ is inner regular on $p$ and $q'$."}
{"name": "is_primitive_root.norm_eq_one_of_linearly_ordered", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/cyclotomic/primitive_roots.lean", "formal_statement": "theorem is_primitive_root.norm_eq_one_of_linearly_ordered {n : \u2115+} {L : Type v}\n\t[field L] {\u03b6 : L} (h\u03b6 : is_primitive_root \u03b6 \u2191n) {K : Type*}\n\t[linear_ordered_field K] [algebra K L] (hodd : odd \u2191n) :\n\t\u21d1(algebra.norm K) \u03b6 = 1 :=", "nl_statement_of_codex": "Let $n$ be a positive integer and let $L$ be a field. Let $\\zeta$ be a primitive $n$-th root of unity in $L$. Let $K$ be a linearly ordered field and let $L$ be a field extension of $K$. If $n$ is odd, then $\\zeta$ is a unit in $L$."}
{"name": "matrix.vec_mul_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/notation.lean", "formal_statement": "theorem matrix.vec_mul_empty {\u03b1 : Type u} {n' : Type*} [semiring \u03b1] [fintype n']\n\t(v : n' \u2192 \u03b1) (B : matrix n' (fin 0) \u03b1) :\n\tmatrix.vec_mul v B = matrix.vec_empty :=", "nl_statement_of_codex": "Let $v$ be a vector in $\\mathbb{R}^n$ and let $B$ be a $n\\times 0$ matrix. Then $vB=0$."}
{"name": "category_theory.is_separator_op_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/generator.lean", "formal_statement": "theorem category_theory.is_separator_op_iff {C : Type u}\n\t[category_theory.category C] (G : C) :\n\tcategory_theory.is_separator (opposite.op G) \u2194 category_theory.is_coseparator G :=", "nl_statement_of_codex": "Let $C$ be a category and let $G$ be an object of $C$. Then $G$ is a coseparator if and only if $G^\\text{op}$ is a separator."}
{"name": "traversable.comp_sequence", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/control/traversable/lemmas.lean", "formal_statement": "theorem traversable.comp_sequence {t : Type u \u2192 Type u} [traversable t]\n\t[is_lawful_traversable t] {F G : Type u \u2192 Type u} [applicative F]\n\t[is_lawful_applicative F] [applicative G] [is_lawful_applicative G]\n\t{\u03b1 : Type u} (x : t (F (G \u03b1))) :\n\tsequence (functor.comp.mk <$> x) = functor.comp.mk (sequence <$> sequence x) :=", "nl_statement_of_codex": "Let $t$ be a traversable functor. Let $F$ and $G$ be applicative functors. Then the sequence of the composition of $F$ and $G$ applied to $t$ is equal to the composition of the sequence of $F$ applied to $t$ and the sequence of $G$ applied to $t$."}
{"name": "topological_vector_bundle.pretrivialization.symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/vector_bundle/basic.lean", "formal_statement": "theorem topological_vector_bundle.pretrivialization.symm_apply\n\t{R B F E : B \u2192 Type*} [semiring R] [\u03a0 (x : B), add_comm_monoid (E x)]\n\t[\u03a0 (x : B), module R (E x)] [topological_space F] [add_comm_monoid F]\n\t[module R F] [topological_space B]\n\t(e : topological_vector_bundle.pretrivialization R F E) {b : B}\n\t(hb : b \u2208 e.to_fiber_bundle_pretrivialization.base_set) (y : F) :\n\te.symm b y = cast _ (\u21d1(e.to_fiber_bundle_pretrivialization.to_local_equiv.symm) (b, y)).snd :=", "nl_statement_of_codex": "Let $R$ be a semiring, $B$ a topological space, $F$ an $R$-module, and $E$ a topological vector bundle over $B$ with fiber $F$. Let $e$ be a pretrivialization of $E$. Then for each $b\\in B$ and $y\\in F$, $e(b,y)=(b,e^{-1}(b,y))$."}
{"name": "finset.cons_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.cons_subset {\u03b1 : Type*} {s t : finset \u03b1} {a : \u03b1} {h : a \u2209 s} :\n\tfinset.cons a s h \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets. Then $a\\in s$ and $s\\subset t$ if and only if $a\\in t$ and $s\\subset t$."}
{"name": "fun_like.coe_fn_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fun_like/basic.lean", "formal_statement": "theorem fun_like.coe_fn_eq {F : Sort u_1} {\u03b1 : Sort u_2} {\u03b2 : \u03b1 \u2192 Sort u_3}\n\t[i : fun_like F \u03b1 \u03b2] {f g : F} :\n\t\u21d1f = \u21d1g \u2194 f = g :=", "nl_statement_of_codex": "Let $F$ be a type, and let $\\alpha$ and $\\beta$ be types indexed by $F$. Then two elements $f,g\\in F$ are equal if and only if the corresponding functions $\\alpha\\to\\beta$ are equal."}
{"name": "equiv_functor.map_equiv.injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/control/equiv_functor.lean", "formal_statement": "theorem equiv_functor.map_equiv.injective (f : Type u\u2080 \u2192 Type u\u2081)\n\t[applicative f] [is_lawful_applicative f] {\u03b1 \u03b2 : Type u\u2080}\n\t(h : \u2200 (\u03b3 : Type u\u2080), function.injective has_pure.pure) :\n\tfunction.injective (equiv_functor.map_equiv f) :=", "nl_statement_of_codex": "Let $f$ be an applicative functor. Then the map $f(\u03b1)\\to f(\u03b2)$ induced by an equivalence $\u03b1\\to \u03b2$ is injective."}
{"name": "tensor_product.tensor_tensor_tensor_comm_symm_tmul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/tensor_product.lean", "formal_statement": "theorem tensor_product.tensor_tensor_tensor_comm_symm_tmul (R : Type*)\n\t[comm_semiring R] {M N P Q : Type*} [add_comm_monoid M] [add_comm_monoid N]\n\t[add_comm_monoid P] [add_comm_monoid Q] [module R M] [module R N] [module R P]\n\t[module R Q] (m : M) (n : N) (p : P) (q : Q) :\n\t\u21d1((tensor_product.tensor_tensor_tensor_comm R M N P Q).symm) (m \u2297\u209c[R] p \u2297\u209c[R] (n \u2297\u209c[R] q)) = m \u2297\u209c[R] n \u2297\u209c[R] (p \u2297\u209c[R] q) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M, N, P, Q$ be $R$-modules. Then $(m\\otimes p)\\otimes (n\\otimes q)=(m\\otimes n)\\otimes (p\\otimes q)$."}
{"name": "finset.ne_of_mem_erase", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.ne_of_mem_erase {\u03b1 : Type*} [decidable_eq \u03b1] {s : finset \u03b1}\n\t{a b : \u03b1} :\n\tb \u2208 s.erase a \u2192 b \u2260 a :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $a,b\\in s$. If $b\\in s\\setminus\\{a\\}$, then $b\\neq a$."}
{"name": "fractional_ideal.ne_zero_of_mul_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.ne_zero_of_mul_eq_one {R\u2081 : Type*} [comm_ring R\u2081]\n\t{K : Type*} [field K] [algebra R\u2081 K]\n\t(I J : fractional_ideal (non_zero_divisors R\u2081) K) (h : I * J = 1) :\n\tI \u2260 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $K$ a field, and $R\\to K$ a ring homomorphism. Let $I$ and $J$ be fractional ideals of $R$ such that $IJ=1$. Then $I\\neq 0$."}
{"name": "equiv.is_lawful_functor", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/control/traversable/equiv.lean", "formal_statement": "theorem equiv.is_lawful_functor {t t' : Type u \u2192 Type u}\n\t(eqv : \u03a0 (\u03b1 : Type u), t \u03b1 \u2243 t' \u03b1) [functor t] [is_lawful_functor t] :\n\tis_lawful_functor t' :=", "nl_statement_of_codex": "If $t$ is a lawful functor, then so is $t'$."}
{"name": "denoms_clearable_C_mul_X_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/denoms_clearable.lean", "formal_statement": "theorem denoms_clearable_C_mul_X_pow {R K : Type*} [semiring R]\n\t[comm_semiring K] {i : R \u2192+* K} {b : R} {bi : K} {N : \u2115} (a : R)\n\t(bu : bi * \u21d1i b = 1) {n : \u2115} (r : R) (nN : n \u2264 N) :\n\tdenoms_clearable a b N (\u21d1polynomial.C r * polynomial.X ^ n) i :=", "nl_statement_of_codex": "Let $R$ be a semiring, $K$ a commutative semiring, $i:R\\to K$ a ring homomorphism, $b\\in R$, $bi\\in K$ such that $bi\\cdot i(b)=1$, $N\\in\\mathbb{N}$, $a\\in R$, $n\\in\\mathbb{N}$ such that $n\\leq N$, and $r\\in R$. Then $a$ is a denominator of $r\\cdot X^n$ with respect to $b$ and $i$."}
{"name": "real.pi_gt_31415", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/pi/bounds.lean", "formal_statement": "theorem real.pi_gt_31415 :\n\t6283 / 2000 < real.pi :=", "nl_statement_of_codex": "$\\pi$ is greater than $6283/2000$."}
{"name": "order_iso.is_bounded_under_ge_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/liminf_limsup.lean", "formal_statement": "theorem order_iso.is_bounded_under_ge_comp {\u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b1]\n\t[preorder \u03b2] (e : \u03b1 \u2243o \u03b2) {l : filter \u03b3} {u : \u03b3 \u2192 \u03b1} :\n\tfilter.is_bounded_under ge l (\u03bb (x : \u03b3), \u21d1e (u x)) \u2194 filter.is_bounded_under ge l u :=", "nl_statement_of_codex": "Let $e:A\\to B$ be an order isomorphism between preorders $A$ and $B$. Then $e$ maps bounded sets to bounded sets."}
{"name": "measure_theory.lintegral_add_right_eq_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/integration.lean", "formal_statement": "theorem measure_theory.lintegral_add_right_eq_self {G : Type*}\n\t[measurable_space G] {\u03bc : measure_theory.measure G} [add_group G]\n\t[has_measurable_add G] [\u03bc.is_add_right_invariant] (f : G \u2192 ennreal) (g : G) :\n\t\u222b\u207b (x : G), f (x + g) \u2202\u03bc = \u222b\u207b (x : G), f x \u2202\u03bc :=", "nl_statement_of_codex": "Let $G$ be a measurable space and let $\\mu$ be a measure on $G$. Let $f:G\\to \\overline{\\mathbb{R}}$ be a measurable function. Then $\\int f(x+g)d\\mu=\\int f(x)d\\mu$ for all $g\\in G$."}
{"name": "polynomial.trailing_degree_X", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/trailing_degree.lean", "formal_statement": "theorem polynomial.trailing_degree_X {R : Type u} [semiring R] [nontrivial R] :\n\tpolynomial.X.trailing_degree = 1 :=", "nl_statement_of_codex": "The trailing degree of $X$ is $1$."}
{"name": "map_list_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/big_operators.lean", "formal_statement": "theorem map_list_sum {M N : Type*} [add_monoid M] [add_monoid N] {F : Type*}\n\t[add_monoid_hom_class F M N] (f : F) (l : list M) :\n\t\u21d1f l.sum = (list.map \u21d1f l).sum :=", "nl_statement_of_codex": "Let $M$ and $N$ be add monoids and let $f:M\\to N$ be an additive monoid homomorphism. Then $f$ commutes with the sum of lists."}
{"name": "vitali_family.mul_measure_le_of_subset_lt_lim_ratio_meas", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/covering/differentiation.lean", "formal_statement": "theorem vitali_family.mul_measure_le_of_subset_lt_lim_ratio_meas {\u03b1 : Type*}\n\t[metric_space \u03b1] {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t(v : vitali_family \u03bc) [sigma_compact_space \u03b1] [borel_space \u03b1]\n\t[measure_theory.is_locally_finite_measure \u03bc] {\u03c1 : measure_theory.measure \u03b1}\n\t[measure_theory.is_locally_finite_measure \u03c1] (h\u03c1 : \u03c1.absolutely_continuous \u03bc)\n\t{q : nnreal} {s : set \u03b1} (h : s \u2286 {x : \u03b1 | \u2191q < v.lim_ratio_meas h\u03c1 x}) :\n\t\u2191q * \u21d1\u03bc s \u2264 \u21d1\u03c1 s :=", "nl_statement_of_codex": "Let $X$ be a metric space, let $\\mu$ be a measure on $X$, and let $v$ be a Vitali family of subsets of $X$. Let $\\rho$ be a measure on $X$ that is absolutely continuous with respect to $\\mu$. Let $q$ be a nonnegative real number and let $s$ be a subset of $X$. If $s$ is contained in the set of all $x\\in X$ such that $q<v.lim\\_ratio\\_meas(h\\rho)(x)$, then $q\\mu(s)\\leq\\rho(s)$."}
{"name": "has_mfderiv_within_at.union", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/mfderiv.lean", "formal_statement": "theorem has_mfderiv_within_at.union {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*}\n\t[topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M] {E' : Type*} [normed_group E']\n\t[normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {f : M \u2192 M'} {x : M} {s t : set M}\n\t[Is : smooth_manifold_with_corners I M]\n\t[I's : smooth_manifold_with_corners I' M']\n\t{f' : tangent_space I x \u2192L[\ud835\udd5c] tangent_space I' (f x)}\n\t(hs : has_mfderiv_within_at I I' f s x f')\n\t(ht : has_mfderiv_within_at I I' f t x f') :\n\thas_mfderiv_within_at I I' f (s \u222a t) x f' :=", "nl_statement_of_codex": "Let $M$ and $M'$ be smooth manifolds with corners, let $f:M\\to M'$ be a smooth map, and let $x\\in M$. Suppose that $f$ has a derivative at $x$ in the direction of each point in $s$ and in the direction of each point in $t$. Then $f$ has a derivative at $x$ in the direction of each point in $s\\cup t$."}
{"name": "set.eq_on.congr_strict_anti_on", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/function.lean", "formal_statement": "theorem set.eq_on.congr_strict_anti_on {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1}\n\t{f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} [preorder \u03b1] [preorder \u03b2] (h : set.eq_on f\u2081 f\u2082 s) :\n\tstrict_anti_on f\u2081 s \u2194 strict_anti_on f\u2082 s :=", "nl_statement_of_codex": "Let $f_1, f_2:A\\to B$ be functions. If $f_1$ and $f_2$ are equal on a subset $S$ of $A$, then $f_1$ is strictly anti-monotone on $S$ if and only if $f_2$ is strictly anti-monotone on $S$."}
{"name": "units.inv_eq_coe_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/units.lean", "formal_statement": "theorem units.inv_eq_coe_inv {\u03b1 : Type u} [monoid \u03b1] (a : \u03b1\u02e3) :\n\ta.inv = \u2191a\u207b\u00b9 :=", "nl_statement_of_codex": "The inverse of a unit is the inverse of the underlying element."}
{"name": "submodule.fg_of_fg_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem submodule.fg_of_fg_map {R M P : Type*} [ring R] [add_comm_group M]\n\t[module R M] [add_comm_group P] [module R P] (f : M \u2192\u2097[R] P) (hf : f.ker = \u22a5)\n\t{N : submodule R M} (hfn : (submodule.map f N).fg) :\n\tN.fg :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ and $P$ be $R$-modules, and $f:M\\to P$ be a linear map. If $f$ is injective and $N$ is a submodule of $M$ such that $f(N)$ is finitely generated, then $N$ is finitely generated."}
{"name": "sdiff_sdiff_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/boolean_algebra.lean", "formal_statement": "theorem sdiff_sdiff_right {\u03b1 : Type u} {x y z : \u03b1}\n\t[generalized_boolean_algebra \u03b1] :\n\tx \\ (y \\ z) = x \\ y \u2294 x \u2293 y \u2293 z :=", "nl_statement_of_codex": "Let $x,y,z$ be elements of a generalized boolean algebra. Then $x\\setminus (y\\setminus z) = (x\\setminus y)\\cup (x\\cap y\\cap z)$."}
{"name": "mv_polynomial.eval\u2082_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.eval\u2082_pow {R : Type u} {S\u2081 : Type v} {\u03c3 : Type*}\n\t[comm_semiring R] [comm_semiring S\u2081] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081)\n\t{p : mv_polynomial \u03c3 R} {n : \u2115} :\n\tmv_polynomial.eval\u2082 f g (p ^ n) = mv_polynomial.eval\u2082 f g p ^ n :=", "nl_statement_of_codex": "Let $R$ and $S_1$ be commutative rings, let $f:R\\to S_1$ be a ring homomorphism, and let $g:\\sigma\\to S_1$ be a function. Then for any multivariate polynomial $p$ over $R$ and any natural number $n$, we have $f(p^n)=f(p)^n$."}
{"name": "first_order.language.Lhom.mk\u2082_funext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/language_map.lean", "formal_statement": "theorem first_order.language.Lhom.mk\u2082_funext {L' : first_order.language}\n\t{c f\u2081 f\u2082 : Type u} {r\u2081 r\u2082 : Type v}\n\t{F G : first_order.language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082 \u2192\u1d38 L'}\n\t(h0 : \u2200 (c_1 : (first_order.language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082).constants), F.on_function c_1 = G.on_function c_1)\n\t(h1 : \u2200 (f : (first_order.language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082).functions 1), F.on_function f = G.on_function f)\n\t(h2 : \u2200 (f : (first_order.language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082).functions 2), F.on_function f = G.on_function f)\n\t(h1' : \u2200 (r : (first_order.language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082).relations 1), F.on_relation r = G.on_relation r)\n\t(h2' : \u2200 (r : (first_order.language.mk\u2082 c f\u2081 f\u2082 r\u2081 r\u2082).relations 2), F.on_relation r = G.on_relation r) :\n\tF = G :=", "nl_statement_of_codex": "Let $L$ be a language with two sorts $f_1$ and $f_2$ and two relations $r_1$ and $r_2$. Let $L'$ be a language. Let $F, G:L\\to L'$ be two homomorphisms of languages. Then $F=G$ if and only if $F$ and $G$ agree on constants, functions and relations."}
{"name": "category_theory.center.hom.comm_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/center.lean", "formal_statement": "theorem category_theory.center.hom.comm_assoc {C : Type u\u2081}\n\t[category_theory.category C] [category_theory.monoidal_category C]\n\t{X Y : category_theory.center C} (self : X.hom Y) (U : C) {X' : C}\n\t(f' : U \u2297 Y.fst \u27f6 X') :\n\t(self.f \u2297 \ud835\udfd9 U) \u226b (Y.snd.\u03b2 U).hom \u226b f' = (X.snd.\u03b2 U).hom \u226b (\ud835\udfd9 U \u2297 self.f) \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X, Y$ be objects of the center of $C$. Let $U$ be an object of $C$. Let $f':U\\otimes Y\\to X'$ be a morphism in $C$. Then $(self.f\\otimes id_U)\\circ (Y.snd.\u03b2 U).hom\\circ f'=(X.snd.\u03b2 U).hom\\circ (id_U\\otimes self.f)\\circ f'$."}
{"name": "abstract_completion.compare_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/abstract_completion.lean", "formal_statement": "theorem abstract_completion.compare_coe {\u03b1 : Type*} [uniform_space \u03b1]\n\t(pkg pkg' : abstract_completion \u03b1) (a : \u03b1) :\n\tpkg.compare pkg' (pkg.coe a) = pkg'.coe a :=", "nl_statement_of_codex": "Let $X$ be a uniform space and let $x\\in X$. Then the comparison map $X\\to\\widehat{X}$ is the identity map."}
{"name": "ennreal.tendsto_finset_prod_of_ne_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.tendsto_finset_prod_of_ne_top {\u03b1 \u03b9 : Type*}\n\t{f : \u03b9 \u2192 \u03b1 \u2192 ennreal} {x : filter \u03b1} {a : \u03b9 \u2192 ennreal} (s : finset \u03b9)\n\t(h : \u2200 (i : \u03b9), i \u2208 s \u2192 filter.tendsto (f i) x (nhds (a i)))\n\t(h' : \u2200 (i : \u03b9), i \u2208 s \u2192 a i \u2260 \u22a4) :\n\tfilter.tendsto (\u03bb (b : \u03b1), s.prod (\u03bb (c : \u03b9), f c b)) x (nhds (s.prod (\u03bb (c : \u03b9), a c))) :=", "nl_statement_of_codex": "Let $f_i:X\\to\\mathbb{R}$ be a sequence of functions on a topological space $X$ and let $a_i\\in\\mathbb{R}$ be a sequence of real numbers. Suppose that $f_i$ converges to $a_i$ for each $i$. If $a_i\\neq\\infty$ for each $i$, then $\\prod_i f_i$ converges to $\\prod_i a_i$."}
{"name": "alg_equiv.restrict_lift_normal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/normal.lean", "formal_statement": "theorem alg_equiv.restrict_lift_normal {F : Type*} [field F] {K\u2081 : Type*}\n\t[field K\u2081] [algebra F K\u2081] (E : Type*) [field E] [algebra F E] [algebra K\u2081 E]\n\t[is_scalar_tower F K\u2081 E] (\u03c7 : K\u2081 \u2243\u2090[F] K\u2081) [normal F K\u2081] [normal F E] :\n\t(\u03c7.lift_normal E).restrict_normal K\u2081 = \u03c7 :=", "nl_statement_of_codex": "Let $F$ be a field, $K_1$ a finite separable extension of $F$, and $E$ a finite separable extension of $K_1$. Let $\\chi:K_1\\to K_1$ be an $F$-algebra automorphism of $K_1$. Then the restriction of the $F$-algebra automorphism $\\chi:E\\to E$ to $K_1$ is $\\chi$."}
{"name": "add_submonoid.mem_comap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem add_submonoid.mem_comap {M N : Type*} [add_zero_class M]\n\t[add_zero_class N] {F : Type*} [mc : add_monoid_hom_class F M N]\n\t{S : add_submonoid N} {f : F} {x : M} :\n\tx \u2208 add_submonoid.comap f S \u2194 \u21d1f x \u2208 S :=", "nl_statement_of_codex": "Let $M$ and $N$ be additive monoids, let $F$ be an additive monoid homomorphism from $M$ to $N$, and let $S$ be an additive submonoid of $N$. Then $x\\in\\operatorname{comap}(f,S)$ if and only if $f(x)\\in S$."}
{"name": "clifford_algebra_complex.to_complex_\u03b9", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/clifford_algebra/equivs.lean", "formal_statement": "theorem clifford_algebra_complex.to_complex_\u03b9 (r : \u211d) :\n\t\u21d1clifford_algebra_complex.to_complex (\u21d1(clifford_algebra.\u03b9 clifford_algebra_complex.Q) r) = r \u2022 complex.I :=", "nl_statement_of_codex": "The Clifford algebra element $r\\cdot\\mathbf{i}$ is mapped to $r\\cdot i$ under the map from the Clifford algebra to the complex numbers."}
{"name": "deriv_within_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem deriv_within_id {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] (x : \ud835\udd5c)\n\t(s : set \ud835\udd5c) (hxs : unique_diff_within_at \ud835\udd5c s x) :\n\tderiv_within id s x = 1 :=", "nl_statement_of_codex": "Let $x$ be a point in a set $S$ in a nondiscrete normed field $K$. If $S$ is differentiable at $x$, then the derivative of the identity function at $x$ is $1$."}
{"name": "list.enum_from_append", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.enum_from_append {\u03b1 : Type u} (xs ys : list \u03b1) (n : \u2115) :\n\tlist.enum_from n (xs ++ ys) = list.enum_from n xs ++ list.enum_from (n + xs.length) ys :=", "nl_statement_of_codex": "Let $xs$ and $ys$ be lists. Then the list obtained by appending $xs$ and $ys$ is the concatenation of the lists obtained by appending $xs$ and $ys$."}
{"name": "category_theory.bicategory.whisker_right_iso_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/basic.lean", "formal_statement": "theorem category_theory.bicategory.whisker_right_iso_hom {B : Type u}\n\t[category_theory.bicategory B] {a b c : B} {f g : a \u27f6 b} (\u03b7 : f \u2245 g)\n\t(h : b \u27f6 c) :\n\t(category_theory.bicategory.whisker_right_iso \u03b7 h).hom = category_theory.bicategory.whisker_right \u03b7.hom h :=", "nl_statement_of_codex": "Let $B$ be a bicategory. Let $a,b,c$ be objects of $B$ and let $f,g:a\\to b$ and $h:b\\to c$ be morphisms. Let $\\eta:f\\cong g$ be an isomorphism. Then the whiskering of $\\eta$ on the right by $h$ is an isomorphism and its homomorphism is the whiskering of $\\eta$'s homomorphism by $h$."}
{"name": "real.mk_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/basic.lean", "formal_statement": "theorem real.mk_lt {f g : cau_seq \u211a has_abs.abs} :\n\treal.mk f < real.mk g \u2194 f < g :=", "nl_statement_of_codex": "The real number $x$ is less than the real number $y$ if and only if the Cauchy sequence $f$ representing $x$ is less than the Cauchy sequence $g$ representing $y$."}
{"name": "BoundedOrder.iso.mk_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/category/BoundedOrder.lean", "formal_statement": "theorem BoundedOrder.iso.mk_inv {\u03b1 \u03b2 : BoundedOrder} (e : \u21a5\u03b1 \u2243o \u21a5\u03b2) :\n\t(BoundedOrder.iso.mk e).inv = \u2191(e.symm) :=", "nl_statement_of_codex": "The inverse of the isomorphism $BoundedOrder.iso.mk(e)$ is the isomorphism $BoundedOrder.iso.mk(e^{-1})$."}
{"name": "measure_theory.integrable.prod_left_ae", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/prod.lean", "formal_statement": "theorem measure_theory.integrable.prod_left_ae {\u03b1 \u03b2 E : Type*}\n\t[measurable_space \u03b1] [measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1}\n\t{\u03bd : measure_theory.measure \u03b2} [normed_group E] [measure_theory.sigma_finite \u03bd]\n\t[measure_theory.sigma_finite \u03bc] \u2983f : \u03b1 \u00d7 \u03b2 \u2192 E\u2984\n\t(hf : measure_theory.integrable f (\u03bc.prod \u03bd)) :\n\t\u2200\u1d50 (y : \u03b2) \u2202\u03bd, measure_theory.integrable (\u03bb (x : \u03b1), f (x, y)) \u03bc :=", "nl_statement_of_codex": "Let $E$ be a normed group, let $\\mu$ and $\\nu$ be $\\sigma$-finite measures on $\\alpha$ and $\\beta$, respectively. Let $f:\\alpha\\times\\beta\\to E$ be integrable with respect to $\\mu\\times\\nu$. Then for $\\nu$-almost every $y\\in\\beta$, the function $x\\mapsto f(x,y)$ is integrable with respect to $\\mu$."}
{"name": "mv_polynomial.support_symm_diff_support_subset_support_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.support_symm_diff_support_subset_support_add {R : Type u}\n\t{\u03c3 : Type*} [comm_semiring R] [decidable_eq \u03c3] (p q : mv_polynomial \u03c3 R) :\n\tp.support \u2206 q.support \u2286 (p + q).support :=", "nl_statement_of_codex": "Let $p$ and $q$ be multivariate polynomials over a commutative semiring $R$. Then the symmetric difference of the supports of $p$ and $q$ is a subset of the support of $p+q$."}
{"name": "finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finite_dimensional.lean", "formal_statement": "theorem finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ\n\t{K V : Type*} [field K] [add_comm_group V] [module K V] (n : \u2115)\n\t[fact (finite_dimensional.finrank K V = n + 1)] :\n\tfinite_dimensional K V :=", "nl_statement_of_codex": "Let $K$ be a field and $V$ a $K$-vector space. If the rank of $V$ is $n+1$, then $V$ is finite dimensional."}
{"name": "algebraic_geometry.structure_sheaf.normalize_finite_fraction_representation", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/structure_sheaf.lean", "formal_statement": "theorem algebraic_geometry.structure_sheaf.normalize_finite_fraction_representation\n\t(R : Type u) [comm_ring R]\n\t(U : topological_space.opens \u21a5(algebraic_geometry.prime_spectrum.Top R))\n\t(s : \u21a5((algebraic_geometry.Spec.structure_sheaf R).val.obj (opposite.op U)))\n\t{\u03b9 : Type*} (t : finset \u03b9) (a h : \u03b9 \u2192 R)\n\t(iDh : \u03a0 (i : \u03b9), prime_spectrum.basic_open (h i) \u27f6 U)\n\t(h_cover : U.val \u2286 \u22c3 (i : \u03b9) (H : i \u2208 t), (prime_spectrum.basic_open (h i)).val)\n\t(hs : \u2200 (i : \u03b9), algebraic_geometry.structure_sheaf.const R (a i) (h i) (prime_spectrum.basic_open (h i)) _ = \u21d1((algebraic_geometry.Spec.structure_sheaf R).val.map (iDh i).op) s) :\n\t\u2203 (a' h' : \u03b9 \u2192 R) (iDh' : \u03a0 (i : \u03b9), prime_spectrum.basic_open (h' i) \u27f6 U), (U.val \u2286 \u22c3 (i : \u03b9) (H : i \u2208 t), (prime_spectrum.basic_open (h' i)).val) \u2227 (\u2200 (i : \u03b9), i \u2208 t \u2192 \u2200 (j : \u03b9), j \u2208 t \u2192 a' i * h' j = h' i * a' j) \u2227 \u2200 (i : \u03b9), i \u2208 t \u2192 \u21d1((algebraic_geometry.Spec.structure_sheaf R).val.map (iDh' i).op) s = algebraic_geometry.structure_sheaf.const R (a' i) (h' i) (prime_spectrum.basic_open (h' i)) _ :=", "nl_statement_of_codex": "Let $R$ be a commutative ring. Let $U$ be an open subset of the prime spectrum of $R$. Let $s$ be a section of the structure sheaf on $U$. Let $t$ be a finite set and let $a,h:t\\to R$ be functions. Suppose that for each $i\\in t$ there is a basic open set $D(h(i))$ such that $D(h(i))\\to U$ and $U\\subset \\bigcup_{i\\in t}D(h(i))$. Suppose that for each $i\\in t$ the section $s$ is equal to the constant section $a("}
{"name": "adic_completion.range_eval", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/adic_completion.lean", "formal_statement": "theorem adic_completion.range_eval {R : Type*} [comm_ring R] (I : ideal R)\n\t(M : Type*) [add_comm_group M] [module R M] (n : \u2115) :\n\t(adic_completion.eval I M n).range = \u22a4 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $I$ an ideal of $R$, $M$ an $R$-module, and $n$ a natural number. Then the range of the map $adic\\_completion.eval\\_n$ is the whole of $M$."}
{"name": "monoid_hom.to_additive'_symm_apply_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/type_tags.lean", "formal_statement": "theorem monoid_hom.to_additive'_symm_apply_apply {\u03b1 : Type u} {\u03b2 : Type v}\n\t[mul_one_class \u03b1] [add_zero_class \u03b2] (\u1fb0 : additive \u03b1 \u2192+ \u03b2) (a : \u03b1) :\n\t\u21d1(\u21d1(monoid_hom.to_additive'.symm) \u1fb0) a = \u21d1multiplicative.of_add (\u21d1\u1fb0 (\u21d1additive.of_mul a)) :=", "nl_statement_of_codex": "Let $R$ be a ring and let $M$ be an $R$-module. Let $f:R\\to M$ be a ring homomorphism. Then $f(a)=f(1)a$ for all $a\\in R$."}
{"name": "has_compact_support.comp_closed_embedding", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/support.lean", "formal_statement": "theorem has_compact_support.comp_closed_embedding {\u03b1 \u03b1' \u03b2 : Type*}\n\t[topological_space \u03b1] [topological_space \u03b1'] [has_zero \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : has_compact_support f) {g : \u03b1' \u2192 \u03b1} (hg : closed_embedding g) :\n\thas_compact_support (f \u2218 g) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function with compact support. Let $g:X'\\to X$ be a closed embedding. Then $f\\circ g$ has compact support."}
{"name": "covby.is_atom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/atoms.lean", "formal_statement": "theorem covby.is_atom {\u03b1 : Type*} [partial_order \u03b1] [order_bot \u03b1] {a : \u03b1} :\n\t\u22a5 \u22d6 a \u2192 is_atom a :=", "nl_statement_of_codex": "If $a$ covers $\u22a5$, then $a$ is an atom."}
{"name": "finset.strongly_measurable_prod'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem finset.strongly_measurable_prod' {\u03b1 M : Type*} [comm_monoid M]\n\t[topological_space M] [has_continuous_mul M] {m : measurable_space \u03b1}\n\t{\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : finset \u03b9)\n\t(hf : \u2200 (i : \u03b9), i \u2208 s \u2192 measure_theory.strongly_measurable (f i)) :\n\tmeasure_theory.strongly_measurable (s.prod (\u03bb (i : \u03b9), f i)) :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid with a topology and continuous multiplication. Let $f_i:X\\to M$ be strongly measurable functions for $i\\in I$. Then the product function $f:X\\to M$ defined by $f(x)=\\prod_{i\\in I}f_i(x)$ is strongly measurable."}
{"name": "is_min_filter_dual_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/extr.lean", "formal_statement": "theorem is_min_filter_dual_iff {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {l : filter \u03b1} {a : \u03b1} :\n\tis_min_filter (\u21d1order_dual.to_dual \u2218 f) l a \u2194 is_max_filter f l a :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function between preordered sets. Then $a\\in A$ is a minimal element of $f(A)$ if and only if $f(a)$ is a maximal element of $f(A)$."}
{"name": "add_submonoid.sup_eq_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem add_submonoid.sup_eq_closure {M : Type*} [add_monoid M]\n\t(H K : add_submonoid M) :\n\tH \u2294 K = add_submonoid.closure (\u2191H + \u2191K) :=", "nl_statement_of_codex": "Let $H$ and $K$ be submonoids of an additive monoid $M$. Then $H\\oplus K$ is the closure of $H+K$."}
{"name": "decidable.mul_self_le_mul_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem decidable.mul_self_le_mul_self {\u03b1 : Type u} [ordered_semiring \u03b1]\n\t{a b : \u03b1} [decidable_rel has_le.le] (h1 : 0 \u2264 a) (h2 : a \u2264 b) :\n\ta * a \u2264 b * b :=", "nl_statement_of_codex": "Let $R$ be an ordered semiring. If $0\\leq a\\leq b$, then $a^2\\leq b^2$."}
{"name": "inner_product_space.to_dual_map_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/dual.lean", "formal_statement": "theorem inner_product_space.to_dual_map_apply (\ud835\udd5c : Type*) {E : Type*}\n\t[is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E] {x y : E} :\n\t\u21d1(\u21d1(inner_product_space.to_dual_map \ud835\udd5c E) x) y = has_inner.inner x y :=", "nl_statement_of_codex": "Let $E$ be an inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Then the inner product of $x$ and $y$ is equal to the dual of the dual of the map $x\\mapsto \\langle x,\\cdot\\rangle$ applied to $y$."}
{"name": "nat.gcd_dvd_gcd_mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.gcd_dvd_gcd_mul_left (m n k : \u2115) :\n\tm.gcd n \u2223 (k * m).gcd n :=", "nl_statement_of_codex": "$\\gcd(m,n)$ divides $\\gcd(km,n)$."}
{"name": "list.countp_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/count.lean", "formal_statement": "theorem list.countp_pos {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t{l : list \u03b1} :\n\t0 < list.countp p l \u2194 \u2203 (a : \u03b1) (H : a \u2208 l), p a :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a type $\u03b1$. Then $0<\\mathrm{countp}(p,l)$ if and only if there is an element $a$ of $l$ such that $p(a)$ holds."}
{"name": "nat.count_le_card", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/count.lean", "formal_statement": "theorem nat.count_le_card {p : \u2115 \u2192 Prop} [decidable_pred p]\n\t(hp : (set_of p).finite) (n : \u2115) :\n\tnat.count p n \u2264 hp.to_finset.card :=", "nl_statement_of_codex": "Let $p$ be a decidable predicate on $\\mathbb{N}$ and let $S$ be the set of all $n\\in\\mathbb{N}$ such that $p(n)$ holds. If $S$ is finite, then the number of elements of $S$ that are less than or equal to $n$ is less than or equal to the cardinality of $S$."}
{"name": "quotient_norm_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/quotient.lean", "formal_statement": "theorem quotient_norm_neg {M : Type*} [semi_normed_group M] {S : add_subgroup M}\n\t(x : M \u29f8 S) :\n\t\u2225-x\u2225 = \u2225x\u2225 :=", "nl_statement_of_codex": "Let $M$ be a semi-normed group and let $S$ be a subgroup of $M$. Then the norm of the negative of an element of $M/S$ is equal to the norm of the element."}
{"name": "bilin_form.is_Ortho_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/bilinear_form.lean", "formal_statement": "theorem bilin_form.is_Ortho_def {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {n : Type w} {B : bilin_form R M} {v : n \u2192 M} :\n\tB.is_Ortho v \u2194 \u2200 (i j : n), i \u2260 j \u2192 \u21d1B (v i) (v j) = 0 :=", "nl_statement_of_codex": "Let $B$ be a bilinear form on a module $M$ over a semiring $R$. Then $B$ is orthogonal if and only if $B(v_i,v_j)=0$ for all $i\\neq j$."}
{"name": "order_add_monoid_hom.add_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/hom/monoid.lean", "formal_statement": "theorem order_add_monoid_hom.add_apply {\u03b1 \u03b2 : Type*} [ordered_add_comm_monoid \u03b1]\n\t[ordered_add_comm_monoid \u03b2] (f g : \u03b1 \u2192+o \u03b2) (a : \u03b1) :\n\t\u21d1(f + g) a = \u21d1f a + \u21d1g a :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be order-preserving monoid homomorphisms. Then $(f+g)(a)=f(a)+g(a)$."}
{"name": "box_integral.box.disjoint_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/box/basic.lean", "formal_statement": "theorem box_integral.box.disjoint_coe {\u03b9 : Type*} {I J : box_integral.box \u03b9} :\n\tdisjoint \u2191I \u2191J \u2194 disjoint \u2191I \u2191J :=", "nl_statement_of_codex": "Let $I$ and $J$ be two boxes. Then $I$ and $J$ are disjoint if and only if $I$ and $J$ are disjoint."}
{"name": "diff_cont_on_cl.sub_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/diff_on_int_cont.lean", "formal_statement": "theorem diff_cont_on_cl.sub_const {\ud835\udd5c E F : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_group E] [normed_group F] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} {s : set E} (hf : diff_cont_on_cl \ud835\udd5c f s) ( : F) :\n\tdiff_cont_on_cl \ud835\udd5c (\u03bb (x : E), f x - c) s :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $\\mathbb{K}$. Let $f:E\\to F$ be differentiable on a closed set $s\\subset E$. Then $g:E\\to F$ defined by $g(x)=f(x)-c$ is differentiable on $s$."}
{"name": "simple_graph.coloring.mem_color_class", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/coloring.lean", "formal_statement": "theorem simple_graph.coloring.mem_color_class {V : Type u} {G : simple_graph V}\n\t{\u03b1 : Type v} (C : G.coloring \u03b1) (v : V) :\n\tv \u2208 C.color_class (\u21d1C v) :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $C$ be a coloring of $G$. Then $v\\in C.color\\_class(C(v))$."}
{"name": "rat.mk_eq_div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/defs.lean", "formal_statement": "theorem rat.mk_eq_div (n d : \u2124) :\n\trat.mk n d = \u2191n / \u2191d :=", "nl_statement_of_codex": "$\\frac{n}{d}=\\frac{n}{d}$."}
{"name": "dlist.to_list_cons", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/data/dlist.lean", "formal_statement": "theorem dlist.to_list_cons {\u03b1 : Type u} (x : \u03b1) (l : dlist \u03b1) :\n\t(dlist.cons x l).to_list = x :: l.to_list :=", "nl_statement_of_codex": "The list obtained by prepending an element $x$ to a dlist $l$ is the list obtained by prepending $x$ to the list obtained by converting $l$ to a list."}
{"name": "lp.coe_lp_submodule", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lp_space.lean", "formal_statement": "theorem lp.coe_lp_submodule {\u03b1 E : \u03b1 \u2192 Type*} {p : ennreal}\n\t[\u03a0 (i : \u03b1), normed_group (E i)] {\ud835\udd5c : Type*} [normed_field \ud835\udd5c]\n\t[\u03a0 (i : \u03b1), normed_space \ud835\udd5c (E i)] :\n\t(lp_submodule E p \ud835\udd5c).to_add_subgroup = lp E p :=", "nl_statement_of_codex": "Let $E$ be a family of normed spaces over a normed field $K$. Then the $p$-normed space $l^p(E)$ is a subspace of the direct sum $\\bigoplus_{i\\in I}E_i$."}
{"name": "is_add_left_regular.of_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/regular/basic.lean", "formal_statement": "theorem is_add_left_regular.of_add {R : Type*} {a b : R} [add_semigroup R]\n\t(ab : is_add_left_regular (a + b)) :\n\tis_add_left_regular b :=", "nl_statement_of_codex": "Let $R$ be an additive semigroup and let $a, b\\in R$. If $a+b$ is left regular, then $b$ is left regular."}
{"name": "simple_graph.subgraph.mem_edge_set", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/subgraph.lean", "formal_statement": "theorem simple_graph.subgraph.mem_edge_set {V : Type u} {G : simple_graph V}\n\t{G' : G.subgraph} {v w : V} :\n\t\u27e6(v, w)\u27e7 \u2208 G'.edge_set \u2194 G'.adj v w :=", "nl_statement_of_codex": "Let $G$ be a simple graph and let $G'$ be a subgraph of $G$. Then $(v,w)\\in G'$ if and only if $v$ is adjacent to $w$ in $G'$."}
{"name": "unique_diff_within_at_inter'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean", "formal_statement": "theorem unique_diff_within_at_inter' {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {x : E} {s t : set E}\n\t(ht : t \u2208 nhds_within x s) :\n\tunique_diff_within_at \ud835\udd5c (s \u2229 t) x \u2194 unique_diff_within_at \ud835\udd5c s x :=", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$. Let $x\\in E$ and let $s,t\\subset E$ be such that $t\\in\\mathcal{N}_x(s)$. Then $x$ has a unique derivative on $s\\cap t$ if and only if $x$ has a unique derivative on $s$."}
{"name": "equiv.perm.sign_prod_list_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/sign.lean", "formal_statement": "theorem equiv.perm.sign_prod_list_swap {\u03b1 : Type u} [decidable_eq \u03b1] [fintype \u03b1]\n\t{l : list (equiv.perm \u03b1)} (hl : \u2200 (g : equiv.perm \u03b1), g \u2208 l \u2192 g.is_swap) :\n\t\u21d1equiv.perm.sign l.prod = (-1) ^ l.length :=", "nl_statement_of_codex": "Let $l$ be a list of permutations of a finite set $X$. If each permutation in $l$ is a transposition, then the sign of the product of the permutations in $l$ is $(-1)^{|l|}$."}
{"name": "local_equiv.copy_source", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/local_equiv.lean", "formal_statement": "theorem local_equiv.copy_source {\u03b1 \u03b2 : Type*} (e : local_equiv \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2)\n\t(hf : \u21d1e = f) (g : \u03b2 \u2192 \u03b1) (hg : \u21d1(e.symm) = g) (s : set \u03b1) (hs : e.source = s)\n\t(t : set \u03b2) (ht : e.target = t) :\n\t(e.copy f hf g hg s hs t ht).source = s :=", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Let $f:X\\to Y$ and $g:Y\\to X$ be functions such that $e=f$ and $e^{-1}=g$. Let $U\\subset X$ and $V\\subset Y$ be open sets such that $e(U)=V$. Then the local homeomorphism $e':U\\to V$ defined by $e'=f$ and $e'^{-1}=g$ has domain $U$."}
{"name": "int.dvd_lcm_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/gcd.lean", "formal_statement": "theorem int.dvd_lcm_right (i j : \u2124) :\n\tj \u2223 \u2191(i.lcm j) :=", "nl_statement_of_codex": "For all integers $i$ and $j$, $j$ divides the least common multiple of $i$ and $j$."}
{"name": "category_theory.limits.biprod.is_iso_inl_iff_id_eq_fst_comp_inl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.biprod.is_iso_inl_iff_id_eq_fst_comp_inl\n\t{C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_zero_morphisms C] (X Y : C)\n\t[category_theory.limits.has_binary_biproduct X Y] :\n\tcategory_theory.is_iso category_theory.limits.biprod.inl \u2194 \ud835\udfd9 (X \u229e Y) = category_theory.limits.biprod.fst \u226b category_theory.limits.biprod.inl :=", "nl_statement_of_codex": "The morphism $inl:X\\to X\\oplus Y$ is an isomorphism if and only if the identity morphism on $X\\oplus Y$ is equal to the composition of the morphism $fst:X\\oplus Y\\to X$ with the morphism $inl:X\\to X\\oplus Y$."}
{"name": "category_theory.limits.concrete.wide_pullback_ext'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/concrete_category.lean", "formal_statement": "theorem category_theory.limits.concrete.wide_pullback_ext' {C : Type u}\n\t[category_theory.category C] [category_theory.concrete_category C] {B : C}\n\t{\u03b9 : Type w} [nonempty \u03b9] {X : \u03b9 \u2192 C} (f : \u03a0 (j : \u03b9), X j \u27f6 B)\n\t[category_theory.limits.has_wide_pullback B X f]\n\t[category_theory.limits.preserves_limit (category_theory.limits.wide_pullback_shape.wide_cospan B X f) (category_theory.forget C)]\n\t(x y : \u21a5(category_theory.limits.wide_pullback B X f))\n\t(h : \u2200 (j : \u03b9), \u21d1(category_theory.limits.wide_pullback.\u03c0 f j) x = \u21d1(category_theory.limits.wide_pullback.\u03c0 f j) y) :\n\tx = y :=", "nl_statement_of_codex": "Let $C$ be a category with concrete objects. Let $B$ be an object of $C$ and let $X$ be a functor from a nonempty set $\\iota$ to $C$. Let $f$ be a natural transformation from $X$ to the constant functor at $B$. Suppose that $C$ has wide pullbacks and that the forgetful functor from $C$ to $Set$ preserves limits. Let $x$ and $y$ be elements of the wide pullback of $f$. Suppose that for each $j\\in\\iota$, the projection of $x$ and $y$ onto the $j$th component of the wide pullback are equal. Then"}
{"name": "computation.think_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.think_mem {\u03b1 : Type u} {s : computation \u03b1} {a : \u03b1} :\n\ta \u2208 s \u2192 a \u2208 s.think :=", "nl_statement_of_codex": "If $a$ is in the computation $s$, then $a$ is in the set of values of $s$."}
{"name": "smooth_bump_covering.sum_to_smooth_partition_of_unity_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/partition_of_unity.lean", "formal_statement": "theorem smooth_bump_covering.sum_to_smooth_partition_of_unity_eq {\u03b9 : Type u\u03b9}\n\t{E : Type uE} [normed_group E] [normed_space \u211d E] [finite_dimensional \u211d E]\n\t{H : Type uH} [topological_space H] {I : model_with_corners \u211d E H}\n\t{M : Type uM} [topological_space M] [charted_space H M]\n\t[smooth_manifold_with_corners I M] {s : set M}\n\t(fs : smooth_bump_covering \u03b9 I M s) [t2_space M] (x : M) :\n\tfinsum (\u03bb (i : \u03b9), \u21d1(\u21d1(fs.to_smooth_partition_of_unity) i) x) = 1 - finprod (\u03bb (i : \u03b9), 1 - \u21d1(\u21d1fs i) x) :=", "nl_statement_of_codex": "Let $M$ be a smooth manifold with corners. Let $s$ be a subset of $M$. Let $f_i:M\\to\\mathbb{R}$ be a smooth bump function for each $i\\in I$. Then $\\sum_{i\\in I}f_i=1$ if and only if $\\prod_{i\\in I}(1-f_i)=0$."}
{"name": "non_unital_ring_hom.coe_to_add_monoid_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/ring.lean", "formal_statement": "theorem non_unital_ring_hom.coe_to_add_monoid_hom {\u03b1 \u03b2 : Type*}\n\t{r\u03b1 : non_unital_non_assoc_semiring \u03b1} {r\u03b2 : non_unital_non_assoc_semiring \u03b2}\n\t(f : \u03b1 \u2192\u2099+* \u03b2) :\n\t\u21d1(f.to_add_monoid_hom) = \u21d1f :=", "nl_statement_of_codex": "Let $f:R\\to S$ be a non-unital ring homomorphism. Then $f$ is a non-unital additive monoid homomorphism."}
{"name": "bounded_lattice_hom.as_boolring_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/boolean_ring.lean", "formal_statement": "theorem bounded_lattice_hom.as_boolring_id {\u03b1 : Type*} [boolean_algebra \u03b1] :\n\t(bounded_lattice_hom.id \u03b1).as_boolring = ring_hom.id (as_boolring \u03b1) :=", "nl_statement_of_codex": "The identity function on a boolean algebra is the identity function on the corresponding boolean ring."}
{"name": "padic_val_nat_primes", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/padics/padic_val.lean", "formal_statement": "theorem padic_val_nat_primes {p q : \u2115} [p_prime : fact (nat.prime p)]\n\t[q_prime : fact (nat.prime q)] (neq : p \u2260 q) :\n\tpadic_val_nat p q = 0 :=", "nl_statement_of_codex": "Let $p$ and $q$ be distinct primes. Then $v_p(q)=0$."}
{"name": "complex.has_fpower_series_on_ball_of_differentiable_off_countable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/cauchy_integral.lean", "formal_statement": "theorem complex.has_fpower_series_on_ball_of_differentiable_off_countable\n\t{E : Type u} [normed_group E] [normed_space \u2102 E] [complete_space E]\n\t{R : nnreal} { : \u2102} {f : \u2102 \u2192 E} {s : set \u2102} (hs : s.countable)\n\t(hc : continuous_on f (metric.closed_ball c \u2191R))\n\t(hd : \u2200 (z : \u2102), z \u2208 metric.ball c \u2191R \\ s \u2192 differentiable_at \u2102 f z)\n\t(hR : 0 < R) :\n\thas_fpower_series_on_ball f (cauchy_power_series f c \u2191R) c \u2191R :=", "nl_statement_of_codex": "Let $E$ be a complete normed space over $\\mathbb{C}$. Let $f:B(c,R)\\to E$ be a continuous function on the closed ball $B(c,R)$ and differentiable on the open ball $B(c,R)\\setminus S$ where $S$ is a countable set. Then $f$ has a power series expansion on $B(c,R)$."}
{"name": "fg_of_ker_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem fg_of_ker_bot {R M P : Type*} [ring R] [add_comm_group M]\n\t[add_comm_group P] [module R M] [module R P] [is_noetherian R P]\n\t{N : submodule R M} (f : M \u2192\u2097[R] P) (hf : f.ker = \u22a5) :\n\tN.fg :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ and $P$ be $R$-modules, and $N$ be a submodule of $M$. If $f:M\\to P$ is a linear map such that $\\ker f=\\{0\\}$, then $N$ is finitely generated."}
{"name": "list.nat.antidiagonal_tuple_pairwise_pi_lex", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/tuple/nat_antidiagonal.lean", "formal_statement": "theorem list.nat.antidiagonal_tuple_pairwise_pi_lex (k n : \u2115) :\n\tlist.pairwise (pi.lex has_lt.lt (\u03bb (_x : fin k), has_lt.lt)) (list.nat.antidiagonal_tuple k n) :=", "nl_statement_of_codex": "The antidiagonal tuple of length $k$ and width $n$ is pairwise $\\pi$-lexicographically ordered."}
{"name": "box_integral.box.empty_ne_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/box_integral/box/basic.lean", "formal_statement": "theorem box_integral.box.empty_ne_coe {\u03b9 : Type*} (I : box_integral.box \u03b9) :\n\t\u2205 \u2260 \u2191I :=", "nl_statement_of_codex": "The empty set is not equal to the box $I$."}
{"name": "ereal.add_lt_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ereal.lean", "formal_statement": "theorem ereal.add_lt_add {x y z t : ereal} (h1 : x < y) (h2 : z < t) :\n\tx + z < y + t :=", "nl_statement_of_codex": "If $x<y$ and $z<t$, then $x+z<y+t$."}
{"name": "affine_map.pi_line_map_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/affine_map.lean", "formal_statement": "theorem affine_map.pi_line_map_apply {k : Type*} [ring k] {\u03b9 V P : \u03b9 \u2192 Type*2}\n\t[\u03a0 (i : \u03b9), add_comm_group (V i)] [\u03a0 (i : \u03b9), module k (V i)]\n\t[\u03a0 (i : \u03b9), add_torsor (V i) (P i)] (f g : \u03a0 (i : \u03b9), P i) ( : k) (i : \u03b9) :\n\t\u21d1(affine_map.line_map f g) c i = \u21d1(affine_map.line_map (f i) (g i)) c :=", "nl_statement_of_codex": "Let $V_i$ be a vector space over a field $k$ for each $i\\in I$. Let $f,g:I\\to V_i$ be two maps. Then the map $f+cg:I\\to V_i$ is given by $(f+cg)(i)=f(i)+cg(i)$."}
{"name": "mvqpf.liftr_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/qpf/multivariate/basic.lean", "formal_statement": "theorem mvqpf.liftr_iff {n : \u2115} {F : typevec n \u2192 Type*} [mvfunctor F]\n\t[q : mvqpf F] {\u03b1 : typevec n} (r : \u03a0 \u2983i : fin2 n\u2984, \u03b1 i \u2192 \u03b1 i \u2192 Prop)\n\t(x y : F \u03b1) :\n\tmvfunctor.liftr r x y \u2194 \u2203 (a : (mvqpf.P F).A) (f\u2080 f\u2081 : ((mvqpf.P F).B a).arrow \u03b1), x = mvqpf.abs \u27e8a, f\u2080\u27e9 \u2227 y = mvqpf.abs \u27e8a, f\u2081\u27e9 \u2227 \u2200 (i : fin2 n) (j : (mvqpf.P F).B a i), r (f\u2080 i j) (f\u2081 i j) :=", "nl_statement_of_codex": "Let $F$ be a multivariate functor. Then $x, y\\in F(\\alpha)$ are related by $r$ if and only if there exist $a\\in A$, $f_0, f_1:B(a)\\to \\alpha$ such that $x=\\mathrm{abs}(a, f_0)$, $y=\\mathrm{abs}(a, f_1)$ and $r(f_0(i, j), f_1(i, j))$ for all $i\\in \\mathrm{fin2}(n)$ and $j\\in B(a)_i$."}
{"name": "left_invariant_derivation.coe_fn_add_monoid_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/algebra/left_invariant_derivation.lean", "formal_statement": "theorem left_invariant_derivation.coe_fn_add_monoid_hom_apply {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{H : Type*} [topological_space H] (I : model_with_corners \ud835\udd5c E H) (G : Type*)\n\t[topological_space G] [charted_space H G] [monoid G] [has_smooth_mul I G]\n\t(X : left_invariant_derivation I G)\n\t(\u1fb0 : cont_mdiff_map I (model_with_corners_self \ud835\udd5c \ud835\udd5c) G \ud835\udd5c \u22a4) :\n\t\u21d1(left_invariant_derivation.coe_fn_add_monoid_hom I G) X \u1fb0 = X.to_derivation.to_linear_map.to_fun \u1fb0 :=", "nl_statement_of_codex": "Let $I$ be a model with corners, $G$ a topological group, $X$ a left-invariant derivation on $G$, and $\\alpha$ a smooth map from $G$ to $\\mathbb{R}$. Then the left-invariant derivation $X$ applied to $\\alpha$ is equal to the derivative of $\\alpha$ in the direction of $X$."}
{"name": "linear_isometry_equiv.coe_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem linear_isometry_equiv.coe_coe {R R\u2082 E E\u2082 : Type*} [semiring R]\n\t[semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n\t[ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [semi_normed_group E] [semi_normed_group E\u2082]\n\t[module R E] [module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\t\u21d1\u2191e = \u21d1e :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $\\sigma_{12}:R\\to R'$ and $\\sigma_{21}:R'\\to R$ be ring homomorphisms such that $\\sigma_{12}\\circ\\sigma_{21}=\\sigma_{21}\\circ\\sigma_{12}=\\mathrm{id}$. Let $E$ and $E'$ be semi-normed groups over $R$ and $R'$, respectively. Then the map $\\sigma_{12}$ induces a linear isometry $\\sigma_{12}^*:E\\to E'$."}
{"name": "category_theory.eq_of_comp_left_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/basic.lean", "formal_statement": "theorem category_theory.eq_of_comp_left_eq {C : Type u}\n\t[category_theory.category C] {X Y : C} {f g : X \u27f6 Y}\n\t(w : \u2200 {Z : C} (h : Y \u27f6 Z), f \u226b h = g \u226b h) :\n\tf = g :=", "nl_statement_of_codex": "Let $C$ be a category and let $f,g:X\\to Y$ be morphisms in $C$. If $f\\circ h=g\\circ h$ for all morphisms $h:Y\\to Z$, then $f=g$."}
{"name": "prod.is_max_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/max.lean", "formal_statement": "theorem prod.is_max_iff {\u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] {x : \u03b1 \u00d7 \u03b2} :\n\tis_max x \u2194 is_max x.fst \u2227 is_max x.snd :=", "nl_statement_of_codex": "Let $x=(x_1,x_2)$ be an element of $\\mathbb{R}^2$. Then $x$ is a maximum if and only if $x_1$ is a maximum and $x_2$ is a maximum."}
{"name": "linear_map.is_adjoint_pair_iff_comp_eq_compl\u2082", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/sesquilinear_form.lean", "formal_statement": "theorem linear_map.is_adjoint_pair_iff_comp_eq_compl\u2082 {R M M\u2081 : Type*}\n\t[comm_semiring R] [add_comm_monoid M] [module R M] [add_comm_monoid M\u2081]\n\t[module R M\u2081] {B : M \u2192\u2097[R] M \u2192\u2097[R] R} {B' : M\u2081 \u2192\u2097[R] M\u2081 \u2192\u2097[R] R}\n\t{f : M \u2192\u2097[R] M\u2081} {g : M\u2081 \u2192\u2097[R] M} :\n\tB.is_adjoint_pair B' f g \u2194 B'.comp f = B.compl\u2082 g :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ and $M_1$ be $R$-modules. Let $B:M\\times M\\to R$ and $B':M_1\\times M_1\\to R$ be bilinear maps. Let $f:M\\to M_1$ and $g:M_1\\to M$ be linear maps. Then $B$ and $B'$ are adjoint if and only if $B'(f(x),y)=B(x,g(y))$ for all $x\\in M$ and $y\\in M_1$."}
{"name": "category_theory.subobject.factors_right_of_factors_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/factor_thru.lean", "formal_statement": "theorem category_theory.subobject.factors_right_of_factors_add {C : Type u\u2081}\n\t[category_theory.category C] [category_theory.preadditive C] {X Y : C}\n\t{P : category_theory.subobject Y} (f g : X \u27f6 Y) (w : P.factors (f + g))\n\t(wf : P.factors f) :\n\tP.factors g :=", "nl_statement_of_codex": "Let $C$ be a preadditive category. Let $X, Y$ be objects of $C$ and let $P$ be a subobject of $Y$. Let $f, g:X\\to Y$ be morphisms. If $P$ factors $f+g$ and $P$ factors $f$, then $P$ factors $g$."}
{"name": "omega_complete_partial_order.\u03c9Sup_le_\u03c9Sup_of_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/omega_complete_partial_order.lean", "formal_statement": "theorem omega_complete_partial_order.\u03c9Sup_le_\u03c9Sup_of_le {\u03b1 : Type u}\n\t[omega_complete_partial_order \u03b1] {c\u2080 c\u2081 : omega_complete_partial_order.chain \u03b1}\n\t(h : c\u2080 \u2264 c\u2081) :\n\tomega_complete_partial_order.\u03c9Sup c\u2080 \u2264 omega_complete_partial_order.\u03c9Sup c\u2081 :=", "nl_statement_of_codex": "Let $c_0$ and $c_1$ be omega-chains in an omega-complete partial order. If $c_0\\leq c_1$, then $\\omega$-sup$(c_0)\\leq\\omega$-sup$(c_1)$."}
{"name": "metric.cthickening_subset_thickening", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_distance.lean", "formal_statement": "theorem metric.cthickening_subset_thickening {\u03b1 : Type u}\n\t[pseudo_emetric_space \u03b1] {\u03b4\u2081 : nnreal} {\u03b4\u2082 : \u211d} (hlt : \u2191\u03b4\u2081 < \u03b4\u2082) (E : set \u03b1) :\n\tmetric.cthickening \u2191\u03b4\u2081 E \u2286 metric.thickening \u03b4\u2082 E :=", "nl_statement_of_codex": "Let $E$ be a subset of a pseudo-metric space $(X,d)$. Then $E^{\\delta_1} \\subset E^{\\delta_2}$ if $\\delta_1 < \\delta_2$."}
{"name": "monoid_with_zero_hom.congr_arg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem monoid_with_zero_hom.congr_arg {M N : Type*} [mul_zero_one_class M]\n\t[mul_zero_one_class N] (f : M \u2192*\u2080 N) {x y : M} (h : x = y) :\n\t\u21d1f x = \u21d1f y :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with zero. Let $f:M\\to N$ be a monoid homomorphism. Then $f(x)=f(y)$ for all $x,y\\in M$."}
{"name": "pnat.div_add_mod'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pnat/basic.lean", "formal_statement": "theorem pnat.div_add_mod' (m k : \u2115+) :\n\tm.div k * \u2191k + \u2191(m.mod k) = \u2191m :=", "nl_statement_of_codex": "For any positive integers $m$ and $k$, we have $m=k\\cdot \\lfloor m/k\\rfloor + m\\bmod k$."}
{"name": "measure_theory.L2.inner_indicator_const_Lp_eq_inner_set_integral", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/l2_space.lean", "formal_statement": "theorem measure_theory.L2.inner_indicator_const_Lp_eq_inner_set_integral\n\t{\u03b1 E : Type*} (\ud835\udd5c : Type*) [is_R_or_C \ud835\udd5c] [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} [inner_product_space \ud835\udd5c E] {s : set \u03b1}\n\t[complete_space E] [normed_space \u211d E] (hs : measurable_set s) (h\u03bcs : \u21d1\u03bc s \u2260 \u22a4)\n\t( : E) (f : \u21a5(measure_theory.Lp E 2 \u03bc)) :\n\thas_inner.inner (measure_theory.indicator_const_Lp 2 hs h\u03bcs c) f = has_inner.inner c (\u222b (x : \u03b1) in s, \u21d1f x \u2202\u03bc) :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ or $\\mathbb{C}$ and let $\\mu$ be a measure on $E$. Let $s$ be a measurable set such that $\\mu(s)<\\infty$. Then for any $c\\in E$ and any $f\\in L^2(E,\\mu)$, we have $\\langle c,\\int_s f\\,d\\mu\\rangle=\\langle c,\\chi_s\\rangle\\langle f,\\chi_s\\rangle$."}
{"name": "ordinal.mex_le_lsub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.mex_le_lsub {\u03b9 : Type*} (f : \u03b9 \u2192 ordinal) :\n\tordinal.mex f \u2264 ordinal.lsub f :=", "nl_statement_of_codex": "The minimum of the ordinals $f(i)$ is less than or equal to the supremum of the ordinals $f(i)$."}
{"name": "order_iso.is_lub_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem order_iso.is_lub_image {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] (f : \u03b1 \u2243o \u03b2) {s : set \u03b1} {x : \u03b2} :\n\tis_lub (\u21d1f '' s) x \u2194 is_lub s (\u21d1(f.symm) x) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an order isomorphism. Then $f$ maps the least upper bound of $S\\subset A$ to the least upper bound of $f(S)$."}
{"name": "zsqrtd.one_re", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/basic.lean", "formal_statement": "theorem zsqrtd.one_re {d : \u2124} :\n\t1.re = 1 :=", "nl_statement_of_codex": "The real part of $1$ is $1$."}
{"name": "psigma.ext_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/sigma/basic.lean", "formal_statement": "theorem psigma.ext_iff {\u03b1 : Sort u_1} {\u03b2 : \u03b1 \u2192 Sort u_2} {x\u2080 x\u2081 : psigma \u03b2} :\n\tx\u2080 = x\u2081 \u2194 x\u2080.fst = x\u2081.fst \u2227 x\u2080.snd == x\u2081.snd :=", "nl_statement_of_codex": "Two pairs $(x_0,y_0)$ and $(x_1,y_1)$ are equal if and only if $x_0=x_1$ and $y_0=y_1$."}
{"name": "int.le_of_sub_nonpos", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.le_of_sub_nonpos {a b : \u2124} (h : a - b \u2264 0) :\n\ta \u2264 b :=", "nl_statement_of_codex": "If $a-b\\leq 0$, then $a\\leq b$."}
{"name": "real.inv_sign", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/sign.lean", "formal_statement": "theorem real.inv_sign (r : \u211d) :\n\t(r.sign)\u207b\u00b9 = r.sign :=", "nl_statement_of_codex": "The inverse of the sign of a real number is the sign of the real number."}
{"name": "part.some_inj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.some_inj {\u03b1 : Type*} {a b : \u03b1} :\n\tpart.some a = part.some b \u2194 a = b :=", "nl_statement_of_codex": "Let $a, b$ be elements of a type $\u03b1$. Then $part.some a = part.some b$ if and only if $a = b$."}
{"name": "real.rpow_lt_one_iff_of_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem real.rpow_lt_one_iff_of_pos {x y : \u211d} (hx : 0 < x) :\n\tx ^ y < 1 \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y :=", "nl_statement_of_codex": "Let $x,y\\in\\mathbb{R}$. If $x>0$, then $x^y<1$ if and only if $1<x$ and $y<0$ or $x<1$ and $y>0$."}
{"name": "is_square_mul_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/parity.lean", "formal_statement": "theorem is_square_mul_self {\u03b1 : Type*} [has_mul \u03b1] (m : \u03b1) :\n\tis_square (m * m) :=", "nl_statement_of_codex": "$m^2$ is a square."}
{"name": "is_left_regular.pow_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/regular/pow.lean", "formal_statement": "theorem is_left_regular.pow_iff {R : Type*} {a : R} [monoid R] {n : \u2115}\n\t(n0 : 0 < n) :\n\tis_left_regular (a ^ n) \u2194 is_left_regular a :=", "nl_statement_of_codex": "Let $R$ be a monoid and let $a\\in R$. Then $a$ is left regular if and only if $a^n$ is left regular for all $n>0$."}
{"name": "submodule.dual_restrict_ker_eq_dual_annihilator", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/dual.lean", "formal_statement": "theorem submodule.dual_restrict_ker_eq_dual_annihilator {R : Type u}\n\t{M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M]\n\t(W : submodule R M) :\n\tW.dual_restrict.ker = W.dual_annihilator :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, and $W$ a submodule of $M$. Then the kernel of the dual of the restriction of $M$ to $W$ is equal to the annihilator of $W$."}
{"name": "euclidean_geometry.left_dist_ne_zero_of_angle_eq_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/euclidean/basic.lean", "formal_statement": "theorem euclidean_geometry.left_dist_ne_zero_of_angle_eq_pi {V P : Type*}\n\t[inner_product_space \u211d V] [metric_space P] [normed_add_torsor V P]\n\t{p1 p2 p3 : P} (h : euclidean_geometry.angle p1 p2 p3 = real.pi) :\n\thas_dist.dist p1 p2 \u2260 0 :=", "nl_statement_of_codex": "Let $p_1, p_2, p_3$ be points in a normed space $V$. If the angle between $p_1p_2$ and $p_2p_3$ is $\\pi$, then the distance between $p_1$ and $p_2$ is nonzero."}
{"name": "non_unital_ring_hom.coe_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/ring.lean", "formal_statement": "theorem non_unital_ring_hom.coe_zero {\u03b1 \u03b2 : Type*}\n\t[r\u03b1 : non_unital_non_assoc_semiring \u03b1] [r\u03b2 : non_unital_non_assoc_semiring \u03b2] :\n\t\u21d10 = 0 :=", "nl_statement_of_codex": "The zero of a non-unital ring is mapped to the zero of the codomain."}
{"name": "nnreal.rpow_nat_cast", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem nnreal.rpow_nat_cast (x : nnreal) (n : \u2115) :\n\tx ^ \u2191n = x ^ n :=", "nl_statement_of_codex": "For any nonnegative real number $x$ and any natural number $n$, $x^n=x^{(n)}$."}
{"name": "add_action.orbit_eq_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/basic.lean", "formal_statement": "theorem add_action.orbit_eq_iff {\u03b1 : Type u} {\u03b2 : Type v} [add_group \u03b1]\n\t[add_action \u03b1 \u03b2] {a b : \u03b2} :\n\tadd_action.orbit \u03b1 a = add_action.orbit \u03b1 b \u2194 a \u2208 add_action.orbit \u03b1 b :=", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then $G\\cdot x=G\\cdot y$ if and only if $x\\in G\\cdot y$."}
{"name": "seminorm_family.with_seminorms_iff_nhds_eq_infi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/with_seminorms.lean", "formal_statement": "theorem seminorm_family.with_seminorms_iff_nhds_eq_infi {\ud835\udd5c E \u03b9 : Type*}\n\t[normed_field \ud835\udd5c] [add_comm_group E] [module \ud835\udd5c E] [topological_space E]\n\t[topological_add_group E] [nonempty \u03b9] (p : seminorm_family \ud835\udd5c E \u03b9) :\n\twith_seminorms p \u2194 nhds 0 = \u2a05 (i : \u03b9), filter.comap \u21d1(p i) (nhds 0) :=", "nl_statement_of_codex": "Let $E$ be a topological vector space over a normed field $K$. Then the following are equivalent:\n(1) $E$ is a topological vector space with respect to the family of seminorms $p_i$;\n(2) the topology on $E$ is the finest topology making all the $p_i$ continuous."}
{"name": "set.forall_not_of_sep_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.forall_not_of_sep_empty {\u03b1 : Type u} {s : set \u03b1} {p : \u03b1 \u2192 Prop}\n\t(H : {x \u2208 s | p x} = \u2205) (x : \u03b1) :\n\tx \u2208 s \u2192 \u00acp x :=", "nl_statement_of_codex": "Let $s$ be a set and let $p$ be a property. If $s$ has no elements with property $p$, then every element of $s$ does not have property $p$."}
{"name": "part_enat.coe_add_get", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/part_enat.lean", "formal_statement": "theorem part_enat.coe_add_get {x : \u2115} {y : part_enat} (h : (\u2191x + y).dom) :\n\t(\u2191x + y).get h = x + y.get _ :=", "nl_statement_of_codex": "Let $x$ be a natural number and let $y$ be a partial natural number. Then $(x+y)$ is defined and $(x+y) = x+y$."}
{"name": "quadratic_form.pos_def.smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/quadratic_form/basic.lean", "formal_statement": "theorem quadratic_form.pos_def.smul {M : Type*} [add_comm_monoid M] {R : Type*}\n\t[linear_ordered_comm_ring R] [module R M] {Q : quadratic_form R M}\n\t(h : Q.pos_def) {a : R} (a_pos : 0 < a) :\n\t(a \u2022 Q).pos_def :=", "nl_statement_of_codex": "Let $Q$ be a positive definite quadratic form on $M$ over $R$. Then $aQ$ is positive definite for any $a>0$."}
{"name": "gaussian_int.coe_nat_abs_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/zsqrtd/gaussian_int.lean", "formal_statement": "theorem gaussian_int.coe_nat_abs_norm (x : gaussian_int) :\n\t\u2191((zsqrtd.norm x).nat_abs) = zsqrtd.norm x :=", "nl_statement_of_codex": "The norm of a Gaussian integer is equal to the absolute value of the norm of the Gaussian integer."}
{"name": "measure_theory.ae_of_forall_measure_lt_top_ae_restrict", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.ae_of_forall_measure_lt_top_ae_restrict {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measure_theory.sigma_finite \u03bc] (P : \u03b1 \u2192 Prop)\n\t(h : \u2200 (s : set \u03b1), measurable_set s \u2192 \u21d1\u03bc s < \u22a4 \u2192 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict s, P x)) :\n\t\u2200\u1d50 (x : \u03b1) \u2202\u03bc, P x :=", "nl_statement_of_codex": "Let $P$ be a property of elements of a measurable space $(X,\\mathcal{A})$. Suppose that for every measurable set $A\\in\\mathcal{A}$ with $\\mu(A)<\\infty$, the set $\\{x\\in A: P(x)\\}$ is measurable and has measure $\\mu(A)$. Then the set $\\{x\\in X: P(x)\\}$ is measurable and has measure $\\mu(X)$."}
{"name": "set.image_const_mul_interval", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean", "formal_statement": "theorem set.image_const_mul_interval {k : Type u} [linear_ordered_field k]\n\t(a b c : k) :\n\t(\u03bb (x : k), a * x) '' set.interval b c = set.interval (a * b) (a * c) :=", "nl_statement_of_codex": "Let $a,b,c$ be real numbers. Then the image of the interval $[b,c]$ under the function $x\\mapsto ax$ is the interval $[ab,ac]$."}
{"name": "algebraic_geometry.Spec.to_LocallyRingedSpace_obj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/Spec.lean", "formal_statement": "theorem algebraic_geometry.Spec.to_LocallyRingedSpace_obj (R : CommRing\u1d52\u1d56) :\n\talgebraic_geometry.Spec.to_LocallyRingedSpace.obj R = algebraic_geometry.Spec.LocallyRingedSpace_obj (opposite.unop R) :=", "nl_statement_of_codex": "The locally ringed space associated to a commutative ring $R$ is the same as the locally ringed space associated to the opposite ring $R^{\\text{op}}$."}
{"name": "int.gcd_greatest", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/gcd.lean", "formal_statement": "theorem int.gcd_greatest {a b d : \u2124} (hd_pos : 0 \u2264 d) (hda : d \u2223 a)\n\t(hdb : d \u2223 b) (hd : \u2200 (e : \u2124), e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) :\n\td = \u2191(a.gcd b) :=", "nl_statement_of_codex": "Let $a,b,d\\in\\mathbb{Z}$. If $d$ is nonnegative and divides $a$ and $b$, and if $d$ is the greatest integer that divides $a$ and $b$, then $d=\\gcd(a,b)$."}
{"name": "submodule.quotient_quotient_equiv_quotient_aux_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/isomorphisms.lean", "formal_statement": "theorem submodule.quotient_quotient_equiv_quotient_aux_mk {R M : Type*} [ring R]\n\t[add_comm_group M] [module R M] (S T : submodule R M) (h : S \u2264 T) (x : M \u29f8 S) :\n\t\u21d1(S.quotient_quotient_equiv_quotient_aux T h) (submodule.quotient.mk x) = \u21d1(S.mapq T linear_map.id h) x :=", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, $S,T$ submodules of $M$ with $S\\leq T$. Then the map $S/T\\to S/T/S$ induced by the quotient map $S\\to S/T$ is the identity map."}
{"name": "category_theory.limits.pushout.congr_hom_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/pullbacks.lean", "formal_statement": "theorem category_theory.limits.pushout.congr_hom_hom {C : Type u}\n\t[category_theory.category C] {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Y} {g\u2081 g\u2082 : X \u27f6 Z}\n\t(h\u2081 : f\u2081 = f\u2082) (h\u2082 : g\u2081 = g\u2082) [category_theory.limits.has_pushout f\u2081 g\u2081]\n\t[category_theory.limits.has_pushout f\u2082 g\u2082] :\n\t(category_theory.limits.pushout.congr_hom h\u2081 h\u2082).hom = category_theory.limits.pushout.map f\u2081 g\u2081 f\u2082 g\u2082 (\ud835\udfd9 Y) (\ud835\udfd9 Z) (\ud835\udfd9 X) _ _ :=", "nl_statement_of_codex": "Let $C$ be a category, let $X, Y, Z$ be objects of $C$, let $f_1, f_2:X\\to Y$ and $g_1, g_2:X\\to Z$ be morphisms of $C$. If $f_1=f_2$ and $g_1=g_2$, then the morphism $X\\to Y\\coprod_X Z$ induced by $f_1$ and $g_1$ is equal to the morphism $X\\to Y\\coprod_X Z$ induced by $f_2$ and $g_2$."}
{"name": "topological_add_group.of_comm_of_nhds_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/group.lean", "formal_statement": "theorem topological_add_group.of_comm_of_nhds_zero {G : Type u}\n\t[add_comm_group G] [topological_space G]\n\t(hmul : filter.tendsto (function.uncurry has_add.add) ((nhds 0).prod (nhds 0)) (nhds 0))\n\t(hinv : filter.tendsto (\u03bb (x : G), -x) (nhds 0) (nhds 0))\n\t(hleft : \u2200 (x\u2080 : G), nhds x\u2080 = filter.map (\u03bb (x : G), x\u2080 + x) (nhds 0)) :\n\ttopological_add_group G :=", "nl_statement_of_codex": "Let $G$ be a commutative topological group. Suppose that the multiplication map $G\\times G\\to G$ is continuous at $(0,0)$, that the inversion map $G\\to G$ is continuous at $0$, and that the left translation map $G\\to G$ is continuous at $0$. Then $G$ is a topological group."}
{"name": "unitization.inl_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/unitization.lean", "formal_statement": "theorem unitization.inl_injective {R A : Type*} [has_zero A] :\n\tfunction.injective unitization.inl :=", "nl_statement_of_codex": "The map $R\\to R\\oplus A$ given by $r\\mapsto (r,0)$ is injective."}
{"name": "has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented_apply_ker", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/implicit.lean", "formal_statement": "theorem has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented_apply_ker\n\t{\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] [complete_space E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] [complete_space F] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {a : E}\n\t(hf : has_strict_fderiv_at f f' a) (hf' : f'.range = \u22a4)\n\t(hker : f'.ker.closed_complemented) (y : \u21a5(f'.ker)) :\n\t\u21d1(has_strict_fderiv_at.implicit_to_local_homeomorph_of_complemented f f' hf hf' hker) (\u2191y + a) = (f (\u2191y + a), y) :=", "nl_statement_of_codex": "Let $E$ and $F$ be complete normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be a function with a strict derivative $f'$ at $a\\in E$. Suppose that $f'$ is surjective and that $\\ker f'$ is closed and complemented. Then the implicit function theorem gives a local homeomorphism $g:E\\to F$ such that $g(a)=f(a)$ and $g'(a)=f'(a)$. For $y\\in \\ker f'$, we have $g(y+a)=f(y+a)$ and $g'("}
{"name": "bounded_order_hom.symm_dual_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/bounded.lean", "formal_statement": "theorem bounded_order_hom.symm_dual_id {\u03b1 : Type*} [preorder \u03b1]\n\t[bounded_order \u03b1] :\n\t\u21d1(bounded_order_hom.dual.symm) (bounded_order_hom.id \u03b1\u1d52\u1d48) = bounded_order_hom.id \u03b1 :=", "nl_statement_of_codex": "The dual of the inverse of the dual of a bounded preorder is the identity."}
{"name": "star_convex.affine_preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/star.lean", "formal_statement": "theorem star_convex.affine_preimage {\ud835\udd5c E F : Type*} [ordered_ring \ud835\udd5c]\n\t[add_comm_group E] [add_comm_group F] [module \ud835\udd5c E] [module \ud835\udd5c F] {x : E}\n\t(f : E \u2192\u1d43[\ud835\udd5c] F) {s : set F} (hs : star_convex \ud835\udd5c (\u21d1f x) s) :\n\tstar_convex \ud835\udd5c x (\u21d1f \u207b\u00b9' s) :=", "nl_statement_of_codex": "Let $f:E\\to F$ be an affine map. If $s$ is star-convex with respect to $f(x)$, then $f^{-1}(s)$ is star-convex with respect to $x$."}
{"name": "cont_diff_on.sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff_on.sub {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {n : with_top \u2115} {s : set E} {f g : E \u2192 F}\n\t(hf : cont_diff_on \ud835\udd5c n f s) (hg : cont_diff_on \ud835\udd5c n g s) :\n\tcont_diff_on \ud835\udd5c n (\u03bb (x : E), f x - g x) s :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $n$ be a nonnegative integer or $\\infty$. Let $f,g:E\\to F$ be functions. If $f$ and $g$ are $n$-times continuously differentiable on $E$, then $f-g$ is $n$-times continuously differentiable on $E$."}
{"name": "function.embedding.equiv_of_fintype_self_embedding_to_embedding", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem function.embedding.equiv_of_fintype_self_embedding_to_embedding\n\t{\u03b1 : Type*} [fintype \u03b1] (e : \u03b1 \u21aa \u03b1) :\n\te.equiv_of_fintype_self_embedding.to_embedding = e :=", "nl_statement_of_codex": "Let $e:A\\to A$ be an injective function on a finite set $A$. Then $e$ is a bijection."}
{"name": "filter.is_countably_generated_principal", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/bases.lean", "formal_statement": "theorem filter.is_countably_generated_principal {\u03b1 : Type*} (s : set \u03b1) :\n\t(filter.principal s).is_countably_generated :=", "nl_statement_of_codex": "The principal filter generated by a set $S$ is countably generated."}
{"name": "differentiable.dist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/calculus.lean", "formal_statement": "theorem differentiable.dist {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] [normed_space \u211d E] {G : Type*} [normed_group G]\n\t[normed_space \u211d G] {f g : G \u2192 E} (hf : differentiable \u211d f)\n\t(hg : differentiable \u211d g) (hne : \u2200 (x : G), f x \u2260 g x) :\n\tdifferentiable \u211d (\u03bb (y : G), has_dist.dist (f y) (g y)) :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $G$ be a normed group. Let $f,g:G\\to E$ be differentiable functions such that $f(x)\\neq g(x)$ for all $x\\in G$. Then the function $y\\mapsto \\|f(y)-g(y)\\|$ is differentiable."}
{"name": "dfinsupp.update_eq_erase", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/dfinsupp/basic.lean", "formal_statement": "theorem dfinsupp.update_eq_erase {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v}\n\t[dec : decidable_eq \u03b9] [\u03a0 (i : \u03b9), has_zero (\u03b2 i)] (i : \u03b9)\n\t(f : \u03a0\u2080 (i : \u03b9), \u03b2 i) [decidable (0 = 0)] :\n\tdfinsupp.update i f 0 = dfinsupp.erase i f :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to R$ be a function. Then $f(n)=0$ if and only if $f(n)=0$."}
{"name": "ring_equiv.op_symm_apply_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/equiv.lean", "formal_statement": "theorem ring_equiv.op_symm_apply_symm_apply {\u03b1 \u03b2 : Type*} [has_add \u03b1]\n\t[has_mul \u03b1] [has_add \u03b2] [has_mul \u03b2] (f : \u03b1\u1d50\u1d52\u1d56 \u2243+* \u03b2\u1d50\u1d52\u1d56) (\u1fb0 : \u03b2) :\n\t\u21d1((\u21d1(ring_equiv.op.symm) f).symm) \u1fb0 = (\u21d1(add_equiv.mul_op.symm) f.to_add_equiv).inv_fun \u1fb0 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a ring isomorphism. Then $f^{-1}(b)=f^{-1}(b)$ for all $b\\in B$."}
{"name": "ring.direct_limit.lift_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_limit.lean", "formal_statement": "theorem ring.direct_limit.lift_unique {\u03b9 : Type v} [preorder \u03b9] {G : \u03b9 \u2192 Type w}\n\t[\u03a0 (i : \u03b9), comm_ring (G i)] {f : \u03a0 (i j : \u03b9), i \u2264 j \u2192 G i \u2192 G j} (P : Type u\u2081)\n\t[comm_ring P] [nonempty \u03b9] [is_directed \u03b9 has_le.le]\n\t(F : ring.direct_limit G f \u2192+* P) (x : ring.direct_limit G f) :\n\t\u21d1F x = \u21d1(ring.direct_limit.lift G f P (\u03bb (i : \u03b9), F.comp (ring.direct_limit.of G f i)) _) x :=", "nl_statement_of_codex": "Let $G$ be a directed system of commutative rings and let $F$ be a ring homomorphism from the direct limit of $G$ to a commutative ring $P$. Then the image of $x\\in\\varinjlim G$ under $F$ is equal to the image of $x$ under the homomorphism from the direct limit of $G$ to $P$ induced by the homomorphisms $F\\circ\\iota_i$."}
{"name": "category_theory.is_iso.eq_inv_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/isomorphism.lean", "formal_statement": "theorem category_theory.is_iso.eq_inv_comp {C : Type u}\n\t[category_theory.category C] {X Y Z : C} (\u03b1 : X \u27f6 Y) [category_theory.is_iso \u03b1]\n\t{f : X \u27f6 Z} {g : Y \u27f6 Z} :\n\tg = category_theory.inv \u03b1 \u226b f \u2194 \u03b1 \u226b g = f :=", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y, Z$ be objects of $C$. Let $\\alpha:X\\to Y$ be an isomorphism. Then $\\alpha^{-1}$ is an isomorphism if and only if $\\alpha^{-1}\\circ f=g$."}
{"name": "list.subperm.trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/perm.lean", "formal_statement": "theorem list.subperm.trans {\u03b1 : Type uu} {l\u2081 l\u2082 l\u2083 : list \u03b1} :\n\tl\u2081 <+~ l\u2082 \u2192 l\u2082 <+~ l\u2083 \u2192 l\u2081 <+~ l\u2083 :=", "nl_statement_of_codex": "If $l_1$ is a subpermutation of $l_2$ and $l_2$ is a subpermutation of $l_3$, then $l_1$ is a subpermutation of $l_3$."}
{"name": "set.univ_prod_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/prod.lean", "formal_statement": "theorem set.univ_prod_univ {\u03b1 \u03b2 : Type*} :\n\tset.univ \u00d7\u02e2 set.univ = set.univ :=", "nl_statement_of_codex": "$\\mathbb{R}^2=\\mathbb{R}$."}
{"name": "homogeneous_ideal.coe_radical", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/graded_algebra/radical.lean", "formal_statement": "theorem homogeneous_ideal.coe_radical {\u03b9 \u03c3 A : Type*} [comm_ring A]\n\t[linear_ordered_cancel_add_comm_monoid \u03b9] [set_like \u03c3 A]\n\t[add_submonoid_class \u03c3 A] {\ud835\udc9c : \u03b9 \u2192 \u03c3} [graded_ring \ud835\udc9c] (I : homogeneous_ideal \ud835\udc9c) :\n\tI.radical.to_ideal = I.to_ideal.radical :=", "nl_statement_of_codex": "Let $A$ be a commutative ring and let $\\mathfrak{a}$ be a graded ideal of $A$. Then the radical of $\\mathfrak{a}$ is equal to the radical of the ideal generated by $\\mathfrak{a}$."}
{"name": "liouville_with.sub_rat_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/liouville/liouville_with.lean", "formal_statement": "theorem liouville_with.sub_rat_iff {p x : \u211d} {r : \u211a} :\n\tliouville_with p (x - \u2191r) \u2194 liouville_with p x :=", "nl_statement_of_codex": "Let $p$ be a real number and let $x$ be a real number. Then $x$ is a Liouville number with respect to $p$ if and only if $x-r$ is a Liouville number with respect to $p$ for all rational numbers $r$."}
{"name": "category_theory.iso.trans_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/isomorphism.lean", "formal_statement": "theorem category_theory.iso.trans_inv {C : Type u} [category_theory.category C]\n\t{X Y Z : C} (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 Z) :\n\t(\u03b1 \u226a\u226b \u03b2).inv = \u03b2.inv \u226b \u03b1.inv :=", "nl_statement_of_codex": "Let $C$ be a category. Let $X, Y, Z$ be objects of $C$. Let $\\alpha:X\\to Y$ and $\\beta:Y\\to Z$ be isomorphisms. Then $(\\alpha\\circ\\beta)^{-1}=\\beta^{-1}\\circ\\alpha^{-1}$."}
{"name": "submonoid_class.coe_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem submonoid_class.coe_subtype {M : Type*} [mul_one_class M] {A : Type*}\n\t[set_like A M] [hA : submonoid_class A M] (S' : A) :\n\t\u21d1(submonoid_class.subtype S') = coe :=", "nl_statement_of_codex": "Let $M$ be a monoid and let $A$ be a submonoid of $M$. Then the subtype of $A$ is equal to the coe map."}
{"name": "order_iso.image_preimage", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/basic.lean", "formal_statement": "theorem order_iso.image_preimage {\u03b1 \u03b2 : Type*} [has_le \u03b1] [has_le \u03b2]\n\t(e : \u03b1 \u2243o \u03b2) (s : set \u03b2) :\n\t\u21d1e '' (\u21d1e \u207b\u00b9' s) = s :=", "nl_statement_of_codex": "Let $e:A\\to B$ be an order isomorphism. Then $e(e^{-1}(S))=S$ for all $S\\subset B$."}
{"name": "monotone_on.map_is_least", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem monotone_on.map_is_least {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {t : set \u03b1} (Hf : monotone_on f t) {a : \u03b1}\n\t(Ha : is_least t a) :\n\tis_least (f '' t) (f a) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function between preordered sets. Let $a$ be the least element of $A$. Then $f(a)$ is the least element of $f(A)$."}
{"name": "monovary_on_const_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monovary.lean", "formal_statement": "theorem monovary_on_const_left {\u03b9 \u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t(g : \u03b9 \u2192 \u03b2) (a : \u03b1) (s : set \u03b9) :\n\tmonovary_on (function.const \u03b9 a) g s :=", "nl_statement_of_codex": "Let $g:\\iota\\to\\beta$ be a function and let $a$ be a constant. Then $g$ is monotone on $a$."}
{"name": "homology_zero_zero_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/image_to_kernel.lean", "formal_statement": "theorem homology_zero_zero_inv {V : Type u} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] {A B C : V}\n\t[category_theory.limits.has_zero_object V] [category_theory.limits.has_image 0]\n\t[category_theory.limits.has_cokernel (image_to_kernel 0 0 homology_zero_zero._proof_3)] :\n\thomology_zero_zero.inv = category_theory.inv (category_theory.limits.kernel_subobject 0).arrow \u226b homology.\u03c0 0 0 homology_zero_zero._proof_15 :=", "nl_statement_of_codex": "The inverse of the zero map is the zero map."}
{"name": "list.length_pos_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.length_pos_of_mem {\u03b1 : Type u} {a : \u03b1} {l : list \u03b1} :\n\ta \u2208 l \u2192 0 < l.length :=", "nl_statement_of_codex": "If $a$ is an element of a list $l$, then $l$ has positive length."}
{"name": "first_order.language.equiv.bijective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/basic.lean", "formal_statement": "theorem first_order.language.equiv.bijective {L : first_order.language}\n\t{M : Type w} {N : Type w'} [L.Structure M] [L.Structure N] (f : L.equiv M N) :\n\tfunction.bijective \u21d1f :=", "nl_statement_of_codex": "Let $L$ be a first-order language, $M$ and $N$ be $L$-structures. If $f:M\\to N$ is an $L$-equivalence, then $f$ is a bijection."}
{"name": "matrix.frobenius_nnnorm_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/matrix.lean", "formal_statement": "theorem matrix.frobenius_nnnorm_def {m n \u03b1 : Type*} [fintype m] [fintype n]\n\t[semi_normed_group \u03b1] (A : matrix m n \u03b1) :\n\t\u2225A\u2225\u208a = finset.univ.sum (\u03bb (i : m), finset.univ.sum (\u03bb (j : n), \u2225A i j\u2225\u208a ^ 2)) ^ (1 / 2) :=", "nl_statement_of_codex": "The Frobenius norm of a matrix $A$ is the square root of the sum of the squares of the norms of the entries of $A$."}
{"name": "measure_theory.sub_ae_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.sub_ae_eq_zero {\u03b1 : Type*} {m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {\u03b2 : Type*} [add_group \u03b2] (f g : \u03b1 \u2192 \u03b2) :\n\tf - g =\u1d50[\u03bc] 0 \u2194 f =\u1d50[\u03bc] g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be measurable functions. Then $f=g$ almost everywhere if and only if $f-g=0$ almost everywhere."}
{"name": "reflection_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/projection.lean", "formal_statement": "theorem reflection_apply {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c] [inner_product_space \ud835\udd5c E]\n\t{K : submodule \ud835\udd5c E} [complete_space \u21a5K] (p : E) :\n\t\u21d1(reflection K) p = bit0 \u2191(\u21d1(orthogonal_projection K) p) - p :=", "nl_statement_of_codex": "Let $E$ be an inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $K$ be a closed subspace of $E$. Then the reflection of $p$ in $K$ is $2\\pi(p)-p$."}
{"name": "finset.sum_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_singleton {\u03b2 : Type u} {\u03b1 : Type v} {a : \u03b1} {f : \u03b1 \u2192 \u03b2}\n\t[add_comm_monoid \u03b2] :\n\t{a}.sum (\u03bb (x : \u03b1), f x) = f a :=", "nl_statement_of_codex": "The sum of a singleton set is the value of the function at that element."}
{"name": "continuous_map.lift_cover_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/basic.lean", "formal_statement": "theorem continuous_map.lift_cover_coe {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] {\u03b9 : Type*} {S : \u03b9 \u2192 set \u03b1} {\u03c6 : \u03a0 (i : \u03b9), C(\u21a5(S i), \u03b2)}\n\t{h\u03c6 : \u2200 (i j : \u03b9) (x : \u03b1) (hxi : x \u2208 S i) (hxj : x \u2208 S j), \u21d1(\u03c6 i) \u27e8x, hxi\u27e9 = \u21d1(\u03c6 j) \u27e8x, hxj\u27e9}\n\t{hS : \u2200 (x : \u03b1), \u2203 (i : \u03b9), S i \u2208 nhds x} {i : \u03b9} (x : \u21a5(S i)) :\n\t\u21d1(continuous_map.lift_cover S \u03c6 h\u03c6 hS) \u2191x = \u21d1(\u03c6 i) x :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces, let $\\{U_i\\}_{i\\in I}$ be a cover of $X$, and let $\\phi_i:U_i\\to Y$ be a collection of continuous maps. Then the map $\\phi:X\\to Y$ defined by $\\phi(x)=\\phi_i(x)$ if $x\\in U_i$ is continuous."}
{"name": "measure_theory.lintegral_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.lintegral_one {\u03b1 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} :\n\t\u222b\u207b (a : \u03b1), 1 \u2202\u03bc = \u21d1\u03bc set.univ :=", "nl_statement_of_codex": "Let $(X,\\mathcal{A},\\mu)$ be a measure space. Then $\\int_X 1\\,d\\mu=\\mu(X)$."}
{"name": "measure_theory.integral_sub'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/bochner.lean", "formal_statement": "theorem measure_theory.integral_sub' {\u03b1 E : Type*} [normed_group E]\n\t[normed_space \u211d E] [complete_space E] {f g : \u03b1 \u2192 E} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} (hf : measure_theory.integrable f \u03bc)\n\t(hg : measure_theory.integrable g \u03bc) :\n\t\u222b (a : \u03b1), (f - g) a \u2202\u03bc = \u222b (a : \u03b1), f a \u2202\u03bc - \u222b (a : \u03b1), g a \u2202\u03bc :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E$ be measurable functions. If $f$ and $g$ are integrable, then $\\int (f-g)d\\mu=\\int fd\\mu-\\int gd\\mu$."}
{"name": "measure_theory.ae_eq_fun.comp_measurable_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/ae_eq_fun.lean", "formal_statement": "theorem measure_theory.ae_eq_fun.comp_measurable_mk {\u03b1 \u03b2 \u03b3 : Type*}\n\t[measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2]\n\t[topological_space \u03b3] [measurable_space \u03b2]\n\t[topological_space.pseudo_metrizable_space \u03b2] [borel_space \u03b2]\n\t[measurable_space \u03b3] [topological_space.pseudo_metrizable_space \u03b3]\n\t[opens_measurable_space \u03b3] [topological_space.second_countable_topology \u03b3]\n\t(g : \u03b2 \u2192 \u03b3) (hg : measurable g) (f : \u03b1 \u2192 \u03b2)\n\t(hf : measure_theory.ae_strongly_measurable f \u03bc) :\n\tmeasure_theory.ae_eq_fun.comp_measurable g hg (measure_theory.ae_eq_fun.mk f hf) = measure_theory.ae_eq_fun.mk (g \u2218 f) _ :=", "nl_statement_of_codex": "Let $f:X\\to Y$ and $g:Y\\to Z$ be measurable functions. Then $g\\circ f$ is measurable."}
{"name": "complex.sin_two_pi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem complex.sin_two_pi :\n\tcomplex.sin (2 * \u2191real.pi) = 0 :=", "nl_statement_of_codex": "$\\sin(2\\pi)=0$."}
{"name": "exists_seq_strict_anti_strict_mono_tendsto", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/order/basic.lean", "formal_statement": "theorem exists_seq_strict_anti_strict_mono_tendsto {\u03b1 : Type u}\n\t[topological_space \u03b1] [linear_order \u03b1] [order_topology \u03b1] [densely_ordered \u03b1]\n\t[topological_space.first_countable_topology \u03b1] {x y : \u03b1} (h : x < y) :\n\t\u2203 (u v : \u2115 \u2192 \u03b1), strict_anti u \u2227 strict_mono v \u2227 (\u2200 (k : \u2115), u k \u2208 set.Ioo x y) \u2227 (\u2200 (l : \u2115), v l \u2208 set.Ioo x y) \u2227 (\u2200 (k l : \u2115), u k < v l) \u2227 filter.tendsto u filter.at_top (nhds x) \u2227 filter.tendsto v filter.at_top (nhds y) :=", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and a dense order topology. Let $x,y\\in X$ with $x<y$. Then there are sequences $u,v:\\mathbb{N}\\to X$ such that $u$ is strictly increasing and $v$ is strictly decreasing, $u(k),v(l)\\in (x,y)$ for all $k,l\\in\\mathbb{N}$, $u(k)<v(l)$ for all $k,l\\in\\mathbb{N}$, $u$ converges to $x$ and $v$ converges to $y$."}
{"name": "algebraic_geometry.PresheafedSpace.is_open_immersion.inv_naturality_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/open_immersion.lean", "formal_statement": "theorem algebraic_geometry.PresheafedSpace.is_open_immersion.inv_naturality_assoc\n\t{C : Type u} [category_theory.category C]\n\t{X Y : algebraic_geometry.PresheafedSpace C} {f : X \u27f6 Y}\n\t(H : algebraic_geometry.PresheafedSpace.is_open_immersion f)\n\t{U V : (topological_space.opens \u21a5X)\u1d52\u1d56} (i : U \u27f6 V) {X' : C}\n\t(f' : Y.presheaf.obj (opposite.op (H.open_functor.obj (opposite.unop V))) \u27f6 X') :\n\tX.presheaf.map i \u226b H.inv_app (opposite.unop V) \u226b f' = H.inv_app (opposite.unop U) \u226b Y.presheaf.map (H.open_functor.op.map i) \u226b f' :=", "nl_statement_of_codex": "Let $X$ and $Y$ be presheafed spaces over a category $C$. Let $f:X\\to Y$ be an open immersion. Let $U$ and $V$ be open subsets of $X$ and let $i:U\\to V$ be a morphism in $C$. Let $X'$ be an object of $C$ and let $f':Y(V)\\to X'$ be a morphism in $C$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nX(U) & \\xrightarrow{f} & Y(U) \\\\\n\\downarrow & & \\downarrow \\\\\nX"}
{"name": "measure_theory.outer_measure.univ_eq_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.univ_eq_zero_iff {\u03b1 : Type*}\n\t(m : measure_theory.outer_measure \u03b1) :\n\t\u21d1m set.univ = 0 \u2194 m = 0 :=", "nl_statement_of_codex": "Let $m$ be an outer measure on a set $X$. Then $m(X)=0$ if and only if $m$ is the zero measure."}
{"name": "equiv.perm.sigma_congr_right_hom_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/basic.lean", "formal_statement": "theorem equiv.perm.sigma_congr_right_hom_apply {\u03b1 : Type*} (\u03b2 : \u03b1 \u2192 Type*)\n\t(F : \u03a0 (a : \u03b1), equiv.perm ((\u03bb (a : \u03b1), \u03b2 a) a)) :\n\t\u21d1(equiv.perm.sigma_congr_right_hom \u03b2) F = equiv.perm.sigma_congr_right F :=", "nl_statement_of_codex": "Let $F$ be a family of permutations of the sets $\\beta_a$ for $a\\in A$. Then the permutation of the set $\\prod_{a\\in A}\\beta_a$ induced by $F$ is equal to the permutation of the set $\\prod_{a\\in A}\\beta_a$ induced by the family $F$."}
{"name": "int.commute_cast", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/cast.lean", "formal_statement": "theorem int.commute_cast {\u03b1 : Type*} [non_assoc_ring \u03b1] (x : \u03b1) (m : \u2124) :\n\tcommute x \u2191m :=", "nl_statement_of_codex": "Let $R$ be a non-associative ring and let $x\\in R$. Then $x$ commutes with $m\\in\\mathbb{Z}$."}
{"name": "ennreal.infi_add_infi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.infi_add_infi {\u03b9 : Sort u_3} {f g : \u03b9 \u2192 ennreal}\n\t(h : \u2200 (i j : \u03b9), \u2203 (k : \u03b9), f k + g k \u2264 f i + g j) :\n\tinfi f + infi g = \u2a05 (a : \u03b9), f a + g a :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be functions. If for all $i,j\\in\\mathbb{N}$ there is $k\\in\\mathbb{N}$ such that $f(k)+g(k)\\leq f(i)+g(j)$, then $\\inf f+\\inf g=\\inf(f+g)$."}
{"name": "filter.mem_vadd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.mem_vadd {\u03b1 \u03b2 : Type*} [has_vadd \u03b1 \u03b2] {f : filter \u03b1}\n\t{g : filter \u03b2} {t : set \u03b2} :\n\tt \u2208 f +\u1d65 g \u2194 \u2203 (t\u2081 : set \u03b1) (t\u2082 : set \u03b2), t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 +\u1d65 t\u2082 \u2286 t :=", "nl_statement_of_codex": "Let $f$ and $g$ be filters on $\u03b1$ and $\u03b2$ respectively. Then $t\\in f+g$ if and only if there are sets $t_1\\in f$ and $t_2\\in g$ such that $t_1+t_2\\subset t$."}
{"name": "measurable.sin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/special_functions.lean", "formal_statement": "theorem measurable.sin {\u03b1 : Type*} {m : measurable_space \u03b1} {f : \u03b1 \u2192 \u211d}\n\t(hf : measurable f) :\n\tmeasurable (\u03bb (x : \u03b1), real.sin (f x)) :=", "nl_statement_of_codex": "Let $f$ be a measurable function from a measurable space $X$ to $\\mathbb{R}$. Then the function $x\\mapsto \\sin(f(x))$ is measurable."}
{"name": "zmod.pow_div_two_eq_neg_one_or_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/legendre_symbol/quadratic_reciprocity.lean", "formal_statement": "theorem zmod.pow_div_two_eq_neg_one_or_one (p : \u2115) [fact (nat.prime p)]\n\t{a : zmod p} (ha : a \u2260 0) :\n\ta ^ (p / 2) = 1 \u2228 a ^ (p / 2) = -1 :=", "nl_statement_of_codex": "Let $p$ be an odd prime and let $a$ be a nonzero element of $\\mathbb{Z}/p\\mathbb{Z}$. Then $a^{(p-1)/2}=\\pm 1$."}
{"name": "cardinal.continuum_add_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/continuum.lean", "formal_statement": "theorem cardinal.continuum_add_nat (n : \u2115) :\n\tcardinal.continuum + \u2191n = cardinal.continuum :=", "nl_statement_of_codex": "The cardinality of the continuum plus the cardinality of the natural numbers is the cardinality of the continuum."}
{"name": "mul_salem_spencer.mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/additive/salem_spencer.lean", "formal_statement": "theorem mul_salem_spencer.mul_left {\u03b1 : Type*} [cancel_comm_monoid \u03b1]\n\t{s : set \u03b1} {a : \u03b1} (hs : mul_salem_spencer s) :\n\tmul_salem_spencer (has_mul.mul a '' s) :=", "nl_statement_of_codex": "Let $s$ be a Salem-Spencer set in a commutative monoid $M$. Then $a\\cdot s$ is a Salem-Spencer set in $M$."}
{"name": "linear_isometry_equiv.continuous", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/linear_isometry.lean", "formal_statement": "theorem linear_isometry_equiv.continuous {R R\u2082 E E\u2082 : Type*} [semiring R]\n\t[semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n\t[ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [semi_normed_group E] [semi_normed_group E\u2082]\n\t[module R E] [module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\tcontinuous \u21d1e :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $\\sigma:R\\to R'$ be a ring homomorphism, and let $E$ and $E'$ be semi-normed groups over $R$ and $R'$, respectively. If $E$ and $E'$ are isomorphic as $R$-modules, then the isomorphism is continuous."}
{"name": "subalgebra.map_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/subalgebra/basic.lean", "formal_statement": "theorem subalgebra.map_le {R : Type u} {A : Type v} {B : Type w}\n\t[comm_semiring R] [semiring A] [algebra R A] [semiring B] [algebra R B]\n\t{S : subalgebra R A} {f : A \u2192\u2090[R] B} {U : subalgebra R B} :\n\tS.map f \u2264 U \u2194 S \u2264 U.comap f :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be $R$-algebras, $S$ be a subalgebra of $A$, and $U$ be a subalgebra of $B$. Then $S$ is mapped to $U$ by $f:A\\to B$ if and only if $S$ is contained in the preimage of $U$ under $f$."}
{"name": "cont_mdiff_on_pi_space", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem cont_mdiff_on_pi_space {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*}\n\t[topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M] {s : set M} {n : with_top \u2115}\n\t{\u03b9 : Type*4} [fintype \u03b9] {Fi : \u03b9 \u2192 Type*5} [\u03a0 (i : \u03b9), normed_group (Fi i)]\n\t[\u03a0 (i : \u03b9), normed_space \ud835\udd5c (Fi i)] {\u03c6 : M \u2192 \u03a0 (i : \u03b9), Fi i} :\n\tcont_mdiff_on I (model_with_corners_self \ud835\udd5c (\u03a0 (i : \u03b9), Fi i)) n \u03c6 s \u2194 \u2200 (i : \u03b9), cont_mdiff_on I (model_with_corners_self \ud835\udd5c (Fi i)) n (\u03bb (x : M), \u03c6 x i) s :=", "nl_statement_of_codex": "Let $E$ be a normed group, $H$ a topological space, $M$ a charted space over $H$, $s$ a subset of $M$, $n$ a natural number, $\\iota$ a finite type, $F_i$ a normed group for each $i\\in\\iota$, and $\\phi:M\\to\\prod_{i\\in\\iota}F_i$. Then $\\phi$ is $n$-times continuously differentiable on $s$ if and only if $\\phi_i$ is $n$-times continuously differentiable on $s$ for each $i\\in\\iota$."}
{"name": "set.prod_subset_preimage_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/prod.lean", "formal_statement": "theorem set.prod_subset_preimage_snd {\u03b1 \u03b2 : Type*} (s : set \u03b1) (t : set \u03b2) :\n\ts \u00d7\u02e2 t \u2286 prod.snd \u207b\u00b9' t :=", "nl_statement_of_codex": "The product of two sets is a subset of the preimage of the second set under the projection onto the second coordinate."}
{"name": "is_chain.succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/chain.lean", "formal_statement": "theorem is_chain.succ {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : set \u03b1}\n\t(hs : is_chain r s) :\n\tis_chain r (succ_chain r s) :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $S$. If $r$ is a chain on $S$, then $r$ is a chain on $S\\cup\\{s\\}$."}
{"name": "category_theory.iso.is_zero_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/zero_objects.lean", "formal_statement": "theorem category_theory.iso.is_zero_iff {C : Type u}\n\t[category_theory.category C] {X Y : C} (e : X \u2245 Y) :\n\tcategory_theory.limits.is_zero X \u2194 category_theory.limits.is_zero Y :=", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y$ be objects of $C$. Then $X$ is zero if and only if $Y$ is zero."}
{"name": "zero_lt.lt_mul_of_lt_mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas_zero_lt.lean", "formal_statement": "theorem zero_lt.lt_mul_of_lt_mul_left {\u03b1 : Type u} {a b c d : \u03b1} [has_mul \u03b1]\n\t[has_zero \u03b1] [preorder \u03b1] [zero_lt.pos_mul_mono \u03b1] (h : a < b * c)\n\t(hle : c \u2264 d) (b0 : 0 < b) :\n\ta < b * d :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a preordered monoid with zero. If $a<bc$ and $c\\leq d$, then $a<bd$."}
{"name": "rbnode.find_mk_insert_result", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rbtree/insert.lean", "formal_statement": "theorem rbnode.find_mk_insert_result {\u03b1 : Type u} (lt : \u03b1 \u2192 \u03b1 \u2192 Prop)\n\t[decidable_rel lt] ( : rbnode.color) (t : rbnode \u03b1) (x : \u03b1) :\n\trbnode.find lt (rbnode.mk_insert_result c t) x = rbnode.find lt t x :=", "nl_statement_of_codex": "Let $t$ be a red-black tree and let $x$ be an element. Then $x$ is in the red-black tree obtained by inserting $x$ into $t$ if and only if $x$ is in $t$."}
{"name": "is_idempotent_elem.iff_eq_zero_or_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/idempotents.lean", "formal_statement": "theorem is_idempotent_elem.iff_eq_zero_or_one {G\u2080 : Type*} [group_with_zero G\u2080]\n\t{p : G\u2080} :\n\tis_idempotent_elem p \u2194 p = 0 \u2228 p = 1 :=", "nl_statement_of_codex": "An element $p$ of a group with zero is idempotent if and only if $p=0$ or $p=1$."}
{"name": "finset.card_div_choose_le_card_shadow_div_choose", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/set_family/lym.lean", "formal_statement": "theorem finset.card_div_choose_le_card_shadow_div_choose {\ud835\udd5c \u03b1 : Type*}\n\t[linear_ordered_field \ud835\udd5c] [decidable_eq \u03b1] [fintype \u03b1] {\ud835\udc9c : finset (finset \u03b1)}\n\t{r : \u2115} (hr : r \u2260 0) (h\ud835\udc9c : set.sized r \u2191\ud835\udc9c) :\n\t\u2191(\ud835\udc9c.card) / \u2191((fintype.card \u03b1).choose r) \u2264 \u2191(\ud835\udc9c.shadow.card) / \u2191((fintype.card \u03b1).choose (r - 1)) :=", "nl_statement_of_codex": "Let $\ud835\udc9c$ be a finite set of finite subsets of a finite set $\u03b1$. Then the number of $r$-element subsets of $\u03b1$ that are contained in some element of $\ud835\udc9c$ is at most the number of $(r-1)$-element subsets of $\u03b1$ that are contained in some element of $\ud835\udc9c$."}
{"name": "is_coprime_one_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/coprime/basic.lean", "formal_statement": "theorem is_coprime_one_right {R : Type u} [comm_semiring R] {x : R} :\n\tis_coprime x 1 :=", "nl_statement_of_codex": "$1$ is coprime to any element of a commutative semiring."}
{"name": "clifford_algebra.submodule_comap_pow_reverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/clifford_algebra/conjugation.lean", "formal_statement": "theorem clifford_algebra.submodule_comap_pow_reverse {R : Type*} [comm_ring R]\n\t{M : Type*} [add_comm_group M] [module R M] (Q : quadratic_form R M)\n\t(p : submodule R (clifford_algebra Q)) (n : \u2115) :\n\tsubmodule.comap clifford_algebra.reverse (p ^ n) = submodule.comap clifford_algebra.reverse p ^ n :=", "nl_statement_of_codex": "Let $Q$ be a quadratic form on a module $M$ over a commutative ring $R$. Let $p$ be a submodule of the Clifford algebra of $Q$. Then the $n$-th power of $p$ is equal to the $n$-th power of the image of $p$ under the reverse map."}
{"name": "adjoin_root.lift_hom_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/adjoin_root.lean", "formal_statement": "theorem adjoin_root.lift_hom_of {R : Type u} {S : Type v} [comm_ring R]\n\t(f : polynomial R) [comm_ring S] {a : S} [algebra R S]\n\t(hfx : \u21d1(polynomial.aeval a) f = 0) {x : R} :\n\t\u21d1(adjoin_root.lift_hom f a hfx) (\u21d1(adjoin_root.of f) x) = \u21d1(algebra_map R S) x :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $S$ be a commutative ring, let $f\\in R[x]$ be a polynomial, let $a\\in S$ be an element, and let $R\\to S$ be a ring homomorphism. Suppose that $f(a)=0$. Then the map $R[x]/(f)\\to S$ sending $x$ to $a$ is a ring homomorphism."}
{"name": "category_theory.splitting.retraction_\u03b9_eq_id_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/short_exact/preadditive.lean", "formal_statement": "theorem category_theory.splitting.retraction_\u03b9_eq_id_sub {\ud835\udc9c : Type*}\n\t[category_theory.category \ud835\udc9c] {A B C : \ud835\udc9c} {f : A \u27f6 B} {g : B \u27f6 C}\n\t[category_theory.preadditive \ud835\udc9c]\n\t[category_theory.limits.has_binary_biproducts \ud835\udc9c]\n\t(h : category_theory.splitting f g) :\n\th.retraction \u226b f = \ud835\udfd9 B - g \u226b h.section :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be morphisms in a category $\\mathcal{A}$ with binary biproducts. If $f$ and $g$ split, then the retraction of $f$ is the identity on $B$ minus the section of $g$."}
{"name": "act_rel_of_act_rel_of_rel_act_rel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/covariant_and_contravariant.lean", "formal_statement": "theorem act_rel_of_act_rel_of_rel_act_rel {M N : Type*} {\u03bc : M \u2192 N \u2192 N}\n\t{r : N \u2192 N \u2192 Prop} [contravariant_class M N \u03bc r] [is_trans N r] (m : M)\n\t{a b c : N} (ab : r (\u03bc m a) b) (rl : r (\u03bc m b) (\u03bc m c)) :\n\tr (\u03bc m a) c :=", "nl_statement_of_codex": "Let $M$ and $N$ be sets and let $\u03bc:M\\times N\\to N$ be a function. Let $r$ be a relation on $N$ such that $\u03bc$ is contravariant with respect to $r$. If $r$ is transitive, then $\u03bc$ is contravariant with respect to $r$."}
{"name": "nnreal.sqrt_le_sqrt_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/sqrt.lean", "formal_statement": "theorem nnreal.sqrt_le_sqrt_iff {x y : nnreal} :\n\t\u21d1nnreal.sqrt x \u2264 \u21d1nnreal.sqrt y \u2194 x \u2264 y :=", "nl_statement_of_codex": "For nonnegative real numbers $x,y$, $\\sqrt{x}\\leq\\sqrt{y}$ if and only if $x\\leq y$."}
{"name": "filter.tendsto_const_mul_pow_at_bot_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.tendsto_const_mul_pow_at_bot_iff {\u03b1 : Type*}\n\t[linear_ordered_field \u03b1] { : \u03b1} {n : \u2115} :\n\tfilter.tendsto (\u03bb (x : \u03b1), c * x ^ n) filter.at_top filter.at_bot \u2194 n \u2260 0 \u2227 c < 0 :=", "nl_statement_of_codex": "Let $c$ be a real number and let $n$ be a natural number. Then the function $f(x)=cx^n$ tends to $-\\infty$ as $x$ tends to $+\\infty$ if and only if $n\\neq 0$ and $c<0$."}
{"name": "complex.abs_sub_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/arg.lean", "formal_statement": "theorem complex.abs_sub_eq {x y : \u2102} (h : x.arg = y.arg) :\n\tcomplex.abs (x - y) = \u2225complex.abs x - complex.abs y\u2225 :=", "nl_statement_of_codex": "Let $x,y\\in\\mathbb{C}$. If $x$ and $y$ have the same argument, then $|x-y|=|x|-|y|$."}
{"name": "simple_graph.subgraph.comap_monotone", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/subgraph.lean", "formal_statement": "theorem simple_graph.subgraph.comap_monotone {V : Type u} {W : Type v}\n\t{G : simple_graph V} {G' : simple_graph W} (f : G \u2192g G') :\n\tmonotone (simple_graph.subgraph.comap f) :=", "nl_statement_of_codex": "Let $G$ and $G'$ be simple graphs. Let $f:G\\to G'$ be a graph homomorphism. Then the function $H\\mapsto f^{-1}(H)$ is monotone."}
{"name": "free_group.map.of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/free_group.lean", "formal_statement": "theorem free_group.map.of {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {x : \u03b1} :\n\t\u21d1(free_group.map f) (free_group.of x) = free_group.of (f x) :=", "nl_statement_of_codex": "The map $f:F_1\\to F_2$ induces a map $f_*:F_1\\to F_2$ such that $f_*(x)=f(x)$ for all $x\\in F_1$."}
{"name": "bump_covering.exists_finset_to_pou_fun_eventually_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/partition_of_unity.lean", "formal_statement": "theorem bump_covering.exists_finset_to_pou_fun_eventually_eq {\u03b9 : Type u}\n\t{X : Type v} [topological_space X] {s : set X} (f : bump_covering \u03b9 X s)\n\t(i : \u03b9) (x : X) :\n\t\u2203 (t : finset \u03b9), f.to_pou_fun i =\u1da0[nhds x] \u21d1(\u21d1f i) * (finset.filter (\u03bb (j : \u03b9), well_ordering_rel j i) t).prod (\u03bb (j : \u03b9), 1 - \u21d1(\u21d1f j)) :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $s$ be a subset of $X$. Let $f$ be a bump covering of $s$. Then for each $i\\in\\mathrm{dom}(f)$ and each $x\\in X$, there is a finite set $t$ such that $f(i)$ is eventually equal to $\\prod_{j\\in t}f(j)$."}
{"name": "sym_alg.unsym_neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/symmetrized.lean", "formal_statement": "theorem sym_alg.unsym_neg {\u03b1 : Type*} [has_neg \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) :\n\tsym_alg.unsym (-a) = -sym_alg.unsym a :=", "nl_statement_of_codex": "Let $a$ be a symmetric algebra over a ring $R$. Then $-a$ is the symmetric algebra of $-a$."}
{"name": "hahn_series.smul_coeff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/hahn_series.lean", "formal_statement": "theorem hahn_series.smul_coeff {\u0393 R : Type*} [partial_order \u0393] {V : Type*}\n\t[monoid R] [add_monoid V] [distrib_mul_action R V] {r : R}\n\t{x : hahn_series \u0393 V} {a : \u0393} :\n\t(r \u2022 x).coeff a = r \u2022 x.coeff a :=", "nl_statement_of_codex": "Let $R$ be a monoid, $V$ be an $R$-module, and $x$ be a Hahn series with coefficients in $V$. Then the coefficient of $a$ in $r\\cdot x$ is $r\\cdot x_a$."}
{"name": "continuous_linear_map.op_norm_lmul_left_right_apply_apply_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.op_norm_lmul_left_right_apply_apply_le (\ud835\udd5c : Type*)\n\t[nondiscrete_normed_field \ud835\udd5c] (\ud835\udd5c' : Type*1) [normed_ring \ud835\udd5c']\n\t[normed_algebra \ud835\udd5c \ud835\udd5c'] (x y : \ud835\udd5c') :\n\t\u2225\u21d1(\u21d1(continuous_linear_map.lmul_left_right \ud835\udd5c \ud835\udd5c') x) y\u2225 \u2264 \u2225x\u2225 * \u2225y\u2225 :=", "nl_statement_of_codex": "Let $K$ be a nondiscrete normed field and let $R$ be a normed ring. Then the norm of the product of two elements of $R$ is less than or equal to the product of their norms."}
{"name": "has_strict_deriv_at.mul_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_strict_deriv_at.mul_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{x : \ud835\udd5c} {\ud835\udd38 : Type*} [normed_ring \ud835\udd38] [normed_algebra \ud835\udd5c \ud835\udd38] { : \ud835\udd5c \u2192 \ud835\udd38} {c' : \ud835\udd38}\n\t(hc : has_strict_deriv_at c c' x) (d : \ud835\udd38) :\n\thas_strict_deriv_at (\u03bb (y : \ud835\udd5c), c y * d) (c' * d) x :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function between normed rings. If $f$ has a strict derivative at $x$, then $f(x)d$ has a strict derivative at $x$."}
{"name": "simple_graph.top_adj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/basic.lean", "formal_statement": "theorem simple_graph.top_adj {V : Type u} (v w : V) :\n\t\u22a4.adj v w \u2194 v \u2260 w :=", "nl_statement_of_codex": "In the complete graph on $V$, two vertices $v$ and $w$ are adjacent if and only if $v\\neq w$."}
{"name": "tsub_self_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem tsub_self_add {\u03b1 : Type*} [canonically_ordered_add_monoid \u03b1] [has_sub \u03b1]\n\t[has_ordered_sub \u03b1] (a b : \u03b1) :\n\ta - (a + b) = 0 :=", "nl_statement_of_codex": "Let $\u03b1$ be a canonically ordered additive monoid with a subtraction operation. Then $a-(a+b)=0$."}
{"name": "ideal.radical_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.radical_top (R : Type u) [comm_semiring R] :\n\t\u22a4.radical = \u22a4 :=", "nl_statement_of_codex": "The radical of the ideal $\\{1\\}$ is the ideal $\\{1\\}$."}
{"name": "set.Union_congr_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Union_congr_of_surjective {\u03b1 : Type*} {\u03b9 : Sort u_4} {\u03b9\u2082 : Sort u_6}\n\t{f : \u03b9 \u2192 set \u03b1} {g : \u03b9\u2082 \u2192 set \u03b1} (h : \u03b9 \u2192 \u03b9\u2082) (h1 : function.surjective h)\n\t(h2 : \u2200 (x : \u03b9), g (h x) = f x) :\n\t(\u22c3 (x : \u03b9), f x) = \u22c3 (y : \u03b9\u2082), g y :=", "nl_statement_of_codex": "Let $f:I\\to\\mathcal{P}(X)$ and $g:J\\to\\mathcal{P}(X)$ be two families of subsets of $X$. If $h:I\\to J$ is a surjective function such that $g(h(i))=f(i)$ for all $i\\in I$, then $\\bigcup_{i\\in I}f(i)=\\bigcup_{j\\in J}g(j)$."}
{"name": "first_order.language.substructure.constants_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/substructures.lean", "formal_statement": "theorem first_order.language.substructure.constants_mem\n\t{L : first_order.language} {M : Type w} [L.Structure M] {S : L.substructure M}\n\t( : L.constants) :\n\t\u2191c \u2208 S :=", "nl_statement_of_codex": "Let $L$ be a first-order language, $M$ a structure for $L$, and $S$ a substructure of $M$. Then the constant symbols of $L$ are in $S$."}
{"name": "real.rpow_sum_of_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/pow.lean", "formal_statement": "theorem real.rpow_sum_of_pos {\u03b9 : Type*} {a : \u211d} (ha : 0 < a) (f : \u03b9 \u2192 \u211d)\n\t(s : finset \u03b9) :\n\ta ^ s.sum (\u03bb (x : \u03b9), f x) = s.prod (\u03bb (x : \u03b9), a ^ f x) :=", "nl_statement_of_codex": "Let $a$ be a positive real number and let $f:\\mathbb{N}\\to\\mathbb{R}$. Then $a^{\\sum_{i\\in I}f(i)}=\\prod_{i\\in I}a^{f(i)}$."}
{"name": "balanced_core_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/balanced_core_hull.lean", "formal_statement": "theorem balanced_core_subset {\ud835\udd5c E : Type*} [semi_normed_ring \ud835\udd5c] [has_smul \ud835\udd5c E]\n\t(s : set E) :\n\tbalanced_core \ud835\udd5c s \u2286 s :=", "nl_statement_of_codex": "The balanced core of a set $S$ is contained in $S$."}
{"name": "zmod.mul_inv_of_unit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/zmod/basic.lean", "formal_statement": "theorem zmod.mul_inv_of_unit {n : \u2115} (a : zmod n) (h : is_unit a) :\n\ta * a\u207b\u00b9 = 1 :=", "nl_statement_of_codex": "Let $n$ be a natural number and let $a$ be an element of $\\mathbb{Z}/n\\mathbb{Z}$. If $a$ is a unit, then $a\\cdot a^{-1}=1$."}
{"name": "finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/pigeonhole.lean", "formal_statement": "theorem finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to {\u03b1 : Type u}\n\t{\u03b2 : Type v} {M : Type w} [decidable_eq \u03b2] {s : finset \u03b1} {t : finset \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} {b : M} [linear_ordered_comm_ring M]\n\t(hf : \u2200 (a : \u03b1), a \u2208 s \u2192 f a \u2208 t) (ht : t.card \u2022 b < \u2191(s.card)) :\n\t\u2203 (y : \u03b2) (H : y \u2208 t), b < \u2191((finset.filter (\u03bb (x : \u03b1), f x = y) s).card) :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets, let $f:s\\to t$ be a function, and let $b$ be a positive integer. Suppose that $f$ is surjective and that $b|t|<|s|$. Then there is a $y\\in t$ such that $b<|f^{-1}(y)|$."}
{"name": "antisymm_rel_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/antisymmetrization.lean", "formal_statement": "theorem antisymm_rel_swap {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n\tantisymm_rel (function.swap r) = antisymm_rel r :=", "nl_statement_of_codex": "The relation $r$ is antisymmetric if and only if the relation $r^{-1}$ is antisymmetric."}
{"name": "category_theory.limits.coequalizer.\u03c0_desc_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/equalizers.lean", "formal_statement": "theorem category_theory.limits.coequalizer.\u03c0_desc_assoc {C : Type u}\n\t[category_theory.category C] {X Y : C} {f g : X \u27f6 Y}\n\t[category_theory.limits.has_coequalizer f g] {W : C} (k : Y \u27f6 W)\n\t(h : f \u226b k = g \u226b k) {X' : C} (f' : W \u27f6 X') :\n\tcategory_theory.limits.coequalizer.\u03c0 f g \u226b category_theory.limits.coequalizer.desc k h \u226b f' = k \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, let $X, Y, W$ be objects of $C$, let $f, g:X\\to Y$ and $k:Y\\to W$ be morphisms of $C$, and let $f':W\\to X'$ be a morphism of $C$. Suppose that $f\\circ k=g\\circ k$. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\nX \\arrow[r, "}
{"name": "filter.tendsto_at_top_at_top_of_monotone'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.tendsto_at_top_at_top_of_monotone' {\u03b9 \u03b1 : Type*} [preorder \u03b9]\n\t[linear_order \u03b1] {u : \u03b9 \u2192 \u03b1} (h : monotone u) (H : \u00acbdd_above (set.range u)) :\n\tfilter.tendsto u filter.at_top filter.at_top :=", "nl_statement_of_codex": "Let $u:\\mathbb{N}\\to\\mathbb{R}$ be a monotone function. If $u$ is unbounded above, then $u$ tends to infinity."}
{"name": "rel.mem_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rel.lean", "formal_statement": "theorem rel.mem_image {\u03b1 \u03b2 : Type*} (r : rel \u03b1 \u03b2) (y : \u03b2) (s : set \u03b1) :\n\ty \u2208 r.image s \u2194 \u2203 (x : \u03b1) (H : x \u2208 s), r x y :=", "nl_statement_of_codex": "Let $r$ be a relation from $A$ to $B$. Then $y\\in r(A)$ if and only if there is an $x\\in A$ such that $r(x,y)$."}
{"name": "znum.zero_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/num/lemmas.lean", "formal_statement": "theorem znum.zero_add (n : znum) :\n\t0 + n = n :=", "nl_statement_of_codex": "$0+n=n$ for all $n\\in\\mathbb{Z}$."}
{"name": "category_theory.coalgebra_to_over_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/products.lean", "formal_statement": "theorem category_theory.coalgebra_to_over_map {C : Type u}\n\t[category_theory.category C] (X : C)\n\t[category_theory.limits.has_binary_products C]\n\t(A\u2081 A\u2082 : (category_theory.prod_comonad X).coalgebra) (f : A\u2081 \u27f6 A\u2082) :\n\t(category_theory.coalgebra_to_over X).map f = category_theory.over.hom_mk f.f _ :=", "nl_statement_of_codex": "Let $C$ be a category with binary products. Let $X$ be an object of $C$. Let $A_1$ and $A_2$ be coalgebras over the product comonad of $X$. Let $f:A_1\\to A_2$ be a morphism. Then the map $f$ is the same as the morphism $f$ in the over category."}
{"name": "polynomial.ne_zero_of_degree_gt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.ne_zero_of_degree_gt {R : Type u} [semiring R]\n\t{p : polynomial R} {n : with_bot \u2115} (h : n < p.degree) :\n\tp \u2260 0 :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. If $p$ has degree $n$, then $p$ is nonzero."}
{"name": "flow.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/flow.lean", "formal_statement": "theorem flow.ext {\u03c4 : Type*} [add_monoid \u03c4] [topological_space \u03c4]\n\t[has_continuous_add \u03c4] {\u03b1 : Type*} [topological_space \u03b1] {\u03d5\u2081 \u03d5\u2082 : flow \u03c4 \u03b1} :\n\t(\u2200 (t : \u03c4) (x : \u03b1), \u21d1\u03d5\u2081 t x = \u21d1\u03d5\u2082 t x) \u2192 \u03d5\u2081 = \u03d5\u2082 :=", "nl_statement_of_codex": "Let $\\phi_1, \\phi_2: \\mathbb{R}\\times X\\to X$ be flows on a topological space $X$. Then $\\phi_1=\\phi_2$ if and only if $\\phi_1(t,x)=\\phi_2(t,x)$ for all $t\\in\\mathbb{R}$ and $x\\in X$."}
{"name": "absorbs.inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/locally_convex/basic.lean", "formal_statement": "theorem absorbs.inter {\ud835\udd5c E : Type*} [normed_field \ud835\udd5c] [add_comm_group E]\n\t[module \ud835\udd5c E] {s t u : set E} (hs : absorbs \ud835\udd5c s u) (ht : absorbs \ud835\udd5c t u) :\n\tabsorbs \ud835\udd5c (s \u2229 t) u :=", "nl_statement_of_codex": "Let $E$ be a normed vector space over a field $K$. Let $s,t,u$ be subsets of $E$. If $s$ and $t$ absorb $u$, then $s\\cap t$ absorbs $u$."}
{"name": "category_theory.monad.monadicity_internal.counit_cofork_\u03b9_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/monadicity.lean", "formal_statement": "theorem category_theory.monad.monadicity_internal.counit_cofork_\u03b9_app\n\t{C : Type u\u2081} {D : Type u\u2082} [category_theory.category C]\n\t[category_theory.category D] {G : D \u2964 C} [category_theory.is_right_adjoint G]\n\t(B : D) (X : category_theory.limits.walking_parallel_pair) :\n\t(category_theory.monad.monadicity_internal.counit_cofork B).\u03b9.app X = category_theory.limits.walking_parallel_pair.rec ((category_theory.adjunction.of_right_adjoint G).counit.app ((category_theory.left_adjoint G).obj (G.obj B)) \u226b (category_theory.adjunction.of_right_adjoint G).counit.app B) ((category_theory.adjunction.of_right_adjoint G).counit.app B) X :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $G:D\\to C$ be a functor. Suppose that $G$ is right adjoint to some functor $F:C\\to D$. Let $B$ be an object of $D$ and let $X$ be a walking parallel pair. Then the counit of the cofork of $B$ applied to $X$ is equal to the recursion of the counit of $G$ applied to $F(G(B))$ followed by the counit of $G$ applied to $B$ and the walking parallel pair $X$."}
{"name": "monoid_hom.mker_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/operations.lean", "formal_statement": "theorem monoid_hom.mker_inr {M N : Type*} [mul_one_class M] [mul_one_class N] :\n\tmonoid_hom.mker (monoid_hom.inr M N) = \u22a5 :=", "nl_statement_of_codex": "The kernel of the monoid homomorphism $M\\to M\\times N$ is the trivial submonoid of $M$."}
{"name": "nat.one_eq_bit1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.one_eq_bit1 {n : \u2115} :\n\t1 = bit1 n \u2194 n = 0 :=", "nl_statement_of_codex": "$1=2^n$ if and only if $n=0$."}
{"name": "submonoid.localization_map.of_mul_equiv_of_mul_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.of_mul_equiv_of_mul_equiv {M : Type*}\n\t[comm_monoid M] {S : submonoid M} {N : Type*} [comm_monoid N] {P : Type*}\n\t[comm_monoid P] (f : S.localization_map N) {T : submonoid P} {Q : Type*}\n\t[comm_monoid Q] {k : T.localization_map Q} {j : M \u2243* P}\n\t(H : submonoid.map j.to_monoid_hom S = T) :\n\t(f.of_mul_equiv_of_localizations (f.mul_equiv_of_mul_equiv k H)).to_map = k.to_map.comp j.to_monoid_hom :=", "nl_statement_of_codex": "Let $M$ and $N$ be commutative monoids, let $S$ be a submonoid of $M$, let $P$ and $Q$ be commutative monoids, let $T$ be a submonoid of $P$, let $f:S\\to N$ be a localization map, let $k:T\\to Q$ be a localization map, and let $j:M\\to P$ be a monoid isomorphism. If $j(S)=T$, then the map $f\\circ j:S\\to N$ is a localization map."}
{"name": "same_ray_neg_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/ray.lean", "formal_statement": "theorem same_ray_neg_iff {R : Type*} [ordered_comm_ring R] {M : Type*}\n\t[add_comm_group M] [module R M] {x y : M} :\n\tsame_ray R (-x) (-y) \u2194 same_ray R x y :=", "nl_statement_of_codex": "Let $R$ be an ordered commutative ring, $M$ an $R$-module, and $x,y\\in M$. Then $x$ and $y$ are on the same ray if and only if $-x$ and $-y$ are on the same ray."}
{"name": "intermediate_field.intermediate_field_map_symm_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/intermediate_field.lean", "formal_statement": "theorem intermediate_field.intermediate_field_map_symm_apply_coe {K L : Type*}\n\t[field K] [field L] [algebra K L] {L' : Type*} [field L'] [algebra K L']\n\t(e : L \u2243\u2090[K] L') (E : intermediate_field K L) (a : \u21a5(E.map e.to_alg_hom)) :\n\t\u2191(\u21d1((intermediate_field.intermediate_field_map e E).symm) a) = \u21d1(e.symm) \u2191a :=", "nl_statement_of_codex": "Let $K$ be a field, let $L$ be a field extension of $K$, let $L'$ be a field extension of $K$, and let $e:L\\to L'$ be an isomorphism of $K$-algebras. Let $E$ be an intermediate field of $K$ and $L$. Then the map $E\\to L'$ induced by $e$ is an isomorphism of $K$-algebras."}
{"name": "finsupp.mul_hom_ext'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.mul_hom_ext' {\u03b1 M N : Type*} [add_zero_class M]\n\t[mul_one_class N] {f g : multiplicative (\u03b1 \u2192\u2080 M) \u2192* N}\n\t(H : \u2200 (x : \u03b1), f.comp (\u21d1add_monoid_hom.to_multiplicative (finsupp.single_add_hom x)) = g.comp (\u21d1add_monoid_hom.to_multiplicative (finsupp.single_add_hom x))) :\n\tf = g :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}^n\\to N$ be two multiplicative functions. If $f(e_i)=g(e_i)$ for all $i=1,\\ldots,n$, then $f=g$."}
{"name": "dioph.abs_poly_dioph", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/dioph.lean", "formal_statement": "theorem dioph.abs_poly_dioph {\u03b1 : Type u} (p : poly \u03b1) :\n\tdioph.dioph_fn (\u03bb (v : \u03b1 \u2192 \u2115), (\u21d1p v).nat_abs) :=", "nl_statement_of_codex": "The function $f:\\mathbb{N}^n\\to\\mathbb{N}$ defined by $f(v)=|p(v)|$ is Diophantine."}
{"name": "power_series.coeff_mul_X_pow'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_series/basic.lean", "formal_statement": "theorem power_series.coeff_mul_X_pow' {R : Type*} [semiring R]\n\t(p : power_series R) (n d : \u2115) :\n\t\u21d1(power_series.coeff R d) (p * power_series.X ^ n) = ite (n \u2264 d) (\u21d1(power_series.coeff R (d - n)) p) 0 :=", "nl_statement_of_codex": "Let $p$ be a power series over a semiring $R$. Then the coefficient of $X^d$ in $p(X)$ is equal to the coefficient of $X^{d-n}$ in $p(X)$ if $n\\leq d$ and is equal to $0$ otherwise."}
{"name": "finset.vsub_eq_empty", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/pointwise.lean", "formal_statement": "theorem finset.vsub_eq_empty {\u03b1 \u03b2 : Type*} [decidable_eq \u03b1] [has_vsub \u03b1 \u03b2]\n\t{s t : finset \u03b2} :\n\ts -\u1d65 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205 :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets. Then $s-t=\\emptyset$ if and only if $s=\\emptyset$ or $t=\\emptyset$."}
{"name": "has_strict_deriv_at.mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_strict_deriv_at.mul {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{x : \ud835\udd5c} {\ud835\udd38 : Type*} [normed_ring \ud835\udd38] [normed_algebra \ud835\udd5c \ud835\udd38] {c d : \ud835\udd5c \u2192 \ud835\udd38}\n\t{c' d' : \ud835\udd38} (hc : has_strict_deriv_at c c' x) (hd : has_strict_deriv_at d d' x) :\n\thas_strict_deriv_at (\u03bb (y : \ud835\udd5c), c y * d y) (c' * d x + c x * d') x :=", "nl_statement_of_codex": "Let $c,d: \\mathbb{R}\\to \\mathbb{R}$ be differentiable at $x$. Then $c\\cdot d$ is differentiable at $x$ and $(c\\cdot d)'(x)=c'(x)\\cdot d(x)+c(x)\\cdot d'(x)$."}
{"name": "set.Icc_subset_Ici_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Icc_subset_Ici_self {\u03b1 : Type*} [preorder \u03b1] {a b : \u03b1} :\n\tset.Icc a b \u2286 set.Ici a :=", "nl_statement_of_codex": "Let $a,b$ be elements of a preorder. Then $[a,b]\\subset (a,\\infty)$."}
{"name": "finset.map_of_dual_min", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.map_of_dual_min {\u03b1 : Type*} [linear_order \u03b1] (s : finset \u03b1\u1d52\u1d48) :\n\twith_top.map \u21d1order_dual.of_dual s.min = (finset.image \u21d1order_dual.of_dual s).max :=", "nl_statement_of_codex": "Let $s$ be a finite set of linear order. Then the minimum of the dual of $s$ is the maximum of the dual of the image of $s$."}
{"name": "continuous_inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/order/lattice.lean", "formal_statement": "theorem continuous_inf {L : Type*} [topological_space L] [has_inf L]\n\t[has_continuous_inf L] :\n\tcontinuous (\u03bb (p : L \u00d7 L), p.fst \u2293 p.snd) :=", "nl_statement_of_codex": "The infimum of two elements of a topological lattice is continuous."}
{"name": "measure_theory.is_stopping_time.measurable_set_lt_of_encodable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/stopping.lean", "formal_statement": "theorem measure_theory.is_stopping_time.measurable_set_lt_of_encodable\n\t{\u03b1 \u03b9 : Type*} {m : measurable_space \u03b1} [partial_order \u03b9] {\u03c4 : \u03b1 \u2192 \u03b9}\n\t{f : measure_theory.filtration \u03b9 m} [encodable \u03b9]\n\t(h\u03c4 : measure_theory.is_stopping_time f \u03c4) (i : \u03b9) :\n\tmeasurable_set {a : \u03b1 | \u03c4 a < i} :=", "nl_statement_of_codex": "Let $\u03b1$ be a measurable space, let $\u03b9$ be a partially ordered set, let $\u03c4:\u03b1\\to \u03b9$ be a stopping time, and let $f$ be a filtration. If $\u03b9$ is encodable, then the set $\\{a\\in \u03b1:\u03c4(a)<i\\}$ is measurable."}
{"name": "ideal.prime_ideals_equiv_symm_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/prod.lean", "formal_statement": "theorem ideal.prime_ideals_equiv_symm_inr {R : Type u} {S : Type v} [ring R]\n\t[ring S] (J : ideal S) (h : J.is_prime) :\n\t\u21d1((ideal.prime_ideals_equiv R S).symm) (sum.inr \u27e8J, h\u27e9) = \u27e8\u22a4.prod J, _\u27e9 :=", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $J$ be a prime ideal of $S$. Then the prime ideals of $R\\times S$ are in bijection with the prime ideals of $R$ and the prime ideals of $S$."}
{"name": "omega_complete_partial_order.continuous_hom.congr_arg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/omega_complete_partial_order.lean", "formal_statement": "theorem omega_complete_partial_order.continuous_hom.congr_arg {\u03b1 : Type u}\n\t{\u03b2 : Type v} [omega_complete_partial_order \u03b1] [omega_complete_partial_order \u03b2]\n\t(f : \u03b1 \u2192\ud835\udc84 \u03b2) {x y : \u03b1} (h : x = y) :\n\t\u21d1f x = \u21d1f y :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous function between omega-complete partial orders. Then $f$ is continuous at $x$ if and only if $f$ is continuous at $y$."}
{"name": "category_theory.limits.wide_equalizer.hom_ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/wide_equalizers.lean", "formal_statement": "theorem category_theory.limits.wide_equalizer.hom_ext {J : Type w} {C : Type u}\n\t[category_theory.category C] {X Y : C} {f : J \u2192 (X \u27f6 Y)}\n\t[category_theory.limits.has_wide_equalizer f] [nonempty J] {W : C}\n\t{k l : W \u27f6 category_theory.limits.wide_equalizer f}\n\t(h : k \u226b category_theory.limits.wide_equalizer.\u03b9 f = l \u226b category_theory.limits.wide_equalizer.\u03b9 f) :\n\tk = l :=", "nl_statement_of_codex": "Let $C$ be a category, $X, Y$ objects of $C$, and $f:J\\to C(X,Y)$ a functor. If $W$ is a wide equalizer of $f$, then the morphisms $k,l:W\\to \\mathrm{eq}(f)$ are equal if and only if $k\\circ \\iota_f=l\\circ \\iota_f$."}
{"name": "nat.count_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/count.lean", "formal_statement": "theorem nat.count_one (p : \u2115 \u2192 Prop) [decidable_pred p] :\n\tnat.count p 1 = ite (p 0) 1 0 :=", "nl_statement_of_codex": "The number of elements of $\\{0\\}$ satisfying $p$ is $1$ if $p(0)$ is true and $0$ otherwise."}
{"name": "interval_integral.integral_lt_integral_of_ae_le_of_measure_set_of_lt_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/interval_integral.lean", "formal_statement": "theorem interval_integral.integral_lt_integral_of_ae_le_of_measure_set_of_lt_ne_zero\n\t{f g : \u211d \u2192 \u211d} {a b : \u211d} {\u03bc : measure_theory.measure \u211d} (hab : a \u2264 b)\n\t(hfi : interval_integrable f \u03bc a b) (hgi : interval_integrable g \u03bc a b)\n\t(hle : f \u2264\u1d50[\u03bc.restrict (set.Ioc a b)] g)\n\t(hlt : \u21d1(\u03bc.restrict (set.Ioc a b)) {x : \u211d | f x < g x} \u2260 0) :\n\t\u222b (x : \u211d) in a..b, f x \u2202\u03bc < \u222b (x : \u211d) in a..b, g x \u2202\u03bc :=", "nl_statement_of_codex": "Let $f, g: \\mathbb{R}\\to \\mathbb{R}$ be integrable functions on $[a,b]$ with respect to a measure $\\mu$. Suppose that $f\\leq g$ almost everywhere and that $\\mu(\\{x\\in [a,b]\\mid f(x)<g(x)\\})>0$. Then $\\int_a^b f(x)d\\mu(x)<\\int_a^b g(x)d\\mu(x)$."}
{"name": "euclidean_domain.gcd_zero_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/euclidean_domain.lean", "formal_statement": "theorem euclidean_domain.gcd_zero_left {R : Type u} [euclidean_domain R]\n\t[decidable_eq R] (a : R) :\n\teuclidean_domain.gcd 0 a = a :=", "nl_statement_of_codex": "In a Euclidean domain, the gcd of $0$ and $a$ is $a$."}
{"name": "edist_pi_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean", "formal_statement": "theorem edist_pi_le_iff {\u03b2 : Type v} {\u03c0 : \u03b2 \u2192 Type*} [fintype \u03b2]\n\t[\u03a0 (b : \u03b2), pseudo_emetric_space (\u03c0 b)] {f g : \u03a0 (b : \u03b2), \u03c0 b} {d : ennreal} :\n\thas_edist.edist f g \u2264 d \u2194 \u2200 (b : \u03b2), has_edist.edist (f b) (g b) \u2264 d :=", "nl_statement_of_codex": "Let $f,g:\\beta\\to\\pi$ be functions. Then $d(f,g)\\leq d$ if and only if $d(f(b),g(b))\\leq d$ for all $b\\in\\beta$."}
{"name": "list.map_lookup_eq_find", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/sigma.lean", "formal_statement": "theorem list.map_lookup_eq_find {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1]\n\t(a : \u03b1) (l : list (sigma \u03b2)) :\n\toption.map (sigma.mk a) (list.lookup a l) = list.find (\u03bb (s : sigma \u03b2), a = s.fst) l :=", "nl_statement_of_codex": "Let $a$ be an element of a type $\u03b1$ and let $l$ be a list of elements of the type $\\sigma \u03b2$. Then the map of the pair $(a,b)$ where $b$ is the element of $l$ with first component $a$ is equal to the find of the list $l$ with the predicate $a=s.fst$."}
{"name": "category_theory.monoidal_category.associator_conjugation_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/category.lean", "formal_statement": "theorem category_theory.monoidal_category.associator_conjugation_assoc\n\t{C : Type u} [category_theory.category C] [category_theory.monoidal_category C]\n\t{X X' Y Y' Z Z' : C} (f : X \u27f6 X') (g : Y \u27f6 Y') (h : Z \u27f6 Z') {X'_1 : C}\n\t(f' : (X' \u2297 Y') \u2297 Z' \u27f6 X'_1) :\n\t((f \u2297 g) \u2297 h) \u226b f' = (\u03b1_ X Y Z).hom \u226b (f \u2297 g \u2297 h) \u226b (\u03b1_ X' Y' Z').inv \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X, X', Y, Y', Z, Z'$ be objects of $C$ and let $f:X\\to X'$, $g:Y\\to Y'$, $h:Z\\to Z'$ be morphisms in $C$. Let $X'_1$ be an object of $C$ and let $f':(X'\\otimes Y')\\otimes Z'\\to X'_1$ be a morphism in $C$. Then $(f\\otimes g\\otimes h)\\circ (\\alpha_{X,Y,Z})^{-1}\\circ f'=(\\alpha_{X"}
{"name": "continuous_map.linear_isometry_bounded_of_compact_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/continuous_function/compact.lean", "formal_statement": "theorem continuous_map.linear_isometry_bounded_of_compact_symm_apply\n\t{\u03b1 E : Type*} [topological_space \u03b1] [compact_space \u03b1] [normed_group E]\n\t{\ud835\udd5c : Type*} [normed_field \ud835\udd5c] [normed_space \ud835\udd5c E]\n\t(f : bounded_continuous_function \u03b1 E) :\n\t\u21d1((continuous_map.linear_isometry_bounded_of_compact \u03b1 E \ud835\udd5c).symm) f = f.to_continuous_map :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $f:E\\to E$ be a bounded continuous function. Then $f$ is a linear isometry."}
{"name": "module.free_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/free_module/basic.lean", "formal_statement": "theorem module.free_def (R : Type u) (M : Type v) [semiring R]\n\t[add_comm_monoid M] [module R M] [small M] :\n\tmodule.free R M \u2194 \u2203 (I : Type w), nonempty (basis I R M) :=", "nl_statement_of_codex": "A module $M$ over a ring $R$ is free if and only if there is a basis for $M$."}
{"name": "cardinal.mk_range_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.mk_range_eq {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2)\n\t(h : function.injective f) :\n\tcardinal.mk \u21a5(set.range f) = cardinal.mk \u03b1 :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $|B|=|A|$."}
{"name": "finset.image_univ_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem finset.image_univ_of_surjective {\u03b1 \u03b2 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] [fintype \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : function.surjective f) :\n\tfinset.image f finset.univ = finset.univ :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a surjective function. Then $f(A)=B$."}
{"name": "absolute_value.ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/absolute_value.lean", "formal_statement": "theorem absolute_value.ne_zero {R S : Type*} [semiring R] [ordered_semiring S]\n\t(abv : absolute_value R S) {x : R} (hx : x \u2260 0) :\n\t\u21d1abv x \u2260 0 :=", "nl_statement_of_codex": "Let $R$ be a semiring and $S$ be an ordered semiring. Let $abv$ be an absolute value on $R$ and let $x\\in R$. If $x\\neq 0$, then $abv(x)\\neq 0$."}
{"name": "pnat.find_eq_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pnat/find.lean", "formal_statement": "theorem pnat.find_eq_iff {p : \u2115+ \u2192 Prop} [decidable_pred p]\n\t(h : \u2203 (n : \u2115+), p n) {m : \u2115+} :\n\tpnat.find h = m \u2194 p m \u2227 \u2200 (n : \u2115+), n < m \u2192 \u00acp n :=", "nl_statement_of_codex": "Let $p$ be a predicate on the positive integers. Then $m$ is the least positive integer satisfying $p$ if and only if $p(m)$ holds and $p(n)$ does not hold for all $n<m$."}
{"name": "category_theory.limits.binary_bicone_of_split_epi_of_kernel_inl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.binary_bicone_of_split_epi_of_kernel_inl\n\t{C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t{X Y : C} {f : X \u27f6 Y} [category_theory.split_epi f]\n\t{ : category_theory.limits.kernel_fork f}\n\t(i : category_theory.limits.is_limit c) :\n\t(category_theory.limits.binary_bicone_of_split_epi_of_kernel i).inl = category_theory.limits.fork.\u03b9 c :=", "nl_statement_of_codex": "Let $C$ be a category with finite limits. Let $f:X\\to Y$ be a split epimorphism with kernel $K$. Then the left leg of the binary bicone of $f$ is the kernel of $f$."}
{"name": "homological_complex.comp_f", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/homological_complex.lean", "formal_statement": "theorem homological_complex.comp_f {\u03b9 : Type*} {V : Type u}\n\t[category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t{ : complex_shape \u03b9} {C\u2081 C\u2082 C\u2083 : homological_complex V c} (f : C\u2081 \u27f6 C\u2082)\n\t(g : C\u2082 \u27f6 C\u2083) (i : \u03b9) :\n\t(f \u226b g).f i = f.f i \u226b g.f i :=", "nl_statement_of_codex": "Let $C_1, C_2, C_3$ be homological complexes of shape $c$ and let $f:C_1\\to C_2$ and $g:C_2\\to C_3$ be morphisms of complexes. Then $(f\\circ g)_i=f_i\\circ g_i$."}
{"name": "exterior_algebra.lift_alternating_algebra_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/exterior_algebra/of_alternating.lean", "formal_statement": "theorem exterior_algebra.lift_alternating_algebra_map {R M N : Type*}\n\t[comm_ring R] [add_comm_group M] [add_comm_group N] [module R M] [module R N]\n\t(f : \u03a0 (i : \u2115), alternating_map R M N (fin i)) (r : R) :\n\t\u21d1(\u21d1exterior_algebra.lift_alternating f) (\u21d1(algebra_map R (exterior_algebra R M)) r) = r \u2022 \u21d1(f 0) 0 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ and $N$ be $R$-modules. Let $f:\\mathbb{N}\\to \\mathrm{Alt}(M,N)$ be a function. Then the exterior algebra of $M$ is a $R$-algebra and the exterior algebra of $N$ is a $R$-algebra. The exterior algebra of $M$ is a $R$-module and the exterior algebra of $N$ is a $R$-module. The exterior algebra of $M$ is a $R$-module and the exterior algebra of $N$ is a $R$-module. The exterior algebra of $"}
{"name": "category_theory.limits.cospan_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/pullbacks.lean", "formal_statement": "theorem category_theory.limits.cospan_left {C : Type u}\n\t[category_theory.category C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n\t(category_theory.limits.cospan f g).obj category_theory.limits.walking_cospan.left = X :=", "nl_statement_of_codex": "The left object of the cospan $X\\leftarrow Z\\rightarrow Y$ is $X$."}
{"name": "subgroup.one_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem subgroup.one_mem {G : Type*} [group G] (H : subgroup G) :\n\t1 \u2208 H :=", "nl_statement_of_codex": "The identity element of a group is in every subgroup."}
{"name": "list.keys_kerase", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/sigma.lean", "formal_statement": "theorem list.keys_kerase {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {a : \u03b1}\n\t{l : list (sigma \u03b2)} :\n\t(list.kerase a l).keys = l.keys.erase a :=", "nl_statement_of_codex": "Let $l$ be a list of pairs $(a,b)$ where $a$ is a key and $b$ is a value. Then the keys of $l$ with the key $a$ removed is the same as the keys of $l$ with $a$ removed."}
{"name": "set.mem_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.mem_def {\u03b1 : Type u} {a : \u03b1} {s : set \u03b1} :\n\ta \u2208 s \u2194 s a :=", "nl_statement_of_codex": "$a\\in s$ if and only if $s(a)$."}
{"name": "first_order.language.empty_card", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/basic.lean", "formal_statement": "theorem first_order.language.empty_card :\n\tfirst_order.language.empty.card = 0 :=", "nl_statement_of_codex": "The cardinality of the empty language is $0$."}
{"name": "int.cast_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/cast/defs.lean", "formal_statement": "theorem int.cast_one {R : Type u} [add_group_with_one R] :\n\t\u21911 = 1 :=", "nl_statement_of_codex": "The cast from $\\mathbb{Z}$ to $R$ sends $1$ to $1$."}
{"name": "circle_integral.integral_sub_inv_of_mem_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/circle_integral.lean", "formal_statement": "theorem circle_integral.integral_sub_inv_of_mem_ball {c w : \u2102} {R : \u211d}\n\t(hw : w \u2208 metric.ball c R) :\n\t\u222e (z : \u2102) in C(c, R), (z - w)\u207b\u00b9 = 2 * \u2191real.pi * complex.I :=", "nl_statement_of_codex": "Let $c$ and $w$ be complex numbers and let $R$ be a real number. If $w$ is in the ball of radius $R$ centered at $c$, then the integral of $(z-w)^{-1}$ over the circle of radius $R$ centered at $c$ is $2\\pi i$."}
{"name": "option.eq_none_of_is_none", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/option/instances.lean", "formal_statement": "theorem option.eq_none_of_is_none {\u03b1 : Type u} {o : option \u03b1} :\n\t\u21a5(o.is_none) \u2192 o = option.none :=", "nl_statement_of_codex": "If $o$ is a none option, then $o=\\text{none}$."}
{"name": "linear_equiv.dual_map_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/dual.lean", "formal_statement": "theorem linear_equiv.dual_map_apply {R : Type*} [comm_semiring R]\n\t{M\u2081 M\u2082 : Type*} [add_comm_monoid M\u2081] [module R M\u2081] [add_comm_monoid M\u2082]\n\t[module R M\u2082] (f : M\u2081 \u2243\u2097[R] M\u2082) (g : module.dual R M\u2082) (x : M\u2081) :\n\t\u21d1(\u21d1(f.dual_map) g) x = \u21d1g (\u21d1f x) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $M_1$ and $M_2$ be $R$-modules, and let $f:M_1\\to M_2$ be a linear map. Then the dual map of the dual map of $f$ is equal to the dual map of $f$."}
{"name": "multiplicative.is_submonoid", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/submonoid.lean", "formal_statement": "theorem multiplicative.is_submonoid {A : Type*} [add_monoid A] {s : set A}\n\t(is : is_add_submonoid s) :\n\tis_submonoid s :=", "nl_statement_of_codex": "Let $A$ be an additive monoid and let $s$ be a subset of $A$. If $s$ is a submonoid of $A$, then $s$ is a submonoid of $A$."}
{"name": "free_group.reduce.exact", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/free_group.lean", "formal_statement": "theorem free_group.reduce.exact {\u03b1 : Type u} {L\u2081 L\u2082 : list (\u03b1 \u00d7 bool)}\n\t[decidable_eq \u03b1] (H : free_group.reduce L\u2081 = free_group.reduce L\u2082) :\n\tfree_group.mk L\u2081 = free_group.mk L\u2082 :=", "nl_statement_of_codex": "Let $L_1$ and $L_2$ be lists of pairs of elements of a type $\u03b1$ and booleans. If the reduced forms of $L_1$ and $L_2$ are equal, then the free groups generated by $L_1$ and $L_2$ are equal."}
{"name": "metric.mem_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.mem_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x y : \u03b1} {\u03b5 : \u211d} :\n\ty \u2208 metric.ball x \u03b5 \u2194 has_dist.dist y x < \u03b5 :=", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. Then $y\\in B(x,\\epsilon)$ if and only if $d(x,y)<\\epsilon$."}
{"name": "rat.num_denom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/defs.lean", "formal_statement": "theorem rat.num_denom {a : \u211a} :\n\trat.mk a.num \u2191(a.denom) = a :=", "nl_statement_of_codex": "The numerator and denominator of a rational number $a$ are coprime."}
{"name": "set.Iic_union_Icc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/basic.lean", "formal_statement": "theorem set.Iic_union_Icc {\u03b1 : Type*} [linear_order \u03b1] {b c d : \u03b1}\n\t(h : linear_order.min c d \u2264 b) :\n\tset.Iic b \u222a set.Icc c d = set.Iic (linear_order.max b d) :=", "nl_statement_of_codex": "Let $\u03b1$ be a linear order and let $b, c, d$ be elements of $\u03b1$. If $c\\leq d\\leq b$, then $[b,\\infty)\\cup [c,d] = [\\max\\{b,d\\},\\infty)$."}
{"name": "conj_act.fixed_points_eq_center", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/group_action/conj_act.lean", "formal_statement": "theorem conj_act.fixed_points_eq_center {G : Type*} [group G] :\n\tmul_action.fixed_points (conj_act G) G = \u2191(subgroup.center G) :=", "nl_statement_of_codex": "The fixed points of the conjugation action of $G$ on itself are the elements of the center of $G$."}
{"name": "iff_false_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem iff_false_right {a b : Prop} (ha : \u00aca) :\n\tb \u2194 a \u2194 \u00acb :=", "nl_statement_of_codex": "If $a$ is false, then $b$ is equivalent to $a$ being equivalent to $b$ being false."}
{"name": "sub_mem_comm_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/subgroup/basic.lean", "formal_statement": "theorem sub_mem_comm_iff {G : Type*} [add_group G] {S : Type*} {H : S}\n\t[set_like S G] [hSG : add_subgroup_class S G] {a b : G} :\n\ta - b \u2208 H \u2194 b - a \u2208 H :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $H$ be a subgroup of $G$. Then $a-b\\in H$ if and only if $b-a\\in H$."}
{"name": "alg_equiv.coe_fun_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem alg_equiv.coe_fun_injective {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w}\n\t[comm_semiring R] [semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082] :\n\tfunction.injective (\u03bb (e : A\u2081 \u2243\u2090[R] A\u2082), \u21d1e) :=", "nl_statement_of_codex": "The map from the set of $R$-algebra isomorphisms from $A_1$ to $A_2$ to the set of all functions from $A_1$ to $A_2$ is injective."}
{"name": "CommMon_.equiv_lax_braided_functor_punit.lax_braided_to_CommMon_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/CommMon_.lean", "formal_statement": "theorem CommMon_.equiv_lax_braided_functor_punit.lax_braided_to_CommMon_map\n\t(C : Type u\u2081) [category_theory.category C]\n\t[category_theory.monoidal_category C] [category_theory.braided_category C]\n\t(F G : category_theory.lax_braided_functor (category_theory.discrete punit) C)\n\t(\u03b1 : F \u27f6 G) :\n\t(CommMon_.equiv_lax_braided_functor_punit.lax_braided_to_CommMon C).map \u03b1 = ((category_theory.lax_braided_functor.map_CommMon_functor (category_theory.discrete punit) C).map \u03b1).app (CommMon_.trivial (category_theory.discrete punit)) :=", "nl_statement_of_codex": "Let $C$ be a braided category. Let $F, G: \\mathbf{1}\\to C$ be lax braided functors. Let $\\alpha:F\\to G$ be a natural transformation. Then the following diagram commutes:\n$$\\begin{array}{ccc}\n\\mathbf{1} & \\xrightarrow{\\alpha} & \\mathbf{1} \\\\\n\\downarrow & & \\downarrow \\\\\n\\mathbf{CommMon} & \\xrightarrow{\\alpha} & \\mathbf{CommMon}\n\\end{array}$$"}
{"name": "is_prime_pow.min_fac_pow_factorization_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/factorization/prime_pow.lean", "formal_statement": "theorem is_prime_pow.min_fac_pow_factorization_eq {n : \u2115} (hn : is_prime_pow n) :\n\tn.min_fac ^ \u21d1(n.factorization) n.min_fac = n :=", "nl_statement_of_codex": "Let $n$ be a prime power. Then $n=p^k$ where $p$ is the smallest prime factor of $n$ and $k$ is the multiplicity of $p$ in the prime factorization of $n$."}
{"name": "polynomial.coeff_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/coeff.lean", "formal_statement": "theorem polynomial.coeff_sum {R : Type u} {S : Type v} [semiring R]\n\t{p : polynomial R} [semiring S] (n : \u2115) (f : \u2115 \u2192 R \u2192 polynomial S) :\n\t(p.sum f).coeff n = p.sum (\u03bb (a : \u2115) (b : R), (f a b).coeff n) :=", "nl_statement_of_codex": "Let $R$ and $S$ be semirings. Let $p$ be a polynomial over $R$ and let $f:\\mathbb{N}\\times R\\to S[x]$ be a function. Then the coefficient of $x^n$ in $p.sum(f)$ is equal to the sum of the coefficients of $x^n$ in $f(a,b)$ for all $a\\in\\mathbb{N}$ and $b\\in R$."}
{"name": "complex.circle_integral_eq_zero_of_differentiable_on_off_countable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/complex/cauchy_integral.lean", "formal_statement": "theorem complex.circle_integral_eq_zero_of_differentiable_on_off_countable\n\t{E : Type u} [normed_group E] [normed_space \u2102 E] [complete_space E] {R : \u211d}\n\t(h0 : 0 \u2264 R) {f : \u2102 \u2192 E} { : \u2102} {s : set \u2102} (hs : s.countable)\n\t(hc : continuous_on f (metric.closed_ball c R))\n\t(hd : \u2200 (z : \u2102), z \u2208 metric.ball c R \\ s \u2192 differentiable_at \u2102 f z) :\n\t\u222e (z : \u2102) in C(c, R), f z = 0 :=", "nl_statement_of_codex": "Let $E$ be a complete normed space over $\\mathbb{C}$. Let $f: \\mathbb{C}\\to E$ be continuous on the closed ball $B(c,R)$ and differentiable on the open ball $B(c,R)\\setminus s$, where $s$ is a countable set. Then $\\int_{B(c,R)} f(z)dz=0$."}
{"name": "part.mem_restrict", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.mem_restrict {\u03b1 : Type*} (p : Prop) (o : part \u03b1) (h : p \u2192 o.dom)\n\t(a : \u03b1) :\n\ta \u2208 part.restrict p o h \u2194 p \u2227 a \u2208 o :=", "nl_statement_of_codex": "Let $p$ be a proposition and let $o$ be a partition of a set $A$. Let $h$ be a function from $p$ to $A$. Then $a\\in o$ if and only if $p$ is true and $a\\in o$."}
{"name": "polynomial.prime_of_degree_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/field_division.lean", "formal_statement": "theorem polynomial.prime_of_degree_eq_one {R : Type u} [field R]\n\t{p : polynomial R} (hp1 : p.degree = 1) :\n\tprime p :=", "nl_statement_of_codex": "Let $R$ be a field and let $p$ be a polynomial over $R$. If $p$ has degree $1$, then $p$ is prime."}
{"name": "closure_operator.id_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/closure.lean", "formal_statement": "theorem closure_operator.id_apply (\u03b1 : Type*) [partial_order \u03b1] (a : \u03b1) :\n\t\u21d1(closure_operator.id \u03b1) a = a :=", "nl_statement_of_codex": "The closure operator $\\overline{id}$ on a poset $P$ is the identity function."}
{"name": "function.is_periodic_pt.apply_iterate", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/periodic_pts.lean", "formal_statement": "theorem function.is_periodic_pt.apply_iterate {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {x : \u03b1}\n\t{n : \u2115} (hx : function.is_periodic_pt f n x) (m : \u2115) :\n\tfunction.is_periodic_pt f n (f^[m] x) :=", "nl_statement_of_codex": "Let $f:X\\to X$ be a function and let $x\\in X$. If $f$ is periodic at $x$ with period $n$, then $f$ is periodic at $f^m(x)$ with period $n$."}
{"name": "multiset.sections_cons", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/sections.lean", "formal_statement": "theorem multiset.sections_cons {\u03b1 : Type*} (s : multiset (multiset \u03b1))\n\t(m : multiset \u03b1) :\n\t(m ::\u2098 s).sections = m.bind (\u03bb (a : \u03b1), multiset.map (multiset.cons a) s.sections) :=", "nl_statement_of_codex": "Let $s$ be a multiset of multisets of $\u03b1$ and let $m$ be a multiset of $\u03b1$. Then the sections of $m::s$ are the multisets obtained by taking an element $a$ of $m$ and appending it to each section of $s$."}
{"name": "simple_graph.not_is_uniform_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/regularity/uniform.lean", "formal_statement": "theorem simple_graph.not_is_uniform_iff {\u03b1 \ud835\udd5c : Type*} [linear_ordered_field \ud835\udd5c]\n\t{G : simple_graph \u03b1} [decidable_rel G.adj] {\u03b5 : \ud835\udd5c} {s t : finset \u03b1} :\n\t\u00acG.is_uniform \u03b5 s t \u2194 \u2203 (s' : finset \u03b1), s' \u2286 s \u2227 \u2203 (t' : finset \u03b1), t' \u2286 t \u2227 \u2191(s.card) * \u03b5 \u2264 \u2191(s'.card) \u2227 \u2191(t.card) * \u03b5 \u2264 \u2191(t'.card) \u2227 \u03b5 \u2264 |\u2191(G.edge_density s' t') - \u2191(G.edge_density s t)| :=", "nl_statement_of_codex": "Let $G$ be a simple graph. Let $s,t$ be finite sets of vertices of $G$. Then $G$ is not $\\epsilon$-uniform with respect to $s$ and $t$ if and only if there are subsets $s'\\subseteq s$ and $t'\\subseteq t$ such that $|s'|\\geq \\epsilon|s|$, $|t'|\\geq \\epsilon|t|$, and $|\\frac{e(s',t')}{|s'||t'|}-\\frac{e(s,t)}{|s||t|}|"}
{"name": "ideal.is_local_of_is_maximal_radical", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/jacobson_ideal.lean", "formal_statement": "theorem ideal.is_local_of_is_maximal_radical {R : Type u} [comm_ring R]\n\t{I : ideal R} (hi : I.radical.is_maximal) :\n\tI.is_local :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $I$ be an ideal of $R$. If the radical of $I$ is maximal, then $I$ is a local ideal."}
{"name": "ordinal.add_log_le_log_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.add_log_le_log_mul {x y : ordinal} (b : ordinal) (x0 : 0 < x)\n\t(y0 : 0 < y) :\n\tordinal.log b x + ordinal.log b y \u2264 ordinal.log b (x * y) :=", "nl_statement_of_codex": "Let $x,y$ be ordinals with $x,y>0$. Then $\\log_b(x)+\\log_b(y)\\leq \\log_b(xy)$."}
{"name": "parser.decorate_error_fail", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/buffer/parser/basic.lean", "formal_statement": "theorem parser.decorate_error_fail {\u03b1 : Type} {msg : thunk string}\n\t{p : parser \u03b1} {cb : char_buffer} {n n' : \u2115} {err : dlist string}\n\t(h : p cb n = parse_result.fail n' err) :\n\tparser.decorate_error msg p cb n = parse_result.fail n (dlist.lazy_of_list (\u03bb (\u00ab_\u00bb : unit), [msg ()])) :=", "nl_statement_of_codex": "If $p$ is a parser that fails on input $cb$ at position $n$, then the parser $parser.decorate_error msg p$ fails on input $cb$ at position $n$ with error message $msg$."}
{"name": "is_add_group_hom.range_add_subgroup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_group_hom.range_add_subgroup {G H : Type*} [add_group G]\n\t[add_group H] {f : G \u2192 H} (hf : is_add_group_hom f) :\n\tis_add_subgroup (set.range f) :=", "nl_statement_of_codex": "Let $G$ and $H$ be additive groups and let $f:G\\to H$ be an additive group homomorphism. Then the range of $f$ is an additive subgroup of $H$."}
{"name": "subtype_or_equiv_symm_inr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/embedding.lean", "formal_statement": "theorem subtype_or_equiv_symm_inr {\u03b1 : Type*} (p q : \u03b1 \u2192 Prop)\n\t[decidable_pred p] (h : disjoint p q) (x : {x // q x}) :\n\t\u21d1((subtype_or_equiv p q h).symm) (sum.inr x) = \u27e8\u2191x, _\u27e9 :=", "nl_statement_of_codex": "Let $p$ and $q$ be decidable predicates on a type $A$. If $p$ and $q$ are disjoint, then the inverse of the map $A\\to A\\sqcup A$ given by $x\\mapsto (x,p(x))$ is given by $(x,q(x))\\mapsto x$."}
{"name": "category_theory.idempotents.karoubi.hom.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/idempotents/karoubi.lean", "formal_statement": "theorem category_theory.idempotents.karoubi.hom.ext {C : Type*}\n\t{_inst_1 : category_theory.category C}\n\t{P Q : category_theory.idempotents.karoubi C} (x y : P.hom Q) (h : x.f = y.f) :\n\tx = y :=", "nl_statement_of_codex": "Let $C$ be a category and let $P$ and $Q$ be idempotent Karoubi completions of $C$. Let $x,y:P\\to Q$ be morphisms. Then $x=y$ if and only if $x.f=y.f$."}
{"name": "bot_lt_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem bot_lt_top {\u03b1 : Type u} [partial_order \u03b1] [bounded_order \u03b1]\n\t[nontrivial \u03b1] :\n\t\u22a5 < \u22a4 :=", "nl_statement_of_codex": "In a nontrivial partially ordered set with a bottom and top element, the bottom element is less than the top element."}
{"name": "div_mul_cancel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_with_zero/basic.lean", "formal_statement": "theorem div_mul_cancel {G\u2080 : Type*} [group_with_zero G\u2080] {b : G\u2080} (a : G\u2080)\n\t(h : b \u2260 0) :\n\ta / b * b = a :=", "nl_statement_of_codex": "Let $G$ be a group with zero. Let $a, b\\in G$ with $b\\neq 0$. Then $a/b\\cdot b=a$."}
{"name": "exists_mem_frontier_inf_dist_compl_eq_dist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/finite_dimension.lean", "formal_statement": "theorem exists_mem_frontier_inf_dist_compl_eq_dist {E : Type*} [normed_group E]\n\t[normed_space \u211d E] [finite_dimensional \u211d E] {x : E} {s : set E} (hx : x \u2208 s)\n\t(hs : s \u2260 set.univ) :\n\t\u2203 (y : E) (H : y \u2208 frontier s), metric.inf_dist x s\u1d9c = has_dist.dist x y :=", "nl_statement_of_codex": "Let $E$ be a finite-dimensional normed space over $\\mathbb{R}$. Let $x\\in E$ and let $s\\subset E$ be a nonempty set. Then there is a point $y\\in\\partial s$ such that $d(x,s^c)=d(x,y)$."}
{"name": "bounded_lattice_hom.dual_apply_to_lattice_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/lattice.lean", "formal_statement": "theorem bounded_lattice_hom.dual_apply_to_lattice_hom {\u03b1 \u03b2 : Type*} [lattice \u03b1]\n\t[bounded_order \u03b1] [lattice \u03b2] [bounded_order \u03b2] (f : bounded_lattice_hom \u03b1 \u03b2) :\n\t(\u21d1bounded_lattice_hom.dual f).to_lattice_hom = \u21d1lattice_hom.dual f.to_lattice_hom :=", "nl_statement_of_codex": "The dual of a bounded lattice homomorphism is a lattice homomorphism."}
{"name": "finsupp.single_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/basic.lean", "formal_statement": "theorem finsupp.single_sub {\u03b1 G : Type*} [add_group G] (a : \u03b1) (b\u2081 b\u2082 : G) :\n\tfinsupp.single a (b\u2081 - b\u2082) = finsupp.single a b\u2081 - finsupp.single a b\u2082 :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $a$ be an element of some set. Then the finitely supported function $f:\\{a\\}\\to G$ defined by $f(a)=b_1-b_2$ is equal to the finitely supported function $g:\\{a\\}\\to G$ defined by $g(a)=b_1$ minus the finitely supported function $h:\\{a\\}\\to G$ defined by $h(a)=b_2$."}
{"name": "differentiable_on.log", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/log/deriv.lean", "formal_statement": "theorem differentiable_on.log {E : Type*} [normed_group E] [normed_space \u211d E]\n\t{f : E \u2192 \u211d} {s : set E} (hf : differentiable_on \u211d f s)\n\t(hx : \u2200 (x : E), x \u2208 s \u2192 f x \u2260 0) :\n\tdifferentiable_on \u211d (\u03bb (x : E), real.log (f x)) s :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $f:E\\to\\mathbb{R}$. If $f$ is differentiable on $E$ and $f(x)\\neq 0$ for all $x\\in E$, then $\\log(f)$ is differentiable on $E$."}
{"name": "category_theory.limits.limit_iso_swap_comp_lim_hom_app", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/functor_category.lean", "formal_statement": "theorem category_theory.limits.limit_iso_swap_comp_lim_hom_app {C : Type u}\n\t[category_theory.category C] {J : Type u\u2081} [category_theory.category J]\n\t{K : Type u\u2082} [category_theory.category K]\n\t[category_theory.limits.has_limits_of_shape J C] (G : J \u2964 K \u2964 C) (X : K) :\n\t(category_theory.limits.limit_iso_swap_comp_lim G).hom.app X = (category_theory.limits.limit_obj_iso_limit_comp_evaluation G X).hom \u226b category_theory.limits.lim_map ((category_theory.flip_iso_curry_swap_uncurry G).hom.app X) :=", "nl_statement_of_codex": "Let $C$ be a category, $J$ and $K$ be categories, and $G:J\\to K\\to C$ be a functor. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\n\\lim G \\arrow[r, "}
{"name": "nat.mul_one", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/lemmas.lean", "formal_statement": "theorem nat.mul_one (n : \u2115) :\n\tn * 1 = n :=", "nl_statement_of_codex": "For all natural numbers $n$, $n\\cdot 1=n$."}
{"name": "omega_limit_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/omega_limit.lean", "formal_statement": "theorem omega_limit_def {\u03c4 \u03b1 \u03b2 : Type*} [topological_space \u03b2] (f : filter \u03c4)\n\t(\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s : set \u03b1) :\n\tomega_limit f \u03d5 s = \u22c2 (u : set \u03c4) (H : u \u2208 f), closure (set.image2 \u03d5 u s) :=", "nl_statement_of_codex": "Let $f$ be a filter on $\\tau$, let $\\phi:\\tau\\times\\alpha\\to\\beta$ be a function, and let $s$ be a subset of $\\alpha$. Then the omega limit of $\\phi$ with respect to $f$ and $s$ is the intersection of the closures of the images of $\\phi$ restricted to $u\\times s$ over all $u\\in f$."}
{"name": "non_unital_alg_hom.coe_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/non_unital_alg.lean", "formal_statement": "theorem non_unital_alg_hom.coe_mk {R : Type u} {A : Type v} {B : Type w}\n\t[monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A]\n\t[non_unital_non_assoc_semiring B] [distrib_mul_action R B] (f : A \u2192 B)\n\t(h\u2081 : \u2200 (m : R) (x : A), f (m \u2022 x) = m \u2022 f x) (h\u2082 : f 0 = 0)\n\t(h\u2083 : \u2200 (x y : A), f (x + y) = f x + f y)\n\t(h\u2084 : \u2200 (x y : A), f (x * y) = f x * f y) :\n\t\u21d1{to_fun := f, map_smul' := h\u2081, map_zero' := h\u2082, map_add' := h\u2083, map_mul' := h\u2084} = f :=", "nl_statement_of_codex": "Let $R$ be a monoid, $A$ and $B$ be non-unital non-associative semirings, and $f:A\\to B$ be a function. If $f$ is a homomorphism of $R$-modules, and a homomorphism of semirings, then $f$ is a homomorphism of non-unital non-associative semirings."}
{"name": "group.exists_list_of_mem_closure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem group.exists_list_of_mem_closure {G : Type*} [group G] {s : set G}\n\t{a : G} (h : a \u2208 group.closure s) :\n\t\u2203 (l : list G), (\u2200 (x : G), x \u2208 l \u2192 x \u2208 s \u2228 x\u207b\u00b9 \u2208 s) \u2227 l.prod = a :=", "nl_statement_of_codex": "Let $G$ be a group and let $s$ be a subset of $G$. Let $a\\in G$. Then there is a list $l$ of elements of $G$ such that $l$ is a product of elements of $s$ and their inverses and $l$ is equal to $a$."}
{"name": "nat.eq_zero_of_gcd_eq_zero_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.eq_zero_of_gcd_eq_zero_right {m n : \u2115} (H : m.gcd n = 0) :\n\tn = 0 :=", "nl_statement_of_codex": "If $m$ and $n$ are natural numbers and $\\gcd(m,n)=0$, then $n=0$."}
{"name": "summable_mul_of_summable_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/field/basic.lean", "formal_statement": "theorem summable_mul_of_summable_norm {\u03b1 \u03b9 \u03b9' : Type*} [normed_ring \u03b1]\n\t[complete_space \u03b1] {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} (hf : summable (\u03bb (x : \u03b9), \u2225f x\u2225))\n\t(hg : summable (\u03bb (x : \u03b9'), \u2225g x\u2225)) :\n\tsummable (\u03bb (x : \u03b9 \u00d7 \u03b9'), f x.fst * g x.snd) :=", "nl_statement_of_codex": "Let $f:I\\to\\mathbb{R}$ and $g:I'\\to\\mathbb{R}$ be summable functions. Then the function $h:I\\times I'\\to\\mathbb{R}$ defined by $h(i,j)=f(i)g(j)$ is summable."}
{"name": "discrete_quotient.proj_continuous", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/discrete_quotient.lean", "formal_statement": "theorem discrete_quotient.proj_continuous {X : Type*} [topological_space X]\n\t(S : discrete_quotient X) :\n\tcontinuous S.proj :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $S$ be a discrete quotient of $X$. Then the projection map $S\\to X$ is continuous."}
{"name": "monotone_on.Iic_union_Ici", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/monotone.lean", "formal_statement": "theorem monotone_on.Iic_union_Ici {\u03b1 \u03b2 : Type*} [linear_order \u03b1] [preorder \u03b2]\n\t{a : \u03b1} {f : \u03b1 \u2192 \u03b2} (h\u2081 : monotone_on f (set.Iic a))\n\t(h\u2082 : monotone_on f (set.Ici a)) :\n\tmonotone f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function where $A$ is a linearly ordered set and $B$ is a partially ordered set. Suppose that $f$ is monotone on $(a,\\infty)$ and monotone on $[a,\\infty)$. Then $f$ is monotone."}
{"name": "nat.prod_pow_factorization_eq_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/factorization/basic.lean", "formal_statement": "theorem nat.prod_pow_factorization_eq_self {f : \u2115 \u2192\u2080 \u2115}\n\t(hf : \u2200 (p : \u2115), p \u2208 f.support \u2192 nat.prime p) :\n\t(f.prod has_pow.pow).factorization = f :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\mathbb{N}$ be a function such that $f(p)$ is a prime number for each $p\\in\\mathbb{N}$. Then $f(p)^p$ is the factorization of $f(p)^p$."}
{"name": "add_order_of_eq_add_order_of_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/order_of_element.lean", "formal_statement": "theorem add_order_of_eq_add_order_of_iff {G : Type u} {x : G} [add_monoid G]\n\t{H : Type*} [add_monoid H] {y : H} :\n\tadd_order_of x = add_order_of y \u2194 \u2200 (n : \u2115), n \u2022 x = 0 \u2194 n \u2022 y = 0 :=", "nl_statement_of_codex": "Let $G$ and $H$ be additive monoids and let $x\\in G$ and $y\\in H$. Then $x$ and $y$ have the same order if and only if $nx=0$ if and only if $ny=0$ for all $n\\in\\mathbb{N}$."}
{"name": "lie_module.lower_central_series_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/nilpotent.lean", "formal_statement": "theorem lie_module.lower_central_series_succ (R : Type u) (L : Type v)\n\t(M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M]\n\t[module R M] [lie_ring_module L M] [lie_module R L M] (k : \u2115) :\n\tlie_module.lower_central_series R L M (k + 1) = \u2045\u22a4,lie_module.lower_central_series R L M k\u2046 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a Lie $R$-module. Then the $(k+1)$-th term of the lower central series of $M$ is the ideal generated by the $k$-th term of the lower central series of $M$."}
{"name": "or_iff_left_iff_imp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem or_iff_left_iff_imp {a b : Prop} :\n\ta \u2228 b \u2194 a \u2194 b \u2192 a :=", "nl_statement_of_codex": "$a\\lor b$ if and only if $a$ if and only if $b$ implies $a$."}
{"name": "asymptotics.is_o_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_o_comm {\u03b1 F E' : Type*} [has_norm F]\n\t[semi_normed_group E'] {g : \u03b1 \u2192 F} {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'} :\n\t(\u03bb (x : \u03b1), f\u2081 x - f\u2082 x) =o[l] g \u2194 (\u03bb (x : \u03b1), f\u2082 x - f\u2081 x) =o[l] g :=", "nl_statement_of_codex": "Let $f_1, f_2: \\alpha \\to E'$ and $g:\\alpha \\to F$ be functions. Then $f_1-f_2=o(g)$ if and only if $f_2-f_1=o(g)$."}
{"name": "continuous_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem continuous_apply {\u03b9 \u03c0 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), topological_space (\u03c0 i)]\n\t(i : \u03b9) :\n\tcontinuous (\u03bb (p : \u03a0 (i : \u03b9), \u03c0 i), p i) :=", "nl_statement_of_codex": "The projection map $\\pi_i:\\prod_{i\\in I}\\pi_i\\to\\pi_i$ is continuous."}
{"name": "ordinal.nfp_bfamily_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/fixed_point.lean", "formal_statement": "theorem ordinal.nfp_bfamily_le {o : ordinal}\n\t{f : \u03a0 (b : ordinal), b < o \u2192 ordinal \u2192 ordinal} {a b : ordinal} :\n\t(\u2200 (l : list (quotient.out o).\u03b1), list.foldr (o.family_of_bfamily f) a l \u2264 b) \u2192 o.nfp_bfamily f a \u2264 b :=", "nl_statement_of_codex": "Let $o$ be an ordinal and let $f:o\\to o$. Then $\\sup_{b<o}f(b)$ is less than or equal to $b$."}
{"name": "topological_space.is_topological_basis.open_eq_sUnion'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bases.lean", "formal_statement": "theorem topological_space.is_topological_basis.open_eq_sUnion' {\u03b1 : Type u}\n\t[t : topological_space \u03b1] {B : set (set \u03b1)}\n\t(hB : topological_space.is_topological_basis B) {u : set \u03b1} (ou : is_open u) :\n\tu = \u22c3\u2080 {s \u2208 B | s \u2286 u} :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $B$ be a basis for $X$. Then $U$ is open if and only if $U$ is a union of elements of $B$."}
{"name": "abs_sq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/order.lean", "formal_statement": "theorem abs_sq {R : Type*} [linear_ordered_ring R] (x : R) :\n\t|x ^ 2| = x ^ 2 :=", "nl_statement_of_codex": "For any $x\\in R$, $|x^2|=x^2$."}
{"name": "AddGroup.filtered_colimits.colimit_neg_mk_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Group/filtered_colimits.lean", "formal_statement": "theorem AddGroup.filtered_colimits.colimit_neg_mk_eq {J : Type v}\n\t[category_theory.small_category J] [category_theory.is_filtered J]\n\t(F : J \u2964 AddGroup) (x : \u03a3 (j : J), \u21a5(F.obj j)) :\n\t-AddGroup.filtered_colimits.G.mk F x = AddGroup.filtered_colimits.G.mk F \u27e8x.fst, -x.snd\u27e9 :=", "nl_statement_of_codex": "Let $F:J\\to \\mathrm{AddGroup}$ be a functor from a filtered category $J$ to the category of additive groups. Then for any $x\\in \\mathrm{colim}_J F$, we have $-\\mathrm{colim}_J F(x) = \\mathrm{colim}_J F(-x)$."}
{"name": "structure_groupoid.local_invariant_prop.lift_prop_at_of_mem_maximal_atlas", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/local_invariant_properties.lean", "formal_statement": "theorem structure_groupoid.local_invariant_prop.lift_prop_at_of_mem_maximal_atlas\n\t{H M : Type*} [topological_space H] [topological_space M] [charted_space H M]\n\t{G : structure_groupoid H} {e : local_homeomorph M H} {x : M}\n\t{Q : (H \u2192 H) \u2192 set H \u2192 H \u2192 Prop} [has_groupoid M G]\n\t(hG : G.local_invariant_prop G Q) (hQ : \u2200 (y : H), Q id set.univ y)\n\t(he : e \u2208 structure_groupoid.maximal_atlas M G)\n\t(hx : x \u2208 e.to_local_equiv.source) :\n\tcharted_space.lift_prop_at Q \u21d1e x :=", "nl_statement_of_codex": "Let $M$ be a topological space and let $G$ be a structure groupoid on $M$. Let $e$ be a local homeomorphism from $M$ to $H$ and let $x$ be a point in $M$. Suppose that $G$ is locally invariant with respect to $Q$ and that $Q$ holds for all points in $H$. If $e$ is in the maximal atlas of $G$ and $x$ is in the source of $e$, then $Q$ holds at $x$."}
{"name": "finsupp.disjoint_supported_supported_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/finsupp.lean", "formal_statement": "theorem finsupp.disjoint_supported_supported_iff {\u03b1 M R : Type*} [semiring R]\n\t[add_comm_monoid M] [module R M] [nontrivial M] {s t : set \u03b1} :\n\tdisjoint (finsupp.supported M R s) (finsupp.supported M R t) \u2194 disjoint s t :=", "nl_statement_of_codex": "Let $M$ be a nontrivial $R$-module. Then the supports of two finite $R$-linear combinations of elements of $M$ are disjoint if and only if the supports of the elements are disjoint."}
{"name": "algebraic_geometry.LocallyRingedSpace.to_\u0393_Spec_continuous", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/Gamma_Spec_adjunction.lean", "formal_statement": "theorem algebraic_geometry.LocallyRingedSpace.to_\u0393_Spec_continuous\n\t(X : algebraic_geometry.LocallyRingedSpace) :\n\tcontinuous X.to_\u0393_Spec_fun :=", "nl_statement_of_codex": "The map $X\\to \\Gamma(X,\\mathcal{O}_X)$ is continuous."}
{"name": "cont_diff_bump_of_inner.integral_normed", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/specific_functions.lean", "formal_statement": "theorem cont_diff_bump_of_inner.integral_normed {E : Type*}\n\t[inner_product_space \u211d E] { : E} (f : cont_diff_bump_of_inner c)\n\t[measurable_space E] {\u03bc : measure_theory.measure E} [borel_space E]\n\t[finite_dimensional \u211d E] [measure_theory.is_locally_finite_measure \u03bc]\n\t[\u03bc.is_open_pos_measure] :\n\t\u222b (x : E), f.normed \u03bc x \u2202\u03bc = 1 :=", "nl_statement_of_codex": "Let $E$ be a finite-dimensional inner product space. Let $f$ be a continuous bump function with support $c$. Then $\\int_E f(x)dx=1$."}
{"name": "continuous_multilinear_map.op_norm_le_bound", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/multilinear.lean", "formal_statement": "theorem continuous_multilinear_map.op_norm_le_bound {\ud835\udd5c : Type u} {\u03b9 : Type v}\n\t{E : \u03b9 \u2192 Type wE} {G : Type wG} [decidable_eq \u03b9] [fintype \u03b9]\n\t[nondiscrete_normed_field \ud835\udd5c] [\u03a0 (i : \u03b9), normed_group (E i)]\n\t[\u03a0 (i : \u03b9), normed_space \ud835\udd5c (E i)] [normed_group G] [normed_space \ud835\udd5c G]\n\t(f : continuous_multilinear_map \ud835\udd5c E G) {M : \u211d} (hMp : 0 \u2264 M)\n\t(hM : \u2200 (m : \u03a0 (i : \u03b9), E i), \u2225\u21d1f m\u2225 \u2264 M * finset.univ.prod (\u03bb (i : \u03b9), \u2225m i\u2225)) :\n\t\u2225f\u2225 \u2264 M :=", "nl_statement_of_codex": "Let $f:E_1\\times\\cdots\\times E_n\\to G$ be a continuous multilinear map. If there is a constant $M\\geq 0$ such that $\\|f(m_1,\\ldots,m_n)\\|\\leq M\\|m_1\\|\\cdots\\|m_n\\|$ for all $m_1\\in E_1,\\ldots,m_n\\in E_n$, then $\\|f\\|\\leq M$."}
{"name": "pnat.factor_multiset_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pnat/factors.lean", "formal_statement": "theorem pnat.factor_multiset_pow (n : \u2115+) (m : \u2115) :\n\t(n ^ m).factor_multiset = m \u2022 n.factor_multiset :=", "nl_statement_of_codex": "The multiset of prime factors of $n^m$ is $m$ times the multiset of prime factors of $n$."}
{"name": "subsingleton.strict_anti", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monotone.lean", "formal_statement": "theorem subsingleton.strict_anti {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] [subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) :\n\tstrict_anti f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function between preorders. If $A$ is a singleton, then $f$ is strictly anti-monotone."}
{"name": "orthonormal.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/euclidean/oriented_angle.lean", "formal_statement": "theorem orthonormal.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero\n\t{V : Type*} [inner_product_space \u211d V] {b : basis (fin 2) \u211d V}\n\t(hb : orthonormal \u211d \u21d1b) {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) (\u03b8 : real.angle) :\n\thb.oangle x y = \u03b8 \u2194 y = (\u2225y\u2225 / \u2225x\u2225) \u2022 \u21d1(hb.rotation \u03b8) x :=", "nl_statement_of_codex": "Let $V$ be a real inner product space and let $b$ be an orthonormal basis of $V$. Let $x,y\\in V$ be nonzero vectors. Then $y$ is a scalar multiple of the rotation of $x$ by angle $\\theta$ if and only if the angle between $x$ and $y$ is $\\theta$."}
{"name": "monoid_algebra.of_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/monoid_algebra/basic.lean", "formal_statement": "theorem monoid_algebra.of_injective {k : Type u\u2081} {G : Type u\u2082} [semiring k]\n\t[mul_one_class G] [nontrivial k] :\n\tfunction.injective \u21d1(monoid_algebra.of k G) :=", "nl_statement_of_codex": "The map $G\\to k[G]$ sending $g\\in G$ to $g\\in k[G]$ is injective."}
{"name": "finset.nonempty.cInf_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/conditionally_complete_lattice.lean", "formal_statement": "theorem finset.nonempty.cInf_mem {\u03b1 : Type*}\n\t[conditionally_complete_linear_order \u03b1] {s : finset \u03b1} (h : s.nonempty) :\n\thas_Inf.Inf \u2191s \u2208 s :=", "nl_statement_of_codex": "Let $s$ be a nonempty finite set of real numbers. Then the infimum of $s$ is in $s$."}
{"name": "continuous_linear_equiv.coe_to_homeomorph", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/module/basic.lean", "formal_statement": "theorem continuous_linear_equiv.coe_to_homeomorph {R\u2081 R\u2082 : Type*} [semiring R\u2081]\n\t[semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n\t[ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type*} [topological_space M\u2081]\n\t[add_comm_monoid M\u2081] {M\u2082 : Type*} [topological_space M\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2081 M\u2081] [module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n\t\u21d1(e.to_homeomorph) = \u21d1e :=", "nl_statement_of_codex": "Let $R_1, R_2$ be semirings, let $M_1, M_2$ be topological spaces, and let $\u03c3_{12}:R_1\\to R_2$ be a ring homomorphism. Suppose that $\u03c3_{12}$ has an inverse $\u03c3_{21}:R_2\\to R_1$. Suppose that $M_1$ and $M_2$ are $R_1$-modules and $R_2$-modules, respectively. Suppose that $e:M_1\\to M_2$ is a continuous linear equivalence. Then $e$ is a homeomorphism."}
{"name": "tendsto_list_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/monoid.lean", "formal_statement": "theorem tendsto_list_prod {\u03b9 \u03b1 M : Type*} [topological_space M] [monoid M]\n\t[has_continuous_mul M] {f : \u03b9 \u2192 \u03b1 \u2192 M} {x : filter \u03b1} {a : \u03b9 \u2192 M} (l : list \u03b9) :\n\t(\u2200 (i : \u03b9), i \u2208 l \u2192 filter.tendsto (f i) x (nhds (a i))) \u2192 filter.tendsto (\u03bb (b : \u03b1), (list.map (\u03bb (c : \u03b9), f c b) l).prod) x (nhds (list.map a l).prod) :=", "nl_statement_of_codex": "Let $M$ be a topological monoid with continuous multiplication. Let $f:I\\times A\\to M$ and $a:I\\to M$. If $f(i,\\cdot)$ tends to $a(i)$ for each $i\\in I$, then $\\prod_{i\\in I}f(i,\\cdot)$ tends to $\\prod_{i\\in I}a(i)$."}
{"name": "category_theory.sheafification_iso_inv_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sheafification.lean", "formal_statement": "theorem category_theory.sheafification_iso_inv_val {C : Type u}\n\t[category_theory.category C] {J : category_theory.grothendieck_topology C}\n\t{D : Type w} [category_theory.category D] [category_theory.concrete_category D]\n\t[category_theory.limits.preserves_limits (category_theory.forget D)]\n\t[\u2200 (P : C\u1d52\u1d56 \u2964 D) (X : C) (S : J.cover X), category_theory.limits.has_multiequalizer (S.index P)]\n\t[\u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 D]\n\t[\u03a0 (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)\u1d52\u1d56 (category_theory.forget D)]\n\t[category_theory.reflects_isomorphisms (category_theory.forget D)]\n\t(P : category_theory.Sheaf J D) :\n\t(category_theory.sheafification_iso P).inv.val = (J.iso_sheafify _).inv :=", "nl_statement_of_codex": "Let $C$ be a category, $J$ a Grothendieck topology on $C$, $D$ a category with concrete limits and colimits, and $P$ a sheaf on $C$ with values in $D$. Then the inverse of the sheafification of $P$ is the inverse of the sheafification of the inverse of $P$."}
{"name": "polynomial.as_sum_support", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/definitions.lean", "formal_statement": "theorem polynomial.as_sum_support {R : Type u} [semiring R] (p : polynomial R) :\n\tp = p.support.sum (\u03bb (i : \u2115), \u21d1(polynomial.monomial i) (p.coeff i)) :=", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$. Then $p$ is equal to the sum of the monomials of $p$ with nonzero coefficients."}
{"name": "continuous_at.clog", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/log.lean", "formal_statement": "theorem continuous_at.clog {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u2102} {x : \u03b1}\n\t(h\u2081 : continuous_at f x) (h\u2082 : 0 < (f x).re \u2228 (f x).im \u2260 0) :\n\tcontinuous_at (\u03bb (t : \u03b1), complex.log (f t)) x :=", "nl_statement_of_codex": "Let $f:X\\to\\mathbb{C}$ be a continuous function on a topological space $X$. If $f(x)$ is not on the negative real axis, then the function $g:X\\to\\mathbb{C}$ defined by $g(x)=\\log(f(x))$ is continuous at $x$."}
{"name": "measure_theory.volume_pi_closed_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/pi.lean", "formal_statement": "theorem measure_theory.volume_pi_closed_ball {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9]\n\t[\u03a0 (i : \u03b9), measure_theory.measure_space (\u03b1 i)]\n\t[\u2200 (i : \u03b9), measure_theory.sigma_finite measure_theory.measure_space.volume]\n\t[\u03a0 (i : \u03b9), metric_space (\u03b1 i)] (x : \u03a0 (i : \u03b9), \u03b1 i) {r : \u211d} (hr : 0 \u2264 r) :\n\t\u21d1measure_theory.measure_space.volume (metric.closed_ball x r) = finset.univ.prod (\u03bb (i : \u03b9), \u21d1measure_theory.measure_space.volume (metric.closed_ball (x i) r)) :=", "nl_statement_of_codex": "Let $X_1,\\ldots,X_n$ be sigma-finite metric spaces. Then the volume of the closed ball of radius $r$ centered at $x\\in X_1\\times\\cdots\\times X_n$ is the product of the volumes of the closed balls of radius $r$ centered at $x_1,\\ldots,x_n$."}
{"name": "primrec.bor", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/primrec.lean", "formal_statement": "theorem primrec.bor :\n\tprimrec\u2082 bor :=", "nl_statement_of_codex": "The function $f:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$ defined by $f(m,n)=m\\vee n$ is primitive recursive."}
{"name": "ideal.infi_span_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/operations.lean", "formal_statement": "theorem ideal.infi_span_singleton {R : Type u} [comm_semiring R] {\u03b9 : Type*}\n\t[fintype \u03b9] (I : \u03b9 \u2192 R) (hI : \u2200 (i j : \u03b9), i \u2260 j \u2192 is_coprime (I i) (I j)) :\n\t(\u2a05 (i : \u03b9), ideal.span {I i}) = ideal.span {finset.univ.prod (\u03bb (i : \u03b9), I i)} :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $I:\\mathbb{N}\\to R$ be a function. Suppose that $I(i)$ and $I(j)$ are coprime for all $i\\neq j$. Then the intersection of the ideals generated by $I(i)$ is the ideal generated by $\\prod_{i\\in\\mathbb{N}}I(i)$."}
{"name": "set.snd_image_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/prod.lean", "formal_statement": "theorem set.snd_image_prod {\u03b1 \u03b2 : Type*} {s : set \u03b1} (hs : s.nonempty)\n\t(t : set \u03b2) :\n\tprod.snd '' s \u00d7\u02e2 t = t :=", "nl_statement_of_codex": "Let $s$ be a nonempty set and let $t$ be a set. Then $s\\times t$ is equal to $t$."}
{"name": "nat.prime_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/prime.lean", "formal_statement": "theorem nat.prime_iff {p : \u2115} :\n\tnat.prime p \u2194 prime p :=", "nl_statement_of_codex": "A natural number $p$ is prime if and only if $p$ is prime."}
{"name": "prod.fst_eq_or_snd_eq_of_wcovby", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/cover.lean", "formal_statement": "theorem prod.fst_eq_or_snd_eq_of_wcovby {\u03b1 \u03b2 : Type*} [partial_order \u03b1]\n\t[partial_order \u03b2] {x y : \u03b1 \u00d7 \u03b2} :\n\tx \u2a7f y \u2192 x.fst = y.fst \u2228 x.snd = y.snd :=", "nl_statement_of_codex": "Let $x,y$ be elements of $A\\times B$. If $x$ and $y$ are comparable, then either $x_1=y_1$ or $x_2=y_2$."}
{"name": "int.nat_abs_lt_iff_mul_self_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.nat_abs_lt_iff_mul_self_lt {a b : \u2124} :\n\ta.nat_abs < b.nat_abs \u2194 a * a < b * b :=", "nl_statement_of_codex": "For integers $a$ and $b$, $|a|<|b|$ if and only if $a^2<b^2$."}
{"name": "is_prime_pow_nat_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/is_prime_pow.lean", "formal_statement": "theorem is_prime_pow_nat_iff (n : \u2115) :\n\tis_prime_pow n \u2194 \u2203 (p k : \u2115), nat.prime p \u2227 0 < k \u2227 p ^ k = n :=", "nl_statement_of_codex": "A natural number $n$ is a prime power if and only if there are a prime $p$ and a natural number $k$ such that $p^k=n$."}
{"name": "category_theory.limits.prod_comparison_natural_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/binary_products.lean", "formal_statement": "theorem category_theory.limits.prod_comparison_natural_assoc {C : Type u}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t(F : C \u2964 D) {A A' B B' : C} [category_theory.limits.has_binary_product A B]\n\t[category_theory.limits.has_binary_product A' B']\n\t[category_theory.limits.has_binary_product (F.obj A) (F.obj B)]\n\t[category_theory.limits.has_binary_product (F.obj A') (F.obj B')] (f : A \u27f6 A')\n\t(g : B \u27f6 B') {X' : D} (f' : F.obj A' \u2a2f F.obj B' \u27f6 X') :\n\tF.map (category_theory.limits.prod.map f g) \u226b category_theory.limits.prod_comparison F A' B' \u226b f' = category_theory.limits.prod_comparison F A B \u226b category_theory.limits.prod.map (F.map f) (F.map g) \u226b f' :=", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor between categories $C$ and $D$. Let $A, A', B, B'$ be objects of $C$ and let $f:A\\to A'$ and $g:B\\to B'$ be morphisms in $C$. Let $X'$ be an object of $D$ and let $f':F(A')\\times F(B')\\to X'$ be a morphism in $D$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nF(A)\\times F(B) & \\xrightarrow{F(f)\\times F(g)}"}
{"name": "ennreal.of_real_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.of_real_eq_zero {p : \u211d} :\n\tennreal.of_real p = 0 \u2194 p \u2264 0 :=", "nl_statement_of_codex": "$\\mathbb{R}$ is mapped to $\\mathbb{R}^+$ by $x\\mapsto x$ if and only if $x\\leq 0$."}
{"name": "tendsto_coe_int_at_top_at_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/archimedean.lean", "formal_statement": "theorem tendsto_coe_int_at_top_at_top {R : Type*} [ordered_ring R]\n\t[archimedean R] :\n\tfilter.tendsto coe filter.at_top filter.at_top :=", "nl_statement_of_codex": "The function $f:\\mathbb{Z}\\to R$ defined by $f(n)=n$ tends to infinity."}
{"name": "category_theory.Mat_.additive_obj_iso_biproduct_naturality'_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/preadditive/Mat.lean", "formal_statement": "theorem category_theory.Mat_.additive_obj_iso_biproduct_naturality'_assoc\n\t{C : Type u\u2081} [category_theory.category C] [category_theory.preadditive C]\n\t{D : Type u\u2081} [category_theory.category D] [category_theory.preadditive D]\n\t[category_theory.limits.has_finite_biproducts D]\n\t(F : category_theory.Mat_ C \u2964 D) [F.additive] {M N : category_theory.Mat_ C}\n\t(f : M \u27f6 N) {X' : D} (f' : F.obj N \u27f6 X') :\n\t(category_theory.Mat_.additive_obj_iso_biproduct F M).inv \u226b F.map f \u226b f' = category_theory.limits.biproduct.matrix (\u03bb (i : M.\u03b9) (j : N.\u03b9), F.map ((category_theory.Mat_.embedding C).map (f i j))) \u226b (category_theory.Mat_.additive_obj_iso_biproduct F N).inv \u226b f' :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ be a functor. Suppose that $F$ is additive. Let $M$ and $N$ be matrices over $C$ and let $f:M\\to N$ be a morphism of matrices. Let $X'$ be an object of $D$ and let $f':F(N)\\to X'$ be a morphism of $D$. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\nF(M)\\ar[r,"}
{"name": "rat.coe_pnat_denom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/defs.lean", "formal_statement": "theorem rat.coe_pnat_denom (x : \u211a) :\n\t\u2191(x.pnat_denom) = x.denom :=", "nl_statement_of_codex": "The denominator of a rational number $x$ is equal to the numerator of the positive rational number $x$."}
{"name": "measure_theory.supr_lintegral_measurable_le_eq_lintegral", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.supr_lintegral_measurable_le_eq_lintegral {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (f : \u03b1 \u2192 ennreal) :\n\t(\u2a06 (g : \u03b1 \u2192 ennreal) (g_meas : measurable g) (hg : g \u2264 f), \u222b\u207b (a : \u03b1), g a \u2202\u03bc) = \u222b\u207b (a : \u03b1), f a \u2202\u03bc :=", "nl_statement_of_codex": "Let $f$ be a measurable function on a measurable space $(X,\\mathcal{A})$ with measure $\\mu$. Then $\\sup_{g\\leq f} \\int_X g\\,d\\mu = \\int_X f\\,d\\mu$."}
{"name": "subgroup.fg_iff_add_fg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/finiteness.lean", "formal_statement": "theorem subgroup.fg_iff_add_fg {G : Type*} [group G] (P : subgroup G) :\n\tP.fg \u2194 (\u21d1subgroup.to_add_subgroup P).fg :=", "nl_statement_of_codex": "A subgroup $P$ of a group $G$ is finitely generated if and only if the additive subgroup generated by $P$ is finitely generated."}
{"name": "dense_inducing.mk'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/dense_embedding.lean", "formal_statement": "theorem dense_inducing.mk' {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] (i : \u03b1 \u2192 \u03b2) ( : continuous i)\n\t(dense : \u2200 (x : \u03b2), x \u2208 closure (set.range i))\n\t(H : \u2200 (a : \u03b1) (s : set \u03b1), s \u2208 nhds a \u2192 (\u2203 (t : set \u03b2) (H : t \u2208 nhds (i a)), \u2200 (b : \u03b1), i b \u2208 t \u2192 b \u2208 s)) :\n\tdense_inducing i :=", "nl_statement_of_codex": "Let $i:X\\to Y$ be a continuous map. Suppose that $i(X)$ is dense in $Y$ and that for each $a\\in X$ and each open set $U$ containing $a$, there is an open set $V$ containing $i(a)$ such that $i^{-1}(V)\\subset U$. Then $i$ is a dense inducing map."}
{"name": "category_theory.limits.mono_factorisation.of_arrow_iso_e", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/images.lean", "formal_statement": "theorem category_theory.limits.mono_factorisation.of_arrow_iso_e {C : Type u}\n\t[category_theory.category C] {f g : category_theory.arrow C}\n\t(F : category_theory.limits.mono_factorisation f.hom) (sq : f \u27f6 g)\n\t[category_theory.is_iso sq] :\n\t(F.of_arrow_iso sq).e = category_theory.inv sq.left \u226b F.e :=", "nl_statement_of_codex": "Let $C$ be a category and let $f,g:X\\to Y$ be morphisms in $C$. Let $F$ be a mono-factorisation of $f$. If $f\\cong g$, then $F(f\\cong g)=F(f)\\cong F(g)$."}
{"name": "add_submonoid.localization_map.eq_mk'_iff_add_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem add_submonoid.localization_map.eq_mk'_iff_add_eq {M : Type*}\n\t[add_comm_monoid M] {S : add_submonoid M} {N : Type*} [add_comm_monoid N]\n\t(f : S.localization_map N) {x : M} {y : \u21a5S} {z : N} :\n\tz = f.mk' x y \u2194 z + \u21d1(f.to_map) \u2191y = \u21d1(f.to_map) x :=", "nl_statement_of_codex": "Let $M$ and $N$ be additive commutative monoids, let $S$ be an additive submonoid of $M$, and let $f:S^{-1}M\\to N$ be a morphism of additive commutative monoids. Then $z=f(x/y)$ if and only if $z+f(y)=f(x)$."}
{"name": "submonoid.localization_map.away_map.lift_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.away_map.lift_eq {M : Type*} [comm_monoid M]\n\t{N : Type*} [comm_monoid N] {P : Type*} [comm_monoid P] {g : M \u2192* P} (x : M)\n\t(F : submonoid.localization_map.away_map x N) (hg : is_unit (\u21d1g x)) (a : M) :\n\t\u21d1(submonoid.localization_map.away_map.lift x F hg) (\u21d1(submonoid.localization_map.to_map F) a) = \u21d1g a :=", "nl_statement_of_codex": "Let $M$ and $N$ be commutative monoids, let $P$ be a commutative monoid, let $g:M\\to P$ be a monoid homomorphism, let $x\\in M$, let $F:M\\to N$ be the away map of $x$, and let $hg$ be the assumption that $g(x)$ is a unit in $P$. Then the map $M\\to P$ given by $a\\mapsto g(a)$ is equal to the map $M\\to P$ given by $a\\mapsto g(F(a))$."}
{"name": "is_add_left_regular_of_add_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/regular/basic.lean", "formal_statement": "theorem is_add_left_regular_of_add_eq_zero {R : Type*} {a b : R} [add_monoid R]\n\t(h : b + a = 0) :\n\tis_add_left_regular a :=", "nl_statement_of_codex": "Let $R$ be an additive monoid and let $a, b\\in R$. If $b+a=0$, then $a$ is left regular."}
{"name": "real.cos_add_pi_div_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem real.cos_add_pi_div_two (x : \u211d) :\n\treal.cos (x + real.pi / 2) = -real.sin x :=", "nl_statement_of_codex": "$\\cos(x+\\pi/2)=-\\sin(x)$."}
{"name": "homological_complex.homological_complex_to_dgo_obj_d", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/differential_object.lean", "formal_statement": "theorem homological_complex.homological_complex_to_dgo_obj_d {\u03b2 : Type*}\n\t[add_comm_group \u03b2] (b : \u03b2) (V : Type*) [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V]\n\t(X : homological_complex V (complex_shape.up' b)) (i : \u03b2) :\n\t((homological_complex.homological_complex_to_dgo b V).obj X).d i = X.d i (i + 1 \u2022 b) :=", "nl_statement_of_codex": "Let $X$ be a homological complex in $V$ with shape $b$. Then the differential of the $i$th component of the associated dg-object is the differential of the $i$th component of $X$."}
{"name": "pairwise.set_pairwise", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pairwise.lean", "formal_statement": "theorem pairwise.set_pairwise {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : pairwise r)\n\t(s : set \u03b1) :\n\ts.pairwise r :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $X$. If $r$ is pairwise, then the restriction of $r$ to any subset of $X$ is pairwise."}
{"name": "is_add_cyclic.image_range_card", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/specific_groups/cyclic.lean", "formal_statement": "theorem is_add_cyclic.image_range_card {\u03b1 : Type u} {a : \u03b1} [add_group \u03b1]\n\t[decidable_eq \u03b1] [fintype \u03b1] (ha : \u2200 (x : \u03b1), x \u2208 add_subgroup.zmultiples a) :\n\tfinset.image (\u03bb (i : \u2115), i \u2022 a) (finset.range (fintype.card \u03b1)) = finset.univ :=", "nl_statement_of_codex": "Let $G$ be a finite abelian group generated by $a$. Then the set $\\{0,a,2a,\\ldots,(|G|-1)a\\}$ is equal to $G$."}
{"name": "measurable_equiv.symm_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/measurable_equiv.lean", "formal_statement": "theorem measurable_equiv.symm_inv {G : Type*} [measurable_space G]\n\t[has_involutive_inv G] [has_measurable_inv G] :\n\t(measurable_equiv.inv G).symm = measurable_equiv.inv G :=", "nl_statement_of_codex": "The inverse of the inverse of a measurable space is the measurable space itself."}
{"name": "topological_space.compacts.coe_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sets/compacts.lean", "formal_statement": "theorem topological_space.compacts.coe_bot {\u03b1 : Type*} [topological_space \u03b1] :\n\t\u2191\u22a5 = \u2205 :=", "nl_statement_of_codex": "The empty set is compact."}
{"name": "computation.length_thinkN", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.length_thinkN {\u03b1 : Type u} (s : computation \u03b1)\n\t[h : s.terminates] (n : \u2115) :\n\t(s.thinkN n).length = s.length + n :=", "nl_statement_of_codex": "Let $s$ be a computation that terminates. Then the length of $s$ is equal to the length of $s$ plus $n$."}
{"name": "category_theory.prod_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/products/basic.lean", "formal_statement": "theorem category_theory.prod_comp (C : Type u\u2081) [category_theory.category C]\n\t(D : Type u\u2082) [category_theory.category D] {P Q R : C} {S T U : D}\n\t(f : (P, S) \u27f6 (Q, T)) (g : (Q, T) \u27f6 (R, U)) :\n\tf \u226b g = (f.fst \u226b g.fst, f.snd \u226b g.snd) :=", "nl_statement_of_codex": "Let $C$ and $D$ be categories. Let $P, Q, R$ be objects of $C$ and $S, T, U$ be objects of $D$. Let $f: (P, S)\\to (Q, T)$ and $g: (Q, T)\\to (R, U)$ be morphisms in $C\\times D$. Then $(f\\circ g) = (f_1\\circ g_1, f_2\\circ g_2)$."}
{"name": "turing.pointed_map.map_pt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/turing_machine.lean", "formal_statement": "theorem turing.pointed_map.map_pt {\u0393 \u0393' : Type*} [inhabited \u0393] [inhabited \u0393']\n\t(f : turing.pointed_map \u0393 \u0393') :\n\t\u21d1f inhabited.default = inhabited.default :=", "nl_statement_of_codex": "Let $f:\\Gamma\\to\\Gamma'$ be a pointed map. Then $f$ maps the default element of $\\Gamma$ to the default element of $\\Gamma'$."}
{"name": "measure_theory.measure_preserving_pi_equiv_pi_subtype_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/pi.lean", "formal_statement": "theorem measure_theory.measure_preserving_pi_equiv_pi_subtype_prod {\u03b9 : Type u}\n\t{\u03b1 : \u03b9 \u2192 Type v} [fintype \u03b9] {m : \u03a0 (i : \u03b9), measurable_space (\u03b1 i)}\n\t(\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i))\n\t[\u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)] (p : \u03b9 \u2192 Prop)\n\t[decidable_pred p] :\n\tmeasure_theory.measure_preserving \u21d1(measurable_equiv.pi_equiv_pi_subtype_prod \u03b1 p) (measure_theory.measure.pi \u03bc) ((measure_theory.measure.pi (\u03bb (i : subtype p), \u03bc \u2191i)).prod (measure_theory.measure.pi (\u03bb (i : {i // \u00acp i}), \u03bc \u2191i))) :=", "nl_statement_of_codex": "Let $X_1,\\ldots,X_n$ be measurable spaces and let $\\mu_1,\\ldots,\\mu_n$ be measures on $X_1,\\ldots,X_n$. Let $p_1,\\ldots,p_n$ be predicates on $X_1,\\ldots,X_n$. Then the map $f:X_1\\times\\cdots\\times X_n\\to (X_1\\times\\cdots\\times X_n)$ defined by $f(x_1,\\ldots,x_n)=(x_1,\\ldots,x_n)$ if $"}
{"name": "list.map_of_fn", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/of_fn.lean", "formal_statement": "theorem list.map_of_fn {\u03b1 : Type u} {\u03b2 : Type*} {n : \u2115} (f : fin n \u2192 \u03b1)\n\t(g : \u03b1 \u2192 \u03b2) :\n\tlist.map g (list.of_fn f) = list.of_fn (g \u2218 f) :=", "nl_statement_of_codex": "Let $f: \\{0,\\ldots,n-1\\}\\to \\alpha$ and $g:\\alpha\\to\\beta$. Then $g\\circ f: \\{0,\\ldots,n-1\\}\\to\\beta$ and $\\mathrm{list.map}(g,\\mathrm{list.of\\_fn}(f))=\\mathrm{list.of\\_fn}(g\\circ f)$."}
{"name": "nat.of_digits_neg_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/digits.lean", "formal_statement": "theorem nat.of_digits_neg_one (L : list \u2115) :\n\tnat.of_digits (-1) L = (list.map (\u03bb (n : \u2115), \u2191n) L).alternating_sum :=", "nl_statement_of_codex": "The alternating sum of the digits of a number is equal to the number with a minus sign."}
{"name": "cont_diff_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/cont_diff.lean", "formal_statement": "theorem cont_diff_top {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} :\n\tcont_diff \ud835\udd5c \u22a4 f \u2194 \u2200 (n : \u2115), cont_diff \ud835\udd5c \u2191n f :=", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Then a function $f:E\\to F$ is continuously differentiable if and only if it is continuously differentiable of order $n$ for all $n\\in\\mathbb{N}$."}
{"name": "ideal.exists_coeff_ne_zero_mem_comap_of_root_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/over.lean", "formal_statement": "theorem ideal.exists_coeff_ne_zero_mem_comap_of_root_mem {R : Type*}\n\t[comm_ring R] {S : Type*} [comm_ring S] {f : R \u2192+* S} {I : ideal S}\n\t[is_domain S] {r : S} (r_ne_zero : r \u2260 0) (hr : r \u2208 I) {p : polynomial R}\n\t(p_ne_zero : p \u2260 0) (hp : polynomial.eval\u2082 f r p = 0) :\n\t\u2203 (i : \u2115), p.coeff i \u2260 0 \u2227 p.coeff i \u2208 ideal.comap f I :=", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings, let $f:R\\to S$ be a ring homomorphism, let $I$ be an ideal of $S$, and let $r\\in S$. Suppose that $r\\neq 0$ and $r\\in I$. Let $p$ be a polynomial in $R[x]$ such that $p\\neq 0$ and $p(r)=0$. Then there is a nonzero coefficient of $p$ that is in the preimage of $I$ under $f$."}
{"name": "equiv.perm.order_of_is_cycle", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/basic.lean", "formal_statement": "theorem equiv.perm.order_of_is_cycle {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1]\n\t{\u03c3 : equiv.perm \u03b1} (h\u03c3 : \u03c3.is_cycle) :\n\torder_of \u03c3 = \u03c3.support.card :=", "nl_statement_of_codex": "Let $\\sigma$ be a permutation of a finite set $X$. If $\\sigma$ is a cycle, then the order of $\\sigma$ is the number of elements in the support of $\\sigma$."}
{"name": "set_like.int_cast_mem_graded", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/direct_sum/internal.lean", "formal_statement": "theorem set_like.int_cast_mem_graded {\u03b9 \u03c3 R : Type*} [has_zero \u03b9]\n\t[add_group_with_one R] [set_like \u03c3 R] [add_subgroup_class \u03c3 R] (A : \u03b9 \u2192 \u03c3)\n\t[set_like.has_graded_one A] (z : \u2124) :\n\t\u2191z \u2208 A 0 :=", "nl_statement_of_codex": "Let $A$ be a graded set of $R$-modules. Then $0\\in A_0$."}
{"name": "measure_theory.measure.to_signed_measure_sub_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/vector_measure.lean", "formal_statement": "theorem measure_theory.measure.to_signed_measure_sub_apply {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1}\n\t[measure_theory.is_finite_measure \u03bc] [measure_theory.is_finite_measure \u03bd]\n\t{i : set \u03b1} (hi : measurable_set i) :\n\t\u21d1(\u03bc.to_signed_measure - \u03bd.to_signed_measure) i = (\u21d1\u03bc i).to_real - (\u21d1\u03bd i).to_real :=", "nl_statement_of_codex": "Let $\u03bc$ and $\u03bd$ be finite measures on a measurable space $(X,\\mathcal{A})$. Then for any $A\\in\\mathcal{A}$, we have $(\u03bc-\u03bd)(A)=\u03bc(A)-\u03bd(A)$."}
{"name": "power_basis.equiv_of_root_symm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/power_basis.lean", "formal_statement": "theorem power_basis.equiv_of_root_symm {S : Type*} [comm_ring S] {A : Type*}\n\t[comm_ring A] [algebra A S] {S' : Type*} [comm_ring S'] [algebra A S']\n\t[is_domain A] (pb : power_basis A S) (pb' : power_basis A S')\n\t(h\u2081 : \u21d1(polynomial.aeval pb.gen) (minpoly A pb'.gen) = 0)\n\t(h\u2082 : \u21d1(polynomial.aeval pb'.gen) (minpoly A pb.gen) = 0) :\n\t(pb.equiv_of_root pb' h\u2081 h\u2082).symm = pb'.equiv_of_root pb h\u2082 h\u2081 :=", "nl_statement_of_codex": "Let $A$ be a domain and let $S$ and $S'$ be $A$-algebras. Let $pb$ and $pb'$ be power bases of $A$ over $S$ and $S'$, respectively. If $pb.gen$ is a root of the minimal polynomial of $pb'.gen$ and $pb'.gen$ is a root of the minimal polynomial of $pb.gen$, then the equivalence between $S$ and $S'$ induced by $pb$ and $pb'$ is the inverse of the equivalence induced by $pb'$ and $pb$."}
{"name": "algebraic_geometry.Scheme.id_val_base", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/Scheme.lean", "formal_statement": "theorem algebraic_geometry.Scheme.id_val_base (X : algebraic_geometry.Scheme) :\n\t(\ud835\udfd9 X).val.base = \ud835\udfd9 \u2191(X.to_LocallyRingedSpace.to_SheafedSpace.to_PresheafedSpace) :=", "nl_statement_of_codex": "The base of the value of the identity morphism of a scheme $X$ is the identity morphism of the presheafed space of $X$."}
{"name": "category_theory.nat_trans.mono_iff_app_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/evaluation.lean", "formal_statement": "theorem category_theory.nat_trans.mono_iff_app_mono {C : Type u\u2081}\n\t[category_theory.category C] (D : Type u\u2082) [category_theory.category D]\n\t[\u2200 (a b : C), category_theory.limits.has_coproducts_of_shape (a \u27f6 b) D]\n\t{F G : C \u2964 D} (\u03b7 : F \u27f6 G) :\n\tcategory_theory.mono \u03b7 \u2194 \u2200 (c : C), category_theory.mono (\u03b7.app c) :=", "nl_statement_of_codex": "A natural transformation $\\eta:F\\to G$ is a monomorphism if and only if $\\eta_c:F(c)\\to G(c)$ is a monomorphism for all $c\\in C$."}
{"name": "diffeomorph.cont_mdiff_within_at_diffeomorph_comp_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/diffeomorph.lean", "formal_statement": "theorem diffeomorph.cont_mdiff_within_at_diffeomorph_comp_iff {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {H : Type*} [topological_space H] {H' : Type*}\n\t[topological_space H'] {G : Type*} [topological_space G]\n\t{I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'}\n\t{J : model_with_corners \ud835\udd5c F G} {M : Type*} [topological_space M]\n\t[charted_space H M] {M' : Type*0} [topological_space M'] [charted_space H' M']\n\t{N : Type*1} [topological_space N] [charted_space G N] {n m : with_top \u2115}\n\t(h : diffeomorph I J M N n) {f : M' \u2192 M} (hm : m \u2264 n) {s : set M'} {x : M'} :\n\tcont_mdiff_within_at I' J m (\u21d1h \u2218 f) s x \u2194 cont_mdiff_within_at I' I m f s x :=", "nl_statement_of_codex": "Let $I:H\\to E$ and $I':H'\\to E'$ be charts on $E$ and $E'$, respectively. Let $J:G\\to F$ be a chart on $F$. Let $M$ and $M'$ be manifolds modeled on $H$ and $H'$, respectively, and let $N$ be a manifold modeled on $G$. Let $h:M\\to N$ be a $C^n$-diffeomorphism. Let $f:M'\\to M$ be a $C^m$-map. Then $h\\circ f$ is $C^m$-differentiable at $x\\in"}
{"name": "list.inter_cons_of_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/lattice.lean", "formal_statement": "theorem list.inter_cons_of_mem {\u03b1 : Type*} {l\u2082 : list \u03b1} {a : \u03b1}\n\t[decidable_eq \u03b1] (l\u2081 : list \u03b1) (h : a \u2208 l\u2082) :\n\t(a :: l\u2081) \u2229 l\u2082 = a :: l\u2081 \u2229 l\u2082 :=", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of elements of a type $\u03b1$ with decidable equality. If $a\\in l_2$, then $(a::l_1)\\cap l_2=a::(l_1\\cap l_2)$."}
{"name": "affine_isometry_equiv.linear_eq_linear_isometry", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/affine_isometry.lean", "formal_statement": "theorem affine_isometry_equiv.linear_eq_linear_isometry {\ud835\udd5c V V\u2082 P P\u2082 : Type*}\n\t[normed_field \ud835\udd5c] [semi_normed_group V] [semi_normed_group V\u2082]\n\t[normed_space \ud835\udd5c V] [normed_space \ud835\udd5c V\u2082] [pseudo_metric_space P]\n\t[pseudo_metric_space P\u2082] [normed_add_torsor V P] [normed_add_torsor V\u2082 P\u2082]\n\t(e : P \u2243\u1d43\u2071[\ud835\udd5c] P\u2082) :\n\te.to_affine_equiv.linear = e.linear_isometry_equiv.to_linear_equiv :=", "nl_statement_of_codex": "Let $P$ and $P_2$ be normed spaces over a normed field $K$. Let $e:P\\to P_2$ be an affine isometry. Then $e$ is a linear isometry."}
{"name": "algebra.algebra_map_of_subring", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/algebra/basic.lean", "formal_statement": "theorem algebra.algebra_map_of_subring {R : Type*} [comm_ring R] (S : subring R) :\n\talgebra_map \u21a5S R = S.subtype :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $S$ be a subring of $R$. Then the algebra map $S\\to R$ is the inclusion map."}
{"name": "continuous_map.has_basis_nhds_compact_convergence", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/compact_convergence.lean", "formal_statement": "theorem continuous_map.has_basis_nhds_compact_convergence {\u03b1 : Type u\u2081}\n\t{\u03b2 : Type u\u2082} [topological_space \u03b1] [uniform_space \u03b2] (f : C(\u03b1, \u03b2)) :\n\t(nhds f).has_basis (\u03bb (p : set \u03b1 \u00d7 set (\u03b2 \u00d7 \u03b2)), is_compact p.fst \u2227 p.snd \u2208 uniformity \u03b2) (\u03bb (p : set \u03b1 \u00d7 set (\u03b2 \u00d7 \u03b2)), continuous_map.compact_conv_nhd p.fst p.snd f) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous map between topological spaces $X$ and $Y$. Then the topology on $Y$ is generated by the sets of the form $f(K)\\times U$ where $K$ is a compact subset of $X$ and $U$ is an open subset of $Y\\times Y$."}
{"name": "one_lt_iff_ne_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid.lean", "formal_statement": "theorem one_lt_iff_ne_one {\u03b1 : Type u} [canonically_ordered_monoid \u03b1] {a : \u03b1} :\n\t1 < a \u2194 a \u2260 1 :=", "nl_statement_of_codex": "Let $\u03b1$ be a canonically ordered monoid. Then $1<a$ if and only if $a\\neq 1$."}
{"name": "part_enat.dom_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/part_enat.lean", "formal_statement": "theorem part_enat.dom_coe (x : \u2115) :\n\t\u2191x.dom :=", "nl_statement_of_codex": "The domain of a partition of $x$ is $x$."}
{"name": "filter.at_top_basis_Ioi", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.at_top_basis_Ioi {\u03b1 : Type*} [nonempty \u03b1] [semilattice_sup \u03b1]\n\t[no_max_order \u03b1] :\n\tfilter.at_top.has_basis (\u03bb (_x : \u03b1), true) set.Ioi :=", "nl_statement_of_codex": "The filter at infinity on a nonempty set $X$ with a partial order that has no maximum element has a basis of the sets of the form $X\\setminus [a,\\infty)$."}
{"name": "le_of_inf_le_sup_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/lattice.lean", "formal_statement": "theorem le_of_inf_le_sup_le {\u03b1 : Type u} [distrib_lattice \u03b1] {x y z : \u03b1}\n\t(h\u2081 : x \u2293 z \u2264 y \u2293 z) (h\u2082 : x \u2294 z \u2264 y \u2294 z) :\n\tx \u2264 y :=", "nl_statement_of_codex": "Let $x,y,z$ be elements of a distributive lattice. If $x\\wedge z\\leq y\\wedge z$ and $x\\vee z\\leq y\\vee z$, then $x\\leq y$."}
{"name": "is_localization.localization_localization_surj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/localization_localization.lean", "formal_statement": "theorem is_localization.localization_localization_surj {R : Type*} [comm_ring R]\n\t(M : submonoid R) {S : Type*} [comm_ring S] [algebra R S] (N : submonoid S)\n\t(T : Type*) [comm_ring T] [algebra R T] [algebra S T] [is_scalar_tower R S T]\n\t[is_localization M S] [is_localization N T] (x : T) :\n\t\u2203 (y : R \u00d7 \u21a5(is_localization.localization_localization_submodule M N)), x * \u21d1(algebra_map R T) \u2191(y.snd) = \u21d1(algebra_map R T) y.fst :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ a submonoid of $R$, $S$ a commutative $R$-algebra, $N$ a submonoid of $S$, $T$ a commutative $R$-algebra, and $T$ a commutative $S$-algebra. Suppose that $S$ is a localization of $M$, $T$ is a localization of $N$, and $T$ is a scalar extension of $S$. Then for each $x\\in T$ there is an element $y\\in R\\times N$ such that $x\\cdot y=y$."}
{"name": "ring_hom.map_multiset_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem ring_hom.map_multiset_sum {\u03b2 : Type u} {\u03b3 : Type w}\n\t[non_assoc_semiring \u03b2] [non_assoc_semiring \u03b3] (f : \u03b2 \u2192+* \u03b3) (s : multiset \u03b2) :\n\t\u21d1f s.sum = (multiset.map \u21d1f s).sum :=", "nl_statement_of_codex": "Let $f:R\\to S$ be a ring homomorphism. Then $f(\\sum_{i\\in I}a_i)=\\sum_{i\\in I}f(a_i)$ for any multiset $I$ of elements of $R$."}
{"name": "associates.factors_eq_some_iff_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/unique_factorization_domain.lean", "formal_statement": "theorem associates.factors_eq_some_iff_ne_zero {\u03b1 : Type*}\n\t[cancel_comm_monoid_with_zero \u03b1] [unique_factorization_monoid \u03b1]\n\t[dec : decidable_eq \u03b1] [dec' : decidable_eq (associates \u03b1)] {a : associates \u03b1} :\n\t(\u2203 (s : multiset {p // irreducible p}), a.factors = option.some s) \u2194 a \u2260 0 :=", "nl_statement_of_codex": "Let $R$ be a unique factorization domain. Then an element $a\\in R$ is nonzero if and only if it has a factorization into irreducible elements."}
{"name": "normalize_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/gcd_monoid/basic.lean", "formal_statement": "theorem normalize_zero {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1]\n\t[normalization_monoid \u03b1] :\n\t\u21d1normalize 0 = 0 :=", "nl_statement_of_codex": "The normalization of $0$ is $0$."}
{"name": "mul_equiv.coe_prod_comm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/prod.lean", "formal_statement": "theorem mul_equiv.coe_prod_comm {M N : Type*} [mul_one_class M]\n\t[mul_one_class N] :\n\t\u21d1mul_equiv.prod_comm = prod.swap :=", "nl_statement_of_codex": "The map $(x,y)\\mapsto (y,x)$ is the inverse of the map $(x,y)\\mapsto (x,y)$."}
{"name": "category_theory.adjunction.mk_of_hom_equiv_hom_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/adjunction/basic.lean", "formal_statement": "theorem category_theory.adjunction.mk_of_hom_equiv_hom_equiv {C : Type u\u2081}\n\t[category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t{F : C \u2964 D} {G : D \u2964 C} (adj : category_theory.adjunction.core_hom_equiv F G)\n\t(X : C) (Y : D) :\n\t(category_theory.adjunction.mk_of_hom_equiv adj).hom_equiv X Y = adj.hom_equiv X Y :=", "nl_statement_of_codex": "Let $F:C\\to D$ and $G:D\\to C$ be functors between categories $C$ and $D$. If $F$ and $G$ form an adjunction, then the hom-equivalence of the adjunction is the same as the hom-equivalence of the adjunction."}
{"name": "submonoid.localization_map.lift_spec_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.lift_spec_mul {M : Type*} [comm_monoid M]\n\t{S : submonoid M} {N : Type*} [comm_monoid N] {P : Type*} [comm_monoid P]\n\t(f : S.localization_map N) {g : M \u2192* P} (hg : \u2200 (y : \u21a5S), is_unit (\u21d1g \u2191y))\n\t(z : N) (w v : P) :\n\t\u21d1(f.lift hg) z * w = v \u2194 \u21d1g (f.sec z).fst * w = \u21d1g \u2191((f.sec z).snd) * v :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, let $P$ be a commutative monoid, let $f:S\\to N$ be a localization map, let $g:M\\to P$ be a monoid homomorphism, and suppose that $g$ sends every element of $S$ to a unit of $P$. Then the following are equivalent:\n\\begin{enumerate}\n\\item $f(z)w=v$\n\\item $g(f(z))w=g(z)v$\n\\end{en"}
{"name": "asymptotics.is_Theta.div", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/theta.lean", "formal_statement": "theorem asymptotics.is_Theta.div {\u03b1 \ud835\udd5c \ud835\udd5c' : Type*5} [normed_field \ud835\udd5c]\n\t[normed_field \ud835\udd5c'] {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \ud835\udd5c} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c'}\n\t(h\u2081 : f\u2081 =\u0398[l] g\u2081) (h\u2082 : f\u2082 =\u0398[l] g\u2082) :\n\t(\u03bb (x : \u03b1), f\u2081 x / f\u2082 x) =\u0398[l] \u03bb (x : \u03b1), g\u2081 x / g\u2082 x :=", "nl_statement_of_codex": "Let $f_1, f_2, g_1, g_2$ be functions from a filter $l$ to a normed field $F$. If $f_1=\\Theta(g_1)$ and $f_2=\\Theta(g_2)$, then $f_1/f_2=\\Theta(g_1/g_2)$."}
{"name": "galois_insertion.l_binfi_u", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/galois_connection.lean", "formal_statement": "theorem galois_insertion.l_binfi_u {\u03b1 : Type u} {\u03b2 : Type v} {l : \u03b1 \u2192 \u03b2}\n\t{u : \u03b2 \u2192 \u03b1} [complete_lattice \u03b1] [complete_lattice \u03b2]\n\t(gi : galois_insertion l u) {\u03b9 : Sort x} {p : \u03b9 \u2192 Prop}\n\t(f : \u03a0 (i : \u03b9), p i \u2192 \u03b2) :\n\tl (\u2a05 (i : \u03b9) (hi : p i), u (f i hi)) = \u2a05 (i : \u03b9) (hi : p i), f i hi :=", "nl_statement_of_codex": "Let $l:A\\to B$ and $u:B\\to A$ be a Galois insertion. Then $l(\\inf_{i\\in I}u(f(i)))=\\inf_{i\\in I}f(i)$."}
{"name": "part.none_ne_some", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.none_ne_some {\u03b1 : Type*} (x : \u03b1) :\n\tpart.none \u2260 part.some x :=", "nl_statement_of_codex": "The partition $\\emptyset$ is not equal to the partition $\\{x\\}$."}
{"name": "first_order.language.direct_limit.rel_map_equiv_unify", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/direct_limit.lean", "formal_statement": "theorem first_order.language.direct_limit.rel_map_equiv_unify\n\t{L : first_order.language} {\u03b9 : Type v} [preorder \u03b9] (G : \u03b9 \u2192 Type w)\n\t[\u03a0 (i : \u03b9), L.Structure (G i)]\n\t(f : \u03a0 (i j : \u03b9), i \u2264 j \u2192 L.embedding (G i) (G j)) [is_directed \u03b9 has_le.le]\n\t[directed_system G (\u03bb (i j : \u03b9) (h : i \u2264 j), \u21d1(f i j h))] [nonempty \u03b9] {n : \u2115}\n\t(R : L.relations n) (x : fin n \u2192 (\u03a3 (i : \u03b9), G i)) (i : \u03b9)\n\t(hi : i \u2208 upper_bounds (set.range (sigma.fst \u2218 x))) :\n\tfirst_order.language.Structure.rel_map R x = first_order.language.Structure.rel_map R (first_order.language.direct_limit.unify f x i hi) :=", "nl_statement_of_codex": "Let $L$ be a first-order language, let $\\{G_i\\}_{i\\in I}$ be a directed system of $L$-structures, and let $f_{ij}:G_i\\to G_j$ be the embeddings. Let $R$ be an $n$-ary relation on $L$. Let $x:n\\to \\Sigma_{i\\in I} G_i$ be a tuple of elements of the direct limit of the system. Let $i\\in I$ be an upper bound of the set of indices of the elements of $x$. Then the $R$-value of $x$ is equal to the $R"}
{"name": "bool.bnot_false", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bool/basic.lean", "formal_statement": "theorem bool.bnot_false :\n\t!bool.ff = bool.tt :=", "nl_statement_of_codex": "The negation of false is true."}
{"name": "complex.norm_sq_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/complex/basic.lean", "formal_statement": "theorem complex.norm_sq_apply (z : \u2102) :\n\t\u21d1complex.norm_sq z = z.re * z.re + z.im * z.im :=", "nl_statement_of_codex": "The square of the norm of a complex number $z$ is equal to the sum of the squares of its real and imaginary parts."}
{"name": "nat.coprime_one_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/gcd.lean", "formal_statement": "theorem nat.coprime_one_left (n : \u2115) :\n\t1.coprime n :=", "nl_statement_of_codex": "$1$ is coprime to any natural number $n$."}
{"name": "clifford_algebra.foldr_\u03b9", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/clifford_algebra/fold.lean", "formal_statement": "theorem clifford_algebra.foldr_\u03b9 {R M N : Type*} [comm_ring R]\n\t[add_comm_group M] [add_comm_group N] [module R M] [module R N]\n\t(Q : quadratic_form R M) (f : M \u2192\u2097[R] N \u2192\u2097[R] N)\n\t(hf : \u2200 (m : M) (x : N), \u21d1(\u21d1f m) (\u21d1(\u21d1f m) x) = \u21d1Q m \u2022 x) (n : N) (m : M) :\n\t\u21d1(\u21d1(clifford_algebra.foldr Q f hf) n) (\u21d1(clifford_algebra.\u03b9 Q) m) = \u21d1(\u21d1f m) n :=", "nl_statement_of_codex": "Let $Q$ be a quadratic form on $M$ and let $f:M\\to\\mathrm{End}_R(N)$ be a linear map. Then $\\mathrm{Cl}(Q,f)$ is a Clifford algebra of $Q$."}
{"name": "SemiNormedGroup.Completion.map_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/SemiNormedGroup/completion.lean", "formal_statement": "theorem SemiNormedGroup.Completion.map_zero (V W : SemiNormedGroup) :\n\tSemiNormedGroup.Completion.map 0 = 0 :=", "nl_statement_of_codex": "The map $0:V\\to W$ is sent to $0:V\\to W$ under the completion map."}
{"name": "is_topological_fiber_bundle.is_open_map_proj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/fiber_bundle.lean", "formal_statement": "theorem is_topological_fiber_bundle.is_open_map_proj {B F Z : Type*}\n\t[topological_space B] [topological_space F] {proj : Z \u2192 B}\n\t[topological_space Z] (h : is_topological_fiber_bundle F proj) :\n\tis_open_map proj :=", "nl_statement_of_codex": "Let $F$ be a topological fiber bundle over $B$. Then the projection map $Z\\to B$ is open."}
{"name": "filter.mem_sets", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.mem_sets {\u03b1 : Type u} {f : filter \u03b1} {s : set \u03b1} :\n\ts \u2208 f.sets \u2194 s \u2208 f :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$. Then $s\\in f$ if and only if $s\\in f.sets$."}
{"name": "polynomial.of_finsupp_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.of_finsupp_eq_zero {R : Type u} [semiring R]\n\t{a : add_monoid_algebra R \u2115} :\n\t{to_finsupp := a} = 0 \u2194 a = 0 :=", "nl_statement_of_codex": "Let $R$ be a semiring and let $a$ be an element of the free $R$-module on $\\mathbb{N}$. Then $a$ is zero if and only if the polynomial $a(x)$ is zero."}
{"name": "finsupp_add_equiv_dfinsupp_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/to_dfinsupp.lean", "formal_statement": "theorem finsupp_add_equiv_dfinsupp_symm_apply {\u03b9 M : Type*} [decidable_eq \u03b9]\n\t[add_zero_class M] [\u03a0 (m : M), decidable (m \u2260 0)] :\n\t\u21d1(finsupp_add_equiv_dfinsupp.symm) = dfinsupp.to_finsupp :=", "nl_statement_of_codex": "The inverse of the equivalence between finitely supported functions and functions with finite support is the function that sends a function with finite support to its finitely supported version."}
{"name": "neg_le_abs_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem neg_le_abs_self {\u03b1 : Type u} [has_neg \u03b1] [linear_order \u03b1] (a : \u03b1) :\n\t-a \u2264 |a| :=", "nl_statement_of_codex": "For any $a\\in\\mathbb{R}$, $-a\\leq |a|$."}
{"name": "category_theory.endofunctor.algebra.id_eq_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/endofunctor/algebra.lean", "formal_statement": "theorem category_theory.endofunctor.algebra.id_eq_id {C : Type u}\n\t[category_theory.category C] {F : C \u2964 C}\n\t(A : category_theory.endofunctor.algebra F) :\n\tcategory_theory.endofunctor.algebra.hom.id A = \ud835\udfd9 A :=", "nl_statement_of_codex": "Let $C$ be a category and let $F:C\\to C$ be an endofunctor. Let $A$ be an $F$-algebra. Then the identity morphism on $A$ is the identity morphism on $A$."}
{"name": "diffeomorph.symm_to_homeomorph", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/diffeomorph.lean", "formal_statement": "theorem diffeomorph.symm_to_homeomorph {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {H : Type*} [topological_space H] {G : Type*}\n\t[topological_space G] {I : model_with_corners \ud835\udd5c E H}\n\t{J : model_with_corners \ud835\udd5c F G} {M : Type*} [topological_space M]\n\t[charted_space H M] {N : Type*1} [topological_space N] [charted_space G N]\n\t{n : with_top \u2115} (h : diffeomorph I J M N n) :\n\th.symm.to_homeomorph = h.to_homeomorph.symm :=", "nl_statement_of_codex": "Let $I$ and $J$ be models with corners, $M$ and $N$ be manifolds, and $n$ be a natural number. Then the diffeomorphism $I\\to J$ is the inverse of the diffeomorphism $J\\to I$ if and only if the homeomorphism $I\\to J$ is the inverse of the homeomorphism $J\\to I$."}
{"name": "measure_theory.measure.is_finite_measure_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.is_finite_measure_map {\u03b1 \u03b2 : Type*}\n\t[measurable_space \u03b2] {m : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1)\n\t[measure_theory.is_finite_measure \u03bc] (f : \u03b1 \u2192 \u03b2) :\n\tmeasure_theory.is_finite_measure (measure_theory.measure.map f \u03bc) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a measurable function between measurable spaces $X$ and $Y$. If $\\mu$ is a finite measure on $X$, then $f_*\\mu$ is a finite measure on $Y$."}
{"name": "linear_map.of_is_compl_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/projection.lean", "formal_statement": "theorem linear_map.of_is_compl_eq {R : Type*} [ring R] {E : Type*}\n\t[add_comm_group E] [module R E] {F : Type*} [add_comm_group F] [module R F]\n\t{p q : submodule R E} (h : is_compl p q) {\u03c6 : \u21a5p \u2192\u2097[R] F} {\u03c8 : \u21a5q \u2192\u2097[R] F}\n\t{\u03c7 : E \u2192\u2097[R] F} (h\u03c6 : \u2200 (u : \u21a5p), \u21d1\u03c6 u = \u21d1\u03c7 \u2191u) (h\u03c8 : \u2200 (u : \u21a5q), \u21d1\u03c8 u = \u21d1\u03c7 \u2191u) :\n\tlinear_map.of_is_compl h \u03c6 \u03c8 = \u03c7 :=", "nl_statement_of_codex": "Let $R$ be a ring, $E$ and $F$ be $R$-modules, $p$ and $q$ be submodules of $E$, and $\\phi:p\\to F$ and $\\psi:q\\to F$ be $R$-linear maps. If $p$ and $q$ are complementary, then $\\phi$ and $\\psi$ uniquely determine an $R$-linear map $\\chi:E\\to F$."}
{"name": "real.differentiable_sinh", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem real.differentiable_sinh :\n\tdifferentiable \u211d real.sinh :=", "nl_statement_of_codex": "The function $f(x)=\\sinh(x)$ is differentiable on $\\mathbb{R}$."}
{"name": "mul_div_cancel'''", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem mul_div_cancel''' {G : Type*} [comm_group G] (a b : G) :\n\ta * b / a = b :=", "nl_statement_of_codex": "Let $G$ be a commutative group. Then $a*b/a=b$ for all $a,b\\in G$."}
{"name": "norm_num.subst_into_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/norm_num.lean", "formal_statement": "theorem norm_num.subst_into_mul {\u03b1 : Type*} [has_mul \u03b1] (l r tl tr t : \u03b1)\n\t(prl : l = tl) (prr : r = tr) (prt : tl * tr = t) :\n\tl * r = t :=", "nl_statement_of_codex": "Let $l, r, tl, tr, t$ be elements of a ring $R$. If $l=tl$ and $r=tr$ and $tl\\cdot tr=t$, then $l\\cdot r=t$."}
{"name": "is_noetherian_of_fg_of_noetherian", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem is_noetherian_of_fg_of_noetherian {R M : Type*} [ring R]\n\t[add_comm_group M] [module R M] (N : submodule R M) [is_noetherian_ring R]\n\t(hN : N.fg) :\n\tis_noetherian R \u21a5N :=", "nl_statement_of_codex": "Let $R$ be a ring and $M$ be an $R$-module. If $R$ is Noetherian and $N$ is a finitely generated submodule of $M$, then $N$ is Noetherian."}
{"name": "affine_subspace.vadd_mem_pointwise_vadd_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/pointwise.lean", "formal_statement": "theorem affine_subspace.vadd_mem_pointwise_vadd_iff {k : Type*} [ring k]\n\t{V P : Type*} [add_comm_group V] [module k V] [add_torsor V P] {v : V}\n\t{s : affine_subspace k P} {p : P} :\n\tv +\u1d65 p \u2208 v +\u1d65 s \u2194 p \u2208 s :=", "nl_statement_of_codex": "Let $V$ be a $k$-module, $P$ be an affine space over $V$, and $s$ be an affine subspace of $P$. Then $v+p\\in v+s$ if and only if $p\\in s$."}
{"name": "antilipschitz_with_iff_le_mul_nndist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/antilipschitz.lean", "formal_statement": "theorem antilipschitz_with_iff_le_mul_nndist {\u03b1 \u03b2 : Type*}\n\t[pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2} :\n\tantilipschitz_with K f \u2194 \u2200 (x y : \u03b1), has_nndist.nndist x y \u2264 K * has_nndist.nndist (f x) (f y) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between pseudo-metric spaces. Then $f$ is antilipschitz with constant $K$ if and only if $d(x,y)\\leq Kd(f(x),f(y))$ for all $x,y\\in X$."}
{"name": "measure_theory.measure_preserving.integrable_on_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/integrable_on.lean", "formal_statement": "theorem measure_theory.measure_preserving.integrable_on_image {\u03b1 \u03b2 E : Type*}\n\t[measurable_space \u03b1] [normed_group E] {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space \u03b2] {e : \u03b1 \u2192 \u03b2} {\u03bd : measure_theory.measure \u03b2 . \"volume_tac\"}\n\t(h\u2081 : measure_theory.measure_preserving e \u03bc \u03bd) (h\u2082 : measurable_embedding e)\n\t{f : \u03b2 \u2192 E} {s : set \u03b1} :\n\tmeasure_theory.integrable_on f (e '' s) \u03bd \u2194 measure_theory.integrable_on (f \u2218 e) s \u03bc :=", "nl_statement_of_codex": "Let $E$ be a normed group, let $\\alpha$ and $\\beta$ be measurable spaces, let $\\mu$ be a measure on $\\alpha$, let $\\nu$ be a measure on $\\beta$, let $e:\\alpha\\to\\beta$ be a measurable embedding, and let $f:\\beta\\to E$. Then $f$ is integrable on $e[S]$ with respect to $\\nu$ if and only if $f\\circ e$ is integrable on $S$ with respect to $\\mu$."}
{"name": "category_theory.lax_monoidal_functor.left_unitality", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/functor.lean", "formal_statement": "theorem category_theory.lax_monoidal_functor.left_unitality {C : Type u\u2081}\n\t[category_theory.category C] [category_theory.monoidal_category C]\n\t{D : Type u\u2082} [category_theory.category D]\n\t[category_theory.monoidal_category D]\n\t(self : category_theory.lax_monoidal_functor C D) (X : C) :\n\t(\u03bb_ (self.to_functor.obj X)).hom = (self.\u03b5 \u2297 \ud835\udfd9 (self.to_functor.obj X)) \u226b self.\u03bc (\ud835\udfd9_ C) X \u226b self.to_functor.map (\u03bb_ X).hom :=", "nl_statement_of_codex": "Let $C$ and $D$ be monoidal categories and let $F:C\\to D$ be a lax monoidal functor. Then for any object $X$ of $C$, the morphism $F(\\lambda_X)$ is equal to the composition of the morphisms $F(\\lambda_X)$, $F(\\lambda_X)$, and $F(\\lambda_X)$."}
{"name": "embedding_sigma_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/constructions.lean", "formal_statement": "theorem embedding_sigma_mk {\u03b9 \u03c3 : \u03b9 \u2192 Type*}\n\t[\u03a0 (i : \u03b9), topological_space (\u03c3 i)] {i : \u03b9} :\n\tembedding (sigma.mk i) :=", "nl_statement_of_codex": "The map $\\sigma_i:\\Sigma_{i\\in I}\\sigma_i\\to\\sigma_i$ is an embedding."}
{"name": "Preorder.dual_equiv_functor", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/category/Preorder.lean", "formal_statement": "theorem Preorder.dual_equiv_functor :\n\tPreorder.dual_equiv.functor = Preorder.dual :=", "nl_statement_of_codex": "The functor $Preorder.dual$ is equivalent to itself."}
{"name": "asymptotics.is_O_with.const_mul_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_with.const_mul_left {\u03b1 F R : Type*2} [has_norm F]\n\t[semi_normed_ring R] { : \u211d} {g : \u03b1 \u2192 F} {l : filter \u03b1} {f : \u03b1 \u2192 R}\n\t(h : asymptotics.is_O_with c l f g) (c' : R) :\n\tasymptotics.is_O_with (\u2225c'\u2225 * c) l (\u03bb (x : \u03b1), c' * f x) g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to R$ be functions and let $c,c'\\in R$. If $f$ is $O(g)$ as $x\\to\\infty$, then $c'f$ is $O(g)$ as $x\\to\\infty$."}
{"name": "char_two.neg_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/char_p/two.lean", "formal_statement": "theorem char_two.neg_eq {R : Type*} [ring R] [char_p R 2] (x : R) :\n\t-x = x :=", "nl_statement_of_codex": "In a ring of characteristic $2$, $-x=x$ for all $x$."}
{"name": "finset.sup_inf_distrib_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.sup_inf_distrib_left {\u03b1 \u03b9 : Type*} [distrib_lattice \u03b1]\n\t[order_bot \u03b1] (s : finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n\ta \u2293 s.sup f = s.sup (\u03bb (i : \u03b9), a \u2293 f i) :=", "nl_statement_of_codex": "Let $s$ be a finite set, let $f:s\\to \\alpha$ be a function, and let $a\\in \\alpha$. Then $a\\wedge \\sup_{i\\in s} f(i)=\\sup_{i\\in s} (a\\wedge f(i))$."}
{"name": "diffeomorph.cont_mdiff_within_at_comp_diffeomorph_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/diffeomorph.lean", "formal_statement": "theorem diffeomorph.cont_mdiff_within_at_comp_diffeomorph_iff {\ud835\udd5c : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E] [normed_space \ud835\udd5c E]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {H : Type*} [topological_space H] {H' : Type*}\n\t[topological_space H'] {G : Type*} [topological_space G]\n\t{I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'}\n\t{J : model_with_corners \ud835\udd5c F G} {M : Type*} [topological_space M]\n\t[charted_space H M] {M' : Type*0} [topological_space M'] [charted_space H' M']\n\t{N : Type*1} [topological_space N] [charted_space G N] {n m : with_top \u2115}\n\t(h : diffeomorph I J M N n) {f : N \u2192 M'} {s : set M} {x : M} (hm : m \u2264 n) :\n\tcont_mdiff_within_at I I' m (f \u2218 \u21d1h) s x \u2194 cont_mdiff_within_at J I' m f (\u21d1(h.symm) \u207b\u00b9' s) (\u21d1h x) :=", "nl_statement_of_codex": "Let $I, I', J$ be models with corners, $M, M', N$ be manifolds, $n, m$ be natural numbers, $h:M\\to N$ be a diffeomorphism, $f:N\\to M'$ be a function, $s$ be a subset of $M$, and $x$ be an element of $M$. Then $f\\circ h$ is $m$-times continuously differentiable at $x$ in $s$ if and only if $f$ is $m$-times continuously differentiable at $h(x)$ in $h^{-1}(s)$."}
{"name": "set.Union_diff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Union_diff {\u03b2 : Type*} {\u03b9 : Sort u_4} (s : set \u03b2) (t : \u03b9 \u2192 set \u03b2) :\n\t(\u22c3 (i : \u03b9), t i) \\ s = \u22c3 (i : \u03b9), t i \\ s :=", "nl_statement_of_codex": "Let $s$ be a set and let $t$ be a function from an index set $\\iota$ to sets. Then $(\\bigcup_{i\\in\\iota} t(i))\\setminus s = \\bigcup_{i\\in\\iota} (t(i)\\setminus s)$."}
{"name": "nat.pow_dvd_pow_iff_le_right'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/pow.lean", "formal_statement": "theorem nat.pow_dvd_pow_iff_le_right' {b k l : \u2115} :\n\t(b + 2) ^ k \u2223 (b + 2) ^ l \u2194 k \u2264 l :=", "nl_statement_of_codex": "For all $b,k,l\\in\\mathbb{N}$, $(b+2)^k$ divides $(b+2)^l$ if and only if $k\\leq l$."}
{"name": "pnat.to_pnat'_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pnat/basic.lean", "formal_statement": "theorem pnat.to_pnat'_coe {n : \u2115} :\n\t0 < n \u2192 \u2191(n.to_pnat') = n :=", "nl_statement_of_codex": "If $n$ is a positive integer, then $n$ is equal to the positive natural number $n$."}
{"name": "ordinal.cof_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/cofinality.lean", "formal_statement": "theorem ordinal.cof_add (a b : ordinal) :\n\tb \u2260 0 \u2192 (a + b).cof = b.cof :=", "nl_statement_of_codex": "Let $a$ and $b$ be ordinals. Then the cofinality of $a+b$ is equal to the cofinality of $b$."}
{"name": "deriv_sin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem deriv_sin {f : \u211d \u2192 \u211d} {x : \u211d} (hc : differentiable_at \u211d f x) :\n\tderiv (\u03bb (x : \u211d), real.sin (f x)) x = real.cos (f x) * deriv f x :=", "nl_statement_of_codex": "If $f$ is differentiable at $x$, then $\\sin(f(x))$ is differentiable at $x$ and $\\frac{d}{dx}\\sin(f(x))=\\cos(f(x))\\cdot f'(x)$."}
{"name": "set.image_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.image_surjective {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} :\n\tfunction.surjective (set.image f) \u2194 function.surjective f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then $f$ is surjective if and only if the function $f':A\\to f(A)$ defined by $f'(x)=f(x)$ is surjective."}
{"name": "measure_theory.measure.regular.inner_regular_measurable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/regular.lean", "formal_statement": "theorem measure_theory.measure.regular.inner_regular_measurable {\u03b1 : Type*}\n\t[measurable_space \u03b1] [topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t[\u03bc.regular] :\n\t\u03bc.inner_regular is_compact (\u03bb (s : set \u03b1), measurable_set s \u2227 \u21d1\u03bc s \u2260 \u22a4) :=", "nl_statement_of_codex": "Let $\\mu$ be a regular measure on a topological space $X$. Then $\\mu$ is inner regular on the set of compact measurable sets."}
{"name": "witt_vector.standard_one_dim_isocrystal.frobenius_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/isocrystal.lean", "formal_statement": "theorem witt_vector.standard_one_dim_isocrystal.frobenius_apply (p : \u2115)\n\t[fact (nat.prime p)] (k : Type*) [comm_ring k] [is_domain k] [char_p k p]\n\t[perfect_ring k p] (m : \u2124) (x : witt_vector.standard_one_dim_isocrystal p k m) :\n\t\u21d1(witt_vector.isocrystal.frobenius p k) x = \u2191p ^ m \u2022 \u21d1(witt_vector.fraction_ring.frobenius_ring_hom p k) x :=", "nl_statement_of_codex": "Let $p$ be a prime, $k$ a perfect domain of characteristic $p$, and $m\\in\\mathbb{Z}$. Then the Frobenius map on the $m$-th standard one-dimensional $p$-isocrystal over $k$ is given by $x\\mapsto p^m\\cdot x$."}
{"name": "PartialOrder.dual_equiv_functor", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/category/PartialOrder.lean", "formal_statement": "theorem PartialOrder.dual_equiv_functor :\n\tPartialOrder.dual_equiv.functor = PartialOrder.dual :=", "nl_statement_of_codex": "The functor $F$ from the category of partial orders to itself that takes a partial order to its dual is the same as the functor $G$ that takes a partial order to its dual."}
{"name": "monoid_hom.coe_eq_to_mul_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem monoid_hom.coe_eq_to_mul_hom {M N : Type*} {mM : mul_one_class M}\n\t{mN : mul_one_class N} (f : M \u2192* N) :\n\t\u2191f = f.to_mul_hom :=", "nl_statement_of_codex": "Let $M$ and $N$ be monoids. Then the monoid homomorphism $f:M\\to N$ is equal to the monoid homomorphism $f:M\\to N$."}
{"name": "category_theory.sieve.le_pushforward_pullback", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sieves.lean", "formal_statement": "theorem category_theory.sieve.le_pushforward_pullback {C : Type u\u2081}\n\t[category_theory.category C] {X Y : C} (f : Y \u27f6 X)\n\t(R : category_theory.sieve Y) :\n\tR \u2264 category_theory.sieve.pullback f (category_theory.sieve.pushforward f R) :=", "nl_statement_of_codex": "Let $f:Y\\to X$ be a morphism in a category $C$. Then the pullback of the pushforward of a sieve $R$ on $Y$ is a sieve on $Y$ that contains $R$."}
{"name": "polynomial.nat_degree_derivative_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/derivative.lean", "formal_statement": "theorem polynomial.nat_degree_derivative_lt {R : Type u} [semiring R]\n\t{p : polynomial R} (hp : p.nat_degree \u2260 0) :\n\t(\u21d1polynomial.derivative p).nat_degree < p.nat_degree :=", "nl_statement_of_codex": "Let $p$ be a non-zero polynomial over a semiring $R$. Then the degree of the derivative of $p$ is less than the degree of $p$."}
{"name": "right.add_pos_of_nonneg_of_pos", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/monoid_lemmas.lean", "formal_statement": "theorem right.add_pos_of_nonneg_of_pos {\u03b1 : Type*} [add_zero_class \u03b1]\n\t[preorder \u03b1] [covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le]\n\t{a b : \u03b1} (ha : 0 \u2264 a) (hb : 0 < b) :\n\t0 < a + b :=", "nl_statement_of_codex": "Let $a, b$ be elements of a preordered additive monoid. If $a\\geq 0$ and $b>0$, then $a+b>0$."}
{"name": "Module.colimits.cocone_naturality_components", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/category/Module/colimits.lean", "formal_statement": "theorem Module.colimits.cocone_naturality_components {R : Type u} [ring R]\n\t{J : Type w} [category_theory.category J] (F : J \u2964 Module R) (j j' : J)\n\t(f : j \u27f6 j') (x : \u21a5(F.obj j)) :\n\t\u21d1(Module.colimits.cocone_morphism F j') (\u21d1(F.map f) x) = \u21d1(Module.colimits.cocone_morphism F j) x :=", "nl_statement_of_codex": "Let $R$ be a ring, $J$ a category, and $F:J\\to R$-Mod a functor. Let $j,j'$ be objects of $J$ and $f:j\\to j'$ a morphism. Then the diagram\n\\[\n\\begin{tikzcd}\nF(j) \\arrow[r, "}
{"name": "category_theory.bicategory.associator_naturality_right_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/basic.lean", "formal_statement": "theorem category_theory.bicategory.associator_naturality_right_assoc\n\t{B : Type u} [category_theory.bicategory B] {a b c d : B} (f : a \u27f6 b)\n\t(g : b \u27f6 c) {h h' : c \u27f6 d} (\u03b7 : h \u27f6 h') {X' : a \u27f6 d} (f' : f \u226b g \u226b h' \u27f6 X') :\n\tcategory_theory.bicategory.whisker_left (f \u226b g) \u03b7 \u226b (category_theory.bicategory.associator f g h').hom \u226b f' = (category_theory.bicategory.associator f g h).hom \u226b category_theory.bicategory.whisker_left f (category_theory.bicategory.whisker_left g \u03b7) \u226b f' :=", "nl_statement_of_codex": "Let $B$ be a bicategory. Let $a,b,c,d$ be objects of $B$ and let $f:a\\to b$, $g:b\\to c$, $h,h':c\\to d$, $X':a\\to d$ and $f':f\\circ g\\circ h'\\to X'$. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\na \\arrow[r, "}
{"name": "category_theory.ulift.equivalence_unit_iso_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/category/ulift.lean", "formal_statement": "theorem category_theory.ulift.equivalence_unit_iso_inv {C : Type u\u2081}\n\t[category_theory.category C] :\n\tcategory_theory.ulift.equivalence.unit_iso.inv = \ud835\udfd9 (category_theory.ulift.up_functor \u22d9 category_theory.ulift.down_functor) :=", "nl_statement_of_codex": "The inverse of the unit of the equivalence between the category of types and the category of types with a chosen point is the identity functor."}
{"name": "mv_polynomial.fin_succ_equiv_X_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/equiv.lean", "formal_statement": "theorem mv_polynomial.fin_succ_equiv_X_zero {R : Type u} [comm_semiring R]\n\t{n : \u2115} :\n\t\u21d1(mv_polynomial.fin_succ_equiv R n) (mv_polynomial.X 0) = polynomial.X :=", "nl_statement_of_codex": "The polynomial $X$ is equivalent to $X$ in the ring of multivariate polynomials over $R$."}
{"name": "uniform_equiv.symm_comp_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/equiv.lean", "formal_statement": "theorem uniform_equiv.symm_comp_self {\u03b1 \u03b2 : Type*} [uniform_space \u03b1]\n\t[uniform_space \u03b2] (h : \u03b1 \u2243\u1d64 \u03b2) :\n\t\u21d1(h.symm) \u2218 \u21d1h = id :=", "nl_statement_of_codex": "Let $h:X\\to Y$ be a uniform equivalence. Then $h^{-1}\\circ h=\\mathrm{id}_X$."}
{"name": "measurable_of_fintype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measurable_space.lean", "formal_statement": "theorem measurable_of_fintype {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[measurable_space \u03b2] [fintype \u03b1] [measurable_singleton_class \u03b1] (f : \u03b1 \u2192 \u03b2) :\n\tmeasurable f :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between measurable spaces. If $X$ is finite, then $f$ is measurable."}
{"name": "int.add_neg_of_neg_of_nonpos", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/order.lean", "formal_statement": "theorem int.add_neg_of_neg_of_nonpos {a b : \u2124} (ha : a < 0) (hb : b \u2264 0) :\n\ta + b < 0 :=", "nl_statement_of_codex": "If $a<0$ and $b\\leq 0$, then $a+b<0$."}
{"name": "polynomial.monic.degree_le_zero_iff_eq_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/monic.lean", "formal_statement": "theorem polynomial.monic.degree_le_zero_iff_eq_one {R : Type u} [semiring R]\n\t{p : polynomial R} (hp : p.monic) :\n\tp.degree \u2264 0 \u2194 p = 1 :=", "nl_statement_of_codex": "Let $p$ be a monic polynomial. Then $p$ is a constant polynomial if and only if $p=1$."}
{"name": "field.closure_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subfield.lean", "formal_statement": "theorem field.closure_subset {F : Type*} [field F] {S T : set F}\n\t(hT : is_subfield T) (H : S \u2286 T) :\n\tfield.closure S \u2286 T :=", "nl_statement_of_codex": "Let $F$ be a field and let $S$ and $T$ be subsets of $F$. If $T$ is a subfield of $F$ and $S\\subset T$, then the closure of $S$ in $F$ is contained in $T$."}
{"name": "decidable.imp_iff_or_not", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem decidable.imp_iff_or_not {a b : Prop} [decidable b] :\n\tb \u2192 a \u2194 a \u2228 \u00acb :=", "nl_statement_of_codex": "If $b$ is decidable, then $b\\implies a$ if and only if $a$ or $\\neg b$."}
{"name": "multiset.right_mem_Icc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/locally_finite.lean", "formal_statement": "theorem multiset.right_mem_Icc {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1]\n\t{a b : \u03b1} :\n\tb \u2208 multiset.Icc a b \u2194 a \u2264 b :=", "nl_statement_of_codex": "Let $a,b$ be elements of a preorder $P$ with the locally finite order property. Then $b\\in [a,b]$ if and only if $a\\le b$."}
{"name": "finset.mem_of_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.mem_of_subset {\u03b1 : Type*} {s\u2081 s\u2082 : finset \u03b1} {a : \u03b1} :\n\ts\u2081 \u2286 s\u2082 \u2192 a \u2208 s\u2081 \u2192 a \u2208 s\u2082 :=", "nl_statement_of_codex": "If $s_1\\subset s_2$ and $a\\in s_1$, then $a\\in s_2$."}
{"name": "filter.infi_principal_finset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.infi_principal_finset {\u03b1 : Type u} {\u03b9 : Type w} (s : finset \u03b9)\n\t(f : \u03b9 \u2192 set \u03b1) :\n\t(\u2a05 (i : \u03b9) (H : i \u2208 s), filter.principal (f i)) = filter.principal (\u22c2 (i : \u03b9) (H : i \u2208 s), f i) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to\\mathcal{P}(X)$ be a function. Then $\\bigcap_{i\\in s}f(i)=\\bigcap_{i\\in s}f(i)$."}
{"name": "tsub_pos_iff_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/sub.lean", "formal_statement": "theorem tsub_pos_iff_lt {\u03b1 : Type*} [canonically_linear_ordered_add_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1} :\n\t0 < a - b \u2194 b < a :=", "nl_statement_of_codex": "Let $a, b$ be elements of a linearly ordered monoid. Then $0<a-b$ if and only if $b<a$."}
{"name": "computable_pred.halting_problem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/halting.lean", "formal_statement": "theorem computable_pred.halting_problem (n : \u2115) :\n\t\u00accomputable_pred (\u03bb (c : nat.partrec.code), (c.eval n).dom) :=", "nl_statement_of_codex": "The halting problem is not computable."}
{"name": "measure_theory.fin_meas_additive.smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/set_to_l1.lean", "formal_statement": "theorem measure_theory.fin_meas_additive.smul {\u03b1 \ud835\udd5c : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {\u03b2 : Type*}\n\t[add_comm_monoid \u03b2] {T : set \u03b1 \u2192 \u03b2} [monoid \ud835\udd5c] [distrib_mul_action \ud835\udd5c \u03b2]\n\t(hT : measure_theory.fin_meas_additive \u03bc T) ( : \ud835\udd5c) :\n\tmeasure_theory.fin_meas_additive \u03bc (\u03bb (s : set \u03b1), c \u2022 T s) :=", "nl_statement_of_codex": "Let $\u03b1$ be a measurable space and let $\u03bc$ be a measure on $\u03b1$. Let $\u03b2$ be an abelian monoid and let $T:2^\u03b1\\to \u03b2$ be a finitely additive function. Let $\ud835\udd5c$ be a monoid and let $c\\in \ud835\udd5c$. Then $cT$ is a finitely additive function."}
{"name": "eq_mpr_eq_cast", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/basic.lean", "formal_statement": "theorem eq_mpr_eq_cast {\u03b1 \u03b2 : Sort u_1} (h : \u03b1 = \u03b2) :\n\th.mpr = cast _ :=", "nl_statement_of_codex": "If $\\alpha=\\beta$, then $\\alpha\\to\\beta$ is the identity function."}
{"name": "multiset.mem_sort", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/sort.lean", "formal_statement": "theorem multiset.mem_sort {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [decidable_rel r]\n\t[is_trans \u03b1 r] [is_antisymm \u03b1 r] [is_total \u03b1 r] {s : multiset \u03b1} {a : \u03b1} :\n\ta \u2208 multiset.sort r s \u2194 a \u2208 s :=", "nl_statement_of_codex": "Let $r$ be a total order on a set $A$. Then $a\\in\\mathrm{sort}(s)$ if and only if $a\\in s$."}
{"name": "polynomial.to_laurent_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/laurent.lean", "formal_statement": "theorem polynomial.to_laurent_one {R : Type*} [semiring R] :\n\t\u21d1polynomial.to_laurent 1 = 1 :=", "nl_statement_of_codex": "The Laurent polynomial corresponding to the constant polynomial $1$ is $1$."}
{"name": "order_iso.bdd_above_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/galois_connection.lean", "formal_statement": "theorem order_iso.bdd_above_image {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1]\n\t[preorder \u03b2] (e : \u03b1 \u2243o \u03b2) {s : set \u03b1} :\n\tbdd_above (\u21d1e '' s) \u2194 bdd_above s :=", "nl_statement_of_codex": "Let $e:A\\to B$ be an order isomorphism. Then $e$ maps bounded above sets to bounded above sets."}
{"name": "nat.size_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/pow.lean", "formal_statement": "theorem nat.size_le {m n : \u2115} :\n\tm.size \u2264 n \u2194 m < 2 ^ n :=", "nl_statement_of_codex": "The size of a natural number $m$ is less than or equal to $n$ if and only if $m$ is less than $2^n$."}
{"name": "continuous_map.has_basis_compact_convergence_uniformity_of_compact", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/compact_convergence.lean", "formal_statement": "theorem continuous_map.has_basis_compact_convergence_uniformity_of_compact\n\t{\u03b1 : Type u\u2081} {\u03b2 : Type u\u2082} [topological_space \u03b1] [uniform_space \u03b2]\n\t[compact_space \u03b1] :\n\t(uniformity C(\u03b1, \u03b2)).has_basis (\u03bb (V : set (\u03b2 \u00d7 \u03b2)), V \u2208 uniformity \u03b2) (\u03bb (V : set (\u03b2 \u00d7 \u03b2)), {fg : C(\u03b1, \u03b2) \u00d7 C(\u03b1, \u03b2) | \u2200 (x : \u03b1), (\u21d1(fg.fst) x, \u21d1(fg.snd) x) \u2208 V}) :=", "nl_statement_of_codex": "Let $X$ be a compact topological space and $Y$ a uniform space. Then the uniformity of the space of continuous functions $C(X,Y)$ is generated by the uniformity of $Y$."}
{"name": "submonoid.localization_map.of_mul_equiv_of_localizations_eq_iff_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.of_mul_equiv_of_localizations_eq_iff_eq\n\t{M : Type*} [comm_monoid M] {S : submonoid M} {N : Type*} [comm_monoid N]\n\t{P : Type*} [comm_monoid P] (f : S.localization_map N) {k : N \u2243* P} {x : M}\n\t{y : P} :\n\t\u21d1((f.of_mul_equiv_of_localizations k).to_map) x = y \u2194 \u21d1(f.to_map) x = \u21d1(k.symm) y :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, let $P$ be a commutative monoid, let $f:S\\to N$ be a localization map, let $k:N\\to P$ be an isomorphism of commutative monoids, let $x\\in M$, and let $y\\in P$. Then $f(x)=y$ if and only if $k^{-1}(y)=f(x)$."}
{"name": "exists_embedding_euclidean_of_compact", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/whitney_embedding.lean", "formal_statement": "theorem exists_embedding_euclidean_of_compact {E : Type uE} [normed_group E]\n\t[normed_space \u211d E] [finite_dimensional \u211d E] {H : Type uH} [topological_space H]\n\t{I : model_with_corners \u211d E H} {M : Type uM} [topological_space M]\n\t[charted_space H M] [smooth_manifold_with_corners I M] [t2_space M]\n\t[compact_space M] :\n\t\u2203 (n : \u2115) (e : M \u2192 euclidean_space \u211d (fin n)), smooth I (model_with_corners_self \u211d (euclidean_space \u211d (fin n))) e \u2227 closed_embedding e \u2227 \u2200 (x : M), function.injective \u21d1(mfderiv I (model_with_corners_self \u211d (euclidean_space \u211d (fin n))) e x) :=", "nl_statement_of_codex": "Let $M$ be a compact smooth manifold with corners. Then there exists a smooth embedding $e:M\\to \\mathbb{R}^n$ for some $n\\in\\mathbb{N}$ such that the derivative of $e$ is injective at each point of $M$."}
{"name": "finset.sum_filter_add_sum_filter_not", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_filter_add_sum_filter_not {\u03b2 : Type u} {\u03b1 : Type v}\n\t[add_comm_monoid \u03b2] (s : finset \u03b1) (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t[decidable_pred (\u03bb (x : \u03b1), \u00acp x)] (f : \u03b1 \u2192 \u03b2) :\n\t(finset.filter p s).sum (\u03bb (x : \u03b1), f x) + (finset.filter (\u03bb (x : \u03b1), \u00acp x) s).sum (\u03bb (x : \u03b1), f x) = s.sum (\u03bb (x : \u03b1), f x) :=", "nl_statement_of_codex": "Let $s$ be a finite set, $p$ a predicate on $s$, and $f$ a function from $s$ to a commutative monoid. Then $\\sum_{x\\in s}f(x)=\\sum_{x\\in s, p(x)}f(x)+\\sum_{x\\in s, \\neg p(x)}f(x)$."}
{"name": "continuous.matrix_elem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/matrix.lean", "formal_statement": "theorem continuous.matrix_elem {X m n R : Type*} [topological_space X]\n\t[topological_space R] {A : X \u2192 matrix m n R} (hA : continuous A) (i : m)\n\t(j : n) :\n\tcontinuous (\u03bb (x : X), A x i j) :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A:X\\to M_{m\\times n}(\\mathbb{R})$ be a continuous function. Then the function $A_{ij}:X\\to\\mathbb{R}$ defined by $A_{ij}(x)=A(x)_{ij}$ is continuous."}
{"name": "ennreal.tsum_coe_ne_top_iff_summable_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.tsum_coe_ne_top_iff_summable_coe {\u03b1 : Type*} {f : \u03b1 \u2192 nnreal} :\n\t\u2211' (a : \u03b1), \u2191(f a) \u2260 \u22a4 \u2194 summable (\u03bb (a : \u03b1), \u2191(f a)) :=", "nl_statement_of_codex": "The series $\\sum_{a\\in A} f(a)$ converges if and only if $\\sum_{a\\in A} f(a)$ does not equal $\\infty$."}
{"name": "algebra.discr_power_basis_eq_prod''", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/discriminant.lean", "formal_statement": "theorem algebra.discr_power_basis_eq_prod'' (K : Type u) {L : Type v}\n\t(E : Type z) [field K] [field L] [field E] [algebra K L] [algebra K E]\n\t[module.finite K L] [is_alg_closed E] (pb : power_basis K L) [is_separable K L]\n\t(e : fin pb.dim \u2243 (L \u2192\u2090[K] E)) :\n\t\u21d1(algebra_map K E) (algebra.discr K \u21d1(pb.basis)) = (-1) ^ (finite_dimensional.finrank K L * (finite_dimensional.finrank K L - 1) / 2) * finset.univ.prod (\u03bb (i : fin pb.dim), (finset.Ioi i).prod (\u03bb (j : fin pb.dim), (\u21d1(\u21d1e j) pb.gen - \u21d1(\u21d1e i) pb.gen) * (\u21d1(\u21d1e i) pb.gen - \u21d1(\u21d1e j) pb.gen))) :=", "nl_statement_of_codex": "Let $K$ be a field, $L$ be a finite-dimensional $K$-algebra, $E$ be a field extension of $K$ which is algebraically closed, and $e:L\\to E$ be an isomorphism of $K$-algebras. Then the discriminant of $L$ is equal to the product of the differences of the images of the basis elements of $L$ under $e$."}
{"name": "pgame.quot_left_distrib", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/basic.lean", "formal_statement": "theorem pgame.quot_left_distrib (x y z : pgame) :\n\t\u27e6x * (y + z)\u27e7 = \u27e6x * y\u27e7 + \u27e6x * z\u27e7 :=", "nl_statement_of_codex": "The left distributive law holds in the quotient space of impartial games."}
{"name": "continuous_linear_map.restrict_scalars_isometry_to_linear_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem continuous_linear_map.restrict_scalars_isometry_to_linear_map\n\t{\ud835\udd5c E F\u2097 : Type*} [semi_normed_group E] [semi_normed_group F\u2097]\n\t[nondiscrete_normed_field \ud835\udd5c] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c F\u2097]\n\t{\ud835\udd5c' : Type*1} [nondiscrete_normed_field \ud835\udd5c'] [normed_algebra \ud835\udd5c' \ud835\udd5c]\n\t[normed_space \ud835\udd5c' E] [is_scalar_tower \ud835\udd5c' \ud835\udd5c E] [normed_space \ud835\udd5c' F\u2097]\n\t[is_scalar_tower \ud835\udd5c' \ud835\udd5c F\u2097] {\ud835\udd5c'' : Type*2} [ring \ud835\udd5c''] [module \ud835\udd5c'' F\u2097]\n\t[has_continuous_const_smul \ud835\udd5c'' F\u2097] [smul_comm_class \ud835\udd5c \ud835\udd5c'' F\u2097]\n\t[smul_comm_class \ud835\udd5c' \ud835\udd5c'' F\u2097] :\n\t(continuous_linear_map.restrict_scalars_isometry \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'').to_linear_map = continuous_linear_map.restrict_scalars\u2097 \ud835\udd5c E F\u2097 \ud835\udd5c' \ud835\udd5c'' :=", "nl_statement_of_codex": "Let $E$ and $F$ be semi-normed groups, let $\ud835\udd5c$ be a nondiscrete normed field, and let $\ud835\udd5c'$ be a nondiscrete normed field that is a normed algebra over $\ud835\udd5c$. Suppose that $E$ and $F$ are normed spaces over $\ud835\udd5c$ and $\ud835\udd5c'$, respectively, and that $\ud835\udd5c'$ is a scalar tower over $\ud835\udd5c$ for $E$ and $F$. Let $\ud835\udd5c''$ be a ring and a module over $\ud835\udd5c''$ such that $\ud835\udd5c''$ has a continuous scalar multiplication on $"}
{"name": "measure_theory.measure.sum_fintype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.measure.sum_fintype {\u03b1 \u03b9 : Type*}\n\t{m0 : measurable_space \u03b1} [fintype \u03b9] (\u03bc : \u03b9 \u2192 measure_theory.measure \u03b1) :\n\tmeasure_theory.measure.sum \u03bc = finset.univ.sum (\u03bb (i : \u03b9), \u03bc i) :=", "nl_statement_of_codex": "Let $\u03b1$ be a measurable space and let $\\{\u03bc_i\\}_{i\\in I}$ be a family of measures on $\u03b1$. Then $\\sum_{i\\in I}\u03bc_i=\\sum_{i\\in I}\u03bc_i(\u03b1)$."}
{"name": "inner_product_space.to_dual_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/dual.lean", "formal_statement": "theorem inner_product_space.to_dual_apply {\ud835\udd5c E : Type*} [is_R_or_C \ud835\udd5c]\n\t[inner_product_space \ud835\udd5c E] [complete_space E] {x y : E} :\n\t\u21d1(\u21d1(inner_product_space.to_dual \ud835\udd5c E) x) y = has_inner.inner x y :=", "nl_statement_of_codex": "Let $E$ be a complete inner product space over $\\mathbb{R}$ or $\\mathbb{C}$. Then the inner product on $E$ is the same as the inner product on the dual space of $E$."}
{"name": "covby_iff_wcovby_and_ne", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/cover.lean", "formal_statement": "theorem covby_iff_wcovby_and_ne {\u03b1 : Type*} [partial_order \u03b1] {a b : \u03b1} :\n\ta \u22d6 b \u2194 a \u2a7f b \u2227 a \u2260 b :=", "nl_statement_of_codex": "Let $a$ and $b$ be elements of a partially ordered set. Then $a$ covers $b$ if and only if $a$ weakly covers $b$ and $a\\neq b$."}
{"name": "category_theory.limits.cocone_morphism.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.limits.cocone_morphism.ext {J : Type u\u2081}\n\t{_inst_1 : category_theory.category J} {C : Type u\u2083}\n\t{_inst_3 : category_theory.category C} {F : J \u2964 C}\n\t{A B : category_theory.limits.cocone F}\n\t(x y : category_theory.limits.cocone_morphism A B) (h : x.hom = y.hom) :\n\tx = y :=", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor. Let $A$ and $B$ be cocones over $F$. Let $x,y:A\\to B$ be cocone morphisms. If $x$ and $y$ have the same underlying morphism, then $x=y$."}
{"name": "measure_theory.lintegral_bUnion\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.lintegral_bUnion\u2080 {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {t : set \u03b2} {s : \u03b2 \u2192 set \u03b1} (ht : t.countable)\n\t(hm : \u2200 (i : \u03b2), i \u2208 t \u2192 measure_theory.null_measurable_set (s i) \u03bc)\n\t(hd : t.pairwise (measure_theory.ae_disjoint \u03bc on s)) (f : \u03b1 \u2192 ennreal) :\n\t\u222b\u207b (a : \u03b1) in \u22c3 (i : \u03b2) (H : i \u2208 t), s i, f a \u2202\u03bc = \u2211' (i : \u21a5t), \u222b\u207b (a : \u03b1) in s \u2191i, f a \u2202\u03bc :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $t$ be a countable set and let $s:t\\to X$ be a function. Suppose that $s(i)$ is a null set for each $i\\in t$ and that $s(i)\\cap s(j)=\\emptyset$ for all $i\\neq j$. Then $\\int_{\\bigcup_{i\\in t}s(i)}f\\,d\\mu=\\sum_{i\\in t}\\int_{s(i)}f\\,d\\mu$."}
{"name": "linear_map.pi_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/pi.lean", "formal_statement": "theorem linear_map.pi_apply {R : Type u} {M\u2082 : Type w} {\u03b9 : Type x} [semiring R]\n\t[add_comm_monoid M\u2082] [module R M\u2082] {\u03c6 : \u03b9 \u2192 Type i}\n\t[\u03a0 (i : \u03b9), add_comm_monoid (\u03c6 i)] [\u03a0 (i : \u03b9), module R (\u03c6 i)]\n\t(f : \u03a0 (i : \u03b9), M\u2082 \u2192\u2097[R] \u03c6 i) ( : M\u2082) (i : \u03b9) :\n\t\u21d1(linear_map.pi f) c i = \u21d1(f i) c :=", "nl_statement_of_codex": "Let $R$ be a semiring, $M_2$ an $R$-module, and $\\phi$ a family of $R$-modules. Let $f:\\phi\\to M_2$ be a family of linear maps. Then the linear map $\\pi f:M_2\\to\\prod_{i\\in I}\\phi_i$ is given by $\\pi f(c)=(f_i(c))_{i\\in I}$."}
{"name": "polynomial.dickson_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/polynomial/dickson.lean", "formal_statement": "theorem polynomial.dickson_zero {R : Type*} [comm_ring R] (k : \u2115) (a : R) :\n\tpolynomial.dickson k a 0 = 3 - \u2191k :=", "nl_statement_of_codex": "The Dickson polynomial $D_k(a,0)$ is equal to $3-k$."}
{"name": "mul_char.inv_apply'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/number_theory/legendre_symbol/mul_character.lean", "formal_statement": "theorem mul_char.inv_apply' {R' : Type v} [comm_monoid_with_zero R']\n\t{R : Type u} [field R] (\u03c7 : mul_char R R') (a : R) :\n\t\u21d1\u03c7\u207b\u00b9 a = \u21d1\u03c7 a\u207b\u00b9 :=", "nl_statement_of_codex": "Let $R$ be a field and let $\\chi:R\\to R'$ be a multiplicative character. Then $\\chi^{-1}(a)=\\chi(a^{-1})$."}
{"name": "ring_hom.to_fun_eq_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/ring.lean", "formal_statement": "theorem ring_hom.to_fun_eq_coe {\u03b1 \u03b2 : Type*} {r\u03b1 : non_assoc_semiring \u03b1}\n\t{r\u03b2 : non_assoc_semiring \u03b2} (f : \u03b1 \u2192+* \u03b2) :\n\tf.to_fun = \u21d1f :=", "nl_statement_of_codex": "Let $f:R\\to S$ be a ring homomorphism. Then $f$ is equal to the function $f:R\\to S$ defined by $f(r)=f(r)$."}
{"name": "cont_diff_within_at.sqrt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/sqrt.lean", "formal_statement": "theorem cont_diff_within_at.sqrt {E : Type*} [normed_group E] [normed_space \u211d E]\n\t{f : E \u2192 \u211d} {n : with_top \u2115} {s : set E} {x : E}\n\t(hf : cont_diff_within_at \u211d n f s x) (hx : f x \u2260 0) :\n\tcont_diff_within_at \u211d n (\u03bb (y : E), real.sqrt (f y)) s x :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ and let $f:E\\to\\mathbb{R}$. If $f$ is $n$-times differentiable at $x\\in E$ and $f(x)\\neq 0$, then $\\sqrt{f}$ is $n$-times differentiable at $x$."}
{"name": "polynomial.X_pow_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.X_pow_mul {R : Type u} [semiring R] {p : polynomial R}\n\t{n : \u2115} :\n\tpolynomial.X ^ n * p = p * polynomial.X ^ n :=", "nl_statement_of_codex": "For any polynomial $p$ and any natural number $n$, $X^n\\cdot p=p\\cdot X^n$."}
{"name": "linear_map.is_adjoint_pair.mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/sesquilinear_form.lean", "formal_statement": "theorem linear_map.is_adjoint_pair.mul {R M : Type*} [comm_semiring R]\n\t[add_comm_monoid M] [module R M] {B : M \u2192\u2097[R] M \u2192\u2097[R] R}\n\t{f g f' g' : module.End R M} (h : B.is_adjoint_pair B f g)\n\t(h' : B.is_adjoint_pair B f' g') :\n\tB.is_adjoint_pair B (f * f') (g' * g) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, and $B:M\\times M\\to R$ a bilinear map. Let $f,g,f',g'$ be $R$-linear maps from $M$ to $M$. If $B$ is an adjoint pair for $f$ and $g$, and $B$ is an adjoint pair for $f'$ and $g'$, then $B$ is an adjoint pair for $f\\circ f'$ and $g'\\circ g$."}
{"name": "map_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/group.lean", "formal_statement": "theorem map_inv {G H F : Type*} [group G] [division_monoid H]\n\t[monoid_hom_class F G H] (f : F) (a : G) :\n\t\u21d1f a\u207b\u00b9 = (\u21d1f a)\u207b\u00b9 :=", "nl_statement_of_codex": "Let $G$ be a group, $H$ a division monoid, and $F$ a monoid homomorphism from $G$ to $H$. Then $f(a^{-1})=f(a)^{-1}$."}
{"name": "metric.uniform_continuous_inf_dist_Hausdorff_dist", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/closeds.lean", "formal_statement": "theorem metric.uniform_continuous_inf_dist_Hausdorff_dist {\u03b1 : Type u}\n\t[metric_space \u03b1] :\n\tuniform_continuous (\u03bb (p : \u03b1 \u00d7 topological_space.nonempty_compacts \u03b1), metric.inf_dist p.fst \u2191(p.snd)) :=", "nl_statement_of_codex": "The function $f:\\alpha\\times\\mathcal{K}(\\alpha)\\to\\mathbb{R}$ defined by $f(x,K)=\\inf_{y\\in K}d(x,y)$ is uniformly continuous."}
{"name": "homotopy.comp_left_id_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/homology/homotopy.lean", "formal_statement": "theorem homotopy.comp_left_id_hom {\u03b9 : Type*} {V : Type u}\n\t[category_theory.category V] [category_theory.preadditive V]\n\t{ : complex_shape \u03b9} {C D : homological_complex V c} {f : D \u27f6 D}\n\t(h : homotopy f (\ud835\udfd9 D)) (g : C \u27f6 D) (i j : \u03b9) :\n\t(h.comp_left_id g).hom i j = g.f i \u226b h.hom i j :=", "nl_statement_of_codex": "Let $V$ be a category with preadditive structure. Let $C$ and $D$ be homological complexes over $V$ and let $f:D\\to D$ be a homotopy between $f$ and the identity map on $D$. Then the homotopy between $f\\circ g$ and $g$ is given by $h\\circ g$."}
{"name": "valuation_subring.valuation_subring_valuation", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/valuation/valuation_subring.lean", "formal_statement": "theorem valuation_subring.valuation_subring_valuation {K : Type*} [field K]\n\t(A : valuation_subring K) :\n\tA.valuation.valuation_subring = A :=", "nl_statement_of_codex": "Let $K$ be a field and let $A$ be a valuation subring of $K$. Then $A$ is the valuation subring of the valuation on $K$ induced by $A$."}
{"name": "first_order.language.direct_limit.of_f", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/model_theory/direct_limit.lean", "formal_statement": "theorem first_order.language.direct_limit.of_f {L : first_order.language}\n\t{\u03b9 : Type v} [preorder \u03b9] {G : \u03b9 \u2192 Type w} [\u03a0 (i : \u03b9), L.Structure (G i)]\n\t{f : \u03a0 (i j : \u03b9), i \u2264 j \u2192 L.embedding (G i) (G j)} [is_directed \u03b9 has_le.le]\n\t[directed_system G (\u03bb (i j : \u03b9) (h : i \u2264 j), \u21d1(f i j h))] [nonempty \u03b9]\n\t{i j : \u03b9} {hij : i \u2264 j} {x : G i} :\n\t\u21d1(first_order.language.direct_limit.of L \u03b9 G f j) (\u21d1(f i j hij) x) = \u21d1(first_order.language.direct_limit.of L \u03b9 G f i) x :=", "nl_statement_of_codex": "Let $L$ be a first-order language, let $\\iota$ be a directed set, let $G$ be a functor from $\\iota$ to the category of $L$-structures, and let $f$ be a natural transformation from $G$ to itself. Then for any $i,j\\in\\iota$ with $i\\leq j$ and any $x\\in G(i)$, the image of $x$ under the map $f_{ij}$ is equal to the image of $x$ under the map $f_{ii}$."}
{"name": "category_theory.subobject.iso_of_mk_eq_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/subobject/basic.lean", "formal_statement": "theorem category_theory.subobject.iso_of_mk_eq_inv {C : Type u\u2081}\n\t[category_theory.category C] {B A : C} (f : A \u27f6 B) [category_theory.mono f]\n\t(X : category_theory.subobject B) (h : category_theory.subobject.mk f = X) :\n\t(category_theory.subobject.iso_of_mk_eq f X h).inv = X.of_le_mk f _ :=", "nl_statement_of_codex": "Let $C$ be a category, $A, B$ objects of $C$, and $f:A\\to B$ a monomorphism. Let $X$ be a subobject of $B$. If $f$ is equal to $X$, then the inverse of the isomorphism $f\\to X$ is equal to $X$."}
{"name": "measure_theory.Lp.mem_Lp_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/lp_space.lean", "formal_statement": "theorem measure_theory.Lp.mem_Lp_const {E : Type*} {p : ennreal}\n\t[normed_group E] (\u03b1 : Type*) {m : measurable_space \u03b1}\n\t(\u03bc : measure_theory.measure \u03b1) ( : E) [measure_theory.is_finite_measure \u03bc] :\n\tmeasure_theory.ae_eq_fun.const \u03b1 c \u2208 measure_theory.Lp E p \u03bc :=", "nl_statement_of_codex": "Let $E$ be a normed group, let $p$ be an extended nonnegative real number, let $\\alpha$ be a type, let $m$ be a measurable space, let $\\mu$ be a measure on $m$, and let $c$ be an element of $E$. If $\\mu$ is a finite measure, then the constant function $f:\\alpha\\to E$ defined by $f(x)=c$ for all $x\\in\\alpha$ is in $L^p(\\alpha,\\mu)$."}
{"name": "finpartition.extend_parts", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/partition/finpartition.lean", "formal_statement": "theorem finpartition.extend_parts {\u03b1 : Type*} [distrib_lattice \u03b1] [order_bot \u03b1]\n\t[decidable_eq \u03b1] {a b c : \u03b1} (P : finpartition a) (hb : b \u2260 \u22a5)\n\t(hab : disjoint a b) (hc : a \u2294 b = c) :\n\t(P.extend hb hab hc).parts = has_insert.insert b P.parts :=", "nl_statement_of_codex": "Let $P$ be a finite partition of $a$. Let $b$ be a non-zero element of $a$ such that $a$ and $b$ are disjoint. Let $c=a\\vee b$. Then the parts of the partition $P$ extended by $b$ are $b$ and the parts of $P$."}
{"name": "equiv.perm.is_three_cycle.order_of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/cycle/type.lean", "formal_statement": "theorem equiv.perm.is_three_cycle.order_of {\u03b1 : Type*} [fintype \u03b1]\n\t[decidable_eq \u03b1] {g : equiv.perm \u03b1} (ht : g.is_three_cycle) :\n\torder_of g = 3 :=", "nl_statement_of_codex": "Let $g$ be a permutation of a finite set $X$. If $g$ is a three-cycle, then the order of $g$ is $3$."}
{"name": "is_dedekind_domain_iff_is_dedekind_domain_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/dedekind_domain/ideal.lean", "formal_statement": "theorem is_dedekind_domain_iff_is_dedekind_domain_inv {A : Type*} [comm_ring A]\n\t[is_domain A] :\n\tis_dedekind_domain A \u2194 is_dedekind_domain_inv A :=", "nl_statement_of_codex": "A commutative ring $A$ is a Dedekind domain if and only if $A$ is a Dedekind domain with inverses."}
{"name": "prime_spectrum.zero_locus_singleton_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebraic_geometry/prime_spectrum/basic.lean", "formal_statement": "theorem prime_spectrum.zero_locus_singleton_zero {R : Type u} [comm_ring R] :\n\tprime_spectrum.zero_locus {0} = set.univ :=", "nl_statement_of_codex": "The zero locus of the ideal $(0)$ is the whole prime spectrum."}
{"name": "polynomial.taylor_zero'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/taylor.lean", "formal_statement": "theorem polynomial.taylor_zero' {R : Type*} [semiring R] :\n\tpolynomial.taylor 0 = linear_map.id :=", "nl_statement_of_codex": "The Taylor series of $0$ is the identity map."}
{"name": "witt_vector.recursion_base.solution_spec", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/witt_vector/frobenius_fraction_field.lean", "formal_statement": "theorem witt_vector.recursion_base.solution_spec (p : \u2115)\n\t[hp : fact (nat.prime p)] {k : Type*} [field k] [is_alg_closed k]\n\t(a\u2081 a\u2082 : witt_vector p k) :\n\twitt_vector.recursion_base.solution p a\u2081 a\u2082 ^ (p - 1) = a\u2082.coeff 0 / a\u2081.coeff 0 :=", "nl_statement_of_codex": "Let $p$ be a prime number and let $k$ be a field of characteristic $p$. Let $a_1, a_2$ be Witt vectors over $k$. Then $(a_2/a_1)^{p-1}=a_2/a_1$."}
{"name": "category_theory.non_preadditive_abelian.lift_map_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/abelian/non_preadditive.lean", "formal_statement": "theorem category_theory.non_preadditive_abelian.lift_map_assoc {C : Type u}\n\t[category_theory.category C] [category_theory.non_preadditive_abelian C]\n\t{X Y : C} (f : X \u27f6 Y) {X' : C} (f' : Y \u2a2f Y \u27f6 X') :\n\tcategory_theory.limits.prod.lift (\ud835\udfd9 X) 0 \u226b category_theory.limits.prod.map f f \u226b f' = f \u226b category_theory.limits.prod.lift (\ud835\udfd9 Y) 0 \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category with finite products and coproducts. Let $f:X\\to Y$ and $f':Y\\times Y\\to X'$ be morphisms in $C$. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\nX\\times X \\arrow[r, "}
{"name": "inv_mul_eq_one\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_with_zero/basic.lean", "formal_statement": "theorem inv_mul_eq_one\u2080 {G\u2080 : Type*} [group_with_zero G\u2080] {a b : G\u2080}\n\t(ha : a \u2260 0) :\n\ta\u207b\u00b9 * b = 1 \u2194 a = b :=", "nl_statement_of_codex": "Let $G$ be a group with zero. Let $a, b\\in G$. If $a\\neq 0$, then $a^{-1}b=1$ if and only if $a=b$."}
{"name": "pequiv.le_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/pequiv.lean", "formal_statement": "theorem pequiv.le_def {\u03b1 : Type u} {\u03b2 : Type v} {f g : \u03b1 \u2243. \u03b2} :\n\tf \u2264 g \u2194 \u2200 (a : \u03b1) (b : \u03b2), b \u2208 \u21d1f a \u2192 b \u2208 \u21d1g a :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be permutations. Then $f\\leq g$ if and only if $f(a)\\subset g(a)$ for all $a\\in\\alpha$."}
{"name": "finpartition.card_parts_equitabilise", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/regularity/equitabilise.lean", "formal_statement": "theorem finpartition.card_parts_equitabilise {\u03b1 : Type*} [decidable_eq \u03b1]\n\t{s : finset \u03b1} {m a b : \u2115} (P : finpartition s)\n\t(h : a * m + b * (m + 1) = s.card) (hm : m \u2260 0) :\n\t(P.equitabilise h).parts.card = a + b :=", "nl_statement_of_codex": "Let $P$ be a partition of a finite set $S$. If $a\\cdot m+b\\cdot(m+1)=|S|$ for some $m\\neq 0$, then the number of parts of $P$ is $a+b$."}
{"name": "nat.image_sub_const_Ico", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/interval.lean", "formal_statement": "theorem nat.image_sub_const_Ico {a b c : \u2115} (h : c \u2264 a) :\n\tfinset.image (\u03bb (x : \u2115), x - c) (finset.Ico a b) = finset.Ico (a - c) (b - c) :=", "nl_statement_of_codex": "Let $a,b,c$ be natural numbers with $c\\leq a$. Then the image of the interval $[a,b]$ under the map $x\\mapsto x-c$ is the interval $[a-c,b-c]$."}
{"name": "equiv.perm.card_support_swap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/perm/support.lean", "formal_statement": "theorem equiv.perm.card_support_swap {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1]\n\t{x y : \u03b1} (hxy : x \u2260 y) :\n\t(equiv.swap x y).support.card = 2 :=", "nl_statement_of_codex": "The support of the permutation $(x\\ y)$ has cardinality $2$."}
{"name": "category_theory.free_monoidal_category.mk_l_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/free/basic.lean", "formal_statement": "theorem category_theory.free_monoidal_category.mk_l_inv {C : Type u}\n\t{X : category_theory.free_monoidal_category C} :\n\t\u27e6category_theory.free_monoidal_category.hom.l_inv X\u27e7 = (\u03bb_ X).inv :=", "nl_statement_of_codex": "The inverse of the left unit of a free monoidal category is the left inverse."}
{"name": "set.Union_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Union_prod {\u03b9 \u03b9' \u03b1 \u03b2 : Type*} (s : \u03b9 \u2192 set \u03b1) (t : \u03b9' \u2192 set \u03b2) :\n\t(\u22c3 (x : \u03b9 \u00d7 \u03b9'), s x.fst \u00d7\u02e2 t x.snd) = (\u22c3 (i : \u03b9), s i) \u00d7\u02e2 \u22c3 (i : \u03b9'), t i :=", "nl_statement_of_codex": "Let $s$ and $t$ be families of sets. Then $\\bigcup_{(i,j)\\in I\\times J} s_i\\times t_j=\\bigcup_i s_i\\times\\bigcup_j t_j$."}
{"name": "bornology.cobounded_eq_bot_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/bornology/basic.lean", "formal_statement": "theorem bornology.cobounded_eq_bot_iff {\u03b1 : Type*} [bornology \u03b1] :\n\tbornology.cobounded \u03b1 = \u22a5 \u2194 bounded_space \u03b1 :=", "nl_statement_of_codex": "A bornology $\\mathcal{B}$ on a set $X$ is the trivial bornology if and only if $X$ is a bounded space."}
{"name": "real.dist_0_eq_abs", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem real.dist_0_eq_abs (x : \u211d) :\n\thas_dist.dist x 0 = |x| :=", "nl_statement_of_codex": "The distance from $x$ to $0$ is equal to the absolute value of $x$."}
{"name": "category_theory.functor.op_inv_obj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/opposites.lean", "formal_statement": "theorem category_theory.functor.op_inv_obj (C : Type u\u2081)\n\t[category_theory.category C] (D : Type u\u2082) [category_theory.category D]\n\t(F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) :\n\t(category_theory.functor.op_inv C D).obj F = opposite.op F.unop :=", "nl_statement_of_codex": "The functor $F:C^{op}\\to D^{op}$ is the same as the functor $F^{op}:C\\to D$."}
{"name": "equiv.map_matrix_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem equiv.map_matrix_apply {m n : Type*} {\u03b1 : Type v} {\u03b2 : Type w}\n\t(f : \u03b1 \u2243 \u03b2) (M : matrix m n \u03b1) :\n\t\u21d1(f.map_matrix) M = M.map \u21d1f :=", "nl_statement_of_codex": "Let $f:A\\to B$ be an equivalence. Then for any matrix $M$ with entries in $A$, the matrix $f(M)$ is equal to the matrix obtained by applying $f$ to each entry of $M$."}
{"name": "polynomial.rev_at_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/reverse.lean", "formal_statement": "theorem polynomial.rev_at_zero (N : \u2115) :\n\t\u21d1(polynomial.rev_at N) 0 = N :=", "nl_statement_of_codex": "The polynomial $p(x)=x^N$ evaluated at $0$ is $0$."}
{"name": "category_theory.quotient.comp_closure.of", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/quotient.lean", "formal_statement": "theorem category_theory.quotient.comp_closure.of {C : Type*}\n\t[category_theory.category C] (r : hom_rel C) {a b : C} (m\u2081 m\u2082 : a \u27f6 b)\n\t(h : r m\u2081 m\u2082) :\n\tcategory_theory.quotient.comp_closure r m\u2081 m\u2082 :=", "nl_statement_of_codex": "Let $C$ be a category and let $r$ be a hom-relation on $C$. Let $a,b$ be objects of $C$ and let $m_1,m_2:a\\to b$ be morphisms. If $r(m_1,m_2)$ holds, then $m_1$ and $m_2$ are composable."}
{"name": "bdd_above.neg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/bounds.lean", "formal_statement": "theorem bdd_above.neg {G : Type*} [add_group G] [preorder G]\n\t[covariant_class G G has_add.add has_le.le]\n\t[covariant_class G G (function.swap has_add.add) has_le.le] {s : set G}\n\t(h : bdd_above s) :\n\tbdd_below (-s) :=", "nl_statement_of_codex": "Let $G$ be an additive group and let $s\\subset G$. If $s$ is bounded above, then $-s$ is bounded below."}
{"name": "right_coset_equivalence_rel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/coset.lean", "formal_statement": "theorem right_coset_equivalence_rel {\u03b1 : Type*} [has_mul \u03b1] (s : set \u03b1) :\n\tequivalence (right_coset_equivalence s) :=", "nl_statement_of_codex": "The relation $a\\sim b$ if and only if $a=sb$ for some $s\\in S$ is an equivalence relation on $G$."}
{"name": "ennreal.order_iso_unit_interval_birational_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.order_iso_unit_interval_birational_apply_coe (x : ennreal) :\n\t\u2191(\u21d1ennreal.order_iso_unit_interval_birational x) = (x\u207b\u00b9 + 1)\u207b\u00b9.to_real :=", "nl_statement_of_codex": "Let $x$ be a non-negative real number. Then the real number $x^{-1}+1$ is the image of $x$ under the inverse of the bijection between the non-negative real numbers and the unit interval."}
{"name": "category_theory.grothendieck_topology.to_sheafify_comp_sheafify_comp_iso_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/compatible_sheafification.lean", "formal_statement": "theorem category_theory.grothendieck_topology.to_sheafify_comp_sheafify_comp_iso_inv\n\t{C : Type u} [category_theory.category C]\n\t(J : category_theory.grothendieck_topology C) {D : Type w\u2081}\n\t[category_theory.category D] {E : Type w\u2082} [category_theory.category E]\n\t(F : D \u2964 E)\n\t[\u2200 (\u03b1 \u03b2 : Type (max v u)) (fst snd : \u03b2 \u2192 \u03b1), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) D]\n\t[\u2200 (\u03b1 \u03b2 : Type (max v u)) (fst snd : \u03b2 \u2192 \u03b1), category_theory.limits.has_limits_of_shape (category_theory.limits.walking_multicospan fst snd) E]\n\t[\u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 D]\n\t[\u2200 (X : C), category_theory.limits.has_colimits_of_shape (J.cover X)\u1d52\u1d56 E]\n\t[\u03a0 (X : C), category_theory.limits.preserves_colimits_of_shape (J.cover X)\u1d52\u1d56 F]\n\t[\u03a0 (X : C) (W : J.cover X) (P : C\u1d52\u1d56 \u2964 D), category_theory.limits.preserves_limit (W.index P).multicospan F]\n\t(P : C\u1d52\u1d56 \u2964 D) :\n\tJ.to_sheafify (P \u22d9 F) \u226b (J.sheafify_comp_iso F P).inv = category_theory.whisker_right (J.to_sheafify P) F :=", "nl_statement_of_codex": "Let $C$ be a category, $J$ a Grothendieck topology on $C$, $D$ and $E$ categories, and $F:D\\to E$ a functor. Suppose that $F$ preserves limits of walking multicospans and colimits of covers. Then the following diagram commutes:\n\\begin{equation*}\n\\begin{tikzcd}\nJ\\text{-sheaves}(C) \\arrow[r, "}
{"name": "locally_constant.char_fn_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/locally_constant/algebra.lean", "formal_statement": "theorem locally_constant.char_fn_eq_zero {X : Type*} (Y : Type*)\n\t[topological_space X] [mul_zero_one_class Y] {U : set X} [nontrivial Y] (x : X)\n\t(hU : is_clopen U) :\n\t\u21d1(locally_constant.char_fn Y hU) x = 0 \u2194 x \u2209 U :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a nontrivial ring. Let $U$ be a clopen subset of $X$. Then the characteristic function of $U$ is zero at $x$ if and only if $x$ is not in $U$."}
{"name": "add_sub_add_left_eq_sub", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/basic.lean", "formal_statement": "theorem add_sub_add_left_eq_sub {G : Type*} [add_comm_group G] (a b c : G) :\n\tc + a - (c + b) = a - b :=", "nl_statement_of_codex": "Let $G$ be an abelian group. Then $c+a-(c+b)=a-b$."}
{"name": "set.image2_singleton_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.image2_singleton_left {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {t : set \u03b2}\n\t{a : \u03b1} :\n\tset.image2 f {a} t = f a '' t :=", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. Then $f(a,B)=f(a,\\cdot)''B$."}
{"name": "typevec.snd_diag", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/typevec.lean", "formal_statement": "theorem typevec.snd_diag {n : \u2115} {\u03b1 : typevec n} :\n\ttypevec.comp typevec.prod.snd typevec.prod.diag = typevec.id :=", "nl_statement_of_codex": "The second projection of the diagonal of a type vector is the identity."}
{"name": "add_comm_group.equiv_free_prod_direct_sum_zmod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/finite_abelian.lean", "formal_statement": "theorem add_comm_group.equiv_free_prod_direct_sum_zmod (G : Type*)\n\t[add_comm_group G] [hG : add_group.fg G] :\n\t\u2203 (n : \u2115) (\u03b9 : Type) [_inst_2 : fintype \u03b9] (p : \u03b9 \u2192 \u2115) [_inst_3 : \u2200 (i : \u03b9), nat.prime (p i)] (e : \u03b9 \u2192 \u2115), nonempty (G \u2243+ (fin n \u2192\u2080 \u2124) \u00d7 direct_sum \u03b9 (\u03bb (i : \u03b9), zmod (p i ^ e i))) :=", "nl_statement_of_codex": "Let $G$ be a finitely generated abelian group. Then there exist a natural number $n$, a finite set $\\iota$, a function $p:\\iota\\to\\mathbb{N}$ such that $p(i)$ is a prime for each $i\\in\\iota$, a function $e:\\iota\\to\\mathbb{N}$, and an isomorphism $G\\cong\\mathbb{Z}^n\\times\\bigoplus_{i\\in\\iota}\\mathbb{Z}_{p(i)^{e(i)}}$."}
{"name": "measure_theory.signed_measure.of_symm_diff_compl_positive_negative", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/decomposition/signed_hahn.lean", "formal_statement": "theorem measure_theory.signed_measure.of_symm_diff_compl_positive_negative\n\t{\u03b1 : Type*} [measurable_space \u03b1] {s : measure_theory.signed_measure \u03b1}\n\t{i j : set \u03b1} (hi : measurable_set i) (hj : measurable_set j)\n\t(hi' : 0.restrict i \u2264 measure_theory.vector_measure.restrict s i \u2227 measure_theory.vector_measure.restrict s i\u1d9c \u2264 0.restrict i\u1d9c)\n\t(hj' : 0.restrict j \u2264 measure_theory.vector_measure.restrict s j \u2227 measure_theory.vector_measure.restrict s j\u1d9c \u2264 0.restrict j\u1d9c) :\n\t\u21d1s (i \u2206 j) = 0 \u2227 \u21d1s (i\u1d9c \u2206 j\u1d9c) = 0 :=", "nl_statement_of_codex": "Let $s$ be a signed measure on a measurable space $X$. Let $i, j$ be measurable subsets of $X$. Suppose that $s$ is non-negative on $i$ and non-positive on $i^c$, and that $s$ is non-negative on $j$ and non-positive on $j^c$. Then $s$ is zero on $i\\Delta j$ and $s$ is zero on $(i^c)\\Delta (j^c)$."}
{"name": "symm_diff_symm_diff_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/symm_diff.lean", "formal_statement": "theorem symm_diff_symm_diff_right {\u03b1 : Type*} [generalized_boolean_algebra \u03b1]\n\t(a b c : \u03b1) :\n\ta \u2206 (b \u2206 c) = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) \u2294 c \\ (a \u2294 b) \u2294 a \u2293 b \u2293 c :=", "nl_statement_of_codex": "Let $A$ be a generalized boolean algebra. Then for all $a,b,c\\in A$, we have $a\\Delta(b\\Delta c)=(a\\setminus(b\\vee c))\\cup(b\\setminus(a\\vee c))\\cup(c\\setminus(a\\vee b))\\cup(a\\wedge b\\wedge c)$."}
{"name": "matrix.trace_fin_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/trace.lean", "formal_statement": "theorem matrix.trace_fin_two {R : Type*} [add_comm_monoid R]\n\t(A : matrix (fin 2) (fin 2) R) :\n\tA.trace = A 0 0 + A 1 1 :=", "nl_statement_of_codex": "The trace of a $2\\times 2$ matrix is the sum of its diagonal entries."}
{"name": "pgame.short_birthday", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/game/short.lean", "formal_statement": "theorem pgame.short_birthday (x : pgame) [x.short] :\n\tx.birthday < ordinal.omega :=", "nl_statement_of_codex": "If $x$ is a short game, then the birthday of $x$ is less than $\\omega$."}
{"name": "SemilatticeSup.coe_forget_to_PartialOrder", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/category/Semilattice.lean", "formal_statement": "theorem SemilatticeSup.coe_forget_to_PartialOrder (X : SemilatticeSup) :\n\t\u21a5((category_theory.forget\u2082 SemilatticeSup PartialOrder).obj X) = \u21a5X :=", "nl_statement_of_codex": "The forgetful functor from the category of semilattices to the category of partial orders is faithful."}
{"name": "asymptotics.is_O_one_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_one_iff {\u03b1 E : Type*} (F : Type*) [has_norm E]\n\t[has_norm F] {f : \u03b1 \u2192 E} {l : filter \u03b1} [has_one F] [norm_one_class F] :\n\t(f =O[l] \u03bb (x : \u03b1), 1) \u2194 filter.is_bounded_under has_le.le l (\u03bb (x : \u03b1), \u2225f x\u2225) :=", "nl_statement_of_codex": "Let $f:\\alpha\\to E$ be a function. Then $f$ is $O_l(1)$ if and only if $\\|f(x)\\|$ is bounded on $\\alpha$."}
{"name": "set.nsmul_subset_nsmul_of_zero_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/pointwise.lean", "formal_statement": "theorem set.nsmul_subset_nsmul_of_zero_mem {\u03b1 : Type*} [add_monoid \u03b1]\n\t{s : set \u03b1} {m n : \u2115} (hs : 0 \u2208 s) :\n\tm \u2264 n \u2192 m \u2022 s \u2286 n \u2022 s :=", "nl_statement_of_codex": "Let $s$ be a subset of an additive monoid $M$. If $0\\in s$, then $m\\cdot s\\subset n\\cdot s$ for all $m\\leq n$."}
{"name": "ae_measurable.const_vadd'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/arithmetic.lean", "formal_statement": "theorem ae_measurable.const_vadd' {M \u03b2 \u03b1 : Type*} [measurable_space M]\n\t[measurable_space \u03b2] [has_vadd M \u03b2] {m : measurable_space \u03b1} {g : \u03b1 \u2192 \u03b2}\n\t[has_measurable_vadd M \u03b2] {\u03bc : measure_theory.measure \u03b1}\n\t(hg : ae_measurable g \u03bc) ( : M) :\n\tae_measurable (\u03bb (x : \u03b1), c +\u1d65 g x) \u03bc :=", "nl_statement_of_codex": "Let $M$ be a measurable space, let $\u03b2$ be a measurable space, and let $\u03b1$ be a measurable space. Let $g:\u03b1\\to \u03b2$ be a measurable function. Then the function $x\\mapsto c+g(x)$ is measurable."}
{"name": "cau_seq.lim_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/cau_seq_completion.lean", "formal_statement": "theorem cau_seq.lim_lt {\u03b1 : Type*} [linear_ordered_field \u03b1]\n\t[cau_seq.is_complete \u03b1 has_abs.abs] {f : cau_seq \u03b1 has_abs.abs} {x : \u03b1}\n\t(h : f < cau_seq.const has_abs.abs x) :\n\tf.lim < x :=", "nl_statement_of_codex": "Let $f$ be a Cauchy sequence in $\\mathbb{R}$. If $f$ is less than the constant sequence $x$, then the limit of $f$ is less than $x$."}
{"name": "measure_theory.simple_func.range_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/lebesgue.lean", "formal_statement": "theorem measure_theory.simple_func.range_one {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[nonempty \u03b1] [has_one \u03b2] :\n\t1.range = {1} :=", "nl_statement_of_codex": "The range of the constant function $1:\\alpha\\to\\beta$ is $\\{1\\}$."}
{"name": "measure_theory.measure.pi_Ioo_ae_eq_pi_Ioc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/pi.lean", "formal_statement": "theorem measure_theory.measure.pi_Ioo_ae_eq_pi_Ioc {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9]\n\t[\u03a0 (i : \u03b9), measurable_space (\u03b1 i)]\n\t{\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)}\n\t[\u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)] [\u03a0 (i : \u03b9), partial_order (\u03b1 i)]\n\t[\u2200 (i : \u03b9), measure_theory.has_no_atoms (\u03bc i)] {s : set \u03b9}\n\t{f g : \u03a0 (i : \u03b9), \u03b1 i} :\n\ts.pi (\u03bb (i : \u03b9), set.Ioo (f i) (g i)) =\u1d50[measure_theory.measure.pi \u03bc] s.pi (\u03bb (i : \u03b9), set.Ioc (f i) (g i)) :=", "nl_statement_of_codex": "Let $\\{X_i\\}_{i\\in I}$ be a family of measurable spaces and let $\\{m_i\\}_{i\\in I}$ be a family of sigma-finite measures on $\\{X_i\\}_{i\\in I}$. Let $f,g:I\\to\\bigcup_{i\\in I}X_i$ be two functions such that $f(i)\\leq g(i)$ for all $i\\in I$. Then the set $\\{i\\in I:f(i)<g(i)\\}$ is measurable and has measure zero."}
{"name": "set.Inter_subset_of_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/lattice.lean", "formal_statement": "theorem set.Inter_subset_of_subset {\u03b1 : Type*} {\u03b9 : Sort u_4} {s : \u03b9 \u2192 set \u03b1}\n\t{t : set \u03b1} (i : \u03b9) (h : s i \u2286 t) :\n\t(\u22c2 (i : \u03b9), s i) \u2286 t :=", "nl_statement_of_codex": "Let $s_i$ be a family of sets. Then $\\bigcap_{i\\in I}s_i\\subset t$ if $s_i\\subset t$ for all $i\\in I$."}
{"name": "submodule.map_inf_comap_of_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/basic.lean", "formal_statement": "theorem submodule.map_inf_comap_of_surjective {R R\u2082 M M\u2082 : Type*2} [semiring R]\n\t[semiring R\u2082] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M]\n\t[module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n\t(hf : function.surjective \u21d1f) [ring_hom_surjective \u03c3\u2081\u2082] (p q : submodule R\u2082 M\u2082) :\n\tsubmodule.map f (submodule.comap f p \u2293 submodule.comap f q) = p \u2293 q :=", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $M$ and $M'$ be $R$-modules and $R'$-modules, respectively, and let $f:M\\to M'$ be a surjective $R$-module homomorphism. Then $f(p\\cap q)=f(p)\\cap f(q)$ for all submodules $p$ and $q$ of $M'$."}
{"name": "finset.Icc_subset_Ioo_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/locally_finite.lean", "formal_statement": "theorem finset.Icc_subset_Ioo_iff {\u03b1 : Type*} [preorder \u03b1]\n\t[locally_finite_order \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} (h\u2081 : a\u2081 \u2264 b\u2081) :\n\tfinset.Icc a\u2081 b\u2081 \u2286 finset.Ioo a\u2082 b\u2082 \u2194 a\u2082 < a\u2081 \u2227 b\u2081 < b\u2082 :=", "nl_statement_of_codex": "Let $a_1\\leq b_1$ be elements of a preorder $P$. Then $[a_1,b_1]\\subset (a_2,b_2)$ if and only if $a_2<a_1$ and $b_1<b_2$."}
{"name": "finset.sum_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_image {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} {f : \u03b1 \u2192 \u03b2}\n\t[add_comm_monoid \u03b2] [decidable_eq \u03b1] {s : finset \u03b3} {g : \u03b3 \u2192 \u03b1} :\n\t(\u2200 (x : \u03b3), x \u2208 s \u2192 \u2200 (y : \u03b3), y \u2208 s \u2192 g x = g y \u2192 x = y) \u2192 (finset.image g s).sum (\u03bb (x : \u03b1), f x) = s.sum (\u03bb (x : \u03b3), f (g x)) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $g:C\\to A$ be a function. Let $S$ be a finite set. If $g$ is injective, then $\\sum_{x\\in S}f(g(x))=\\sum_{x\\in g(S)}f(x)$."}
{"name": "language.le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/language.lean", "formal_statement": "theorem language.le_iff {\u03b1 : Type*} (l m : language \u03b1) :\n\tl \u2264 m \u2194 l + m = m :=", "nl_statement_of_codex": "Let $L$ and $M$ be languages. Then $L\\subseteq M$ if and only if $L\\cup M=M$."}
{"name": "category_theory.eq_functor_obj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monad/types.lean", "formal_statement": "theorem category_theory.eq_functor_obj (m : Type u \u2192 Type u) [monad m]\n\t[is_lawful_monad m] (X : category_theory.Kleisli m) :\n\t(category_theory.eq m).functor.obj X = X :=", "nl_statement_of_codex": "The functor $X\\mapsto X$ is the identity functor on the Kleisli category of a monad."}
{"name": "normed_space.eq_zero_of_forall_dual_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/dual.lean", "formal_statement": "theorem normed_space.eq_zero_of_forall_dual_eq_zero (\ud835\udd5c : Type v) [is_R_or_C \ud835\udd5c]\n\t{E : Type u} [normed_group E] [normed_space \ud835\udd5c E] {x : E}\n\t(h : \u2200 (f : normed_space.dual \ud835\udd5c E), \u21d1f x = 0) :\n\tx = 0 :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $x\\in E$. If $f(x)=0$ for all $f\\in E^*$, then $x=0$."}
{"name": "set.finite.supr_binfi_of_monotone", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/finite.lean", "formal_statement": "theorem set.finite.supr_binfi_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [preorder \u03b9']\n\t[nonempty \u03b9'] [is_directed \u03b9' has_le.le] [order.frame \u03b1] {s : set \u03b9}\n\t(hs : s.finite) {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} (hf : \u2200 (i : \u03b9), i \u2208 s \u2192 monotone (f i)) :\n\t(\u2a06 (j : \u03b9'), \u2a05 (i : \u03b9) (H : i \u2208 s), f i j) = \u2a05 (i : \u03b9) (H : i \u2208 s), \u2a06 (j : \u03b9'), f i j :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\times\\mathbb{N}\\to\\mathbb{R}$ be a function such that $f(i,\\cdot)$ is monotone for each $i\\in s$. Then $\\sup_{j\\in\\mathbb{N}}\\inf_{i\\in s}f(i,j)=\\inf_{i\\in s}\\sup_{j\\in\\mathbb{N}}f(i,j)$."}
{"name": "alg_hom.map_adjoin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/adjoin/basic.lean", "formal_statement": "theorem alg_hom.map_adjoin {R : Type u} {A : Type v} {B : Type w}\n\t[comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B]\n\t(\u03c6 : A \u2192\u2090[R] B) (s : set A) :\n\t(algebra.adjoin R s).map \u03c6 = algebra.adjoin R (\u21d1\u03c6 '' s) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be $R$-algebras, and $\\phi:A\\to B$ be an $R$-algebra homomorphism. Then $\\phi$ induces an $R$-algebra homomorphism $\\phi:A[S]\\to B[\\phi(S)]$."}
{"name": "polynomial.coeff_one_reverse", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/reverse.lean", "formal_statement": "theorem polynomial.coeff_one_reverse {R : Type*} [semiring R] (f : polynomial R) :\n\tf.reverse.coeff 1 = f.next_coeff :=", "nl_statement_of_codex": "Let $f$ be a polynomial over a semiring $R$. Then the coefficient of $x^1$ in $f$ is equal to the next coefficient of $f$."}
{"name": "nat.dvd_of_mod_eq_zero", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/lemmas.lean", "formal_statement": "theorem nat.dvd_of_mod_eq_zero {m n : \u2115} (H : n % m = 0) :\n\tm \u2223 n :=", "nl_statement_of_codex": "If $n\\equiv 0\\pmod{m}$, then $m\\mid n$."}
{"name": "qpf.liftr_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/qpf/univariate/basic.lean", "formal_statement": "theorem qpf.liftr_iff {F : Type u \u2192 Type u} [functor F] [q : qpf F] {\u03b1 : Type u}\n\t(r : \u03b1 \u2192 \u03b1 \u2192 Prop) (x y : F \u03b1) :\n\tfunctor.liftr r x y \u2194 \u2203 (a : (qpf.P F).A) (f\u2080 f\u2081 : (qpf.P F).B a \u2192 \u03b1), x = qpf.abs \u27e8a, f\u2080\u27e9 \u2227 y = qpf.abs \u27e8a, f\u2081\u27e9 \u2227 \u2200 (i : (qpf.P F).B a), r (f\u2080 i) (f\u2081 i) :=", "nl_statement_of_codex": "Let $F$ be a functor and $q$ a quotient preorder functor on $F$. Let $r$ be a relation on $F$ and $x, y$ elements of $F$. Then $x$ and $y$ are related by $r$ if and only if there are $a\\in A$, $f_0, f_1:B(a)\\to F$ such that $x=\\overline{(a,f_0)}$ and $y=\\overline{(a,f_1)}$ and $f_0(i)=f_1(i)$ for all $i\\in B(a)$."}
{"name": "measure_theory.outer_measure.smul_supr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.smul_supr {\u03b1 R : Type*}\n\t[has_smul R ennreal] [is_scalar_tower R ennreal ennreal] {\u03b9 : Sort u_2}\n\t(f : \u03b9 \u2192 measure_theory.outer_measure \u03b1) ( : R) :\n\t(c \u2022 \u2a06 (i : \u03b9), f i) = \u2a06 (i : \u03b9), c \u2022 f i :=", "nl_statement_of_codex": "Let $R$ be a ring and let $f_i:\\mathcal{P}(X)\\to R$ be a family of outer measures on $X$. Then $(c\\cdot\\sup_i f_i)(A)=c\\cdot(\\sup_i f_i)(A)$ for all $A\\subset X$."}
{"name": "set.ite_inter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.ite_inter {\u03b1 : Type u} (t s\u2081 s\u2082 s : set \u03b1) :\n\tt.ite (s\u2081 \u2229 s) (s\u2082 \u2229 s) = t.ite s\u2081 s\u2082 \u2229 s :=", "nl_statement_of_codex": "Let $t, s_1, s_2, s$ be sets. Then $t\\cdot (s_1\\cap s)=(t\\cdot s_1)\\cap s$."}
{"name": "Cauchy.nonempty_Cauchy_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/completion.lean", "formal_statement": "theorem Cauchy.nonempty_Cauchy_iff {\u03b1 : Type u} [uniform_space \u03b1] :\n\tnonempty (Cauchy \u03b1) \u2194 nonempty \u03b1 :=", "nl_statement_of_codex": "A uniform space is nonempty if and only if it has a Cauchy sequence."}
{"name": "continuous_map.homotopy_rel.cast_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homotopy/basic.lean", "formal_statement": "theorem continuous_map.homotopy_rel.cast_apply {X : Type u} {Y : Type v}\n\t[topological_space X] [topological_space Y] {S : set X} {f\u2080 f\u2081 g\u2080 g\u2081 : C(X, Y)}\n\t(F : f\u2080.homotopy_rel f\u2081 S) (h\u2080 : f\u2080 = g\u2080) (h\u2081 : f\u2081 = g\u2081)\n\t(\u1fb0 : \u21a5unit_interval \u00d7 X) :\n\t\u21d1(F.cast h\u2080 h\u2081) \u1fb0 = \u21d1F \u1fb0 :=", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces, let $S$ be a subset of $X$, and let $f_0, f_1, g_0, g_1:X\\to Y$. If $f_0$ is homotopic to $f_1$ relative to $S$, and $f_0=g_0$ and $f_1=g_1$, then $g_0$ is homotopic to $g_1$ relative to $S$."}
{"name": "subrel_val", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/rel_iso.lean", "formal_statement": "theorem subrel_val {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (p : set \u03b1) {a b : \u21a5p} :\n\tsubrel r p a b \u2194 r a.val b.val :=", "nl_statement_of_codex": "Let $r$ be a relation on a set $X$ and let $p$ be a subset of $X$. Then $a\\mathrel{r}b$ if and only if $a\\mathrel{r}b$."}
{"name": "linear_map.mk_continuous\u2082_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/operator_norm.lean", "formal_statement": "theorem linear_map.mk_continuous\u2082_apply {\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 E F G : Type*}\n\t[semi_normed_group E] [semi_normed_group F] [semi_normed_group G]\n\t[nondiscrete_normed_field \ud835\udd5c] [nondiscrete_normed_field \ud835\udd5c\u2082]\n\t[nondiscrete_normed_field \ud835\udd5c\u2083] [normed_space \ud835\udd5c E] [normed_space \ud835\udd5c\u2082 F]\n\t[normed_space \ud835\udd5c\u2083 G] {\u03c3\u2082\u2083 : \ud835\udd5c\u2082 \u2192+* \ud835\udd5c\u2083} {\u03c3\u2081\u2083 : \ud835\udd5c \u2192+* \ud835\udd5c\u2083} [ring_hom_isometric \u03c3\u2082\u2083]\n\t(f : E \u2192\u209b\u2097[\u03c3\u2081\u2083] F \u2192\u209b\u2097[\u03c3\u2082\u2083] G) {C : \u211d}\n\t(hC : \u2200 (x : E) (y : F), \u2225\u21d1(\u21d1f x) y\u2225 \u2264 C * \u2225x\u2225 * \u2225y\u2225) (x : E) (y : F) :\n\t\u21d1(\u21d1(f.mk_continuous\u2082 C hC) x) y = \u21d1(\u21d1f x) y :=", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over fields $K, L, M$ respectively. Let $f:E\\times F\\to G$ be a bilinear map. Then the map $f$ is continuous if and only if the map $f':E\\to L(F,G)$ is continuous."}
{"name": "polynomial.ne_zero_of_trailing_degree_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/degree/trailing_degree.lean", "formal_statement": "theorem polynomial.ne_zero_of_trailing_degree_lt {R : Type u} [semiring R]\n\t{p : polynomial R} {n : with_top \u2115} (h : p.trailing_degree < n) :\n\tp \u2260 0 :=", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$. If the trailing degree of $p$ is less than $n$, then $p$ is nonzero."}
{"name": "bounded_order_hom.symm_dual_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/bounded.lean", "formal_statement": "theorem bounded_order_hom.symm_dual_comp {\u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b1]\n\t[bounded_order \u03b1] [preorder \u03b2] [bounded_order \u03b2] [preorder \u03b3] [bounded_order \u03b3]\n\t(g : bounded_order_hom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : bounded_order_hom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n\t\u21d1(bounded_order_hom.dual.symm) (g.comp f) = (\u21d1(bounded_order_hom.dual.symm) g).comp (\u21d1(bounded_order_hom.dual.symm) f) :=", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be bounded order homomorphisms. Then the dual of the composition of $g$ and $f$ is the composition of the dual of $g$ and the dual of $f$."}
{"name": "mv_polynomial.zero_locus_vanishing_ideal_galois_connection", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/nullstellensatz.lean", "formal_statement": "theorem mv_polynomial.zero_locus_vanishing_ideal_galois_connection {k : Type*}\n\t[field k] {\u03c3 : Type*} :\n\tgalois_connection mv_polynomial.zero_locus mv_polynomial.vanishing_ideal :=", "nl_statement_of_codex": "The zero locus and the vanishing ideal of a multivariate polynomial form a Galois connection."}
{"name": "lists'.subset_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/lists.lean", "formal_statement": "theorem lists'.subset_nil {\u03b1 : Type*} {l : lists' \u03b1 bool.tt} :\n\tl \u2286 lists'.nil \u2192 l = lists'.nil :=", "nl_statement_of_codex": "If $l$ is a subset of the empty list, then $l$ is the empty list."}
{"name": "list.sublist_iff_exists_order_embedding_nth_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/nodup_equiv_fin.lean", "formal_statement": "theorem list.sublist_iff_exists_order_embedding_nth_eq {\u03b1 : Type*}\n\t{l l' : list \u03b1} :\n\tl <+ l' \u2194 \u2203 (f : \u2115 \u21aao \u2115), \u2200 (ix : \u2115), l.nth ix = l'.nth (\u21d1f ix) :=", "nl_statement_of_codex": "A list $l$ is a sublist of a list $l'$ if and only if there is an order embedding $f:\\mathbb{N}\\to\\mathbb{N}$ such that $l_i=l'_{f(i)}$ for all $i\\in\\mathbb{N}$."}
{"name": "add_commute.zsmul_zsmul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/basic.lean", "formal_statement": "theorem add_commute.zsmul_zsmul {G : Type w} [add_group G] {a b : G}\n\t(h : add_commute a b) (m n : \u2124) :\n\tadd_commute (m \u2022 a) (n \u2022 b) :=", "nl_statement_of_codex": "Let $G$ be an additive group. If $a,b\\in G$ commute, then $m\\cdot a$ and $n\\cdot b$ commute for all $m,n\\in\\mathbb{Z}$."}
{"name": "measure_theory.bounded_by_measure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.bounded_by_measure {\u03b1 : Type*} [ms : measurable_space \u03b1]\n\t(\u03bc : measure_theory.measure \u03b1) :\n\tmeasure_theory.outer_measure.bounded_by \u21d1\u03bc = \u03bc.to_outer_measure :=", "nl_statement_of_codex": "The outer measure of a set $A$ is bounded by the measure of $A$."}
{"name": "nat.floor_div_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/floor.lean", "formal_statement": "theorem nat.floor_div_nat {\u03b1 : Type*} [linear_ordered_semifield \u03b1]\n\t[floor_semiring \u03b1] (a : \u03b1) (n : \u2115) :\n\t\u230aa / \u2191n\u230b\u208a = \u230aa\u230b\u208a / n :=", "nl_statement_of_codex": "Let $a$ be a real number and $n$ a natural number. Then $\\lfloor a/n\\rfloor=\\lfloor a\\rfloor/n$."}
{"name": "cardinal.aleph_0_le_lift", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.aleph_0_le_lift { : cardinal} :\n\tcardinal.aleph_0 \u2264 c.lift \u2194 cardinal.aleph_0 \u2264 c :=", "nl_statement_of_codex": "$\\aleph_0\\leq c^+$ if and only if $\\aleph_0\\leq c$."}
{"name": "fractional_ideal.map_mem_map", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/fractional_ideal.lean", "formal_statement": "theorem fractional_ideal.map_mem_map {R : Type*} [comm_ring R] {S : submonoid R}\n\t{P : Type*} [comm_ring P] [algebra R P] {P' : Type*} [comm_ring P']\n\t[algebra R P'] {f : P \u2192\u2090[R] P'} (h : function.injective \u21d1f) {x : P}\n\t{I : fractional_ideal S P} :\n\t\u21d1f x \u2208 fractional_ideal.map f I \u2194 x \u2208 I :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a submonoid of $R$, $P$ a commutative $R$-algebra, $P'$ a commutative $R$-algebra, and $f:P\\to P'$ an injective $R$-algebra homomorphism. Then $f(I)$ is a fractional ideal of $P'$ for each fractional ideal $I$ of $P$."}
{"name": "list.length_tails", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.length_tails {\u03b1 : Type*} (l : list \u03b1) :\n\tl.tails.length = l.length + 1 :=", "nl_statement_of_codex": "The length of the list of tails of a list $l$ is one more than the length of $l$."}
{"name": "measure_theory.outer_measure.coe_fn_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/outer_measure.lean", "formal_statement": "theorem measure_theory.outer_measure.coe_fn_injective {\u03b1 : Type*} :\n\tfunction.injective (\u03bb (\u03bc : measure_theory.outer_measure \u03b1) (s : set \u03b1), \u21d1\u03bc s) :=", "nl_statement_of_codex": "The function that maps an outer measure $\\mu$ to the function $s\\mapsto \\mu(s)$ is injective."}
{"name": "encodable.axiom_of_choice", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/encodable/basic.lean", "formal_statement": "theorem encodable.axiom_of_choice {\u03b1 \u03b2 : \u03b1 \u2192 Type*} {R : \u03a0 (x : \u03b1), \u03b2 x \u2192 Prop}\n\t[\u03a0 (a : \u03b1), encodable (\u03b2 a)] [\u03a0 (x : \u03b1) (y : \u03b2 x), decidable (R x y)]\n\t(H : \u2200 (x : \u03b1), \u2203 (y : \u03b2 x), R x y) :\n\t\u2203 (f : \u03a0 (a : \u03b1), \u03b2 a), \u2200 (x : \u03b1), R x (f x) :=", "nl_statement_of_codex": "Let $R$ be a relation on a family of sets $\\{B_i\\}_{i\\in I}$. If each $B_i$ is countable and $R$ is decidable, then there is a function $f:I\\to\\bigcup_{i\\in I}B_i$ such that $R(i,f(i))$ for all $i\\in I$."}
{"name": "cardinal.sum_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.sum_const (\u03b9 : Type u) (a : cardinal) :\n\tcardinal.sum (\u03bb (i : \u03b9), a) = (cardinal.mk \u03b9).lift * a.lift :=", "nl_statement_of_codex": "The cardinality of the disjoint union of $a$ copies of a set $X$ is $|X|\\cdot a$."}
{"name": "tendsto_norm_sub_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/basic.lean", "formal_statement": "theorem tendsto_norm_sub_self {E : Type*} [semi_normed_group E] (x : E) :\n\tfilter.tendsto (\u03bb (g : E), \u2225g - x\u2225) (nhds x) (nhds 0) :=", "nl_statement_of_codex": "The function $g\\mapsto \\|g-x\\|$ tends to $0$ as $g$ tends to $x$."}
{"name": "differentiable_pow", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem differentiable_pow {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] (n : \u2115) :\n\tdifferentiable \ud835\udd5c (\u03bb (x : \ud835\udd5c), x ^ n) :=", "nl_statement_of_codex": "The function $x\\mapsto x^n$ is differentiable for all $n\\in\\mathbb{N}$."}
{"name": "measure_theory.outer_measure.mk_metric'.trim_pre", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/hausdorff.lean", "formal_statement": "theorem measure_theory.outer_measure.mk_metric'.trim_pre {X : Type*}\n\t[emetric_space X] [measurable_space X] [opens_measurable_space X]\n\t(m : set X \u2192 ennreal) (hcl : \u2200 (s : set X), m (closure s) = m s) (r : ennreal) :\n\t(measure_theory.outer_measure.mk_metric'.pre m r).trim = measure_theory.outer_measure.mk_metric'.pre m r :=", "nl_statement_of_codex": "Let $X$ be a metric space and let $m$ be an outer measure on $X$. Then for any $r\\in\\mathbb{R}^+$, the set of $m$-measurable sets of outer measure at most $r$ is equal to the set of $m$-measurable sets of outer measure at most $r$ whose closure has outer measure at most $r$."}
{"name": "onote.fast_growing_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/notation.lean", "formal_statement": "theorem onote.fast_growing_limit (o : onote) {f : \u2115 \u2192 onote}\n\t(h : o.fundamental_sequence = sum.inr f) :\n\to.fast_growing = \u03bb (i : \u2115), (f i).fast_growing i :=", "nl_statement_of_codex": "Let $o$ be an ordinal notation. If $o$ is a fundamental sequence, then $o$ is fast growing if and only if $o$ is fast growing."}
{"name": "filter.tendsto_at_bot_add_nonpos_left'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/at_top_bot.lean", "formal_statement": "theorem filter.tendsto_at_bot_add_nonpos_left' {\u03b1 \u03b2 : Type*}\n\t[ordered_add_comm_monoid \u03b2] {l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2}\n\t(hf : \u2200\u1da0 (x : \u03b1) in l, f x \u2264 0) (hg : filter.tendsto g l filter.at_bot) :\n\tfilter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_bot :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions where $\\beta$ is an ordered commutative monoid. If $f$ is eventually non-positive and $g$ tends to $-\\infty$, then $f+g$ tends to $-\\infty$."}
{"name": "list.concat_ne_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.concat_ne_nil {\u03b1 : Type u} (a : \u03b1) (l : list \u03b1) :\n\tl.concat a \u2260 list.nil :=", "nl_statement_of_codex": "The concatenation of a list $l$ and an element $a$ is not the empty list."}
{"name": "ideal.exists_sub_one_mem_and_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/ideal/quotient.lean", "formal_statement": "theorem ideal.exists_sub_one_mem_and_mem {R : Type u} [comm_ring R] {\u03b9 : Type v}\n\t(s : finset \u03b9) {f : \u03b9 \u2192 ideal R}\n\t(hf : \u2200 (i : \u03b9), i \u2208 s \u2192 \u2200 (j : \u03b9), j \u2208 s \u2192 i \u2260 j \u2192 f i \u2294 f j = \u22a4) (i : \u03b9)\n\t(his : i \u2208 s) :\n\t\u2203 (r : R), r - 1 \u2208 f i \u2227 \u2200 (j : \u03b9), j \u2208 s \u2192 j \u2260 i \u2192 r \u2208 f j :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $s$ be a finite set. Let $f:s\\to \\mathrm{Idl}(R)$ be a function such that for all $i,j\\in s$ with $i\\neq j$, $f(i)\\cup f(j)=R$. Then there exists $r\\in R$ such that $r-1\\in f(i)$ and $r\\in f(j)$ for all $j\\in s$ with $j\\neq i$."}
{"name": "ennreal.tendsto_of_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.tendsto_of_real {\u03b1 : Type*} {f : filter \u03b1} {m : \u03b1 \u2192 \u211d} {a : \u211d}\n\t(h : filter.tendsto m f (nhds a)) :\n\tfilter.tendsto (\u03bb (a : \u03b1), ennreal.of_real (m a)) f (nhds (ennreal.of_real a)) :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$ and let $m:X\\to\\mathbb{R}$. If $m$ converges to $a\\in\\mathbb{R}$ with respect to $f$, then $m$ converges to $a$ with respect to $f$."}
{"name": "ennreal.ae_eq_zero_of_lintegral_rpow_eq_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/mean_inequalities.lean", "formal_statement": "theorem ennreal.ae_eq_zero_of_lintegral_rpow_eq_zero {\u03b1 : Type*}\n\t[measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {p : \u211d} (hp0 : 0 \u2264 p)\n\t{f : \u03b1 \u2192 ennreal} (hf : ae_measurable f \u03bc)\n\t(hf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0) :\n\tf =\u1d50[\u03bc] 0 :=", "nl_statement_of_codex": "Let $f$ be a measurable function from a measure space $(X,\\mathcal{A},\\mu)$ to $\\overline{\\mathbb{R}}$. If $f$ is $p$-integrable for some $p\\geq 0$ and $\\int_X f^p\\,d\\mu=0$, then $f=0$ almost everywhere."}
{"name": "derive_fintype.finset_above.mem_union_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/derive_fintype.lean", "formal_statement": "theorem derive_fintype.finset_above.mem_union_left {\u03b1 : Type*} {enum : \u03b1 \u2192 \u2115}\n\t{n : \u2115} {s : derive_fintype.finset_in (\u03bb (a : \u03b1), enum a = n)}\n\t{t : derive_fintype.finset_above \u03b1 enum (n + 1)} {a : \u03b1} (H : a \u2208 s.val) :\n\ta \u2208 (derive_fintype.finset_above.union n s t).val :=", "nl_statement_of_codex": "Let $A$ be a set and let $f:A\\to\\mathbb{N}$ be a function. Let $n\\in\\mathbb{N}$ and let $s$ be a finite subset of $A$ such that $f(a)=n$ for all $a\\in s$. Let $t$ be a finite subset of $A$ such that $f(a)\\geq n+1$ for all $a\\in t$. Then $s\\cup t$ is a finite subset of $A$."}
{"name": "ennreal.supr_add_supr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ennreal.lean", "formal_statement": "theorem ennreal.supr_add_supr {\u03b9 : Sort u_1} {f g : \u03b9 \u2192 ennreal}\n\t(h : \u2200 (i j : \u03b9), \u2203 (k : \u03b9), f i + g j \u2264 f k + g k) :\n\tsupr f + supr g = \u2a06 (a : \u03b9), f a + g a :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be functions. If for all $i,j\\in\\mathbb{N}$ there is $k\\in\\mathbb{N}$ such that $f(i)+g(j)\\leq f(k)+g(k)$, then $\\sup_{i\\in\\mathbb{N}}f(i)+\\sup_{j\\in\\mathbb{N}}g(j)=\\sup_{i\\in\\mathbb{N}}f(i)+g(i)$."}
{"name": "real.cos_pi_div_two", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/basic.lean", "formal_statement": "theorem real.cos_pi_div_two :\n\treal.cos (real.pi / 2) = 0 :=", "nl_statement_of_codex": "$\\cos(\\pi/2)=0$."}
{"name": "mul_opposite.comap_op_nhds", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/algebra/constructions.lean", "formal_statement": "theorem mul_opposite.comap_op_nhds {M : Type*} [topological_space M] (x : M\u1d50\u1d52\u1d56) :\n\tfilter.comap mul_opposite.op (nhds x) = nhds (mul_opposite.unop x) :=", "nl_statement_of_codex": "Let $M$ be a topological space. Then the filter of neighborhoods of $x\\in M$ is equal to the filter of neighborhoods of $x^{-1}$."}
{"name": "has_le.le.is_open_pos_measure", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/open_pos.lean", "formal_statement": "theorem has_le.le.is_open_pos_measure {X : Type*} [topological_space X]\n\t{m : measurable_space X} {\u03bc \u03bd : measure_theory.measure X}\n\t[\u03bc.is_open_pos_measure] (h : \u03bc \u2264 \u03bd) :\n\t\u03bd.is_open_pos_measure :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $\\mu,\\nu$ be measures on $X$. If $\\mu$ is an open positive measure and $\\mu\\leq\\nu$, then $\\nu$ is an open positive measure."}
{"name": "matrix.map_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/matrix/basic.lean", "formal_statement": "theorem matrix.map_mul {m n o : Type*} {\u03b1 : Type v} {\u03b2 : Type w}\n\t[non_assoc_semiring \u03b1] [fintype n] {L : matrix m n \u03b1} {M : matrix n o \u03b1}\n\t[non_assoc_semiring \u03b2] {f : \u03b1 \u2192+* \u03b2} :\n\t(L.mul M).map \u21d1f = (L.map \u21d1f).mul (M.map \u21d1f) :=", "nl_statement_of_codex": "Let $L$ and $M$ be matrices over a non-associative semiring $R$ and let $f:R\\to S$ be a semiring homomorphism. Then $f(LM)=f(L)f(M)$."}
{"name": "topological_space.closeds.coe_inf", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/sets/closeds.lean", "formal_statement": "theorem topological_space.closeds.coe_inf {\u03b1 : Type*} [topological_space \u03b1]\n\t(s t : topological_space.closeds \u03b1) :\n\t\u2191(s \u2293 t) = \u2191s \u2229 \u2191t :=", "nl_statement_of_codex": "Let $X$ be a topological space. Then the intersection of two closed sets is closed."}
{"name": "ultrafilter.mem_or_compl_mem", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/ultrafilter.lean", "formal_statement": "theorem ultrafilter.mem_or_compl_mem {\u03b1 : Type u} (f : ultrafilter \u03b1)\n\t(s : set \u03b1) :\n\ts \u2208 f \u2228 s\u1d9c \u2208 f :=", "nl_statement_of_codex": "Let $f$ be an ultrafilter on a set $X$. Then $f$ contains either $s$ or $s^c$."}
{"name": "subfield.to_subring.subtype_eq_subtype", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/subfield.lean", "formal_statement": "theorem subfield.to_subring.subtype_eq_subtype (F : Type*) [field F]\n\t(S : subfield F) :\n\tS.to_subring.subtype = S.subtype :=", "nl_statement_of_codex": "Let $F$ be a field and let $S$ be a subfield of $F$. Then $S$ is a subring of $F$."}
{"name": "two_pointing.ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/two_pointing.lean", "formal_statement": "theorem two_pointing.ext {\u03b1 : Type*} (x y : two_pointing \u03b1)\n\t(h : x.to_prod = y.to_prod) :\n\tx = y :=", "nl_statement_of_codex": "Let $x,y$ be two-pointing functions. If $x$ and $y$ have the same image, then $x=y$."}
{"name": "mv_polynomial.C_eq_coe_nat", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.C_eq_coe_nat {R : Type u} {\u03c3 : Type*} [comm_semiring R]\n\t(n : \u2115) :\n\t\u21d1mv_polynomial.C \u2191n = \u2191n :=", "nl_statement_of_codex": "The monomial $x^n$ is equal to $n$."}
{"name": "is_p_group.comap_of_ker_is_p_group", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/p_group.lean", "formal_statement": "theorem is_p_group.comap_of_ker_is_p_group {p : \u2115} {G : Type*} [group G]\n\t{H : subgroup G} (hH : is_p_group p \u21a5H) {K : Type*} [group K] (\u03d5 : K \u2192* G)\n\t(h\u03d5 : is_p_group p \u21a5(\u03d5.ker)) :\n\tis_p_group p \u21a5(subgroup.comap \u03d5 H) :=", "nl_statement_of_codex": "Let $G$ be a group, $H$ a $p$-subgroup of $G$, and $K$ a group. Let $\\phi:K\\to G$ be a homomorphism. If $\\ker\\phi$ is a $p$-subgroup of $K$, then $\\phi^{-1}(H)$ is a $p$-subgroup of $K$."}
{"name": "cardinal.power_lt_aleph_0", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.power_lt_aleph_0 {a b : cardinal} (ha : a < cardinal.aleph_0)\n\t(hb : b < cardinal.aleph_0) :\n\ta ^ b < cardinal.aleph_0 :=", "nl_statement_of_codex": "If $a,b<\\aleph_0$, then $a^b<\\aleph_0$."}
{"name": "ordinal.sub_is_limit", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.sub_is_limit {a b : ordinal} (l : a.is_limit) (h : b < a) :\n\t(a - b).is_limit :=", "nl_statement_of_codex": "Let $a$ be a limit ordinal and let $b$ be an ordinal such that $b<a$. Then $a-b$ is a limit ordinal."}
{"name": "ereal.continuous_on_to_real", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/instances/ereal.lean", "formal_statement": "theorem ereal.continuous_on_to_real :\n\tcontinuous_on ereal.to_real {\u22a5, \u22a4}\u1d9c :=", "nl_statement_of_codex": "The function $f:\\mathbb{R}\\cup\\{-\\infty,\\infty\\}\\to\\mathbb{R}$ defined by $f(x)=x$ if $x\\in\\mathbb{R}$ and $f(x)=0$ if $x\\in\\{-\\infty,\\infty\\}$ is continuous."}
{"name": "metric.nonempty_Inter_of_nonempty_bInter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem metric.nonempty_Inter_of_nonempty_bInter {\u03b1 : Type u}\n\t[pseudo_metric_space \u03b1] [complete_space \u03b1] {s : \u2115 \u2192 set \u03b1}\n\t(hs : \u2200 (n : \u2115), is_closed (s n)) (h's : \u2200 (n : \u2115), metric.bounded (s n))\n\t(h : \u2200 (N : \u2115), (\u22c2 (n : \u2115) (H : n \u2264 N), s n).nonempty)\n\t(h' : filter.tendsto (\u03bb (n : \u2115), metric.diam (s n)) filter.at_top (nhds 0)) :\n\t(\u22c2 (n : \u2115), s n).nonempty :=", "nl_statement_of_codex": "Let $\\{s_n\\}_{n\\in\\mathbb{N}}$ be a sequence of closed subsets of a complete metric space $X$. Suppose that $\\{s_n\\}_{n\\in\\mathbb{N}}$ is bounded and that $\\lim_{n\\to\\infty}\\text{diam}(s_n)=0$. If $\\bigcap_{n=1}^N s_n$ is nonempty for all $N\\in\\mathbb{N}$, then $\\bigcap_{n\\in\\mathbb{N}} s_n$ is nonempty."}
{"name": "category_theory.functor.map_cone_op_inv_hom", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/cones.lean", "formal_statement": "theorem category_theory.functor.map_cone_op_inv_hom {J : Type u\u2081}\n\t[category_theory.category J] {C : Type u\u2083} [category_theory.category C]\n\t{D : Type u\u2084} [category_theory.category D] {F : J \u2964 C} (G : C \u2964 D)\n\t(t : category_theory.limits.cone F) :\n\t(G.map_cone_op t).inv.hom = (category_theory.iso.refl (G.map_cone t).op.X).inv :=", "nl_statement_of_codex": "Let $F:J\\to C$ and $G:C\\to D$ be functors. Let $t$ be a cone over $F$. Then the inverse of the homomorphism of the inverse of the cone over $G\\circ F$ is the inverse of the identity morphism of the object of the cone over $G\\circ F$."}
{"name": "isometric.dimH_image", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/hausdorff_dimension.lean", "formal_statement": "theorem isometric.dimH_image {X Y : Type*} [emetric_space X] [emetric_space Y]\n\t(e : X \u2243\u1d62 Y) (s : set X) :\n\tdimH (\u21d1e '' s) = dimH s :=", "nl_statement_of_codex": "Let $X$ and $Y$ be metric spaces and let $e:X\\to Y$ be an isometry. Then the Hausdorff dimension of $e(S)$ is equal to the Hausdorff dimension of $S$."}
{"name": "cont_diff_at.csin", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/trigonometric/deriv.lean", "formal_statement": "theorem cont_diff_at.csin {E : Type*} [normed_group E] [normed_space \u2102 E]\n\t{f : E \u2192 \u2102} {x : E} {n : with_top \u2115} (hf : cont_diff_at \u2102 n f x) :\n\tcont_diff_at \u2102 n (\u03bb (x : E), complex.sin (f x)) x :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{C}$ and let $f:E\\to\\mathbb{C}$. If $f$ is $n$ times continuously differentiable at $x$, then $\\sin(f)$ is $n$ times continuously differentiable at $x$."}
{"name": "nat.nth_zero_of_nth_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/nth.lean", "formal_statement": "theorem nat.nth_zero_of_nth_zero (p : \u2115 \u2192 Prop) (h\u2080 : \u00acp 0) {a b : \u2115}\n\t(hab : a \u2264 b) (ha : nat.nth p a = 0) :\n\tnat.nth p b = 0 :=", "nl_statement_of_codex": "Let $p$ be a property of natural numbers. If $p(0)$ is false and $a\\leq b$, then $p(a)=0$ implies $p(b)=0$."}
{"name": "category_theory.is_separator_coprod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/generator.lean", "formal_statement": "theorem category_theory.is_separator_coprod {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t(G H : C) [category_theory.limits.has_binary_coproduct G H] :\n\tcategory_theory.is_separator (G \u2a3f H) \u2194 category_theory.is_separating {G, H} :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms and let $G, H$ be objects of $C$. Then $G\\coprod H$ is a separator if and only if $\\{G, H\\}$ is a separating set."}
{"name": "finset.sum_ite_of_false", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.sum_ite_of_false {\u03b2 : Type u} {\u03b1 : Type v} {s : finset \u03b1}\n\t[add_comm_monoid \u03b2] {p : \u03b1 \u2192 Prop} {hp : decidable_pred p} (f g : \u03b1 \u2192 \u03b2)\n\t(h : \u2200 (x : \u03b1), x \u2208 s \u2192 \u00acp x) :\n\ts.sum (\u03bb (x : \u03b1), ite (p x) (f x) (g x)) = s.sum (\u03bb (x : \u03b1), g x) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $p$ be a predicate on $s$. Let $f,g:s\\to \\mathbb{R}$ be functions. If $p(x)$ is false for all $x\\in s$, then $\\sum_{x\\in s} f(x)=\\sum_{x\\in s} g(x)$."}
{"name": "nat.two_le_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.two_le_iff (n : \u2115) :\n\t2 \u2264 n \u2194 n \u2260 0 \u2227 n \u2260 1 :=", "nl_statement_of_codex": "$2\\leq n$ if and only if $n\\neq 0$ and $n\\neq 1$."}
{"name": "fin.cast_add_nat_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.cast_add_nat_zero {n n' : \u2115} (i : fin n) (h : n + 0 = n') :\n\t\u21d1(fin.cast h) (\u21d1(fin.add_nat 0) i) = \u21d1(fin.cast _) i :=", "nl_statement_of_codex": "Let $n,n'\\in\\mathbb{N}$ and let $i$ be an element of $\\{0,\\ldots,n-1\\}$. If $n+0=n'$, then the function $f:\\{0,\\ldots,n-1\\}\\to\\{0,\\ldots,n'-1\\}$ defined by $f(i)=i$ is a bijection."}
{"name": "list.sublist_insert", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.sublist_insert {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1) :\n\tl <+ list.insert a l :=", "nl_statement_of_codex": "The list $l$ is a sublist of the list $l$ with $a$ inserted."}
{"name": "category_theory.sieve.functor_pullback_id", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sieves.lean", "formal_statement": "theorem category_theory.sieve.functor_pullback_id {C : Type u\u2081}\n\t[category_theory.category C] {X : C} (R : category_theory.sieve X) :\n\tcategory_theory.sieve.functor_pullback (\ud835\udfed C) R = R :=", "nl_statement_of_codex": "Let $C$ be a category and let $X$ be an object of $C$. Then the pullback of the identity functor on $C$ along the sieve $R$ on $X$ is $R$."}
{"name": "monoid_hom.coe_finset_prod", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem monoid_hom.coe_finset_prod {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w}\n\t[mul_one_class \u03b2] [comm_monoid \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192* \u03b3) (s : finset \u03b1) :\n\t\u21d1(s.prod (\u03bb (x : \u03b1), f x)) = s.prod (\u03bb (x : \u03b1), \u21d1(f x)) :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a monoid homomorphism. Then $f(A\\times B)=f(A)f(B)$."}
{"name": "hahn_series.of_power_series_apply_coeff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/hahn_series.lean", "formal_statement": "theorem hahn_series.of_power_series_apply_coeff {\u0393 R : Type*} [semiring R]\n\t[ordered_semiring \u0393] [nontrivial \u0393] (x : power_series R) (n : \u2115) :\n\t(\u21d1(hahn_series.of_power_series \u0393 R) x).coeff \u2191n = \u21d1(power_series.coeff R n) x :=", "nl_statement_of_codex": "Let $x$ be a power series in $R$. Then the $n$-th coefficient of the Hahn series associated to $x$ is the $n$-th coefficient of $x$."}
{"name": "is_add_unit_iff_exists_neg'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/units.lean", "formal_statement": "theorem is_add_unit_iff_exists_neg' {M : Type*} [add_comm_monoid M] {a : M} :\n\tis_add_unit a \u2194 \u2203 (b : M), b + a = 0 :=", "nl_statement_of_codex": "An element $a$ of an additive commutative monoid $M$ is an additive unit if and only if there exists an element $b$ of $M$ such that $b+a=0$."}
{"name": "category_theory.limits.is_image.fac_lift_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/images.lean", "formal_statement": "theorem category_theory.limits.is_image.fac_lift_assoc {C : Type u}\n\t[category_theory.category C] {X Y : C} {f : X \u27f6 Y}\n\t{F : category_theory.limits.mono_factorisation f}\n\t(hF : category_theory.limits.is_image F)\n\t(F' : category_theory.limits.mono_factorisation f) {X' : C} (f' : F'.I \u27f6 X') :\n\tF.e \u226b hF.lift F' \u226b f' = F'.e \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, let $f:X\\to Y$ be a morphism in $C$, let $F$ be a mono-factorisation of $f$, and let $F'$ be another mono-factorisation of $f$. If $F$ is an image factorisation, then the diagram\n$$\\begin{array}{ccc}\nF.I & \\xrightarrow{F.e} & X \\\\\n\\downarrow{hF.lift F'} & & \\downarrow{f'} \\\\\nF'.I & \\xrightarrow{F'.e} & X'\n\\end{array}$$\ncommutes."}
{"name": "sup_sdiff_left_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/boolean_algebra.lean", "formal_statement": "theorem sup_sdiff_left_self {\u03b1 : Type u} {x y : \u03b1}\n\t[generalized_boolean_algebra \u03b1] :\n\t(x \u2294 y) \\ x = y \\ x :=", "nl_statement_of_codex": "Let $x,y$ be elements of a generalized boolean algebra $A$. Then $(x\\vee y)\\setminus x=y\\setminus x$."}
{"name": "filter.eventually_eq.le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.eventually_eq.le {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b2]\n\t{l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g) :\n\tf \u2264\u1da0[l] g :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions. If $f$ and $g$ are eventually equal, then $f$ is eventually less than or equal to $g$."}
{"name": "is_noetherian_ring_iff_ideal_fg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/noetherian.lean", "formal_statement": "theorem is_noetherian_ring_iff_ideal_fg (R : Type*) [semiring R] :\n\tis_noetherian_ring R \u2194 \u2200 (I : ideal R), I.fg :=", "nl_statement_of_codex": "A ring $R$ is Noetherian if and only if every ideal of $R$ is finitely generated."}
{"name": "ideal.filtration.bot_N", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/filtration.lean", "formal_statement": "theorem ideal.filtration.bot_N {R M : Type u} [comm_ring R] [add_comm_group M]\n\t[module R M] {I : ideal R} :\n\t\u22a5.N = \u22a5 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and $M$ be an $R$-module. Let $I$ be an ideal of $R$. Then $I^0=\\{0\\}$."}
{"name": "polynomial.erase_same", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.erase_same {R : Type u} [semiring R] (p : polynomial R)\n\t(n : \u2115) :\n\t(polynomial.erase n p).coeff n = 0 :=", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$. Then the coefficient of $x^n$ in $p$ is zero."}
{"name": "Icc_homeo_I_symm_apply_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/unit_interval.lean", "formal_statement": "theorem Icc_homeo_I_symm_apply_coe {\ud835\udd5c : Type*} [linear_ordered_field \ud835\udd5c]\n\t[topological_space \ud835\udd5c] [topological_ring \ud835\udd5c] (a b : \ud835\udd5c) (h : a < b)\n\t(x : \u21a5(set.Icc 0 1)) :\n\t\u2191(\u21d1((Icc_homeo_I a b h).symm) x) = (b - a) * \u2191x + a :=", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{R}$ with $a<b$. Then the inverse of the homeomorphism $f:I\\to I_{a,b}$ given by $f(x)=(b-a)x+a$ is given by $f^{-1}(x)=(x-a)/(b-a)$."}
{"name": "inf_eq_min_default", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/lattice.lean", "formal_statement": "theorem inf_eq_min_default {\u03b1 : Type u} [semilattice_inf \u03b1]\n\t[decidable_rel has_le.le] [is_total \u03b1 has_le.le] :\n\thas_inf.inf = min_default :=", "nl_statement_of_codex": "The infimum of a set $A$ is the minimum of $A$."}
{"name": "continuous_on_update_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/separation.lean", "formal_statement": "theorem continuous_on_update_iff {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[t1_space \u03b1] [decidable_eq \u03b1] [topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}\n\t{x : \u03b1} {y : \u03b2} :\n\tcontinuous_on (function.update f x y) s \u2194 continuous_on f (s \\ {x}) \u2227 (x \u2208 s \u2192 filter.tendsto f (nhds_within x (s \\ {x})) (nhds y)) :=", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function and let $x\\in X$. Then $f$ is continuous at $x$ if and only if $f$ is continuous at $x$ and $f$ converges to $f(x)$ at $x$."}
{"name": "measure_theory.Lp.simple_func.zero_to_simple_func", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/simple_func_dense_lp.lean", "formal_statement": "theorem measure_theory.Lp.simple_func.zero_to_simple_func {\u03b1 : Type*}\n\t(E : Type*) [measurable_space \u03b1] [normed_group E] {p : ennreal}\n\t(\u03bc : measure_theory.measure \u03b1) :\n\t\u21d1(measure_theory.Lp.simple_func.to_simple_func 0) =\u1d50[\u03bc] 0 :=", "nl_statement_of_codex": "Let $E$ be a normed group and let $\\mu$ be a measure on $E$. Then the function $f:E\\to\\mathbb{R}$ defined by $f(x)=0$ for all $x\\in E$ is a simple function."}
{"name": "bilin_form.to_matrix_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/bilinear_form.lean", "formal_statement": "theorem bilin_form.to_matrix_apply {R\u2082 M\u2082 : Type*} [comm_semiring R\u2082]\n\t[add_comm_monoid M\u2082] [module R\u2082 M\u2082] {n : Type*1} [fintype n] [decidable_eq n]\n\t(b : basis n R\u2082 M\u2082) (B : bilin_form R\u2082 M\u2082) (i j : n) :\n\t\u21d1(bilin_form.to_matrix b) B i j = \u21d1B (\u21d1b i) (\u21d1b j) :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, $n$ a finite type, and $b$ a basis of $M$. Then the matrix of a bilinear form $B$ with respect to $b$ is given by $(B_{ij})_{i,j}$ where $B_{ij}=B(b_i,b_j)$."}
{"name": "finset.inter_eq_left_iff_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/basic.lean", "formal_statement": "theorem finset.inter_eq_left_iff_subset {\u03b1 : Type*} [decidable_eq \u03b1]\n\t(s t : finset \u03b1) :\n\ts \u2229 t = s \u2194 s \u2286 t :=", "nl_statement_of_codex": "Let $s$ and $t$ be finite sets. Then $s\\cap t=s$ if and only if $s\\subset t$."}
{"name": "measure_theory.spanning_sets_index_eq_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/measure_space.lean", "formal_statement": "theorem measure_theory.spanning_sets_index_eq_iff {\u03b1 : Type*}\n\t{m0 : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1)\n\t[measure_theory.sigma_finite \u03bc] {x : \u03b1} {n : \u2115} :\n\tmeasure_theory.spanning_sets_index \u03bc x = n \u2194 x \u2208 disjointed (measure_theory.spanning_sets \u03bc) n :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a $\\sigma$-finite measure on $X$. Then $x\\in X$ is in the $n$-th disjoint set of the spanning sets of $\\mu$ if and only if the spanning sets index of $x$ is $n$."}
{"name": "norm_sup_sub_sup_le_add_norm", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed_space/lattice_ordered_group.lean", "formal_statement": "theorem norm_sup_sub_sup_le_add_norm {\u03b1 : Type*}\n\t[normed_lattice_add_comm_group \u03b1] (a b c d : \u03b1) :\n\t\u2225a \u2294 b - c \u2294 d\u2225 \u2264 \u2225a - c\u2225 + \u2225b - d\u2225 :=", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a normed lattice. Then $\\|a\\vee b-c\\vee d\\|\\leq \\|a-c\\|+\\|b-d\\|$."}
{"name": "nat.not_succ_le_self", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/nat/basic.lean", "formal_statement": "theorem nat.not_succ_le_self (n : \u2115) :\n\t\u00acn.succ \u2264 n :=", "nl_statement_of_codex": "$n+1\\leq n$ is false."}
{"name": "list.map_length_split_wrt_composition", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/composition.lean", "formal_statement": "theorem list.map_length_split_wrt_composition {\u03b1 : Type*} (l : list \u03b1)\n\t( : composition l.length) :\n\tlist.map list.length (l.split_wrt_composition c) = c.blocks :=", "nl_statement_of_codex": "Let $l$ be a list of length $n$. Let $c$ be a composition of $n$. Then the lengths of the blocks of $l$ split according to $c$ are the parts of $c$."}
{"name": "category_theory.unmop_id_mop", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/opposite.lean", "formal_statement": "theorem category_theory.unmop_id_mop {C : Type u\u2081} [category_theory.category C]\n\t{X : C} :\n\t(\ud835\udfd9 (category_theory.monoidal_opposite.mop X)).unmop = \ud835\udfd9 X :=", "nl_statement_of_codex": "The identity morphism of the monoidal opposite of $X$ is the monoidal opposite of the identity morphism of $X$."}
{"name": "asymptotics.is_O_with.eq_zero_imp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/asymptotics/asymptotics.lean", "formal_statement": "theorem asymptotics.is_O_with.eq_zero_imp {\u03b1 E'' F'' : Type*0}\n\t[normed_group E''] [normed_group F''] { : \u211d} {f'' : \u03b1 \u2192 E''} {g'' : \u03b1 \u2192 F''}\n\t{l : filter \u03b1} (h : asymptotics.is_O_with c l f'' g'') :\n\t\u2200\u1da0 (x : \u03b1) in l, g'' x = 0 \u2192 f'' x = 0 :=", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E''$ be functions. If $f$ is $O(g)$ as $x\\to\\infty$, then $g(x)=0$ implies $f(x)=0$."}
{"name": "list.length_scanl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.length_scanl {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2} (a : \u03b2)\n\t(l : list \u03b1) :\n\t(list.scanl f a l).length = l.length + 1 :=", "nl_statement_of_codex": "The length of the list $l$ is one more than the length of the list $scanl(f,a,l)$."}
{"name": "int.neg_one_pow_ne_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.neg_one_pow_ne_zero {n : \u2115} :\n\t(-1) ^ n \u2260 0 :=", "nl_statement_of_codex": "$(-1)^n\\neq 0$ for all $n\\in\\mathbb{N}$."}
{"name": "is_basis_iff_det", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/determinant.lean", "formal_statement": "theorem is_basis_iff_det {R : Type*} [comm_ring R] {M : Type*}\n\t[add_comm_group M] [module R M] {\u03b9 : Type*} [decidable_eq \u03b9] [fintype \u03b9]\n\t(e : basis \u03b9 R M) {v : \u03b9 \u2192 M} :\n\tlinear_independent R v \u2227 submodule.span R (set.range v) = \u22a4 \u2194 is_unit (\u21d1(e.det) v) :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ an $R$-module, and $\\{v_i\\}_{i\\in I}$ a basis of $M$. Then $\\{v_i\\}_{i\\in I}$ is a basis if and only if the determinant of the matrix $(v_i(j))_{i,j\\in I}$ is a unit."}
{"name": "monovary.comp_monotone_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/monovary.lean", "formal_statement": "theorem monovary.comp_monotone_left {\u03b9 \u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t[preorder \u03b3] {f : \u03b9 \u2192 \u03b1} {f' : \u03b1 \u2192 \u03b3} {g : \u03b9 \u2192 \u03b2} (h : monovary f g)\n\t(hf : monotone f') :\n\tmonovary (f' \u2218 f) g :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be monotone functions. If $f$ is eventually greater than $g$, then $f\\circ h$ is eventually greater than $g$ for any monotone function $h:\\mathbb{R}\\to\\mathbb{R}$."}
{"name": "multiset.fold_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/fold.lean", "formal_statement": "theorem multiset.fold_singleton {\u03b1 : Type*} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n\t[hc : is_commutative \u03b1 op] [ha : is_associative \u03b1 op] (b a : \u03b1) :\n\tmultiset.fold op b {a} = op a b :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with identity. Then the product of a single element $a\\in R$ is $a$."}
{"name": "euclidean_geometry.affine_span_of_orthocentric_system", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/euclidean/monge_point.lean", "formal_statement": "theorem euclidean_geometry.affine_span_of_orthocentric_system {V P : Type*}\n\t[inner_product_space \u211d V] [metric_space P] [normed_add_torsor V P] {s : set P}\n\t(ho : euclidean_geometry.orthocentric_system s) {p : fin 3 \u2192 P}\n\t(hps : set.range p \u2286 s) (hpi : function.injective p) :\n\taffine_span \u211d (set.range p) = affine_span \u211d s :=", "nl_statement_of_codex": "Let $V$ be a real inner product space and let $P$ be a metric space. Let $s$ be an orthocentric system in $P$. Let $p: \\{0,1,2\\}\\to P$ be an injective function such that $p(0), p(1), p(2)\\in s$. Then $\\operatorname{aff}(p(0), p(1), p(2))=\\operatorname{aff}(s)$."}
{"name": "set.subset_univ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.subset_univ {\u03b1 : Type u} (s : set \u03b1) :\n\ts \u2286 set.univ :=", "nl_statement_of_codex": "Every set is a subset of the universal set."}
{"name": "category_theory.cartesian_closed.uncurry_natural_left_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/closed/cartesian.lean", "formal_statement": "theorem category_theory.cartesian_closed.uncurry_natural_left_assoc {C : Type u}\n\t[category_theory.category C] {A X X' Y : C}\n\t[category_theory.limits.has_finite_products C]\n\t[category_theory.exponentiable A] (f : X \u27f6 X')\n\t(g : X' \u27f6 (category_theory.exp A).obj Y) {X'_1 : C} (f' : Y \u27f6 X'_1) :\n\tcategory_theory.cartesian_closed.uncurry (f \u226b g) \u226b f' = category_theory.limits.prod.map (\ud835\udfd9 A) f \u226b category_theory.cartesian_closed.uncurry g \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category with finite products and exponentiable objects. Let $A, X, X', Y$ be objects of $C$ and let $f:X\\to X'$, $g:X'\\to Y^A$, $f':Y\\to X'_1$ be morphisms in $C$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nX\\times A & \\xrightarrow{f\\times \\mathrm{id}_A} & X'\\times A \\\\\n\\downarrow & & \\downarrow \\\\\nY & \\xrightarrow{f'} & X'_1\n\\end{array"}
{"name": "category_theory.\u03bc_inv_naturality\u1d63", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/monoidal/End.lean", "formal_statement": "theorem category_theory.\u03bc_inv_naturality\u1d63 {C : Type u}\n\t[category_theory.category C] {M : Type*} [category_theory.category M]\n\t[category_theory.monoidal_category M]\n\t(F : category_theory.monoidal_functor M (C \u2964 C)) {m n n' : M} (g : n \u27f6 n')\n\t(X : C) :\n\t(F.\u03bc_iso m n).inv.app X \u226b (F.to_lax_monoidal_functor.to_functor.map g).app ((F.to_lax_monoidal_functor.to_functor.obj m).obj X) = (F.to_lax_monoidal_functor.to_functor.map (\ud835\udfd9 m \u2297 g)).app X \u226b (F.\u03bc_iso m n').inv.app X :=", "nl_statement_of_codex": "Let $F:M\\to C\\to C$ be a monoidal functor. Then the following diagram commutes:\n\\begin{equation*}\n\\begin{tikzcd}\nF(m)\\otimes F(n) \\arrow[r, "}
{"name": "ordnode.valid'_nil", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.valid'_nil {\u03b1 : Type*} [preorder \u03b1] {o\u2081 : with_bot \u03b1}\n\t{o\u2082 : with_top \u03b1} (h : ordnode.nil.bounded o\u2081 o\u2082) :\n\tordnode.valid' o\u2081 ordnode.nil o\u2082 :=", "nl_statement_of_codex": "Let $o_1$ be a lower bound and $o_2$ be an upper bound. Then the empty list is a valid list of elements between $o_1$ and $o_2$."}
{"name": "ordnode.all_dual", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/ordmap/ordset.lean", "formal_statement": "theorem ordnode.all_dual {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} {t : ordnode \u03b1} :\n\tordnode.all P t.dual \u2194 ordnode.all P t :=", "nl_statement_of_codex": "Let $t$ be an ordnode. Then $t$ satisfies a property $P$ if and only if $t$'s dual satisfies $P$."}
{"name": "category_theory.limits.bicone.to_binary_bicone_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/biproducts.lean", "formal_statement": "theorem category_theory.limits.bicone.to_binary_bicone_snd {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y : C}\n\t(b : category_theory.limits.bicone (category_theory.limits.pair_function X Y)) :\n\tb.to_binary_bicone.snd = b.\u03c0 category_theory.limits.walking_pair.right :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $X$ and $Y$ be objects of $C$. Let $b$ be a bicone over $X$ and $Y$. Then the second projection of $b$ is the projection of $b$ onto $Y$."}
{"name": "is_open_iff_ultrafilter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/basic.lean", "formal_statement": "theorem is_open_iff_ultrafilter {\u03b1 : Type u} [topological_space \u03b1] {s : set \u03b1} :\n\tis_open s \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (l : ultrafilter \u03b1), \u2191l \u2264 nhds x \u2192 s \u2208 l :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a subset of $X$. Then $A$ is open if and only if for each $x\\in A$ and each ultrafilter $l$ on $X$ such that $l\\leq \\mathcal{N}(x)$, we have $A\\in l$."}
{"name": "is_add_subgroup.mem_trivial", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/deprecated/subgroup.lean", "formal_statement": "theorem is_add_subgroup.mem_trivial {G : Type*} [add_group G] {g : G} :\n\tg \u2208 is_add_subgroup.trivial G \u2194 g = 0 :=", "nl_statement_of_codex": "The trivial subgroup of an additive group $G$ is the set of all elements of $G$."}
{"name": "multiset.dedup_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/multiset/finset_ops.lean", "formal_statement": "theorem multiset.dedup_add {\u03b1 : Type*} [decidable_eq \u03b1] (s t : multiset \u03b1) :\n\t(s + t).dedup = s.ndunion t.dedup :=", "nl_statement_of_codex": "Let $s$ and $t$ be multisets. Then the multiset obtained by adding $s$ and $t$ and then removing duplicates is equal to the multiset obtained by removing duplicates from $s$ and $t$ and then adding them."}
{"name": "covby_iff_wcovby_and_not_le", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/cover.lean", "formal_statement": "theorem covby_iff_wcovby_and_not_le {\u03b1 : Type*} [preorder \u03b1] {a b : \u03b1} :\n\ta \u22d6 b \u2194 a \u2a7f b \u2227 \u00acb \u2264 a :=", "nl_statement_of_codex": "$a$ covers $b$ if and only if $a$ weakly covers $b$ and $b$ is not less than $a$."}
{"name": "polynomial.support_monomial", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/basic.lean", "formal_statement": "theorem polynomial.support_monomial {R : Type u} [semiring R] (n : \u2115) {a : R}\n\t(H : a \u2260 0) :\n\t(\u21d1(polynomial.monomial n) a).support = {n} :=", "nl_statement_of_codex": "The support of the monomial $aX^n$ is $\\{n\\}$."}
{"name": "filter.comap_eval_ne_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.comap_eval_ne_bot {\u03b9 \u03b1 : \u03b9 \u2192 Type*} [\u2200 (j : \u03b9), nonempty (\u03b1 j)]\n\t(i : \u03b9) (f : filter (\u03b1 i)) [f.ne_bot] :\n\t(filter.comap (function.eval i) f).ne_bot :=", "nl_statement_of_codex": "Let $f$ be a nonempty filter on a type $A$. Then the filter $f\\circ\\pi_i$ on $A^I$ is nonempty."}
{"name": "finset.prod_filter", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/big_operators/basic.lean", "formal_statement": "theorem finset.prod_filter {\u03b2 : Type u} {\u03b1 : Type v} {s : finset \u03b1}\n\t[comm_monoid \u03b2] (p : \u03b1 \u2192 Prop) [decidable_pred p] (f : \u03b1 \u2192 \u03b2) :\n\t(finset.filter p s).prod (\u03bb (a : \u03b1), f a) = s.prod (\u03bb (a : \u03b1), ite (p a) (f a) 1) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\beta$ be a function. Then the product of the values of $f$ on the subset of $s$ where $p$ holds is equal to the product of the values of $f$ on $s$ where $f$ is replaced by $1$ on the subset of $s$ where $p$ does not hold."}
{"name": "category_theory.iso.symm_self_conj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/conj.lean", "formal_statement": "theorem category_theory.iso.symm_self_conj {C : Type u}\n\t[category_theory.category C] {X Y : C} (\u03b1 : X \u2245 Y) (f : category_theory.End X) :\n\t\u21d1(\u03b1.symm.conj) (\u21d1(\u03b1.conj) f) = f :=", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y$ be objects of $C$. Let $\\alpha:X\\to Y$ be an isomorphism. Then $\\alpha^{-1}\\circ\\alpha=\\mathrm{id}_X$."}
{"name": "coe_inv_units_equiv_prod_subtype_symm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fintype/basic.lean", "formal_statement": "theorem coe_inv_units_equiv_prod_subtype_symm_apply (\u03b1 : Type*) [monoid \u03b1]\n\t(p : {p // p.fst * p.snd = 1 \u2227 p.snd * p.fst = 1}) :\n\t\u2191(\u21d1((units_equiv_prod_subtype \u03b1).symm) p)\u207b\u00b9 = \u2191p.snd :=", "nl_statement_of_codex": "Let $\u03b1$ be a monoid. Then the inverse of the element $\u21d1((units_equiv_prod_subtype \u03b1).symm) p$ is $\u2191p.snd$."}
{"name": "category_theory.limits.is_initial.strict_hom_ext", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/strict_initial.lean", "formal_statement": "theorem category_theory.limits.is_initial.strict_hom_ext {C : Type u}\n\t[category_theory.category C]\n\t[category_theory.limits.has_strict_initial_objects C] {I : C}\n\t(hI : category_theory.limits.is_initial I) {A : C} (f g : A \u27f6 I) :\n\tf = g :=", "nl_statement_of_codex": "Let $C$ be a category with strict initial objects. Let $I$ be a strict initial object of $C$. Then any two strict morphisms from $A$ to $I$ are equal."}
{"name": "sq_le_sq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/order.lean", "formal_statement": "theorem sq_le_sq {R : Type*} [linear_ordered_ring R] {x y : R} :\n\tx ^ 2 \u2264 y ^ 2 \u2194 |x| \u2264 |y| :=", "nl_statement_of_codex": "Let $R$ be a linear ordered ring. Then $x^2\\leq y^2$ if and only if $|x|\\leq |y|$."}
{"name": "torus_map_eq_center_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/integral/torus_integral.lean", "formal_statement": "theorem torus_map_eq_center_iff {n : \u2115} { : fin n \u2192 \u2102} {R \u03b8 : fin n \u2192 \u211d} :\n\ttorus_map c R \u03b8 = c \u2194 R = 0 :=", "nl_statement_of_codex": "Let $c\\in\\mathbb{C}$ and let $R,\\theta:\\{1,\\ldots,n\\}\\to\\mathbb{R}$. Then $c$ is in the image of the torus map $T_{R,\\theta}$ if and only if $R=0$."}
{"name": "measure_theory.ae_strongly_measurable_zero", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/function/strongly_measurable.lean", "formal_statement": "theorem measure_theory.ae_strongly_measurable_zero {\u03b1 \u03b2 : Type*}\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [topological_space \u03b2]\n\t[has_zero \u03b2] :\n\tmeasure_theory.ae_strongly_measurable 0 \u03bc :=", "nl_statement_of_codex": "The zero function is strongly measurable."}
{"name": "set.diff_union_self", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.diff_union_self {\u03b1 : Type u} {s t : set \u03b1} :\n\ts \\ t \u222a t = s \u222a t :=", "nl_statement_of_codex": "$(S\\setminus T)\\cup T=S\\cup T$."}
{"name": "freiman_hom.div_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/hom/freiman.lean", "formal_statement": "theorem freiman_hom.div_apply {\u03b1 G : Type*} [comm_monoid \u03b1] [comm_group G]\n\t{A : set \u03b1} {n : \u2115} (f g : A \u2192*[n] G) (x : \u03b1) :\n\t\u21d1(f / g) x = \u21d1f x / \u21d1g x :=", "nl_statement_of_codex": "Let $A$ be a subset of a commutative monoid $M$ and let $G$ be a commutative group. Let $f,g:A\\to G$ be $n$-homomorphisms. Then $(f/g)(x)=f(x)/g(x)$."}
{"name": "Profinite_to_CompHaus_obj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/category/Profinite/default.lean", "formal_statement": "theorem Profinite_to_CompHaus_obj (self : Profinite) :\n\tProfinite_to_CompHaus.obj self = self.to_CompHaus :=", "nl_statement_of_codex": "The functor $Profinite\\to CompHaus$ is represented by the profinite space $Profinite$."}
{"name": "ring_equiv.of_bijective_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/ring/equiv.lean", "formal_statement": "theorem ring_equiv.of_bijective_apply {F R S : Type*}\n\t[non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S]\n\t[non_unital_ring_hom_class F R S] (f : F) (hf : function.bijective \u21d1f) (x : R) :\n\t\u21d1(ring_equiv.of_bijective f hf) x = \u21d1f x :=", "nl_statement_of_codex": "Let $R$ and $S$ be non-unital non-associative rings and let $f:R\\to S$ be a bijective ring homomorphism. Then $f$ is an isomorphism of rings."}
{"name": "measure_theory.vector_measure.not_measurable", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/vector_measure.lean", "formal_statement": "theorem measure_theory.vector_measure.not_measurable {\u03b1 : Type*}\n\t{m : measurable_space \u03b1} {M : Type*} [add_comm_monoid M] [topological_space M]\n\t(v : measure_theory.vector_measure \u03b1 M) {i : set \u03b1} (hi : \u00acmeasurable_set i) :\n\t\u21d1v i = 0 :=", "nl_statement_of_codex": "Let $v$ be a vector measure on a measurable space $(X,\\mathcal{A})$. If $A\\in\\mathcal{A}$ is not measurable, then $v(A)=0$."}
{"name": "lie_subalgebra.inf_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/lie/subalgebra.lean", "formal_statement": "theorem lie_subalgebra.inf_coe {R : Type u} {L : Type v} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] (K K' : lie_subalgebra R L) :\n\t\u2191(K \u2293 K') = \u2191K \u2229 \u2191K' :=", "nl_statement_of_codex": "Let $L$ be a Lie algebra over a commutative ring $R$. Let $K$ and $K'$ be Lie subalgebras of $L$. Then $K\\cap K'$ is a Lie subalgebra of $L$."}
{"name": "Class.mem_hom_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/zfc.lean", "formal_statement": "theorem Class.mem_hom_left (x : Set) (A : Class) :\n\t\u2191x \u2208 A \u2194 A x :=", "nl_statement_of_codex": "$x\\in A$ if and only if $A(x)$."}
{"name": "category_theory.limits.multifork.hom_comp_\u03b9_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/multiequalizer.lean", "formal_statement": "theorem category_theory.limits.multifork.hom_comp_\u03b9_assoc {C : Type u}\n\t[category_theory.category C] {I : category_theory.limits.multicospan_index C}\n\t(K\u2081 K\u2082 : category_theory.limits.multifork I) (f : K\u2081 \u27f6 K\u2082) (j : I.L) {X' : C}\n\t(f' : I.left j \u27f6 X') :\n\tf.hom \u226b K\u2082.\u03b9 j \u226b f' = K\u2081.\u03b9 j \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category and let $I$ be a multicospan index. Let $K_1$ and $K_2$ be multiforks over $I$. Let $f:K_1\\to K_2$ be a morphism of multiforks and let $j$ be an object of $I$. Let $X'$ be an object of $C$ and let $f':I.left(j)\\to X'$ be a morphism in $C$. Then $f.hom\\circ K_2.\u03b9(j)\\circ f'=K_1.\u03b9(j)\\circ f'$."}
{"name": "measurable_space.dynkin_system.has_diff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/pi_system.lean", "formal_statement": "theorem measurable_space.dynkin_system.has_diff {\u03b1 : Type*}\n\t(d : measurable_space.dynkin_system \u03b1) {s\u2081 s\u2082 : set \u03b1} (h\u2081 : d.has s\u2081)\n\t(h\u2082 : d.has s\u2082) (h : s\u2082 \u2286 s\u2081) :\n\td.has (s\u2081 \\ s\u2082) :=", "nl_statement_of_codex": "Let $d$ be a Dynkin system on a measurable space $(X,\\mathcal{A})$. If $d$ contains $s_1$ and $s_2$ and $s_2\\subset s_1$, then $d$ contains $s_1\\setminus s_2$."}
{"name": "filter.is_unit_iff_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.is_unit_iff_singleton {\u03b1 : Type*} [group \u03b1] {f : filter \u03b1} :\n\tis_unit f \u2194 \u2203 (a : \u03b1), f = has_pure.pure a :=", "nl_statement_of_codex": "A filter $f$ on a group $G$ is a unit if and only if $f$ is the principal filter generated by some element of $G$."}
{"name": "int.bodd_bit1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/int/basic.lean", "formal_statement": "theorem int.bodd_bit1 (n : \u2124) :\n\t(bit1 n).bodd = bool.tt :=", "nl_statement_of_codex": "The integer $2n+1$ is odd."}
{"name": "many_one_reducible.trans", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/computability/reduce.lean", "formal_statement": "theorem many_one_reducible.trans {\u03b1 \u03b2 \u03b3 : Type*} [primcodable \u03b1] [primcodable \u03b2]\n\t[primcodable \u03b3] {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} :\n\tp \u2264\u2080 q \u2192 q \u2264\u2080 r \u2192 p \u2264\u2080 r :=", "nl_statement_of_codex": "If $p$ is many-one reducible to $q$ and $q$ is many-one reducible to $r$, then $p$ is many-one reducible to $r$."}
{"name": "category_theory.presheaf.is_sheaf.amalgamate_map_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/sites/sheaf.lean", "formal_statement": "theorem category_theory.presheaf.is_sheaf.amalgamate_map_assoc {C : Type u\u2081}\n\t[category_theory.category C] {J : category_theory.grothendieck_topology C}\n\t{A : Type u\u2082} [category_theory.category A] {E : A} {X : C} {P : C\u1d52\u1d56 \u2964 A}\n\t(hP : category_theory.presheaf.is_sheaf J P) (S : J.cover X)\n\t(x : \u03a0 (I : S.arrow), E \u27f6 P.obj (opposite.op I.Y))\n\t(hx : \u2200 (I : S.relation), x I.fst \u226b P.map I.g\u2081.op = x I.snd \u226b P.map I.g\u2082.op)\n\t(I : S.arrow) {X' : A} (f' : P.obj (opposite.op I.Y) \u27f6 X') :\n\thP.amalgamate S x hx \u226b P.map I.f.op \u226b f' = x I \u226b f' :=", "nl_statement_of_codex": "Let $C$ be a category, $J$ a Grothendieck topology on $C$, $A$ a category, $E$ an object of $A$, $X$ an object of $C$, $P$ a presheaf on $C$ with values in $A$, $S$ a cover of $X$ in $J$, $x$ a family of morphisms from $E$ to $P(I)$ for each $I\\in S$, and $f':P(I)\\to X'$ a morphism in $A$. Suppose that $P$ is a sheaf. Then the diagram\n$$\\begin{array}{ccc}\nE &"}
{"name": "ennreal.zero_lt_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/ennreal.lean", "formal_statement": "theorem ennreal.zero_lt_one :\n\t0 < 1 :=", "nl_statement_of_codex": "$0<1$."}
{"name": "ring_hom.coe_range_restrict_field", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/subfield.lean", "formal_statement": "theorem ring_hom.coe_range_restrict_field {K : Type u} {L : Type v} [field K]\n\t[field L] (f : K \u2192+* L) (x : K) :\n\t\u2191(\u21d1(f.range_restrict_field) x) = \u21d1f x :=", "nl_statement_of_codex": "Let $K$ and $L$ be fields and let $f:K\\to L$ be a ring homomorphism. Then $f(x)$ is in the image of $f$ if and only if $x$ is in the image of $f$."}
{"name": "homogeneous_localization.num_denom_same_deg.deg_smul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/graded_algebra/homogeneous_localization.lean", "formal_statement": "theorem homogeneous_localization.num_denom_same_deg.deg_smul {\u03b9 R A : Type*}\n\t[add_comm_monoid \u03b9] [decidable_eq \u03b9] [comm_ring R] [comm_ring A] [algebra R A]\n\t{\ud835\udc9c : \u03b9 \u2192 submodule R A} [graded_algebra \ud835\udc9c] (x : ideal A) [x.is_prime]\n\t{\u03b1 : Type*} [has_smul \u03b1 R] [has_smul \u03b1 A] [is_scalar_tower \u03b1 R A]\n\t( : homogeneous_localization.num_denom_same_deg \ud835\udc9c x) (m : \u03b1) :\n\t(m \u2022 c).deg = c.deg :=", "nl_statement_of_codex": "Let $R$ be a commutative ring, $A$ an $R$-algebra, $\ud835\udc9c$ a graded $R$-algebra, $x$ a prime ideal of $A$, and $\u03b1$ a scalar tower over $R$ and $A$. Then the degree of $m\\cdot c$ is the same as the degree of $c$."}
{"name": "nat.dist_zero_left", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/dist.lean", "formal_statement": "theorem nat.dist_zero_left (n : \u2115) :\n\t0.dist n = n :=", "nl_statement_of_codex": "The distance from $0$ to $n$ is $n$."}
{"name": "fin.cast_succ_mk", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/fin/basic.lean", "formal_statement": "theorem fin.cast_succ_mk (n i : \u2115) (h : i < n) :\n\t\u21d1fin.cast_succ \u27e8i, h\u27e9 = \u27e8i, _\u27e9 :=", "nl_statement_of_codex": "Let $n$ and $i$ be natural numbers such that $i<n$. Then $\\overline{i+1}=i$."}
{"name": "probability_theory.strong_law_aux5", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/strong_law.lean", "formal_statement": "theorem probability_theory.strong_law_aux5 {\u03a9 : Type*}\n\t[measure_theory.measure_space \u03a9]\n\t[measure_theory.is_probability_measure measure_theory.measure_space.volume]\n\t(X : \u2115 \u2192 \u03a9 \u2192 \u211d)\n\t(hint : measure_theory.integrable (X 0) measure_theory.measure_space.volume)\n\t(hident : \u2200 (i : \u2115), probability_theory.ident_distrib (X i) (X 0) measure_theory.measure_space.volume measure_theory.measure_space.volume)\n\t(hnonneg : \u2200 (i : \u2115) (\u03c9 : \u03a9), 0 \u2264 X i \u03c9) :\n\t\u2200\u1d50 (\u03c9 : \u03a9), (\u03bb (n : \u2115), (finset.range n).sum (\u03bb (i : \u2115), probability_theory.truncation (X i) \u2191i \u03c9) - (finset.range n).sum (\u03bb (i : \u2115), X i \u03c9)) =o[filter.at_top] \u03bb (n : \u2115), \u2191n :=", "nl_statement_of_codex": "Let $X_i:\\Omega\\to\\mathbb{R}$ be a sequence of random variables. Suppose that $X_0$ is integrable and that $X_i$ is identically distributed as $X_0$ for all $i$. Suppose also that $X_i\\geq 0$ for all $i$. Then $\\sum_{i=1}^n X_i-nX_0$ converges to $0$ almost surely."}
{"name": "hyperreal.infinite_neg_def", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/real/hyperreal.lean", "formal_statement": "theorem hyperreal.infinite_neg_def {x : \u211d*} :\n\tx.infinite_neg \u2194 \u2200 (r : \u211d), x < \u2191r :=", "nl_statement_of_codex": "A hyperreal number $x$ is infinite negative if and only if $x<r$ for all real numbers $r$."}
{"name": "polynomial.count_roots", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/polynomial/ring_division.lean", "formal_statement": "theorem polynomial.count_roots {R : Type u} {a : R} [comm_ring R] [is_domain R]\n\t(p : polynomial R) :\n\tmultiset.count a p.roots = polynomial.root_multiplicity a p :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with identity and let $p$ be a polynomial over $R$. Then the number of roots of $p$ in $R$ is equal to the multiplicity of $p$ at $a$."}
{"name": "uniform_space.completion.extension\u2082_coe_coe", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/uniform_space/completion.lean", "formal_statement": "theorem uniform_space.completion.extension\u2082_coe_coe {\u03b1 : Type*}\n\t[uniform_space \u03b1] {\u03b2 : Type*} [uniform_space \u03b2] {\u03b3 : Type*} [uniform_space \u03b3]\n\t{f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} [separated_space \u03b3] (hf : uniform_continuous\u2082 f) (a : \u03b1)\n\t(b : \u03b2) :\n\tuniform_space.completion.extension\u2082 f \u2191a \u2191b = f a b :=", "nl_statement_of_codex": "Let $f:X\\times Y\\to Z$ be a uniformly continuous function. Then $f$ extends to a uniformly continuous function $\\tilde{f}:X^*\\times Y^*\\to Z^*$."}
{"name": "category_theory.preadditive.has_equalizer_of_has_kernel", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/preadditive/default.lean", "formal_statement": "theorem category_theory.preadditive.has_equalizer_of_has_kernel {C : Type u}\n\t[category_theory.category C] [category_theory.preadditive C] {X Y : C}\n\t(f g : X \u27f6 Y) [category_theory.limits.has_kernel (f - g)] :\n\tcategory_theory.limits.has_equalizer f g :=", "nl_statement_of_codex": "Let $C$ be a preadditive category. If $f,g:X\\to Y$ have a kernel, then they have an equalizer."}
{"name": "algebra.tensor_product.alg_equiv_of_linear_equiv_tensor_product_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/tensor_product.lean", "formal_statement": "theorem algebra.tensor_product.alg_equiv_of_linear_equiv_tensor_product_apply\n\t{R : Type u} [comm_semiring R] {A : Type v\u2081} [semiring A] [algebra R A]\n\t{B : Type v\u2082} [semiring B] [algebra R B] {C : Type v\u2083} [semiring C]\n\t[algebra R C] (f : tensor_product R A B \u2243\u2097[R] C)\n\t(w\u2081 : \u2200 (a\u2081 a\u2082 : A) (b\u2081 b\u2082 : B), \u21d1f ((a\u2081 * a\u2082) \u2297\u209c[R] (b\u2081 * b\u2082)) = \u21d1f (a\u2081 \u2297\u209c[R] b\u2081) * \u21d1f (a\u2082 \u2297\u209c[R] b\u2082))\n\t(w\u2082 : \u2200 (r : R), \u21d1f (\u21d1(algebra_map R A) r \u2297\u209c[R] 1) = \u21d1(algebra_map R C) r)\n\t(x : tensor_product R A B) :\n\t\u21d1(algebra.tensor_product.alg_equiv_of_linear_equiv_tensor_product f w\u2081 w\u2082) x = \u21d1f x :=", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A, B, C$ be $R$-algebras. Let $f:A\\otimes_R B\\to C$ be a linear map such that $f(a_1\\otimes b_1)f(a_2\\otimes b_2)=f(a_1a_2\\otimes b_1b_2)$ and $f(r\\otimes 1)=r$ for all $a_1,a_2\\in A$, $b_1,b_2\\in B$, $r\\in R$. Then $f$ is an $R$-al"}
{"name": "is_primitive_root.zpow_eq_one\u2080", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/roots_of_unity.lean", "formal_statement": "theorem is_primitive_root.zpow_eq_one\u2080 {G\u2080 : Type*} [comm_group_with_zero G\u2080]\n\t{k : \u2115} {\u03b6 : G\u2080} (h : is_primitive_root \u03b6 k) :\n\t\u03b6 ^ \u2191k = 1 :=", "nl_statement_of_codex": "Let $G$ be a group with identity $1$ and let $k$ be a positive integer. If $\\zeta$ is a primitive $k$-th root of unity, then $\\zeta^k=1$."}
{"name": "ordinal.range_enum_ord", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/ordinal/arithmetic.lean", "formal_statement": "theorem ordinal.range_enum_ord {S : set ordinal}\n\t(hS : set.unbounded has_lt.lt S) :\n\tset.range (ordinal.enum_ord S) = S :=", "nl_statement_of_codex": "Let $S$ be an unbounded set of ordinals. Then the range of the enumeration function of $S$ is $S$."}
{"name": "has_deriv_within_at.const_add", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem has_deriv_within_at.const_add {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c}\n\t{s : set \ud835\udd5c} ( : F) (hf : has_deriv_within_at f f' s x) :\n\thas_deriv_within_at (\u03bb (y : \ud835\udd5c), c + f y) f' s x :=", "nl_statement_of_codex": "Let $f:U\\to F$ be a function defined on an open subset $U$ of $\\mathbb{R}^n$ and let $c\\in F$. If $f$ is differentiable at $x\\in U$, then $f+c$ is differentiable at $x$."}
{"name": "category_theory.limits.types.pi_lift_\u03c0_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/types.lean", "formal_statement": "theorem category_theory.limits.types.pi_lift_\u03c0_apply {\u03b2 : Type u}\n\t(f : \u03b2 \u2192 Type u) {P : Type u} (s : \u03a0 (b : \u03b2), P \u27f6 f b) (b : \u03b2) (x : P) :\n\tcategory_theory.limits.pi.\u03c0 f b (category_theory.limits.pi.lift s x) = s b x :=", "nl_statement_of_codex": "Let $f:\u03b2\\to\\mathrm{Type}$ and let $s:\\Pi b:\u03b2, P\\to f(b)$ be a family of morphisms. Then the projection of the lift of $s$ at $x$ is $s$."}
{"name": "is_compact_sphere", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/basic.lean", "formal_statement": "theorem is_compact_sphere {\u03b1 : Type*} [pseudo_metric_space \u03b1] [proper_space \u03b1]\n\t(x : \u03b1) (r : \u211d) :\n\tis_compact (metric.sphere x r) :=", "nl_statement_of_codex": "The sphere of radius $r$ centered at $x$ is compact."}
{"name": "convex_halfspace_re_lt", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/convex/complex.lean", "formal_statement": "theorem convex_halfspace_re_lt (r : \u211d) :\n\tconvex \u211d {c : \u2102 | c.re < r} :=", "nl_statement_of_codex": "The set of complex numbers with real part less than $r$ is convex."}
{"name": "smooth_within_at_pi_space", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/cont_mdiff.lean", "formal_statement": "theorem smooth_within_at_pi_space {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*}\n\t[topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type*}\n\t[topological_space M] [charted_space H M] {s : set M} {x : M} {\u03b9 : Type*4}\n\t[fintype \u03b9] {Fi : \u03b9 \u2192 Type*5} [\u03a0 (i : \u03b9), normed_group (Fi i)]\n\t[\u03a0 (i : \u03b9), normed_space \ud835\udd5c (Fi i)] {\u03c6 : M \u2192 \u03a0 (i : \u03b9), Fi i} :\n\tsmooth_within_at I (model_with_corners_self \ud835\udd5c (\u03a0 (i : \u03b9), Fi i)) \u03c6 s x \u2194 \u2200 (i : \u03b9), smooth_within_at I (model_with_corners_self \ud835\udd5c (Fi i)) (\u03bb (x : M), \u03c6 x i) s x :=", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ or $\\mathbb{C}$. Let $H$ be a topological space and let $M$ be a topological manifold. Let $s$ be a subset of $M$ and let $x$ be a point in $M$. Let $\\phi:M\\to \\Pi_{i\\in I} F_i$ be a function. Then $\\phi$ is smooth at $x$ if and only if $\\phi_i$ is smooth at $x$ for all $i\\in I$."}
{"name": "finset.min'_lt_of_mem_erase_min'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finset/lattice.lean", "formal_statement": "theorem finset.min'_lt_of_mem_erase_min' {\u03b1 : Type*} [linear_order \u03b1]\n\t(s : finset \u03b1) (H : s.nonempty) [decidable_eq \u03b1] {a : \u03b1}\n\t(ha : a \u2208 s.erase (s.min' H)) :\n\ts.min' H < a :=", "nl_statement_of_codex": "Let $s$ be a nonempty finite set of elements of a linear order. If $a$ is an element of $s$ that is not the minimum of $s$, then $a$ is greater than the minimum of $s$."}
{"name": "rat.cast_sum", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rat/cast.lean", "formal_statement": "theorem rat.cast_sum {\u03b9 \u03b1 : Type*} [division_ring \u03b1] [char_zero \u03b1]\n\t(s : finset \u03b9) (f : \u03b9 \u2192 \u211a) :\n\t\u2191(s.sum (\u03bb (i : \u03b9), f i)) = s.sum (\u03bb (i : \u03b9), \u2191(f i)) :=", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to\\mathbb{Q}$. Then $\\sum_{i\\in s}f(i)=\\sum_{i\\in s}\\mathbb{Q}(f(i))$."}
{"name": "Sup_atoms_eq_top", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/atoms.lean", "formal_statement": "theorem Sup_atoms_eq_top {\u03b1 : Type*} [complete_lattice \u03b1] [is_atomistic \u03b1] :\n\thas_Sup.Sup {a : \u03b1 | is_atom a} = \u22a4 :=", "nl_statement_of_codex": "The supremum of the set of atoms of a complete lattice is the top element."}
{"name": "holder_with_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/metric_space/holder.lean", "formal_statement": "theorem holder_with_one {X Y : Type*} [pseudo_emetric_space X]\n\t[pseudo_emetric_space Y] {C : nnreal} {f : X \u2192 Y} :\n\tholder_with C 1 f \u2194 lipschitz_with C f :=", "nl_statement_of_codex": "Let $X$ and $Y$ be pseudo-metric spaces and let $C$ be a non-negative real number. Then a function $f:X\\to Y$ is Holder continuous with exponent $1$ if and only if it is Lipschitz continuous with constant $C$."}
{"name": "measure_theory.is_add_fundamental_domain.image_of_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/group/fundamental_domain.lean", "formal_statement": "theorem measure_theory.is_add_fundamental_domain.image_of_equiv {G \u03b1 : Type*}\n\t[add_group G] [add_action G \u03b1] [measurable_space \u03b1] {s : set \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} [measurable_space G] [has_measurable_vadd G \u03b1]\n\t[measure_theory.vadd_invariant_measure G \u03b1 \u03bc]\n\t(h : measure_theory.is_add_fundamental_domain G s \u03bc) (f : \u03b1 \u2243\u1d50 \u03b1)\n\t(hf\u03bc : measure_theory.measure_preserving \u21d1f \u03bc \u03bc) (e : equiv.perm G)\n\t(hef : \u2200 (g : G), function.semiconj \u21d1f (has_vadd.vadd (\u21d1e g)) (has_vadd.vadd g)) :\n\tmeasure_theory.is_add_fundamental_domain G (\u21d1f '' s) \u03bc :=", "nl_statement_of_codex": "Let $G$ be an additive group acting on a measurable space $(\\alpha,\\mu)$. Let $s\\subset \\alpha$ be a fundamental domain for the action of $G$ on $\\alpha$. Let $f:\\alpha\\to\\alpha$ be a measure-preserving bijection. Then $f(s)$ is a fundamental domain for the action of $G$ on $\\alpha$."}
{"name": "linear_map.coe_single", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/pi.lean", "formal_statement": "theorem linear_map.coe_single {R : Type u} {\u03b9 : Type x} [semiring R]\n\t{\u03c6 : \u03b9 \u2192 Type i} [\u03a0 (i : \u03b9), add_comm_monoid (\u03c6 i)] [\u03a0 (i : \u03b9), module R (\u03c6 i)]\n\t[decidable_eq \u03b9] (i : \u03b9) :\n\t\u21d1(linear_map.single i) = pi.single i :=", "nl_statement_of_codex": "Let $R$ be a semiring, let $\\phi$ be a family of $R$-modules indexed by $\\iota$. Then the map $\\phi\\mapsto\\phi_i$ is a linear map."}
{"name": "euclidean.nhds_basis_closed_ball", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/inner_product_space/euclidean_dist.lean", "formal_statement": "theorem euclidean.nhds_basis_closed_ball {E : Type*} [normed_group E]\n\t[normed_space \u211d E] [finite_dimensional \u211d E] {x : E} :\n\t(nhds x).has_basis (\u03bb (r : \u211d), 0 < r) (euclidean.closed_ball x) :=", "nl_statement_of_codex": "The closed ball of radius $r$ centered at $x$ is a basis for the topology of $E$."}
{"name": "list.sublist.refl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.sublist.refl {\u03b1 : Type u} (l : list \u03b1) :\n\tl <+ l :=", "nl_statement_of_codex": "A list is a sublist of itself."}
{"name": "order.pred_mono", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/succ_pred/basic.lean", "formal_statement": "theorem order.pred_mono {\u03b1 : Type*} [preorder \u03b1] [pred_order \u03b1] :\n\tmonotone order.pred :=", "nl_statement_of_codex": "The predecessor function is monotone."}
{"name": "generalized_continued_fraction.denominators_stable_of_terminated", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/continued_fractions/terminated_stable.lean", "formal_statement": "theorem generalized_continued_fraction.denominators_stable_of_terminated\n\t{K : Type*} {g : generalized_continued_fraction K} {n m : \u2115} [division_ring K]\n\t(n_le_m : n \u2264 m) (terminated_at_n : g.terminated_at n) :\n\tg.denominators m = g.denominators n :=", "nl_statement_of_codex": "Let $g$ be a generalized continued fraction. If $g$ terminates at $n$, then the denominators of $g$ are stable after $n$."}
{"name": "local_equiv.trans_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/logic/equiv/local_equiv.lean", "formal_statement": "theorem local_equiv.trans_assoc {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (e : local_equiv \u03b1 \u03b2)\n\t(e' : local_equiv \u03b2 \u03b3) (e'' : local_equiv \u03b3 \u03b4) :\n\t(e.trans e').trans e'' = e.trans (e'.trans e'') :=", "nl_statement_of_codex": "The composition of local equivalences is associative."}
{"name": "homeomorph.to_equiv_injective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/homeomorph.lean", "formal_statement": "theorem homeomorph.to_equiv_injective {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] :\n\tfunction.injective homeomorph.to_equiv :=", "nl_statement_of_codex": "The function $f\\mapsto f^{-1}$ is injective on the set of homeomorphisms from $X$ to $Y$."}
{"name": "affine_independent_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/affine_space/independent.lean", "formal_statement": "theorem affine_independent_equiv {k V P : Type*} [ring k] [add_comm_group V]\n\t[module k V] [add_torsor V P] {\u03b9 \u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') {p : \u03b9' \u2192 P} :\n\taffine_independent k (p \u2218 \u21d1e) \u2194 affine_independent k p :=", "nl_statement_of_codex": "Let $k$ be a ring, $V$ a $k$-module, $P$ an affine space over $V$, and $e: \\iota\\to\\iota'$ a bijection. Then $p\\circ e$ is affinely independent if and only if $p$ is affinely independent."}
{"name": "nat.exists_lt_succ", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/nat/basic.lean", "formal_statement": "theorem nat.exists_lt_succ {P : \u2115 \u2192 Prop} {n : \u2115} :\n\t(\u2203 (m : \u2115) (H : m < n.succ), P m) \u2194 (\u2203 (m : \u2115) (H : m < n), P m) \u2228 P n :=", "nl_statement_of_codex": "There exists a natural number $m$ such that $m<n+1$ and $P(m)$ holds if and only if there exists a natural number $m$ such that $m<n$ and $P(m)$ holds or $P(n)$ holds."}
{"name": "measure_theory.is_stopping_time.measurable_set_eq_of_countable'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/probability/stopping.lean", "formal_statement": "theorem measure_theory.is_stopping_time.measurable_set_eq_of_countable'\n\t{\u03b1 \u03b9 : Type*} {m : measurable_space \u03b1} [linear_order \u03b9]\n\t{f : measure_theory.filtration \u03b9 m} {\u03c4 : \u03b1 \u2192 \u03b9}\n\t(h\u03c4 : measure_theory.is_stopping_time f \u03c4)\n\t(h_countable : (set.range \u03c4).countable) (i : \u03b9) :\n\tmeasurable_set {x : \u03b1 | \u03c4 x = i} :=", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\tau:X\\to\\mathbb{N}$ be a stopping time. Then the set $\\{x\\in X\\mid \\tau(x)=i\\}$ is measurable for each $i\\in\\mathbb{N}$."}
{"name": "filter.eventually_false_iff_eq_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.eventually_false_iff_eq_bot {\u03b1 : Type u} {f : filter \u03b1} :\n\t(\u2200\u1da0 (x : \u03b1) in f, false) \u2194 f = \u22a5 :=", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$. Then $f$ is eventually false if and only if $f$ is the empty filter."}
{"name": "is_unit.mul_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group/units.lean", "formal_statement": "theorem is_unit.mul_iff {M : Type*} [comm_monoid M] {x y : M} :\n\tis_unit (x * y) \u2194 is_unit x \u2227 is_unit y :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid. Then $x*y$ is a unit if and only if $x$ and $y$ are units."}
{"name": "bdd_below_inv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/bounds.lean", "formal_statement": "theorem bdd_below_inv {G : Type*} [group G] [preorder G]\n\t[covariant_class G G has_mul.mul has_le.le]\n\t[covariant_class G G (function.swap has_mul.mul) has_le.le] {s : set G} :\n\tbdd_below s\u207b\u00b9 \u2194 bdd_above s :=", "nl_statement_of_codex": "Let $G$ be a group with a preorder. Then $s$ is bounded below if and only if $s^{-1}$ is bounded above."}
{"name": "bool.cond_ff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/bool/basic.lean", "formal_statement": "theorem bool.cond_ff {\u03b1 : Type*} (t e : \u03b1) :\n\tcond bool.ff t e = e :=", "nl_statement_of_codex": "The conditional expression $cond(false, t, e)$ is equal to $e$."}
{"name": "list.pmap_congr", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.pmap_congr {\u03b1 : Type u} {\u03b2 : Type v} {p q : \u03b1 \u2192 Prop}\n\t{f : \u03a0 (a : \u03b1), p a \u2192 \u03b2} {g : \u03a0 (a : \u03b1), q a \u2192 \u03b2} (l : list \u03b1)\n\t{H\u2081 : \u2200 (a : \u03b1), a \u2208 l \u2192 p a} {H\u2082 : \u2200 (a : \u03b1), a \u2208 l \u2192 q a}\n\t(h : \u2200 (a : \u03b1) (h\u2081 : p a) (h\u2082 : q a), f a h\u2081 = g a h\u2082) :\n\tlist.pmap f l H\u2081 = list.pmap g l H\u2082 :=", "nl_statement_of_codex": "Let $l$ be a list of elements of $A$. Let $p, q:A\\to B$ be two functions such that $p(a)=q(a)$ for all $a\\in l$. Then $p(l)=q(l)$."}
{"name": "dfinsupp.to_finsupp_to_dfinsupp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/finsupp/to_dfinsupp.lean", "formal_statement": "theorem dfinsupp.to_finsupp_to_dfinsupp {\u03b9 M : Type*} [decidable_eq \u03b9]\n\t[has_zero M] [\u03a0 (m : M), decidable (m \u2260 0)] (f : \u03a0\u2080 (i : \u03b9), M) :\n\tf.to_finsupp.to_dfinsupp = f :=", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to M$ be a function with finite support. Then $f$ is the same as the function $f':\\mathbb{N}\\to M$ defined by $f'(n)=f(n)$ if $f(n)\\neq 0$ and $f'(n)=0$ otherwise."}
{"name": "int.coe_nat_succ", "filename": "/home/rob/.elan/toolchains/leanprover-community--lean---3.45.0/lib/lean/library/init/data/int/basic.lean", "formal_statement": "theorem int.coe_nat_succ (n : \u2115) :\n\t\u2191(n.succ) = \u2191n + 1 :=", "nl_statement_of_codex": "$\\mathbb{Z}$ is a ring."}
{"name": "diffeomorph.symm_to_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/geometry/manifold/diffeomorph.lean", "formal_statement": "theorem diffeomorph.symm_to_equiv {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {H : Type*} [topological_space H] {G : Type*}\n\t[topological_space G] {I : model_with_corners \ud835\udd5c E H}\n\t{J : model_with_corners \ud835\udd5c F G} {M : Type*} [topological_space M]\n\t[charted_space H M] {N : Type*1} [topological_space N] [charted_space G N]\n\t{n : with_top \u2115} (h : diffeomorph I J M N n) :\n\th.symm.to_equiv = h.to_equiv.symm :=", "nl_statement_of_codex": "Let $I$ and $J$ be models with corners, $M$ and $N$ be manifolds, and $n$ be a natural number. If $h:I\\to J$ is a diffeomorphism, then $h^{-1}$ is a diffeomorphism."}
{"name": "simple_graph.comap_surjective", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/basic.lean", "formal_statement": "theorem simple_graph.comap_surjective {V : Type u} {W : Type v} (f : V \u21aa W) :\n\tfunction.surjective (simple_graph.comap \u21d1f) :=", "nl_statement_of_codex": "Let $f:V\\to W$ be an injective function. Then the function $f^*:E(W)\\to E(V)$ defined by $f^*(e)=f^{-1}(e)$ is surjective."}
{"name": "set.inter_union_compl", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/basic.lean", "formal_statement": "theorem set.inter_union_compl {\u03b1 : Type u} (s t : set \u03b1) :\n\ts \u2229 t \u222a s \u2229 t\u1d9c = s :=", "nl_statement_of_codex": "$S\\cap T\\cup S\\cap T^c=S$."}
{"name": "filter.ne_bot.mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/pointwise.lean", "formal_statement": "theorem filter.ne_bot.mul {\u03b1 : Type*} [has_mul \u03b1] {f g : filter \u03b1} :\n\tf.ne_bot \u2192 g.ne_bot \u2192 (f * g).ne_bot :=", "nl_statement_of_codex": "Let $f$ and $g$ be filters on a set $X$. If $f$ and $g$ are not trivial, then $f\\cdot g$ is not trivial."}
{"name": "deriv_within_clm_apply", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/calculus/deriv.lean", "formal_statement": "theorem deriv_within_clm_apply {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {x : \ud835\udd5c} {s : set \ud835\udd5c}\n\t{G : Type*} [normed_group G] [normed_space \ud835\udd5c G] { : \ud835\udd5c \u2192 (F \u2192L[\ud835\udd5c] G)}\n\t{u : \ud835\udd5c \u2192 F} (hxs : unique_diff_within_at \ud835\udd5c s x)\n\t(hc : differentiable_within_at \ud835\udd5c c s x) (hu : differentiable_within_at \ud835\udd5c u s x) :\n\tderiv_within (\u03bb (y : \ud835\udd5c), \u21d1(c y) (u y)) s x = \u21d1(deriv_within c s x) (u x) + \u21d1(c x) (deriv_within u s x) :=", "nl_statement_of_codex": "Let $F$ and $G$ be normed spaces over a nondiscrete normed field $K$. Let $c:K\\to L(F,G)$ and $u:K\\to F$ be differentiable at $x\\in K$. Then the function $K\\to G$ defined by $y\\mapsto c(y)(u(y))$ is differentiable at $x$ and its derivative at $x$ is $c'(x)(u(x))+c(x)(u'(x))$."}
{"name": "push_neg.not_and_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/tactic/push_neg.lean", "formal_statement": "theorem push_neg.not_and_eq (p q : Prop) :\n\t(\u00ac(p \u2227 q)) = (p \u2192 \u00acq) :=", "nl_statement_of_codex": "$\\neg(p\\land q)$ is equivalent to $p\\to\\neg q$."}
{"name": "subring.coe_to_add_subgroup", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/subring/basic.lean", "formal_statement": "theorem subring.coe_to_add_subgroup {R : Type u} [ring R] (s : subring R) :\n\t\u2191(s.to_add_subgroup) = \u2191s :=", "nl_statement_of_codex": "Let $R$ be a ring and let $S$ be a subring of $R$. Then $S$ is a subgroup of the additive group of $R$."}
{"name": "sub_le_sub_right", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/group.lean", "formal_statement": "theorem sub_le_sub_right {\u03b1 : Type u} [add_group \u03b1] [has_le \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b : \u03b1}\n\t(h : a \u2264 b) ( : \u03b1) :\n\ta - c \u2264 b - c :=", "nl_statement_of_codex": "Let $a,b,c$ be elements of an ordered abelian group. If $a\\leq b$, then $a-c\\leq b-c$."}
{"name": "simple_graph.common_neighbors_top_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/combinatorics/simple_graph/basic.lean", "formal_statement": "theorem simple_graph.common_neighbors_top_eq {V : Type u} {v w : V} :\n\t\u22a4.common_neighbors v w = set.univ \\ {v, w} :=", "nl_statement_of_codex": "The common neighbors of $v$ and $w$ in the complete graph on $V$ is the set of all vertices in $V$ except $v$ and $w$."}
{"name": "rel.image_subset_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/rel.lean", "formal_statement": "theorem rel.image_subset_iff {\u03b1 \u03b2 : Type*} (r : rel \u03b1 \u03b2) (s : set \u03b1) (t : set \u03b2) :\n\tr.image s \u2286 t \u2194 s \u2286 r.core t :=", "nl_statement_of_codex": "Let $r$ be a relation from $A$ to $B$. Then $r(A)\\subset B$ if and only if $A\\subset r^{-1}(B)$."}
{"name": "eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/dynamics/omega_limit.lean", "formal_statement": "theorem eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset\n\t{\u03c4 \u03b1 \u03b2 : Type*} [topological_space \u03b2] (f : filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2)\n\t(s : set \u03b1) [t2_space \u03b2] { : set \u03b2} (hc\u2081 : is_compact c)\n\t(hc\u2082 : \u2200\u1da0 (t : \u03c4) in f, set.maps_to (\u03d5 t) s c) {n : set \u03b2} (hn\u2081 : is_open n)\n\t(hn\u2082 : omega_limit f \u03d5 s \u2286 n) :\n\t\u2203 (u : set \u03c4) (H : u \u2208 f), closure (set.image2 \u03d5 u s) \u2286 n :=", "nl_statement_of_codex": "Let $f$ be a filter on $\\tau$, let $\\phi:\\tau\\times\\alpha\\to\\beta$ be a function, let $s$ be a subset of $\\alpha$, let $c$ be a compact subset of $\\beta$, and let $n$ be an open subset of $\\beta$. Suppose that for every $t\\in\\tau$ in $f$, $\\phi(t,s)\\subset c$ and that $\\omega(f,\\phi,s)\\subset n$. Then there is a set $u\\in f$ such that $\\overline{\\phi(u,s)}\\subset n$."}
{"name": "sq_add_mul_sq_mul_sq_add_mul_sq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/group_power/identities.lean", "formal_statement": "theorem sq_add_mul_sq_mul_sq_add_mul_sq {R : Type*} [comm_ring R]\n\t{x\u2081 x\u2082 y\u2081 y\u2082 n : R} :\n\t(x\u2081 ^ 2 + n * x\u2082 ^ 2) * (y\u2081 ^ 2 + n * y\u2082 ^ 2) = (x\u2081 * y\u2081 - n * x\u2082 * y\u2082) ^ 2 + n * (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2 :=", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $x_1, x_2, y_1, y_2, n\\in R$. Then $(x_1^2+nx_2^2)(y_1^2+ny_2^2)=(x_1y_1-nx_2y_2)^2+n(x_1y_2+x_2y_1)^2$."}
{"name": "cardinal.prod_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/set_theory/cardinal/basic.lean", "formal_statement": "theorem cardinal.prod_const (\u03b9 : Type u) (a : cardinal) :\n\tcardinal.prod (\u03bb (i : \u03b9), a) = a.lift ^ (cardinal.mk \u03b9).lift :=", "nl_statement_of_codex": "The cardinality of the product of a family of sets is the cardinality of the indexing set raised to the power of the cardinality of each set."}
{"name": "bdd_above_Icc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounds.lean", "formal_statement": "theorem bdd_above_Icc {\u03b1 : Type u} [preorder \u03b1] {a b : \u03b1} :\n\tbdd_above (set.Icc a b) :=", "nl_statement_of_codex": "The set $\\{x\\in\\mathbb{R}:a\\leq x\\leq b\\}$ is bounded above."}
{"name": "list.forall_mem_singleton", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/basic.lean", "formal_statement": "theorem list.forall_mem_singleton {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} {a : \u03b1} :\n\t(\u2200 (x : \u03b1), x \u2208 [a] \u2192 p x) \u2194 p a :=", "nl_statement_of_codex": "For any property $p$ of elements of a type $\u03b1$, the property $p$ holds for all elements of the singleton list $[a]$ if and only if $p$ holds for $a$."}
{"name": "polynomial.separable_C", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/field_theory/separable.lean", "formal_statement": "theorem polynomial.separable_C {R : Type u} [comm_semiring R] (r : R) :\n\t(\u21d1polynomial.C r).separable \u2194 is_unit r :=", "nl_statement_of_codex": "The polynomial $x-r$ is separable if and only if $r$ is a unit."}
{"name": "complex.ext_abs_arg", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/special_functions/complex/arg.lean", "formal_statement": "theorem complex.ext_abs_arg {x y : \u2102} (h\u2081 : complex.abs x = complex.abs y)\n\t(h\u2082 : x.arg = y.arg) :\n\tx = y :=", "nl_statement_of_codex": "If $x$ and $y$ are complex numbers with the same absolute value and the same argument, then $x=y$."}
{"name": "matrix.det_conj_transpose", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/linear_algebra/matrix/determinant.lean", "formal_statement": "theorem matrix.det_conj_transpose {m : Type*} [decidable_eq m] [fintype m]\n\t{R : Type v} [comm_ring R] [star_ring R] (M : matrix m m R) :\n\tM.conj_transpose.det = has_star.star M.det :=", "nl_statement_of_codex": "Let $R$ be a commutative ring with involution. Then the determinant of the conjugate transpose of a matrix $M$ is the conjugate of the determinant of $M$."}
{"name": "strict_mono.mul_const", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/ring.lean", "formal_statement": "theorem strict_mono.mul_const {\u03b1 : Type u} {\u03b2 : Type*}\n\t[linear_ordered_semiring \u03b1] [preorder \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1}\n\t(hf : strict_mono f) (ha : 0 < a) :\n\tstrict_mono (\u03bb (x : \u03b2), f x * a) :=", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{R}$ be a strictly monotone function. Then $f(x)a$ is also strictly monotone for any $a>0$."}
{"name": "bump_covering.le_one", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/partition_of_unity.lean", "formal_statement": "theorem bump_covering.le_one {\u03b9 : Type u} {X : Type v} [topological_space X]\n\t{s : set X} (f : bump_covering \u03b9 X s) (i : \u03b9) (x : X) :\n\t\u21d1(\u21d1f i) x \u2264 1 :=", "nl_statement_of_codex": "Let $X$ be a topological space and let $s$ be a subset of $X$. Let $f$ be a bump covering of $s$. Then for each $i$ and $x$, the value of $f_i$ at $x$ is at most $1$."}
{"name": "mv_polynomial.C_1", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/mv_polynomial/basic.lean", "formal_statement": "theorem mv_polynomial.C_1 {R : Type u} {\u03c3 : Type*} [comm_semiring R] :\n\t\u21d1mv_polynomial.C 1 = 1 :=", "nl_statement_of_codex": "The constant polynomial $1$ is equal to $1$."}
{"name": "measure_theory.measure_preserving_fun_unique", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/constructions/pi.lean", "formal_statement": "theorem measure_theory.measure_preserving_fun_unique {\u03b2 : Type u}\n\t{m : measurable_space \u03b2} (\u03bc : measure_theory.measure \u03b2) (\u03b1 : Type v) [unique \u03b1] :\n\tmeasure_theory.measure_preserving \u21d1(measurable_equiv.fun_unique \u03b1 \u03b2) (measure_theory.measure.pi (\u03bb (a : \u03b1), \u03bc)) \u03bc :=", "nl_statement_of_codex": "Let $\u03b2$ be a measurable space and let $\\mu$ be a measure on $\u03b2$. Let $\u03b1$ be a type with a unique element. Then the function $f:\u03b2\\to \u03b1$ defined by $f(x)=*$ is measure-preserving."}
{"name": "submonoid.localization_map.surj", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/monoid_localization.lean", "formal_statement": "theorem submonoid.localization_map.surj {M : Type*} [comm_monoid M]\n\t{S : submonoid M} {N : Type*} [comm_monoid N] (f : S.localization_map N)\n\t(z : N) :\n\t\u2203 (x : M \u00d7 \u21a5S), z * \u21d1(f.to_map) \u2191(x.snd) = \u21d1(f.to_map) x.fst :=", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, and let $N$ be a commutative monoid. Let $f:S\\to N$ be a map of monoids. Then for each $z\\in N$ there exist $x\\in M$ and $s\\in S$ such that $zf(s)=f(x)$."}
{"name": "category_theory.limits.types.pullback_iso_pullback_hom_snd", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/limits/shapes/types.lean", "formal_statement": "theorem category_theory.limits.types.pullback_iso_pullback_hom_snd\n\t{X Y Z : Type u} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n\t(p : category_theory.limits.pullback f g) :\n\t\u2191((category_theory.limits.types.pullback_iso_pullback f g).hom p).snd = category_theory.limits.pullback.snd p :=", "nl_statement_of_codex": "Let $f:X\\to Z$ and $g:Y\\to Z$ be morphisms in a category. Then the second projection of the pullback of $f$ and $g$ is the same as the second projection of the pullback of the morphisms $f$ and $g$."}
{"name": "sup_bot_hom.coe_comp", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/hom/lattice.lean", "formal_statement": "theorem sup_bot_hom.coe_comp {\u03b1 \u03b2 \u03b3 : Type*} [has_sup \u03b1] [has_bot \u03b1] [has_sup \u03b2]\n\t[has_bot \u03b2] [has_sup \u03b3] [has_bot \u03b3] (f : sup_bot_hom \u03b2 \u03b3) (g : sup_bot_hom \u03b1 \u03b2) :\n\t\u21d1(f.comp g) = \u21d1f \u2218 \u21d1g :=", "nl_statement_of_codex": "Let $f:B\\to C$ and $g:A\\to B$ be sup-bot homomorphisms. Then $f\\circ g$ is a sup-bot homomorphism and $(f\\circ g)^\\sharp=f^\\sharp\\circ g^\\sharp$."}
{"name": "function.antiperiodic.sub_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/periodic.lean", "formal_statement": "theorem function.antiperiodic.sub_eq {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} { : \u03b1}\n\t[add_group \u03b1] [add_group \u03b2] (h : function.antiperiodic f c) (x : \u03b1) :\n\tf (x - c) = -f x :=", "nl_statement_of_codex": "Let $f:A\\to B$ be a function with $A$ and $B$ abelian groups. If $f$ is antiperiodic with period $c$, then $f(x-c)=-f(x)$ for all $x\\in A$."}
{"name": "computation.get_equiv", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/seq/computation.lean", "formal_statement": "theorem computation.get_equiv {\u03b1 : Type u} {c\u2081 c\u2082 : computation \u03b1} (h : c\u2081 ~ c\u2082)\n\t[c\u2081.terminates] [c\u2082.terminates] :\n\tc\u2081.get = c\u2082.get :=", "nl_statement_of_codex": "If two computations $c_1$ and $c_2$ are equivalent and terminate, then they return the same value."}
{"name": "formal_multilinear_series.norm_change_origin_series_term", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/analytic/basic.lean", "formal_statement": "theorem formal_multilinear_series.norm_change_origin_series_term {\ud835\udd5c E F : Type*}\n\t[nondiscrete_normed_field \ud835\udd5c] [normed_group E] [normed_space \ud835\udd5c E]\n\t[normed_group F] [normed_space \ud835\udd5c F] (p : formal_multilinear_series \ud835\udd5c E F)\n\t(k l : \u2115) (s : finset (fin (k + l))) (hs : s.card = l) :\n\t\u2225p.change_origin_series_term k l s hs\u2225 = \u2225p (k + l)\u2225 :=", "nl_statement_of_codex": "Let $p$ be a formal multilinear series. Then the norm of the $k$-th term of the series obtained by changing the origin of $p$ is equal to the norm of the $(k+l)$-th term of $p$."}
{"name": "is_fraction_ring.comap_is_algebraic_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/ring_theory/localization/integral.lean", "formal_statement": "theorem is_fraction_ring.comap_is_algebraic_iff {A K C : Type*} [comm_ring A]\n\t[is_domain A] [field K] [algebra A K] [is_fraction_ring A K] [comm_ring C]\n\t[algebra A C] [algebra K C] [is_scalar_tower A K C] :\n\talgebra.is_algebraic A C \u2194 algebra.is_algebraic K C :=", "nl_statement_of_codex": "Let $A$ be a domain, $K$ its field of fractions, and $C$ a commutative ring. Suppose that $C$ is an $A$-algebra and a $K$-algebra. Then $C$ is an algebraic $A$-algebra if and only if $C$ is an algebraic $K$-algebra."}
{"name": "filter.map_swap4_eq_comap", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/filter/basic.lean", "formal_statement": "theorem filter.map_swap4_eq_comap {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}\n\t{\u03b4 : Type*} {f : filter ((\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4)} :\n\tfilter.map (\u03bb (p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4), ((p.fst.fst, p.snd.fst), p.fst.snd, p.snd.snd)) f = filter.comap (\u03bb (p : (\u03b1 \u00d7 \u03b3) \u00d7 \u03b2 \u00d7 \u03b4), ((p.fst.fst, p.snd.fst), p.fst.snd, p.snd.snd)) f :=", "nl_statement_of_codex": "Let $f$ be a filter on $(\\alpha\\times\\beta)\\times\\gamma\\times\\delta$. Then the filter $f$ is equal to the filter $g$ on $(\\alpha\\times\\gamma)\\times\\beta\\times\\delta$ defined by $g=f\\circ\\phi$, where $\\phi$ is the map $(\\alpha\\times\\beta)\\times\\gamma\\times\\delta\\to(\\alpha\\times\\gamma)\\times\\beta\\times\\delta$ defined by $\\phi((a,b),c,d)=((a,c),b,d)$."}
{"name": "add_submonoid.mem_closure_pair", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/group_theory/submonoid/membership.lean", "formal_statement": "theorem add_submonoid.mem_closure_pair {A : Type*} [add_comm_monoid A]\n\t(a b c : A) :\n\tc \u2208 add_submonoid.closure {a, b} \u2194 \u2203 (m n : \u2115), m \u2022 a + n \u2022 b = c :=", "nl_statement_of_codex": "Let $A$ be an additive commutative monoid. Then $c\\in\\overline{\\{a,b\\}}$ if and only if there are $m,n\\in\\mathbb{N}$ such that $m\\cdot a+n\\cdot b=c$."}
{"name": "measure_theory.vector_measure.measurable_of_not_zero_le_restrict", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/measure_theory/measure/vector_measure.lean", "formal_statement": "theorem measure_theory.vector_measure.measurable_of_not_zero_le_restrict\n\t{\u03b1 : Type*} {m : measurable_space \u03b1} {M : Type*} [topological_space M]\n\t[ordered_add_comm_monoid M] (v : measure_theory.vector_measure \u03b1 M) {i : set \u03b1}\n\t(hi : \u00ac0.restrict i \u2264 v.restrict i) :\n\tmeasurable_set i :=", "nl_statement_of_codex": "Let $v$ be a vector measure on a measurable space $(X,\\mathcal{A})$. If $v(A)>0$ for some $A\\in\\mathcal{A}$, then $A$ is measurable."}
{"name": "antivary.sum_mul_lt_sum_mul_comp_perm_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/order/rearrangement.lean", "formal_statement": "theorem antivary.sum_mul_lt_sum_mul_comp_perm_iff {\u03b9 \u03b1 : Type*}\n\t[linear_ordered_ring \u03b1] {\u03c3 : equiv.perm \u03b9} {f g : \u03b9 \u2192 \u03b1} [fintype \u03b9]\n\t(hfg : antivary f g) :\n\tfinset.univ.sum (\u03bb (i : \u03b9), f i \u2022 g i) < finset.univ.sum (\u03bb (i : \u03b9), f i \u2022 g (\u21d1\u03c3 i)) \u2194 \u00acantivary f (g \u2218 \u21d1\u03c3) :=", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be two functions. Then $f$ is anti-varying with respect to $g$ if and only if $\\sum_{i=1}^n f(i)g(i)<\\sum_{i=1}^n f(i)g(\\sigma(i))$ for all permutations $\\sigma$ of $\\{1,\\ldots,n\\}$."}
{"name": "category_theory.bicategory.pentagon_inv_assoc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/bicategory/basic.lean", "formal_statement": "theorem category_theory.bicategory.pentagon_inv_assoc {B : Type u}\n\t[category_theory.bicategory B] {a b c d e : B} (f : a \u27f6 b) (g : b \u27f6 c)\n\t(h : c \u27f6 d) (i : d \u27f6 e) {X' : a \u27f6 e} (f' : ((f \u226b g) \u226b h) \u226b i \u27f6 X') :\n\tcategory_theory.bicategory.whisker_left f (category_theory.bicategory.associator g h i).inv \u226b (category_theory.bicategory.associator f (g \u226b h) i).inv \u226b category_theory.bicategory.whisker_right (category_theory.bicategory.associator f g h).inv i \u226b f' = (category_theory.bicategory.associator f g (h \u226b i)).inv \u226b (category_theory.bicategory.associator (f \u226b g) h i).inv \u226b f' :=", "nl_statement_of_codex": "Let $B$ be a bicategory. Let $a,b,c,d,e$ be objects of $B$ and let $f:a\\to b$, $g:b\\to c$, $h:c\\to d$, $i:d\\to e$ be morphisms in $B$. Let $X':((f\\circ g)\\circ h)\\circ i\\to e$ be a morphism in $B$. Then the following diagram commutes:\n\\begin{center}\n\\begin{tikzcd}\n((f\\circ g)\\circ h)\\circ i \\arrow[r, "}
{"name": "list.mem_of_mem_suffix", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/list/infix.lean", "formal_statement": "theorem list.mem_of_mem_suffix {\u03b1 : Type*} {l\u2081 l\u2082 : list \u03b1} {a : \u03b1}\n\t(hx : a \u2208 l\u2081) (hl : l\u2081 <:+ l\u2082) :\n\ta \u2208 l\u2082 :=", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of elements of a type $\u03b1$. If $a$ is an element of $l_1$ and $l_1$ is a suffix of $l_2$, then $a$ is an element of $l_2$."}
{"name": "sup_bot_eq", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/bounded_order.lean", "formal_statement": "theorem sup_bot_eq {\u03b1 : Type u} [semilattice_sup \u03b1] [order_bot \u03b1] {a : \u03b1} :\n\ta \u2294 \u22a5 = a :=", "nl_statement_of_codex": "Let $a$ be an element of a semilattice with bottom. Then $a\\vee\\bot=a$."}
{"name": "quaternion.conj_mul", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/algebra/quaternion.lean", "formal_statement": "theorem quaternion.conj_mul {R : Type*} [comm_ring R] (a b : quaternion R) :\n\t\u21d1quaternion.conj (a * b) = \u21d1quaternion.conj b * \u21d1quaternion.conj a :=", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then the conjugate of the product of two quaternions is the product of the conjugates of the quaternions."}
{"name": "category_theory.differential_object.zero_f", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/category_theory/differential_object.lean", "formal_statement": "theorem category_theory.differential_object.zero_f {C : Type u}\n\t[category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t[category_theory.has_shift C \u2124] (P Q : category_theory.differential_object C) :\n\t0.f = 0 :=", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms and a shift functor. Let $P$ and $Q$ be differential objects in $C$. Then $0.f=0$."}
{"name": "continuous_map.coe_const'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/topology/compact_open.lean", "formal_statement": "theorem continuous_map.coe_const' {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] :\n\t\u21d1continuous_map.const' = continuous_map.const \u03b1 :=", "nl_statement_of_codex": "The map $f:X\\to Y$ is continuous if and only if $f$ is constant."}
{"name": "lower_set.coe_bot", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/order/upper_lower.lean", "formal_statement": "theorem lower_set.coe_bot {\u03b1 : Type*} [has_le \u03b1] :\n\t\u2191\u22a5 = \u2205 :=", "nl_statement_of_codex": "The lower set corresponding to the empty set is the empty set."}
{"name": "part.mem_some_iff", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/part.lean", "formal_statement": "theorem part.mem_some_iff {\u03b1 : Type*} {a b : \u03b1} :\n\tb \u2208 part.some a \u2194 b = a :=", "nl_statement_of_codex": "$b$ is in the part of $a$ if and only if $b=a$."}
{"name": "normed_group_hom.mk_normed_group_hom_norm_le'", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/analysis/normed/group/hom.lean", "formal_statement": "theorem normed_group_hom.mk_normed_group_hom_norm_le' {V\u2081 V\u2082 : Type*}\n\t[semi_normed_group V\u2081] [semi_normed_group V\u2082] (f : V\u2081 \u2192+ V\u2082) {C : \u211d}\n\t(h : \u2200 (x : V\u2081), \u2225\u21d1f x\u2225 \u2264 C * \u2225x\u2225) :\n\t\u2225f.mk_normed_group_hom C h\u2225 \u2264 linear_order.max C 0 :=", "nl_statement_of_codex": "Let $V_1$ and $V_2$ be semi-normed groups and let $f:V_1\\to V_2$ be a group homomorphism. Let $C\\in\\mathbb{R}$ and suppose that $\\|f(x)\\|\\leq C\\|x\\|$ for all $x\\in V_1$. Then $\\|f\\|\\leq \\max\\{C,0\\}$."}
{"name": "set.preimage_sub_const_Icc", "filename": "/home/rob/lean/doc-gen/_target/deps/mathlib/src/data/set/intervals/image_preimage.lean", "formal_statement": "theorem set.preimage_sub_const_Icc {G : Type u} [ordered_add_comm_group G]\n\t(a b c : G) :\n\t(\u03bb (x : G), x - a) \u207b\u00b9' set.Icc b c = set.Icc (b + a) (c + a) :=", "nl_statement_of_codex": "Let $G$ be an ordered abelian group. Then the preimage of the interval $[b,c]$ under the function $x\\mapsto x-a$ is the interval $[b+a,c+a]$."}