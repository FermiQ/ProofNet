{"formal_statement": "theorem exists_mem_multiset_map_dvd {\u03b1 \u03b2 : Type*} [comm_monoid_with_zero \u03b1]\n\t{p : \u03b1} (hp : prime p) (h : p \u2223 (multiset.map f s).prod) :\n\t\u2200 {s : multiset \u03b2} {f : \u03b2 \u2192 \u03b1},  (\u2203 (a : \u03b2) (H : a \u2208 s), p \u2223 f a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : comm_monoid_with_zero \u03b1] {p : \u03b1}, prime p \u2192 \u2200 {s : multiset \u03b2} {f : \u03b2 \u2192 \u03b1}, p \u2223 (multiset.map f s).prod \u2192 (\u2203 (a : \u03b2) (H : a \u2208 s), p \u2223 f a)", "decl_nm": "prime.exists_mem_multiset_map_dvd", "nl_statement_of_codex": "Let $p$ be a prime and let $f:S\\to A$ be a function from a multiset $S$ to a commutative monoid with zero $A$. If $p$ divides the product of the images of $f$, then there is an element $a\\in S$ such that $p$ divides $f(a)$."}
{"formal_statement": "theorem is_complement'_top_left {G : Type*} [group G] {H : subgroup G} :\n\t\u22a4.is_complement' H \u2194 H = \u22a5", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H : subgroup G}, \u22a4.is_complement' H \u2194 H = \u22a5", "decl_nm": "subgroup.is_complement'_top_left", "nl_statement_of_codex": "Let $G$ be a group and let $H$ be a subgroup of $G$. Then $H$ is a complement of the trivial subgroup if and only if $H$ is the trivial subgroup."}
{"formal_statement": "theorem single_apply {\u03b1 : Type u} {\u03b2 : Type v} [decidable_eq \u03b1] [decidable_eq \u03b2]\n\t(a : \u03b1) (b : \u03b2) :\n\t\u21d1(pequiv.single a b) a = option.some b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : decidable_eq \u03b1] [_inst_2 : decidable_eq \u03b2] (a : \u03b1) (b : \u03b2), \u21d1(pequiv.single a b) a = option.some b", "decl_nm": "pequiv.single_apply", "nl_statement_of_codex": "The function $f:\\{a\\}\\to\\{b\\}$ defined by $f(a)=b$ is a bijection."}
{"formal_statement": "theorem sinh {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{s : set E} {n : with_top \u2115} (hf : times_cont_diff_on \u211d n f s) :\n\ttimes_cont_diff_on \u211d n (\u03bb (x : E), real.sinh (f x)) s", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {s : set E} {n : with_top \u2115}, times_cont_diff_on \u211d n f s \u2192 times_cont_diff_on \u211d n (\u03bb (x : E), real.sinh (f x)) s", "decl_nm": "times_cont_diff_on.sinh", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ and let $f:E\\to\\mathbb{R}$. If $f$ is $n$ times continuously differentiable on $E$, then $\\sinh(f)$ is $n$ times continuously differentiable on $E$."}
{"formal_statement": "theorem closure_univ {G : Type*} [group G] :\n\tsubgroup.closure set.univ = \u22a4", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G], subgroup.closure set.univ = \u22a4", "decl_nm": "subgroup.closure_univ", "nl_statement_of_codex": "The closure of the trivial subgroup is the whole group."}
{"formal_statement": "theorem coe_one {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n\t\u21d11 = id", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, \u21d11 = id", "decl_nm": "rel_iso.coe_one", "nl_statement_of_codex": "The equivalence class of the identity relation is the identity function."}
{"formal_statement": "theorem le_iff_exists_add {\u03b1 : Type*} {s t : multiset \u03b1} :\n\ts \u2264 t \u2194 \u2203 (u : multiset \u03b1), t = s + u", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : multiset \u03b1}, s \u2264 t \u2194 \u2203 (u : multiset \u03b1), t = s + u", "decl_nm": "multiset.le_iff_exists_add", "nl_statement_of_codex": "Let $s$ and $t$ be multisets. Then $s\\leq t$ if and only if there is a multiset $u$ such that $t=s+u$."}
{"formal_statement": "theorem pullback_cone_of_left_iso_snd {C : Type u} [category_theory.category C]\n\t{X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [category_theory.is_iso f] :\n\t(category_theory.limits.pullback_cone_of_left_iso f g).snd = \ud835\udfd9 (category_theory.limits.pullback_cone_of_left_iso f g).X", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [_inst_2 : category_theory.is_iso f], (category_theory.limits.pullback_cone_of_left_iso f g).snd = \ud835\udfd9 (category_theory.limits.pullback_cone_of_left_iso f g).X", "decl_nm": "category_theory.limits.pullback_cone_of_left_iso_snd", "nl_statement_of_codex": "Let $f:X\\to Z$ and $g:Y\\to Z$ be morphisms in a category $C$. If $f$ is an isomorphism, then the second projection of the pullback of $f$ and $g$ is the identity morphism."}
{"formal_statement": "theorem image2_empty_left {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {t : set \u03b2} :\n\tset.image2 f \u2205 t = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {t : set \u03b2}, set.image2 f \u2205 t = \u2205", "decl_nm": "set.image2_empty_left", "nl_statement_of_codex": "The image of the empty set under the function $f:\\alpha\\times\\beta\\to\\gamma$ is the empty set."}
{"formal_statement": "theorem conjugates_of_set_subset_normal_closure {G : Type*} {s : set G}\n\t[group G] :\n\tgroup.conjugates_of_set s \u2286 group.normal_closure s", "decl_tp": "\u2200 {G : Type u_1} {s : set G} [_inst_1 : group G], group.conjugates_of_set s \u2286 group.normal_closure s", "decl_nm": "group.conjugates_of_set_subset_normal_closure", "nl_statement_of_codex": "The set of conjugates of a subset $s$ of a group $G$ is contained in the normal closure of $s$."}
{"formal_statement": "theorem restrict_carrier {C : Type u} [category_theory.category C] {U : Top}\n\t(X : algebraic_geometry.PresheafedSpace C) {f : U \u27f6 \u2191X} (h : open_embedding \u21d1f) :\n\t(X.restrict h).carrier = U", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {U : Top} (X : algebraic_geometry.PresheafedSpace C) {f : U \u27f6 \u2191X} (h : open_embedding \u21d1f), (X.restrict h).carrier = U", "decl_nm": "algebraic_geometry.PresheafedSpace.restrict_carrier", "nl_statement_of_codex": "Let $X$ be a presheafed space over a category $C$. Let $U$ be a topological space and let $f:U\\to X$ be an open embedding. Then the carrier of the restriction of $X$ to $U$ is $U$."}
{"formal_statement": "theorem no_zero_divisors {M\u2080 M\u2080' : Type*} [has_mul M\u2080] [has_zero M\u2080] [has_mul M\u2080']\n\t[has_zero M\u2080'] [no_zero_divisors M\u2080'] (f : M\u2080 \u2192 M\u2080') (hf : function.injective f)\n\t(zero : f 0 = 0) :\n\t(\u2200 (x y : M\u2080), f (x * y) = f x * f y) \u2192 no_zero_divisors M\u2080", "decl_tp": "\u2200 {M\u2080 : Type u_1} {M\u2080' : Type u_3} [_inst_1 : has_mul M\u2080] [_inst_2 : has_zero M\u2080] [_inst_3 : has_mul M\u2080'] [_inst_4 : has_zero M\u2080'] [_inst_5 : no_zero_divisors M\u2080'] (f : M\u2080 \u2192 M\u2080'), function.injective f \u2192 f 0 = 0 \u2192 (\u2200 (x y : M\u2080), f (x * y) = f x * f y) \u2192 no_zero_divisors M\u2080", "decl_nm": "function.injective.no_zero_divisors", "nl_statement_of_codex": "Let $M_0$ and $M_0'$ be two rings. Let $f:M_0\\to M_0'$ be an injective ring homomorphism. If $M_0'$ has no zero divisors, then $M_0$ has no zero divisors."}
{"formal_statement": "theorem dual_right {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {s : set \u03b1} (hf : monotone_on f s) :\n\tantitone_on (\u21d1order_dual.to_dual \u2218 f) s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}, monotone_on f s \u2192 antitone_on (\u21d1order_dual.to_dual \u2218 f) s", "decl_nm": "monotone_on.dual_right", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function. Then the dual function $f^*:B^*\\to A^*$ is antitone."}
{"formal_statement": "theorem is_O_with_iff {\u03b1 E F : Type*} [has_norm E] [has_norm F] {c : \u211d}\n\t{f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : filter \u03b1} :\n\tasymptotics.is_O_with c f g l \u2194 \u2200\u1da0 (x : \u03b1) in l, \u2225f x\u2225 \u2264 c * \u2225g x\u2225", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {c : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : filter \u03b1}, asymptotics.is_O_with c f g l \u2194 \u2200\u1da0 (x : \u03b1) in l, \u2225f x\u2225 \u2264 c * \u2225g x\u2225", "decl_nm": "asymptotics.is_O_with_iff", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces and let $f,g:\\alpha\\to E,F$ be functions. Then $f$ is $O(g)$ if and only if $\\|f(x)\\|\\leq c\\|g(x)\\|$ for all $x$ in some filter $\\alpha$."}
{"formal_statement": "theorem neg_to_equiv (G : Type*) [measurable_space G] [add_group G] [has_measurable_neg G] :\n\t(measurable_equiv.neg G).to_equiv = equiv.neg G", "decl_tp": "\u2200 (G : Type u_1) [_inst_1 : measurable_space G] [_inst_4 : add_group G] [_inst_10 : has_measurable_neg G], (measurable_equiv.neg G).to_equiv = equiv.neg G", "decl_nm": "measurable_equiv.neg_to_equiv", "nl_statement_of_codex": "The measurable equivalence $G\\to -G$ is the same as the group equivalence $G\\to -G$."}
{"formal_statement": "theorem find_red_of_incomp {\u03b1 : Type u} (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) [decidable_rel lt]\n\t{l : rbnode \u03b1} {y : \u03b1} {r : rbnode \u03b1} {x : \u03b1} (h : \u00aclt x y \u2227 \u00aclt y x) :\n\trbnode.find lt (l.red_node y r) x = option.some y", "decl_tp": "\u2200 {\u03b1 : Type u} (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) [_inst_1 : decidable_rel lt] {l : rbnode \u03b1} {y : \u03b1} {r : rbnode \u03b1} {x : \u03b1}, \u00aclt x y \u2227 \u00aclt y x \u2192 rbnode.find lt (l.red_node y r) x = option.some y", "decl_nm": "rbnode.find_red_of_incomp", "nl_statement_of_codex": "Let $l, r$ be red-black trees and let $x, y$ be elements of the underlying set. If $x$ and $y$ are incomparable, then $y$ is the result of searching for $x$ in the red-black tree $l.red_node y r$."}
{"formal_statement": "theorem coe_neg (x : \u211d) :\n\t\u2191-x = -\u2191x", "decl_tp": "\u2200 (x : \u211d), \u2191-x = -\u2191x", "decl_nm": "ereal.coe_neg", "nl_statement_of_codex": "The negation of a real number is the negation of the corresponding extended real number."}
{"formal_statement": "theorem prod_assoc_apply (\u03b1 \u03b2 \u03b3 : Type*) (p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3) :\n\t\u21d1(equiv.prod_assoc \u03b1 \u03b2 \u03b3) p = (p.fst.fst, p.fst.snd, p.snd)", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u03b2 : Type u_2) (\u03b3 : Type u_3) (p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3), \u21d1(equiv.prod_assoc \u03b1 \u03b2 \u03b3) p = (p.fst.fst, p.fst.snd, p.snd)", "decl_nm": "equiv.prod_assoc_apply", "nl_statement_of_codex": "The equivalence $(\\alpha\\times\\beta)\\times\\gamma\\cong\\alpha\\times\\beta\\times\\gamma$ is given by $(a,b,c)\\mapsto((a,b),c)$."}
{"formal_statement": "theorem congr' {\u03b1 \u03b2 \u03b3 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] [normed_group \u03b3] [measurable_space \u03b2] [measurable_space \u03b3]\n\t{f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} (hf : measure_theory.integrable f \u03bc) (hg : ae_measurable g \u03bc) :\n\t(\u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2225f a\u2225 = \u2225g a\u2225) \u2192 measure_theory.integrable g \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] [_inst_2 : normed_group \u03b3] [_inst_3 : measurable_space \u03b2] [_inst_4 : measurable_space \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3}, measure_theory.integrable f \u03bc \u2192 ae_measurable g \u03bc \u2192 (\u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2225f a\u2225 = \u2225g a\u2225) \u2192 measure_theory.integrable g \u03bc", "decl_nm": "measure_theory.integrable.congr'", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be measurable functions. If $f$ is integrable and $g$ is almost everywhere equal to $f$, then $g$ is integrable."}
{"formal_statement": "theorem to_finmap_entries {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} (s : alist \u03b2) :\n\ts.to_finmap.entries = \u2191(s.entries)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} (s : alist \u03b2), s.to_finmap.entries = \u2191(s.entries)", "decl_nm": "alist.to_finmap_entries", "nl_statement_of_codex": "The entries of the finmap associated to an alist are the same as the entries of the alist."}
{"formal_statement": "theorem div_eq_zero_of_lt {a b : \u2124} (H1 : 0 \u2264 a) (H2 : a < b) :\n\ta / b = 0", "decl_tp": "\u2200 {a b : \u2124}, 0 \u2264 a \u2192 a < b \u2192 a / b = 0", "decl_nm": "int.div_eq_zero_of_lt", "nl_statement_of_codex": "If $a$ and $b$ are integers with $0\\leq a<b$, then $a/b=0$."}
{"formal_statement": "theorem cons_le {n : \u2115} {\u03b1 : fin (n + 1) \u2192 Type u} [\u03a0 (i : fin (n + 1)), preorder (\u03b1 i)]\n\t{x : \u03b1 0} {q : \u03a0 (i : fin (n + 1)), \u03b1 i} {p : \u03a0 (i : fin n), \u03b1 i.succ} :\n\tfin.cons x p \u2264 q \u2194 x \u2264 q 0 \u2227 p \u2264 fin.tail q", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : fin (n + 1) \u2192 Type u} [_inst_1 : \u03a0 (i : fin (n + 1)), preorder (\u03b1 i)] {x : \u03b1 0} {q : \u03a0 (i : fin (n + 1)), \u03b1 i} {p : \u03a0 (i : fin n), \u03b1 i.succ}, fin.cons x p \u2264 q \u2194 x \u2264 q 0 \u2227 p \u2264 fin.tail q", "decl_nm": "fin.cons_le", "nl_statement_of_codex": "Let $n$ be a natural number and let $\\alpha$ be a family of preorders indexed by $n+1$. Let $x$ be an element of $\\alpha(0)$ and let $p$ and $q$ be functions from $n+1$ to $\\alpha$. Then $x\\leq q(0)$ and $p\\leq q$ if and only if $(x,p)\\leq q$."}
{"formal_statement": "theorem normal_add_subgroup_of_iff {G : Type*} [add_group G] {H K : add_subgroup G}\n\t(hHK : H \u2264 K) :\n\t((H.add_subgroup_of K).normal \u2194 \u2200 (h k : G), h \u2208 H \u2192 k \u2208 K \u2192 k + h + -k \u2208 H)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {H K : add_subgroup G}, H \u2264 K \u2192 ((H.add_subgroup_of K).normal \u2194 \u2200 (h k : G), h \u2208 H \u2192 k \u2208 K \u2192 k + h + -k \u2208 H)", "decl_nm": "add_subgroup.normal_add_subgroup_of_iff", "nl_statement_of_codex": "Let $G$ be an additive group and let $H$ and $K$ be additive subgroups of $G$. If $H\\leq K$, then $H$ is normal in $K$ if and only if $k+h-k\\in H$ for all $h\\in H$ and $k\\in K$."}
{"formal_statement": "theorem comp_strict_mono_on {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [preorder \u03b1]\n\t[preorder \u03b2] [preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {t : set \u03b2}\n\t(hg : strict_anti_on g t) (hf : strict_mono_on f s) (hs : set.maps_to f s t) :\n\tstrict_anti_on (g \u2218 f) s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {t : set \u03b2}, strict_anti_on g t \u2192 strict_mono_on f s \u2192 set.maps_to f s t \u2192 strict_anti_on (g \u2218 f) s", "decl_nm": "strict_anti_on.comp_strict_mono_on", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be functions. If $f$ is strictly monotone on $A$ and $g$ is strictly antimonotone on $B$, then $g\\circ f$ is strictly antimonotone on $A$."}
{"formal_statement": "theorem continuous_on_sin {s : set \u211d} :\n\tcontinuous_on real.sin s", "decl_tp": "\u2200 {s : set \u211d}, continuous_on real.sin s", "decl_nm": "real.continuous_on_sin", "nl_statement_of_codex": "The sine function is continuous on any set $s\\subset\\mathbb{R}$."}
{"formal_statement": "theorem eq_on_set_closure {R : Type u} {S : Type v} [ring R] [ring S] {f g : R \u2192+* S}\n\t{s : set R} (h : set.eq_on \u21d1f \u21d1g s) :\n\tset.eq_on \u21d1f \u21d1g \u2191(subring.closure s)", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : ring R] [_inst_2 : ring S] {f g : R \u2192+* S} {s : set R}, set.eq_on \u21d1f \u21d1g s \u2192 set.eq_on \u21d1f \u21d1g \u2191(subring.closure s)", "decl_nm": "ring_hom.eq_on_set_closure", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f,g:R\\to S$ be ring homomorphisms. Let $s$ be a subset of $R$. If $f$ and $g$ agree on $s$, then they agree on the closure of $s$."}
{"formal_statement": "theorem coe_nonneg (r : nnreal) :\n\t0 \u2264 \u2191r", "decl_tp": "\u2200 (r : nnreal), 0 \u2264 \u2191r", "decl_nm": "nnreal.coe_nonneg", "nl_statement_of_codex": "The nonnegative real number $r$ is nonnegative."}
{"formal_statement": "theorem all_cons {\u03b1 : Type*} (p : \u03b1 \u2192 bool) (a : \u03b1) (l : list \u03b1) :\n\t(a :: l).all p = p a && l.all p", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 bool) (a : \u03b1) (l : list \u03b1), (a :: l).all p = p a && l.all p", "decl_nm": "list.all_cons", "nl_statement_of_codex": "Let $p$ be a predicate on a type $\u03b1$. Then $(a::l).all p$ is true if and only if $p(a)$ is true and $l.all p$ is true."}
{"formal_statement": "theorem integrable_of_compact_closure_support {\u03b1 E : Type*} [measurable_space \u03b1]\n\t[measurable_space E] [normed_group E] [topological_space \u03b1] [opens_measurable_space \u03b1]\n\t[t2_space \u03b1] [borel_space E] {\u03bc : measure_theory.measure \u03b1} [measure_theory.is_locally_finite_measure \u03bc]\n\t{f : \u03b1 \u2192 E} (hf : continuous f) (hfc : is_compact (closure (function.support f))) :\n\tmeasure_theory.integrable f \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space E] [_inst_3 : normed_group E] [_inst_4 : topological_space \u03b1] [_inst_5 : opens_measurable_space \u03b1] [_inst_6 : t2_space \u03b1] [_inst_7 : borel_space E] {\u03bc : measure_theory.measure \u03b1} [_inst_8 : measure_theory.is_locally_finite_measure \u03bc] {f : \u03b1 \u2192 E}, continuous f \u2192 is_compact (closure (function.support f)) \u2192 measure_theory.integrable f \u03bc", "decl_nm": "continuous.integrable_of_compact_closure_support", "nl_statement_of_codex": "Let $f:X\\to E$ be a continuous function on a locally compact Hausdorff space $X$. If the closure of the support of $f$ is compact, then $f$ is integrable."}
{"formal_statement": "theorem inv_c {n : Type*} {R : Type u\u2082} [decidable_eq n] [comm_ring R]\n\t(t : matrix.transvection_struct n R) :\n\tt.inv.c = -t.c", "decl_tp": "\u2200 {n : Type u_1} {R : Type u\u2082} [_inst_2 : decidable_eq n] [_inst_4 : comm_ring R] (t : matrix.transvection_struct n R), t.inv.c = -t.c", "decl_nm": "matrix.transvection_struct.inv_c", "nl_statement_of_codex": "The constant term of the inverse of a transvection is the negative of the constant term of the transvection."}
{"formal_statement": "theorem disjoint {G : Type*} [group G] {H K : subgroup G} (h : H.is_complement' K) :\n\tdisjoint H K", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H K : subgroup G}, H.is_complement' K \u2192 disjoint H K", "decl_nm": "subgroup.is_complement'.disjoint", "nl_statement_of_codex": "Let $G$ be a group and let $H$ and $K$ be subgroups of $G$. If $H$ is a complement of $K$, then $H$ and $K$ are disjoint."}
{"formal_statement": "theorem is_maximal_of_eq_inf {X : Type u} [lattice X] [jordan_holder_lattice X]\n\t(x b : X) {a y : X} (ha : x \u2293 y = a) (hxy : x \u2260 y) (hxb : jordan_holder_lattice.is_maximal x b)\n\t(hyb : jordan_holder_lattice.is_maximal y b) :\n\tjordan_holder_lattice.is_maximal a y", "decl_tp": "\u2200 {X : Type u} [_inst_1 : lattice X] [_inst_2 : jordan_holder_lattice X] (x b : X) {a y : X}, x \u2293 y = a \u2192 x \u2260 y \u2192 jordan_holder_lattice.is_maximal x b \u2192 jordan_holder_lattice.is_maximal y b \u2192 jordan_holder_lattice.is_maximal a y", "decl_nm": "jordan_holder_lattice.is_maximal_of_eq_inf", "nl_statement_of_codex": "Let $X$ be a lattice with a Jordan-Holder order. Let $x, y, a, b\\in X$ such that $x\\wedge y=a$, $x\\neq y$, $x$ is maximal in $b$, and $y$ is maximal in $b$. Then $a$ is maximal in $y$."}
{"formal_statement": "theorem Union_add_right_image {\u03b1 : Type*} {s t : set \u03b1} [has_add \u03b1] :\n\t(\u22c3 (a : \u03b1) (H : a \u2208 t), (\u03bb (x : \u03b1), x + a) '' s) = s + t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1} [_inst_1 : has_add \u03b1], (\u22c3 (a : \u03b1) (H : a \u2208 t), (\u03bb (x : \u03b1), x + a) '' s) = s + t", "decl_nm": "set.Union_add_right_image", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $\\bigcup_{a\\in t}(s+a)=s+t$."}
{"formal_statement": "theorem bit_ff :\n\tnat.bit bool.ff = bit0", "decl_tp": "nat.bit bool.ff = bit0", "decl_nm": "nat.bit_ff", "nl_statement_of_codex": "$\\mathrm{bit}(\\mathrm{ff})=\\mathrm{bit0}$."}
{"formal_statement": "theorem add_mod_self {a b : \u2124} :\n\t(a + b) % b = a % b", "decl_tp": "\u2200 {a b : \u2124}, (a + b) % b = a % b", "decl_nm": "int.add_mod_self", "nl_statement_of_codex": "For all integers $a$ and $b$, $(a+b)\\bmod b=a\\bmod b$."}
{"formal_statement": "theorem exists_of_mem_map {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {b : \u03b2}\n\t{s : wseq \u03b1} (\u1fb0 : b \u2208 wseq.map f s) :\n\t(\u2203 (a : \u03b1), a \u2208 s \u2227 f a = b)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : wseq \u03b1}, b \u2208 wseq.map f s \u2192 (\u2203 (a : \u03b1), a \u2208 s \u2227 f a = b)", "decl_nm": "wseq.exists_of_mem_map", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $b\\in B$. If $b$ is in the image of $f$, then there is an $a\\in A$ such that $f(a)=b$."}
{"formal_statement": "theorem currying_functor_obj_map {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t(F : C \u2964 D \u2964 E) (X Y : C \u00d7 D) (f : X \u27f6 Y) :\n\t(category_theory.currying.functor.obj F).map f = (F.map f.fst).app X.snd \u226b (F.obj Y.fst).map f.snd", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] (F : C \u2964 D \u2964 E) (X Y : C \u00d7 D) (f : X \u27f6 Y), (category_theory.currying.functor.obj F).map f = (F.map f.fst).app X.snd \u226b (F.obj Y.fst).map f.snd", "decl_nm": "category_theory.currying_functor_obj_map", "nl_statement_of_codex": "Let $C, D, E$ be categories and let $F:C\\to D\\to E$ be a functor. Let $X, Y$ be objects of $C\\times D$ and let $f:X\\to Y$ be a morphism. Then the following diagram commutes:\n\\[\n\\begin{tikzcd}\nX\\ar[r, "}
{"formal_statement": "theorem one {G : Type u} [group G] {B : group_filter_basis G} {U : set G} :\n\tU \u2208 B \u2192 1 \u2208 U", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] {B : group_filter_basis G} {U : set G}, U \u2208 B \u2192 1 \u2208 U", "decl_nm": "group_filter_basis.one", "nl_statement_of_codex": "Let $G$ be a group and let $B$ be a group filter basis on $G$. If $U\\in B$, then $1\\in U$."}
{"formal_statement": "theorem finite_of_finite_image {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f : \u03b1 \u2192 \u03b2}\n\t(hi : set.inj_on f s) (\u1fb0 : (f '' s).finite) :\n\ts.finite", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {f : \u03b1 \u2192 \u03b2}, set.inj_on f s \u2192 (f '' s).finite \u2192 s.finite", "decl_nm": "set.finite_of_finite_image", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. If $B$ is finite, then $A$ is finite."}
{"formal_statement": "theorem coe_injective {X Y : Type*} [topological_space X] :\n\tfunction.injective coe_fn", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X], function.injective coe_fn", "decl_nm": "locally_constant.coe_injective", "nl_statement_of_codex": "The function $f:X\\to \\mathcal{O}(X)$ defined by $f(x)=\\{x\\}$ is injective."}
{"formal_statement": "theorem restrict_preimage {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [has_zero \u03b2]\n\t(f : measure_theory.simple_func \u03b1 \u03b2) {s : set \u03b1} (hs : measurable_set s)\n\t(ht : 0 \u2209 t) :\n\t\u2200 {t : set \u03b2},  \u21d1(f.restrict s) \u207b\u00b9' t = s \u2229 \u21d1f \u207b\u00b9' t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : has_zero \u03b2] (f : measure_theory.simple_func \u03b1 \u03b2) {s : set \u03b1}, measurable_set s \u2192 \u2200 {t : set \u03b2}, 0 \u2209 t \u2192 \u21d1(f.restrict s) \u207b\u00b9' t = s \u2229 \u21d1f \u207b\u00b9' t", "decl_nm": "measure_theory.simple_func.restrict_preimage", "nl_statement_of_codex": "Let $f:X\\to Y$ be a measurable function. Then for any measurable set $S\\subset X$ and any set $T\\subset Y$ we have\n$f^{-1}(T)\\cap S=f_S^{-1}(T)$."}
{"formal_statement": "theorem inf_of_le_left {\u03b1 : Type u} [semilattice_inf \u03b1] {a b : \u03b1} (h : a \u2264 b) :\n\ta \u2293 b = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_inf \u03b1] {a b : \u03b1}, a \u2264 b \u2192 a \u2293 b = a", "decl_nm": "inf_of_le_left", "nl_statement_of_codex": "Let $a, b$ be elements of a semilattice with infimum. If $a\\leq b$, then $a\\wedge b=a$."}
{"formal_statement": "theorem tr_num_nat_end (n : num) (x : turing.partrec_to_TM2.\u0393') (H : x \u2208 turing.partrec_to_TM2.tr_num n) :\n\tturing.partrec_to_TM2.nat_end x = bool.ff", "decl_tp": "\u2200 (n : num) (x : turing.partrec_to_TM2.\u0393'), x \u2208 turing.partrec_to_TM2.tr_num n \u2192 turing.partrec_to_TM2.nat_end x = bool.ff", "decl_nm": "turing.partrec_to_TM2.tr_num_nat_end", "nl_statement_of_codex": "Let $n$ be a natural number and let $x$ be a tape of the Turing machine $M_2$. If $x$ is a tape of $M_2$ that represents $n$, then the tape $x$ does not end with a natural number."}
{"formal_statement": "theorem times_cont_mdiff_on_zero {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {s : set M} {n : with_top \u2115} [has_zero M'] :\n\ttimes_cont_mdiff_on I I' n 0 s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {s : set M} {n : with_top \u2115} [_inst_22 : has_zero M'], times_cont_mdiff_on I I' n 0 s", "decl_nm": "times_cont_mdiff_on_zero", "nl_statement_of_codex": "Let $I$ and $I'$ be models with corners. Then the function $f:I\\times I'\\to \\mathbb{R}$ defined by $f(x,y)=0$ is $n$-times continuously differentiable on $s$."}
{"formal_statement": "theorem mem_pos_subgroup {R : Type*} [linear_ordered_semiring R] (u : units R) :\n\tu \u2208 units.pos_subgroup R \u2194 0 < \u2191u", "decl_tp": "\u2200 {R : Type u_1} [_inst_4 : linear_ordered_semiring R] (u : units R), u \u2208 units.pos_subgroup R \u2194 0 < \u2191u", "decl_nm": "units.mem_pos_subgroup", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring. Then $u\\in R^\\times$ is positive if and only if $u>0$."}
{"formal_statement": "theorem Preorder_to_Cat_map (X Y : Preorder) (f : X \u27f6 Y) :\n\tcategory_theory.Preorder_to_Cat.map f = _.functor", "decl_tp": "\u2200 (X Y : Preorder) (f : X \u27f6 Y), category_theory.Preorder_to_Cat.map f = _.functor", "decl_nm": "category_theory.Preorder_to_Cat_map", "nl_statement_of_codex": "The map from a preorder to its category is the identity on morphisms."}
{"formal_statement": "theorem to_linear_map_injective {R M M\u2082 : Type*1} [semiring R] [add_comm_monoid M]\n\t[add_comm_monoid M\u2082] [module R M] [module R M\u2082] {f g : M \u2192+[R] M\u2082} (h : \u2191f = \u2191g) :\n\tf = g", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_9} {M\u2082 : Type u_11} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : add_comm_monoid M\u2082] [_inst_4 : module R M] [_inst_5 : module R M\u2082] {f g : M \u2192+[R] M\u2082}, \u2191f = \u2191g \u2192 f = g", "decl_nm": "distrib_mul_action_hom.to_linear_map_injective", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $M_2$ be $R$-modules. If two linear maps $f,g:M\\to M_2$ are equal as functions, then they are equal as linear maps."}
{"formal_statement": "theorem ext_iff {V\u2081 V\u2082 : Type*} [semi_normed_group V\u2081] [semi_normed_group V\u2082]\n\t{f g : normed_group_hom V\u2081 V\u2082} :\n\tf = g \u2194 \u2200 (x : V\u2081), \u21d1f x = \u21d1g x", "decl_tp": "\u2200 {V\u2081 : Type u_2} {V\u2082 : Type u_3} [_inst_2 : semi_normed_group V\u2081] [_inst_3 : semi_normed_group V\u2082] {f g : normed_group_hom V\u2081 V\u2082}, f = g \u2194 \u2200 (x : V\u2081), \u21d1f x = \u21d1g x", "decl_nm": "normed_group_hom.ext_iff", "nl_statement_of_codex": "Two linear maps $f,g:V_1\\to V_2$ are equal if and only if $f(x)=g(x)$ for all $x\\in V_1$."}
{"formal_statement": "theorem sdiff_eq_of_sup_eq {\u03b1 : Type u} {x y z : \u03b1} [generalized_boolean_algebra \u03b1]\n\t(hi : disjoint x z) (hs : x \u2294 z = y) :\n\ty \\ x = z", "decl_tp": "\u2200 {\u03b1 : Type u} {x y z : \u03b1} [_inst_1 : generalized_boolean_algebra \u03b1], disjoint x z \u2192 x \u2294 z = y \u2192 y \\ x = z", "decl_nm": "disjoint.sdiff_eq_of_sup_eq", "nl_statement_of_codex": "Let $x,y,z$ be elements of a generalized boolean algebra. If $x$ and $z$ are disjoint and $x\\vee z=y$, then $y\\setminus x=z$."}
{"formal_statement": "theorem mem_mk {\u03b1 : Type u} {s : set \u03b1} {t : set (set \u03b1)} {h\u2081 : set.univ \u2208 t}\n\t{h\u2082 : \u2200 {x y : set \u03b1}, x \u2208 t \u2192 x \u2286 y \u2192 y \u2208 t} {h\u2083 : \u2200 {x y : set \u03b1}, x \u2208 t \u2192 y \u2208 t \u2192 x \u2229 y \u2208 t} :\n\ts \u2208 {sets := t, univ_sets := h\u2081, sets_of_superset := h\u2082, inter_sets := h\u2083} \u2194 s \u2208 t", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1} {t : set (set \u03b1)} {h\u2081 : set.univ \u2208 t} {h\u2082 : \u2200 {x y : set \u03b1}, x \u2208 t \u2192 x \u2286 y \u2192 y \u2208 t} {h\u2083 : \u2200 {x y : set \u03b1}, x \u2208 t \u2192 y \u2208 t \u2192 x \u2229 y \u2208 t}, s \u2208 {sets := t, univ_sets := h\u2081, sets_of_superset := h\u2082, inter_sets := h\u2083} \u2194 s \u2208 t", "decl_nm": "filter.mem_mk", "nl_statement_of_codex": "Let $t$ be a collection of subsets of a set $X$. Then $s\\in t$ if and only if $s\\in\\{sets:=t,univ\\_sets:=h_1,sets\\_of\\_superset:=h_2,inter\\_sets:=h_3\\}$."}
{"formal_statement": "theorem comp_affine_map {\ud835\udd5c E F \u03b2 : Type*} [linear_ordered_field \ud835\udd5c] [add_comm_group E]\n\t[add_comm_group F] [ordered_add_comm_monoid \u03b2] [module \ud835\udd5c E] [module \ud835\udd5c F]\n\t[has_scalar \ud835\udd5c \u03b2] {f : F \u2192 \u03b2} (g : E \u2192\u1d43[\ud835\udd5c] F) {s : set F} (hf : concave_on \ud835\udd5c s f) :\n\tconcave_on \ud835\udd5c (\u21d1g \u207b\u00b9' s) (f \u2218 \u21d1g)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {F : Type u_3} {\u03b2 : Type u_4} [_inst_1 : linear_ordered_field \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : add_comm_group F] [_inst_4 : ordered_add_comm_monoid \u03b2] [_inst_5 : module \ud835\udd5c E] [_inst_6 : module \ud835\udd5c F] [_inst_7 : has_scalar \ud835\udd5c \u03b2] {f : F \u2192 \u03b2} (g : E \u2192\u1d43[\ud835\udd5c] F) {s : set F}, concave_on \ud835\udd5c s f \u2192 concave_on \ud835\udd5c (\u21d1g \u207b\u00b9' s) (f \u2218 \u21d1g)", "decl_nm": "concave_on.comp_affine_map", "nl_statement_of_codex": "Let $E$ and $F$ be vector spaces over a linear ordered field $K$, and let $f:F\\to K$ be a concave function.\nLet $g:E\\to F$ be an affine map. Then $f\\circ g:E\\to K$ is concave."}
{"formal_statement": "theorem right_coset_equivalence_rel {\u03b1 : Type*} [has_mul \u03b1] (s : set \u03b1) :\n\tequivalence (right_coset_equivalence s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_mul \u03b1] (s : set \u03b1), equivalence (right_coset_equivalence s)", "decl_nm": "right_coset_equivalence_rel", "nl_statement_of_codex": "The relation $a\\sim b$ if and only if $a=sb$ for some $s\\in S$ is an equivalence relation on $G$."}
{"formal_statement": "theorem ne_zero_of_ne {R : Type u} [semiring R] (h : 0 \u2260 1) (hp : p.monic) :\n\t\u2200 {p : polynomial R},  p \u2260 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R], 0 \u2260 1 \u2192 \u2200 {p : polynomial R}, p.monic \u2192 p \u2260 0", "decl_nm": "polynomial.monic.ne_zero_of_ne", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a monic polynomial. Then $p$ is not equal to $0$."}
{"formal_statement": "theorem countable_encodable {\u03b1 : Type u} [encodable \u03b1] (s : set \u03b1) :\n\ts.countable", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : encodable \u03b1] (s : set \u03b1), s.countable", "decl_nm": "set.countable_encodable", "nl_statement_of_codex": "If $S$ is a set of encodable elements, then $S$ is countable."}
{"formal_statement": "theorem add_snd {q : \u2115+} (x y : lucas_lehmer.X q) :\n\t(x + y).snd = x.snd + y.snd", "decl_tp": "\u2200 {q : \u2115+} (x y : lucas_lehmer.X q), (x + y).snd = x.snd + y.snd", "decl_nm": "lucas_lehmer.X.add_snd", "nl_statement_of_codex": "Let $q$ be a positive integer. Then the second component of the sum of two elements of $\\mathbb{Z}/q\\mathbb{Z}$ is the sum of the second components of the two elements."}
{"formal_statement": "theorem card_support_le_one' {\u03b1 M : Type*} [has_zero M] [nonempty \u03b1] {f : \u03b1 \u2192\u2080 M} :\n\tf.support.card \u2264 1 \u2194 \u2203 (a : \u03b1) (b : M), f = finsupp.single a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] [_inst_2 : nonempty \u03b1] {f : \u03b1 \u2192\u2080 M}, f.support.card \u2264 1 \u2194 \u2203 (a : \u03b1) (b : M), f = finsupp.single a b", "decl_nm": "finsupp.card_support_le_one'", "nl_statement_of_codex": "Let $f:\\alpha\\to M$ be a function with finite support. Then $f$ has at most one nonzero value if and only if there is an $a\\in\\alpha$ and a $b\\in M$ such that $f(x)=b$ for all $x\\in\\alpha$."}
{"formal_statement": "theorem mk'_left {\u0393 : Type*} [inhabited \u0393] (L R : turing.list_blank \u0393) :\n\t(turing.tape.mk' L R).left = L", "decl_tp": "\u2200 {\u0393 : Type u_1} [_inst_1 : inhabited \u0393] (L R : turing.list_blank \u0393), (turing.tape.mk' L R).left = L", "decl_nm": "turing.tape.mk'_left", "nl_statement_of_codex": "The left side of a Turing machine tape is the left side of the tape."}
{"formal_statement": "theorem not_lt_zero' {\u03b1 : Type*} {a : \u03b1} [linear_ordered_comm_monoid_with_zero \u03b1] :\n\t\u00aca < 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a : \u03b1} [_inst_1 : linear_ordered_comm_monoid_with_zero \u03b1], \u00aca < 0", "decl_nm": "not_lt_zero'", "nl_statement_of_codex": "Let $R$ be a commutative monoid with zero. Then $a<0$ is false for all $a\\in R$."}
{"formal_statement": "theorem cos_add_nat_mul_two_pi (x : \u2102) (n : \u2115) :\n\tcomplex.cos (x + \u2191n * (2 * \u2191real.pi)) = complex.cos x", "decl_tp": "\u2200 (x : \u2102) (n : \u2115), complex.cos (x + \u2191n * (2 * \u2191real.pi)) = complex.cos x", "decl_nm": "complex.cos_add_nat_mul_two_pi", "nl_statement_of_codex": "For all $x\\in\\mathbb{C}$ and $n\\in\\mathbb{N}$, we have $\\cos(x+2\\pi n)=\\cos(x)$."}
{"formal_statement": "theorem cons_reverse_aux {V : Type u} {G : simple_graph V} {u v w x : V}\n\t(p : G.walk u v) (q : G.walk w x) (h : G.adj w u) :\n\t(simple_graph.walk.cons h p).reverse_aux q = p.reverse_aux (simple_graph.walk.cons _ q)", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {u v w x : V} (p : G.walk u v) (q : G.walk w x) (h : G.adj w u), (simple_graph.walk.cons h p).reverse_aux q = p.reverse_aux (simple_graph.walk.cons _ q)", "decl_nm": "simple_graph.walk.cons_reverse_aux", "nl_statement_of_codex": "Let $G$ be a simple graph and let $u,v,w,x$ be vertices of $G$. Let $p$ be a walk from $u$ to $v$ and let $q$ be a walk from $w$ to $x$. If $w$ is adjacent to $u$, then the reverse of the walk $p$ followed by the walk $q$ is the walk $q$ followed by the reverse of the walk $p$."}
{"formal_statement": "theorem inv_le_inv' {\u03b1 : Type u} [ordered_comm_group \u03b1] {a b : \u03b1} :\n\ta \u2264 b \u2192 b\u207b\u00b9 \u2264 a\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : ordered_comm_group \u03b1] {a b : \u03b1}, a \u2264 b \u2192 b\u207b\u00b9 \u2264 a\u207b\u00b9", "decl_nm": "inv_le_inv'", "nl_statement_of_codex": "Let $G$ be an ordered commutative group. If $a\\leq b$, then $b^{-1}\\leq a^{-1}$."}
{"formal_statement": "theorem coev_ev {C : Type u} [category_theory.category C] (A B : C) [category_theory.limits.has_finite_products C]\n\t[category_theory.exponentiable A] :\n\t(category_theory.coev A).app ((category_theory.exp A).obj B) \u226b (category_theory.exp A).map ((category_theory.ev A).app B) = \ud835\udfd9 ((category_theory.exp A).obj B)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (A B : C) [_inst_2 : category_theory.limits.has_finite_products C] [_inst_3 : category_theory.exponentiable A], (category_theory.coev A).app ((category_theory.exp A).obj B) \u226b (category_theory.exp A).map ((category_theory.ev A).app B) = \ud835\udfd9 ((category_theory.exp A).obj B)", "decl_nm": "category_theory.coev_ev", "nl_statement_of_codex": "Let $C$ be a category with finite products and exponentiable objects. Let $A$ and $B$ be objects of $C$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nA^B & \\xrightarrow{\\mathrm{coev}_A} & 1 \\\\\n\\downarrow{\\mathrm{exp}_A} & & \\downarrow{\\mathrm{exp}_A} \\\\\n(A^B)^A & \\xrightarrow{\\mathrm{exp}_A(\\mathrm{ev}_A)} & A^A\n\\end{array}$$"}
{"formal_statement": "theorem cast_ne_zero {R : Type*} [add_monoid R] [has_one R] [char_zero R]\n\t{n : \u2115} :\n\t\u2191n \u2260 0 \u2194 n \u2260 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : add_monoid R] [_inst_2 : has_one R] [_inst_3 : char_zero R] {n : \u2115}, \u2191n \u2260 0 \u2194 n \u2260 0", "decl_nm": "nat.cast_ne_zero", "nl_statement_of_codex": "Let $R$ be a commutative ring with identity and characteristic zero. Then $n\\neq 0$ if and only if $n\\neq 0$."}
{"formal_statement": "theorem succ_lt_of_not_succ {o : ordinal} :\n\t(\u00ac\u2203 (a : ordinal), o = a.succ) \u2192 \u2200 {b : ordinal}, b.succ < o \u2194 b < o", "decl_tp": "\u2200 {o : ordinal}, (\u00ac\u2203 (a : ordinal), o = a.succ) \u2192 \u2200 {b : ordinal}, b.succ < o \u2194 b < o", "decl_nm": "ordinal.succ_lt_of_not_succ", "nl_statement_of_codex": "Let $o$ be an ordinal. If $o$ is not a successor ordinal, then for any ordinal $b$, $b+1<o$ if and only if $b<o$."}
{"formal_statement": "theorem Ico_disjoint_Ico {\u03b1 : Type*} [partial_order \u03b1] [locally_finite_order \u03b1]\n\t{a b c d : \u03b1} (h : b \u2264 c) :\n\t(multiset.Ico a b).disjoint (multiset.Ico c d)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b c d : \u03b1}, b \u2264 c \u2192 (multiset.Ico a b).disjoint (multiset.Ico c d)", "decl_nm": "multiset.Ico_disjoint_Ico", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a locally finite partially ordered set. If $b\\leq c$, then the intervals $[a,b]$ and $[c,d]$ are disjoint."}
{"formal_statement": "theorem up_shadow_monotone {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] :\n\tmonotone finset.up_shadow", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1], monotone finset.up_shadow", "decl_nm": "finset.up_shadow_monotone", "nl_statement_of_codex": "The up shadow of a finite set is monotone."}
{"formal_statement": "theorem tan_mul_I (x : \u2102) :\n\tcomplex.tan (x * complex.I) = complex.tanh x * complex.I", "decl_tp": "\u2200 (x : \u2102), complex.tan (x * complex.I) = complex.tanh x * complex.I", "decl_nm": "complex.tan_mul_I", "nl_statement_of_codex": "$\\tan(ix)=i\\tanh(x)$."}
{"formal_statement": "theorem to_real_eq_to_real {a b : ennreal} (ha : a \u2260 \u22a4) (hb : b \u2260 \u22a4) :\n\t(a.to_real = b.to_real \u2194 a = b)", "decl_tp": "\u2200 {a b : ennreal}, a \u2260 \u22a4 \u2192 b \u2260 \u22a4 \u2192 (a.to_real = b.to_real \u2194 a = b)", "decl_nm": "ennreal.to_real_eq_to_real", "nl_statement_of_codex": "Let $a, b$ be extended nonnegative real numbers. Then $a=b$ if and only if $a.to\\_real=b.to\\_real$."}
{"formal_statement": "theorem finsupp_equiv_dfinsupp_symm_apply {\u03b9 M : Type*} [decidable_eq \u03b9]\n\t[has_zero M] [\u03a0 (m : M), decidable (m \u2260 0)] :\n\t\u21d1(finsupp_equiv_dfinsupp.symm) = dfinsupp.to_finsupp", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : Type u_3} [_inst_1 : decidable_eq \u03b9] [_inst_2 : has_zero M] [_inst_3 : \u03a0 (m : M), decidable (m \u2260 0)], \u21d1(finsupp_equiv_dfinsupp.symm) = dfinsupp.to_finsupp", "decl_nm": "finsupp_equiv_dfinsupp_symm_apply", "nl_statement_of_codex": "The inverse of the equivalence between finitely supported functions and decidable finitely supported functions is the function that takes a decidable finitely supported function to a finitely supported function."}
{"formal_statement": "theorem sum_apply {R M : Type*} [add_comm_group M] [ring R] [module R M]\n\t{\u03b9 : Type*} (Q : \u03b9 \u2192 quadratic_form R M) (s : finset \u03b9) (x : M) :\n\t\u21d1(s.sum (\u03bb (i : \u03b9), Q i)) x = s.sum (\u03bb (i : \u03b9), \u21d1(Q i) x)", "decl_tp": "\u2200 {R : Type u_2} {M : Type u_3} [_inst_1 : add_comm_group M] [_inst_2 : ring R] [_inst_4 : module R M] {\u03b9 : Type u_1} (Q : \u03b9 \u2192 quadratic_form R M) (s : finset \u03b9) (x : M), \u21d1(s.sum (\u03bb (i : \u03b9), Q i)) x = s.sum (\u03bb (i : \u03b9), \u21d1(Q i) x)", "decl_nm": "quadratic_form.sum_apply", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, and $Q$ a quadratic form on $M$. Then for any finite set $S$ of indices, the quadratic form $\\sum_{i\\in S} Q_i$ is equal to the sum of the quadratic forms $Q_i$ for $i\\in S$."}
{"formal_statement": "theorem mk_image_eq {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} (hf : function.injective f) :\n\tcardinal.mk \u21a5(f '' s) = cardinal.mk \u21a5s", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}, function.injective f \u2192 cardinal.mk \u21a5(f '' s) = cardinal.mk \u21a5s", "decl_nm": "cardinal.mk_image_eq", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $|f(A)|=|A|$."}
{"formal_statement": "theorem lt_add_of_neg_add_lt_left {\u03b1 : Type u} [add_group \u03b1] [has_lt \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_lt.lt] {a b c : \u03b1} :\n\t-b + a < c \u2192 a < b + c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_lt.lt] {a b c : \u03b1}, -b + a < c \u2192 a < b + c", "decl_nm": "lt_add_of_neg_add_lt_left", "nl_statement_of_codex": "Let $a, b, c$ be elements of an additive group with a total order. If $-b+a<c$, then $a<b+c$."}
{"formal_statement": "theorem convex_le {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [linear_ordered_add_comm_monoid E]\n\t[ordered_add_comm_monoid \u03b2] [module \ud835\udd5c E] [ordered_smul \ud835\udd5c E] {s : set E}\n\t{f : E \u2192 \u03b2} (hf : antitone_on f s) (hs : convex \ud835\udd5c s) :\n\t\u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | f x \u2264 r}", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : linear_ordered_add_comm_monoid E] [_inst_3 : ordered_add_comm_monoid \u03b2] [_inst_4 : module \ud835\udd5c E] [_inst_5 : ordered_smul \ud835\udd5c E] {s : set E} {f : E \u2192 \u03b2}, antitone_on f s \u2192 convex \ud835\udd5c s \u2192 \u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | f x \u2264 r}", "decl_nm": "antitone_on.convex_le", "nl_statement_of_codex": "Let $E$ be a real vector space and let $f:E\\to \\mathbb{R}$ be an antitone function. Let $s$ be a convex subset of $E$. Then the set $\\{x\\in s: f(x)\\leq r\\}$ is convex for each $r\\in \\mathbb{R}$."}
{"formal_statement": "theorem le_one' {t : \u21a5unit_interval} :\n\tt \u2264 1", "decl_tp": "\u2200 {t : \u21a5unit_interval}, t \u2264 1", "decl_nm": "unit_interval.le_one'", "nl_statement_of_codex": "For any $t\\in [0,1]$, $t\\leq 1$."}
{"formal_statement": "theorem row_mul_col_apply {m : Type*} {\u03b1 : Type v} [fintype m] [has_mul \u03b1]\n\t[add_comm_monoid \u03b1] (v w : m \u2192 \u03b1) (i j : unit) :\n\t(matrix.row v).mul (matrix.col w) i j = matrix.dot_product v w", "decl_tp": "\u2200 {m : Type u_2} {\u03b1 : Type v} [_inst_1 : fintype m] [_inst_2 : has_mul \u03b1] [_inst_3 : add_comm_monoid \u03b1] (v w : m \u2192 \u03b1) (i j : unit), (matrix.row v).mul (matrix.col w) i j = matrix.dot_product v w", "decl_nm": "matrix.row_mul_col_apply", "nl_statement_of_codex": "Let $v,w$ be vectors in $\\mathbb{R}^n$. Then the $(i,j)$-entry of the product of the row matrix of $v$ and the column matrix of $w$ is the dot product of $v$ and $w$."}
{"formal_statement": "theorem Union_Union_eq_or_left {\u03b1 \u03b2 : Type*} {b : \u03b2} {p : \u03b2 \u2192 Prop} {s : \u03a0 (x : \u03b2), x = b \u2228 p x \u2192 set \u03b1} :\n\t(\u22c3 (x : \u03b2) (h : x = b \u2228 p x), s x h) = s b _ \u222a \u22c3 (x : \u03b2) (h : p x), s x _", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {b : \u03b2} {p : \u03b2 \u2192 Prop} {s : \u03a0 (x : \u03b2), x = b \u2228 p x \u2192 set \u03b1}, (\u22c3 (x : \u03b2) (h : x = b \u2228 p x), s x h) = s b _ \u222a \u22c3 (x : \u03b2) (h : p x), s x _", "decl_nm": "set.Union_Union_eq_or_left", "nl_statement_of_codex": "Let $b$ be an element of a set $B$ and let $p$ be a property of elements of $B$. Let $s$ be a function from $B$ to sets of elements of a set $A$ such that $s(b)$ is the set of elements of $A$ that satisfy a property $q$ and $s(x)$ is the set of elements of $A$ that satisfy a property $r$ for each $x\\in B$ such that $p(x)$ holds. Then the union of the sets $s(x)$ for all $x\\in B$ is equal to the union of the sets $s(b)$ and $"}
{"formal_statement": "theorem set_seq_mem {\u03b1 : Type u} [uniform_space \u03b1] {f : filter \u03b1} (hf : cauchy f)\n\t{U : \u2115 \u2192 set (\u03b1 \u00d7 \u03b1)} (U_mem : \u2200 (n : \u2115), U n \u2208 uniformity \u03b1) (n : \u2115) :\n\tsequentially_complete.set_seq hf U_mem n \u2208 f", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1] {f : filter \u03b1} (hf : cauchy f) {U : \u2115 \u2192 set (\u03b1 \u00d7 \u03b1)} (U_mem : \u2200 (n : \u2115), U n \u2208 uniformity \u03b1) (n : \u2115), sequentially_complete.set_seq hf U_mem n \u2208 f", "decl_nm": "sequentially_complete.set_seq_mem", "nl_statement_of_codex": "Let $f$ be a Cauchy filter on a uniform space $X$. Let $U_n$ be a sequence of sets in the uniformity of $X$. Then the set $\\{x\\in X: \\forall n\\in\\mathbb{N}, (x,x)\\in U_n\\}$ is in $f$."}
{"formal_statement": "theorem pow_right_injective {x : \u2124} (h : 1 < x.nat_abs) :\n\tfunction.injective (has_pow.pow x)", "decl_tp": "\u2200 {x : \u2124}, 1 < x.nat_abs \u2192 function.injective (has_pow.pow x)", "decl_nm": "int.pow_right_injective", "nl_statement_of_codex": "The function $x^n$ is injective for $x\\in\\mathbb{Z}$ with $|x|>1$."}
{"formal_statement": "theorem continuous_zsmul {M\u2082 : Type*} [topological_space M\u2082] [add_comm_group M\u2082]\n\t[topological_add_group M\u2082] (n : \u2124) :\n\tcontinuous (\u03bb (x : M\u2082), n \u2022 x)", "decl_tp": "\u2200 {M\u2082 : Type u_4} [_inst_5 : topological_space M\u2082] [_inst_6 : add_comm_group M\u2082] [_inst_13 : topological_add_group M\u2082] (n : \u2124), continuous (\u03bb (x : M\u2082), n \u2022 x)", "decl_nm": "continuous_linear_map.continuous_zsmul", "nl_statement_of_codex": "The function $f:M_2\\to M_2$ defined by $f(x)=nx$ is continuous."}
{"formal_statement": "theorem sum_empty_apply_inl {\u03b1 \u03b2 : Type*} [is_empty \u03b2] (a : \u03b1) :\n\t\u21d1(equiv.sum_empty \u03b1 \u03b2) (sum.inl a) = a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : is_empty \u03b2] (a : \u03b1), \u21d1(equiv.sum_empty \u03b1 \u03b2) (sum.inl a) = a", "decl_nm": "equiv.sum_empty_apply_inl", "nl_statement_of_codex": "The function $f:\u03b1\\to \u03b1+\u03b2$ defined by $f(a)=a$ is an isomorphism."}
{"formal_statement": "theorem conj_apply {G : Type*} [add_group G] (g h : G) :\n\t\u21d1(\u21d1add_aut.conj g) h = g + h + -g", "decl_tp": "\u2200 {G : Type u_3} [_inst_2 : add_group G] (g h : G), \u21d1(\u21d1add_aut.conj g) h = g + h + -g", "decl_nm": "add_aut.conj_apply", "nl_statement_of_codex": "Let $G$ be an additive group. Then for all $g, h\\in G$, we have $g+h+(-g)=g+h-g$."}
{"formal_statement": "theorem binary_product_functor_obj_obj (X Y : Type u) :\n\t(category_theory.limits.types.binary_product_functor.obj X).obj Y = (X \u00d7 Y)", "decl_tp": "\u2200 (X Y : Type u), (category_theory.limits.types.binary_product_functor.obj X).obj Y = (X \u00d7 Y)", "decl_nm": "category_theory.limits.types.binary_product_functor_obj_obj", "nl_statement_of_codex": "The object of the functor $X\\times -$ applied to $Y$ is $X\\times Y$."}
{"formal_statement": "theorem times_cont_mdiff_on {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {f : M \u2192 M'} {s : set M} (h : smooth_on I I' f s) :\n\ttimes_cont_mdiff_on I I' \u22a4 f s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {f : M \u2192 M'} {s : set M}, smooth_on I I' f s \u2192 times_cont_mdiff_on I I' \u22a4 f s", "decl_nm": "smooth_on.times_cont_mdiff_on", "nl_statement_of_codex": "Let $f:M\\to M'$ be a smooth map between manifolds with corners. Then $f$ is infinitely differentiable."}
{"formal_statement": "theorem nonempty_iff_univ_nonempty {\u03b1 : Type u} :\n\tnonempty \u03b1 \u2194 set.univ.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u}, nonempty \u03b1 \u2194 set.univ.nonempty", "decl_nm": "set.nonempty_iff_univ_nonempty", "nl_statement_of_codex": "A type $\\alpha$ is nonempty if and only if the universe is nonempty."}
{"formal_statement": "theorem mul_left_comm {G : Type u} [comm_semigroup G] (a b c : G) :\n\ta * (b * c) = b * (a * c)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : comm_semigroup G] (a b c : G), a * (b * c) = b * (a * c)", "decl_nm": "mul_left_comm", "nl_statement_of_codex": "In a commutative semigroup, the left multiplication is commutative."}
{"formal_statement": "theorem iff_def {M : Type*} [comm_monoid M] (\u03b6 : M) (k : \u2115) :\n\tis_primitive_root \u03b6 k \u2194 \u03b6 ^ k = 1 \u2227 \u2200 (l : \u2115), \u03b6 ^ l = 1 \u2192 k \u2223 l", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] (\u03b6 : M) (k : \u2115), is_primitive_root \u03b6 k \u2194 \u03b6 ^ k = 1 \u2227 \u2200 (l : \u2115), \u03b6 ^ l = 1 \u2192 k \u2223 l", "decl_nm": "is_primitive_root.iff_def", "nl_statement_of_codex": "Let $M$ be a commutative monoid. Then $\\zeta$ is a primitive $k$-th root of unity if and only if $\\zeta^k=1$ and $\\zeta^l=1$ implies $k\\mid l$."}
{"formal_statement": "theorem coeff_mul_X_zero {R : Type u} [semiring R] (p : polynomial R) :\n\t(p * polynomial.X).coeff 0 = 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (p : polynomial R), (p * polynomial.X).coeff 0 = 0", "decl_nm": "polynomial.coeff_mul_X_zero", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$. Then the coefficient of $p$ at $0$ is $0$."}
{"formal_statement": "theorem is_O_const_mul_right_iff' {\u03b1 E R : Type*} [has_norm E] [normed_ring R]\n\t{f : \u03b1 \u2192 E} {l : filter \u03b1} {g : \u03b1 \u2192 R} {c : R} (hc : is_unit c) :\n\t(asymptotics.is_O f (\u03bb (x : \u03b1), c * g x) l \u2194 asymptotics.is_O f g l)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {R : Type u_9} [_inst_1 : has_norm E] [_inst_7 : normed_ring R] {f : \u03b1 \u2192 E} {l : filter \u03b1} {g : \u03b1 \u2192 R} {c : R}, is_unit c \u2192 (asymptotics.is_O f (\u03bb (x : \u03b1), c * g x) l \u2194 asymptotics.is_O f g l)", "decl_nm": "asymptotics.is_O_const_mul_right_iff'", "nl_statement_of_codex": "Let $f:\\alpha\\to E$ and $g:\\alpha\\to R$ be functions. Then $f$ is $O(cg)$ if and only if $f$ is $O(g)$."}
{"formal_statement": "theorem to_ring_equiv_apply (G : Type u) [group G] (R : Type v) [semiring R]\n\t[mul_semiring_action G R] (x : G) (\u1fb0 : R) :\n\t\u21d1(mul_semiring_action.to_ring_equiv G R x) \u1fb0 = (distrib_mul_action.to_add_equiv R x).to_fun \u1fb0", "decl_tp": "\u2200 (G : Type u) [_inst_2 : group G] (R : Type v) [_inst_4 : semiring R] [_inst_7 : mul_semiring_action G R] (x : G) (\u1fb0 : R), \u21d1(mul_semiring_action.to_ring_equiv G R x) \u1fb0 = (distrib_mul_action.to_add_equiv R x).to_fun \u1fb0", "decl_nm": "mul_semiring_action.to_ring_equiv_apply", "nl_statement_of_codex": "Let $G$ be a group, $R$ a semiring, and $x\\in G$. Then the map $R\\to R$ given by $r\\mapsto xr$ is equal to the map $R\\to R$ given by $r\\mapsto rx$."}
{"formal_statement": "theorem norm_def {E F : Type*} [normed_group E] [normed_group F] (x : E \u00d7 F) :\n\t\u2225x\u2225 = linear_order.max \u2225x.fst\u2225 \u2225x.snd\u2225", "decl_tp": "\u2200 {E : Type u_3} {F : Type u_4} [_inst_1 : normed_group E] [_inst_2 : normed_group F] (x : E \u00d7 F), \u2225x\u2225 = linear_order.max \u2225x.fst\u2225 \u2225x.snd\u2225", "decl_nm": "prod.norm_def", "nl_statement_of_codex": "The norm of a pair $(x,y)$ is the maximum of the norms of $x$ and $y$."}
{"formal_statement": "theorem mul_lt_of_lt_one_of_le {\u03b1 : Type*} [mul_one_class \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt] {a b c : \u03b1}\n\t(ha : a < 1) (hbc : b \u2264 c) :\n\ta * b < c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : mul_one_class \u03b1] [_inst_2 : preorder \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_lt.lt] {a b c : \u03b1}, a < 1 \u2192 b \u2264 c \u2192 a * b < c", "decl_nm": "mul_lt_of_lt_one_of_le", "nl_statement_of_codex": "Let $a, b, c$ be elements of a preordered monoid with $1$. If $a<1$ and $b\\leq c$, then $ab<c$."}
{"formal_statement": "theorem cexp {\u03b1 : Type*} {l : filter \u03b1} {f : \u03b1 \u2192 \u2102} {z : \u2102} (hf : filter.tendsto f l (nhds z)) :\n\tfilter.tendsto (\u03bb (x : \u03b1), complex.exp (f x)) l (nhds (complex.exp z))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : filter \u03b1} {f : \u03b1 \u2192 \u2102} {z : \u2102}, filter.tendsto f l (nhds z) \u2192 filter.tendsto (\u03bb (x : \u03b1), complex.exp (f x)) l (nhds (complex.exp z))", "decl_nm": "filter.tendsto.cexp", "nl_statement_of_codex": "Let $f$ be a function from a filter $l$ to $\\mathbb{C}$ such that $f$ converges to $z$. Then the function $x\\mapsto e^{f(x)}$ converges to $e^z$."}
{"formal_statement": "theorem ext {x y : unit} :\n\tx = y", "decl_tp": "\u2200 {x y : unit}, x = y", "decl_nm": "unit.ext", "nl_statement_of_codex": "There is only one unit."}
{"formal_statement": "theorem fst {b : Prop} {p : b \u2192 Prop} (\u1fb0 : Exists p) :\n\tb", "decl_tp": "\u2200 {b : Prop} {p : b \u2192 Prop}, Exists p \u2192 b", "decl_nm": "Exists.fst", "nl_statement_of_codex": "Let $b$ be a proposition and let $p$ be a proposition depending on $b$. If there exists $b$ such that $p(b)$ is true, then $b$ is true."}
{"formal_statement": "theorem vanishing_ideal_singleton {R : Type u} [comm_ring R] (x : prime_spectrum R) :\n\tprime_spectrum.vanishing_ideal {x} = x.as_ideal", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] (x : prime_spectrum R), prime_spectrum.vanishing_ideal {x} = x.as_ideal", "decl_nm": "prime_spectrum.vanishing_ideal_singleton", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $x$ be a prime ideal of $R$. Then the vanishing ideal of the singleton set $\\{x\\}$ is equal to $x$."}
{"formal_statement": "theorem mul_left_distrib {\u03b1 : Type} {ds\u2081 ds\u2082 : list \u2115} [distrib \u03b1] (x : holor \u03b1 ds\u2081)\n\t(y z : holor \u03b1 ds\u2082) :\n\tx.mul (y + z) = x.mul y + x.mul z", "decl_tp": "\u2200 {\u03b1 : Type} {ds\u2081 ds\u2082 : list \u2115} [_inst_1 : distrib \u03b1] (x : holor \u03b1 ds\u2081) (y z : holor \u03b1 ds\u2082), x.mul (y + z) = x.mul y + x.mul z", "decl_nm": "holor.mul_left_distrib", "nl_statement_of_codex": "Let $x,y,z$ be holors. Then $x(y+z)=xy+xz$."}
{"formal_statement": "theorem ext {\u03b1 : Type*} {o p : part \u03b1} :\n\t(\u2200 (a : \u03b1), a \u2208 o \u2194 a \u2208 p) \u2192 o = p", "decl_tp": "\u2200 {\u03b1 : Type u_1} {o p : part \u03b1}, (\u2200 (a : \u03b1), a \u2208 o \u2194 a \u2208 p) \u2192 o = p", "decl_nm": "part.ext", "nl_statement_of_codex": "Two partitions of a set $X$ are equal if and only if they have the same blocks."}
{"formal_statement": "theorem find_min'_dual {\u03b1 : Type*} (t : ordnode \u03b1) (x : \u03b1) :\n\tt.dual.find_min' x = ordnode.find_max' x t", "decl_tp": "\u2200 {\u03b1 : Type u_1} (t : ordnode \u03b1) (x : \u03b1), t.dual.find_min' x = ordnode.find_max' x t", "decl_nm": "ordnode.find_min'_dual", "nl_statement_of_codex": "The minimum element of the dual of an ordered tree is the maximum element of the tree."}
{"formal_statement": "theorem some_bind {\u03b1 \u03b2 : Type*} (a : \u03b1) (f : \u03b1 \u2192 option \u03b2) :\n\toption.some a >>= f = f a", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u_1} (a : \u03b1) (f : \u03b1 \u2192 option \u03b2), option.some a >>= f = f a", "decl_nm": "option.some_bind", "nl_statement_of_codex": "Let $a$ be an element of a type $\\alpha$ and let $f:\\alpha\\to\\beta$ be a function. Then $f(a)$ is equal to $f(a)$."}
{"formal_statement": "theorem continuous_nndist {\u03b1 : Type u} [pseudo_metric_space \u03b1] :\n\tcontinuous (\u03bb (p : \u03b1 \u00d7 \u03b1), has_nndist.nndist p.fst p.snd)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1], continuous (\u03bb (p : \u03b1 \u00d7 \u03b1), has_nndist.nndist p.fst p.snd)", "decl_nm": "continuous_nndist", "nl_statement_of_codex": "The function $f:\\alpha\\times\\alpha\\to\\mathbb{R}$ defined by $f(x,y)=d(x,y)$ is continuous."}
{"formal_statement": "theorem uniform_embedding_subtype_coe {\u03b1 : Type*} [uniform_space \u03b1] {p : \u03b1 \u2192 Prop} :\n\tuniform_embedding coe", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] {p : \u03b1 \u2192 Prop}, uniform_embedding coe", "decl_nm": "uniform_embedding_subtype_coe", "nl_statement_of_codex": "The inclusion map $i:A\\to X$ is a uniform embedding if $A$ is a subspace of $X$."}
{"formal_statement": "theorem restrict {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : is_open_map f) (hs : is_open s) :\n\t\u2200 {s : set \u03b1},  is_open_map (set.restrict f s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, is_open_map f \u2192 \u2200 {s : set \u03b1}, is_open s \u2192 is_open_map (set.restrict f s)", "decl_nm": "is_open_map.restrict", "nl_statement_of_codex": "Let $f:X\\to Y$ be an open map and let $A\\subset X$. Then the restriction $f|_A:A\\to Y$ is an open map."}
{"formal_statement": "theorem eq_zpow_of_nonzero (p : \u2115) {q : \u211a} (hq : q \u2260 0) :\n\tpadic_norm p q = \u2191p ^ -padic_val_rat p q", "decl_tp": "\u2200 (p : \u2115) {q : \u211a}, q \u2260 0 \u2192 padic_norm p q = \u2191p ^ -padic_val_rat p q", "decl_nm": "padic_norm.eq_zpow_of_nonzero", "nl_statement_of_codex": "Let $p$ be a prime and let $q\\in\\mathbb{Q}$. If $q\\neq 0$, then $|q|_p=p^{-v_p(q)}$."}
{"formal_statement": "theorem smul_left_dual_symm_apply {k : Type*} (M : Type*) [linear_ordered_field k]\n\t[ordered_add_comm_group M] [module k M] [ordered_smul k M] {c : k} (hc : c < 0)\n\t(b : order_dual M) :\n\t\u21d1(rel_iso.symm (order_iso.smul_left_dual M hc)) b = c\u207b\u00b9 \u2022 \u21d1order_dual.of_dual b", "decl_tp": "\u2200 {k : Type u_1} (M : Type u_2) [_inst_1 : linear_ordered_field k] [_inst_2 : ordered_add_comm_group M] [_inst_3 : module k M] [_inst_4 : ordered_smul k M] {c : k} (hc : c < 0) (b : order_dual M), \u21d1(rel_iso.symm (order_iso.smul_left_dual M hc)) b = c\u207b\u00b9 \u2022 \u21d1order_dual.of_dual b", "decl_nm": "order_iso.smul_left_dual_symm_apply", "nl_statement_of_codex": "Let $M$ be a module over a linear ordered field $k$ and let $c\\in k$ be negative. Then the inverse of the isomorphism\n$\\phi:M\\to M^*$ given by $\\phi(m)=c\\cdot m^*$ is given by $\\phi^{-1}(m^*)=\\frac{1}{c}\\cdot m^*$."}
{"formal_statement": "theorem neg_left_iff {R : Type u} [comm_ring R] (x y : R) :\n\tis_coprime (-x) y \u2194 is_coprime x y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] (x y : R), is_coprime (-x) y \u2194 is_coprime x y", "decl_nm": "is_coprime.neg_left_iff", "nl_statement_of_codex": "$x$ and $y$ are coprime if and only if $-x$ and $y$ are coprime."}
{"formal_statement": "theorem two_dvd_ne_zero {n : \u2115} :\n\t\u00ac2 \u2223 n \u2194 n % 2 = 1", "decl_tp": "\u2200 {n : \u2115}, \u00ac2 \u2223 n \u2194 n % 2 = 1", "decl_nm": "nat.two_dvd_ne_zero", "nl_statement_of_codex": "$2$ does not divide $n$ if and only if $n$ is odd."}
{"formal_statement": "theorem mjoin_pure {m : Type u \u2192 Type u} [monad m] [is_lawful_monad m]\n\t{\u03b1 : Type u} (a : m \u03b1) :\n\tmjoin (has_pure.pure a) = a", "decl_tp": "\u2200 {m : Type u \u2192 Type u} [_inst_1 : monad m] [_inst_2 : is_lawful_monad m] {\u03b1 : Type u} (a : m \u03b1), mjoin (has_pure.pure a) = a", "decl_nm": "mjoin_pure", "nl_statement_of_codex": "Let $m$ be a monad. Then $mjoin(pure(a))=a$ for all $a\\in m(\u03b1)$."}
{"formal_statement": "theorem prod_ite_eq {\u03b1 M N : Type*} [has_zero M] [comm_monoid N] [decidable_eq \u03b1]\n\t(f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : \u03b1 \u2192 M \u2192 N) :\n\tf.prod (\u03bb (x : \u03b1) (v : M), ite (a = x) (b x v) 1) = ite (a \u2208 f.support)\n\t(b a (\u21d1f a)) 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_7} [_inst_1 : has_zero M] [_inst_3 : comm_monoid N] [_inst_4 : decidable_eq \u03b1] (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : \u03b1 \u2192 M \u2192 N), f.prod (\u03bb (x : \u03b1) (v : M), ite (a = x) (b x v) 1) = ite (a \u2208 f.support) (b a (\u21d1f a)) 1", "decl_nm": "finsupp.prod_ite_eq", "nl_statement_of_codex": "Let $f$ be a function from $\\alpha$ to $M$ and let $a$ be an element of $\\alpha$. Let $b$ be a function from $\\alpha$ to $M$ to $N$. Then the product of $f$ and $b$ is equal to the product of $b$ and $a$ if $a$ is in the support of $f$ and is equal to $1$ otherwise."}
{"formal_statement": "theorem monotone_powerset {\u03b1 : Type u} :\n\tmonotone set.powerset", "decl_tp": "\u2200 {\u03b1 : Type u}, monotone set.powerset", "decl_nm": "set.monotone_powerset", "nl_statement_of_codex": "The powerset operator is monotone."}
{"formal_statement": "theorem eq_leaf_of_min_eq_none {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} {t : rbtree \u03b1 lt} :\n\tt.min = option.none \u2192 t = mk_rbtree \u03b1 lt", "decl_tp": "\u2200 {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} {t : rbtree \u03b1 lt}, t.min = option.none \u2192 t = mk_rbtree \u03b1 lt", "decl_nm": "rbtree.eq_leaf_of_min_eq_none", "nl_statement_of_codex": "If the minimum of a red-black tree is none, then the tree is empty."}
{"formal_statement": "theorem tr_respects :\n\tturing.respects turing.to_partrec.step (turing.TM2.step turing.partrec_to_TM2.tr) turing.partrec_to_TM2.tr_cfg", "decl_tp": "turing.respects turing.to_partrec.step (turing.TM2.step turing.partrec_to_TM2.tr) turing.partrec_to_TM2.tr_cfg", "decl_nm": "turing.partrec_to_TM2.tr_respects", "nl_statement_of_codex": "The Turing machine $M$ respects the configuration $c$."}
{"formal_statement": "theorem coe_Pi_congr' {\u03b1 : Sort u} {\u03b2 : Sort v} {W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z}\n\t(h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u03a0 (b : \u03b2), W (\u21d1(h\u2081.symm) b) \u2243 Z b) :\n\t\u21d1(h\u2081.Pi_congr' h\u2082) = \u03bb (f : \u03a0 (a : \u03b1), W a) (b : \u03b2), \u21d1(h\u2082 b) (f (\u21d1(h\u2081.symm) b))", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} {W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u03a0 (b : \u03b2), W (\u21d1(h\u2081.symm) b) \u2243 Z b), \u21d1(h\u2081.Pi_congr' h\u2082) = \u03bb (f : \u03a0 (a : \u03b1), W a) (b : \u03b2), \u21d1(h\u2082 b) (f (\u21d1(h\u2081.symm) b))", "decl_nm": "equiv.coe_Pi_congr'", "nl_statement_of_codex": "Let $W$ and $Z$ be families of sets indexed by $\u03b1$ and $\u03b2$, respectively. Let $h_1:\u03b1\\to \u03b2$ be a bijection and let $h_2:\u03b2\\to Z$ be a family of bijections. Then the function $h_1\\circ h_2$ is a bijection."}
{"formal_statement": "theorem Ioo_eq {\u03b1 : Type*} [preorder \u03b1] {a b : \u03b1} (h : a \u22d6 b) :\n\tset.Ioo a b = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {a b : \u03b1}, a \u22d6 b \u2192 set.Ioo a b = \u2205", "decl_nm": "covers.Ioo_eq", "nl_statement_of_codex": "If $a\\geq b$, then $[a,b]=\\emptyset$."}
{"formal_statement": "theorem refl {R \u0393\u2080 : Type*} [linear_ordered_add_comm_monoid_with_top \u0393\u2080]\n\t[ring R] {v : add_valuation R \u0393\u2080} :\n\tv.is_equiv v", "decl_tp": "\u2200 {R : Type u_1} {\u0393\u2080 : Type u_2} [_inst_1 : linear_ordered_add_comm_monoid_with_top \u0393\u2080] [_inst_3 : ring R] {v : add_valuation R \u0393\u2080}, v.is_equiv v", "decl_nm": "add_valuation.is_equiv.refl", "nl_statement_of_codex": "The identity map is an equivalence of valuations."}
{"formal_statement": "theorem sub_antiperiod_eq {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {c\u2081 c\u2082 : \u03b1} [add_comm_group \u03b1]\n\t[add_group \u03b2] (h1 : function.periodic f c\u2081) (h2 : function.antiperiodic f c\u2082) :\n\tf (c\u2081 - c\u2082) = -f 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {c\u2081 c\u2082 : \u03b1} [_inst_1 : add_comm_group \u03b1] [_inst_2 : add_group \u03b2], function.periodic f c\u2081 \u2192 function.antiperiodic f c\u2082 \u2192 f (c\u2081 - c\u2082) = -f 0", "decl_nm": "function.periodic.sub_antiperiod_eq", "nl_statement_of_codex": "Let $f:A\\to B$ be a periodic function with period $c_1$ and an antiperiodic function with antiperiod $c_2$. Then $f(c_1-c_2)=-f(0)$."}
{"formal_statement": "theorem sum_eq_one {\u03b9 : Type u} {X : Type v} [topological_space X] {s : set X}\n\t(f : partition_of_unity \u03b9 X s) {x : X} (hx : x \u2208 s) :\n\tfinsum (\u03bb (i : \u03b9), \u21d1(\u21d1f i) x) = 1", "decl_tp": "\u2200 {\u03b9 : Type u} {X : Type v} [_inst_1 : topological_space X] {s : set X} (f : partition_of_unity \u03b9 X s) {x : X}, x \u2208 s \u2192 finsum (\u03bb (i : \u03b9), \u21d1(\u21d1f i) x) = 1", "decl_nm": "partition_of_unity.sum_eq_one", "nl_statement_of_codex": "Let $X$ be a topological space and let $s$ be a subset of $X$. Let $f$ be a partition of unity subordinate to $s$. Then $\\sum_{i\\in I} f_i(x)=1$ for all $x\\in s$."}
{"formal_statement": "theorem nodup_iff_ne_cons_cons {\u03b1 : Type*} {s : multiset \u03b1} :\n\ts.nodup \u2194 \u2200 (a : \u03b1) (t : multiset \u03b1), s \u2260 a ::\u2098 a ::\u2098 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : multiset \u03b1}, s.nodup \u2194 \u2200 (a : \u03b1) (t : multiset \u03b1), s \u2260 a ::\u2098 a ::\u2098 t", "decl_nm": "multiset.nodup_iff_ne_cons_cons", "nl_statement_of_codex": "A multiset $s$ is nodup if and only if $s$ is not equal to $a::a::t$ for any $a$ and $t$."}
{"formal_statement": "theorem is_unit_iff_exists_inv {M : Type*} [comm_monoid M] {a : M} :\n\tis_unit a \u2194 \u2203 (b : M), a * b = 1", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {a : M}, is_unit a \u2194 \u2203 (b : M), a * b = 1", "decl_nm": "is_unit_iff_exists_inv", "nl_statement_of_codex": "An element $a$ of a commutative monoid $M$ is a unit if and only if there exists an element $b$ of $M$ such that $ab=1$."}
{"formal_statement": "theorem mem_top {R : Type u} {L : Type v} {M : Type w} [comm_ring R] [lie_ring L]\n\t[lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M]\n\t[lie_module R L M] (x : M) :\n\tx \u2208 \u22a4", "decl_tp": "\u2200 {R : Type u} {L : Type v} {M : Type w} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : module R M] [_inst_6 : lie_ring_module L M] [_inst_7 : lie_module R L M] (x : M), x \u2208 \u22a4", "decl_nm": "lie_submodule.mem_top", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a $R$-module. Then $M$ is a Lie $R$-module and $M$ is a Lie $L$-module. Moreover, $M$ is a Lie $R$-module and a Lie $L$-module. Finally, $x\\in M$."}
{"formal_statement": "theorem differentiable_within_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} {s : set E} (h : is_bounded_linear_map \ud835\udd5c f) :\n\tdifferentiable_within_at \ud835\udd5c f s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} {s : set E}, is_bounded_linear_map \ud835\udd5c f \u2192 differentiable_within_at \ud835\udd5c f s x", "decl_nm": "is_bounded_linear_map.differentiable_within_at", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over $\\mathbb{K}$ and let $f:E\\to F$ be a linear map. Then $f$ is differentiable at each point of $E$."}
{"formal_statement": "theorem coe_curry_symm (R V : Type*8) (V\u2082 : Type*9) [semiring R] :\n\t\u21d1((linear_equiv.curry R V V\u2082).symm) = function.uncurry", "decl_tp": "\u2200 (R : Type u_1) (V : Type u_18) (V\u2082 : Type u_19) [_inst_1 : semiring R], \u21d1((linear_equiv.curry R V V\u2082).symm) = function.uncurry", "decl_nm": "linear_equiv.coe_curry_symm", "nl_statement_of_codex": "The uncurrying of a linear equivalence is the inverse of the currying of the inverse of the linear equivalence."}
{"formal_statement": "theorem comp\u2082 {\u03b1 \u03b2 \u03b3 \u03b4 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2] [primcodable \u03b3]\n\t[primcodable \u03b4] [primcodable \u03c3] {f : \u03b3 \u2192 \u03b4 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {h : \u03b1 \u2192 \u03b2 \u2192 \u03b4}\n\t(hf : primrec\u2082 f) (hg : primrec\u2082 g) (hh : primrec\u2082 h) :\n\tprimrec\u2082 (\u03bb (a : \u03b1) (b : \u03b2), f (g a b) (h a b))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} {\u03c3 : Type u_5} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_3 : primcodable \u03b3] [_inst_4 : primcodable \u03b4] [_inst_5 : primcodable \u03c3] {f : \u03b3 \u2192 \u03b4 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {h : \u03b1 \u2192 \u03b2 \u2192 \u03b4}, primrec\u2082 f \u2192 primrec\u2082 g \u2192 primrec\u2082 h \u2192 primrec\u2082 (\u03bb (a : \u03b1) (b : \u03b2), f (g a b) (h a b))", "decl_nm": "primrec\u2082.comp\u2082", "nl_statement_of_codex": "If $f,g,h:\\mathbb{N}\\to\\mathbb{N}$ are primitive recursive, then so is $f(g(n),h(n))$."}
{"formal_statement": "theorem color_classes_independent {V : Type u} {G : simple_graph V} {\u03b1 : Type v}\n\t(C : G.coloring \u03b1) (c : \u03b1) :\n\tis_antichain G.adj (C.color_class c)", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {\u03b1 : Type v} (C : G.coloring \u03b1) (c : \u03b1), is_antichain G.adj (C.color_class c)", "decl_nm": "simple_graph.coloring.color_classes_independent", "nl_statement_of_codex": "Let $G$ be a simple graph and let $C$ be a coloring of $G$. Then the color class $C(c)$ is an independent set."}
{"formal_statement": "theorem to_subsemiring_subtype {R : Type u} {A : Type v} [comm_semiring R]\n\t[semiring A] [algebra R A] (S : subalgebra R A) :\n\tS.to_subsemiring.subtype = \u2191(S.val)", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] (S : subalgebra R A), S.to_subsemiring.subtype = \u2191(S.val)", "decl_nm": "subalgebra.to_subsemiring_subtype", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ be a semiring, and $R\\to A$ be a semiring homomorphism. Let $S$ be a subalgebra of $A$. Then $S$ is a subsemiring of $A$."}
{"formal_statement": "theorem mem_of_subset {\u03b1 : Type*} {s t : multiset \u03b1} {a : \u03b1} (h : s \u2286 t) :\n\ta \u2208 s \u2192 a \u2208 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : multiset \u03b1} {a : \u03b1}, s \u2286 t \u2192 a \u2208 s \u2192 a \u2208 t", "decl_nm": "multiset.mem_of_subset", "nl_statement_of_codex": "If $s$ is a subset of $t$, then $a\\in s$ implies $a\\in t$."}
{"formal_statement": "theorem of_le_nhds' {\u03b1 : Type u} [topological_space \u03b1] {x : \u03b1} {f : filter \u03b1}\n\t(H : f \u2264 nhds x) (hf : f.ne_bot) :\n\tcluster_pt x f", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {x : \u03b1} {f : filter \u03b1}, f \u2264 nhds x \u2192 f.ne_bot \u2192 cluster_pt x f", "decl_nm": "cluster_pt.of_le_nhds'", "nl_statement_of_codex": "Let $X$ be a topological space and let $x\\in X$. If $f$ is a filter on $X$ such that $f\\leq \\mathcal{N}_x$ and $f$ is not the trivial filter, then $x$ is a cluster point of $f$."}
{"formal_statement": "theorem bit1_apply {I : Type u} {f : I \u2192 Type v\u2081} (x : \u03a0 (i : I), f i)\n\t(i : I) [\u03a0 (i : I), has_add (f i)] [\u03a0 (i : I), has_one (f i)] :\n\tbit1 x i = bit1 (x i)", "decl_tp": "\u2200 {I : Type u} {f : I \u2192 Type v\u2081} (x : \u03a0 (i : I), f i) (i : I) [_inst_1 : \u03a0 (i : I), has_add (f i)] [_inst_2 : \u03a0 (i : I), has_one (f i)], bit1 x i = bit1 (x i)", "decl_nm": "pi.bit1_apply", "nl_statement_of_codex": "Let $f:I\\to\\mathbb{N}$ be a function. Then $f(i)=2f(i)$ for all $i\\in I$."}
{"formal_statement": "theorem exists_lt_is_compact_of_ne_top {\u03b1 : Type*} [measurable_space \u03b1]\n\t[topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [\u03bc.regular] [opens_measurable_space \u03b1] \u2983A : set \u03b1\u2984 (hA : measurable_set A)\n\t(h'A : \u21d1\u03bc A \u2260 \u22a4) (hr : r < \u21d1\u03bc A) :\n\t\u2200 {r : ennreal},  (\u2203 (K : set \u03b1) (H : K \u2286 A), is_compact K \u2227 r < \u21d1\u03bc K)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] [_inst_2 : topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [_inst_3 : \u03bc.regular] [_inst_4 : opens_measurable_space \u03b1] \u2983A : set \u03b1\u2984, measurable_set A \u2192 \u21d1\u03bc A \u2260 \u22a4 \u2192 \u2200 {r : ennreal}, r < \u21d1\u03bc A \u2192 (\u2203 (K : set \u03b1) (H : K \u2286 A), is_compact K \u2227 r < \u21d1\u03bc K)", "decl_nm": "measurable_set.exists_lt_is_compact_of_ne_top", "nl_statement_of_codex": "Let $A$ be a measurable set in a topological space $X$ with a regular measure $\\mu$. If $\\mu(A)\\neq \\infty$, then for any $r<\\mu(A)$ there is a compact subset $K$ of $A$ such that $r<\\mu(K)$."}
{"formal_statement": "theorem to_non_unital_alg_hom_injective {R : Type u} {L : Type v} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] {L\u2082 : Type w} [lie_ring L\u2082] [lie_algebra R L\u2082] :\n\tfunction.injective lie_hom.to_non_unital_alg_hom", "decl_tp": "\u2200 {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] {L\u2082 : Type w} [_inst_4 : lie_ring L\u2082] [_inst_5 : lie_algebra R L\u2082], function.injective lie_hom.to_non_unital_alg_hom", "decl_nm": "lie_hom.to_non_unital_alg_hom_injective", "nl_statement_of_codex": "The map from Lie algebra homomorphisms to non-unital algebra homomorphisms is injective."}
{"formal_statement": "theorem mem_edge_finset {V : Type u} (G : simple_graph V) [decidable_eq V]\n\t[fintype V] [decidable_rel G.adj] (e : sym2 V) :\n\te \u2208 G.edge_finset \u2194 e \u2208 G.edge_set", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) [_inst_1 : decidable_eq V] [_inst_2 : fintype V] [_inst_3 : decidable_rel G.adj] (e : sym2 V), e \u2208 G.edge_finset \u2194 e \u2208 G.edge_set", "decl_nm": "simple_graph.mem_edge_finset", "nl_statement_of_codex": "Let $G$ be a simple graph. Then $e\\in G.edge\\_finset$ if and only if $e\\in G.edge\\_set$."}
{"formal_statement": "theorem concave_on_of_lt {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[ordered_add_comm_monoid \u03b2] [module \ud835\udd5c E] [module \ud835\udd5c \u03b2] [linear_order E]\n\t{s : set E} {f : E \u2192 \u03b2} (hs : convex \ud835\udd5c s) :\n\t(\u2200 \u2983x y : E\u2984, x \u2208 s \u2192 y \u2208 s \u2192 x < y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)) \u2192 concave_on \ud835\udd5c s f", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : ordered_add_comm_monoid \u03b2] [_inst_5 : module \ud835\udd5c E] [_inst_6 : module \ud835\udd5c \u03b2] [_inst_7 : linear_order E] {s : set E} {f : E \u2192 \u03b2}, convex \ud835\udd5c s \u2192 (\u2200 \u2983x y : E\u2984, x \u2208 s \u2192 y \u2208 s \u2192 x < y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)) \u2192 concave_on \ud835\udd5c s f", "decl_nm": "linear_order.concave_on_of_lt", "nl_statement_of_codex": "Let $E$ be a linearly ordered set, let $s\\subset E$ be a convex set, and let $f:E\\to \\mathbb{R}$. If $f$ is strictly increasing on $s$, then $f$ is concave on $s$."}
{"formal_statement": "theorem left_inverse_generate_from {\u03b1 : Type u} :\n\tfunction.left_inverse topological_space.generate_from (\u03bb (t : topological_space \u03b1), {s : set \u03b1 | t.is_open s})", "decl_tp": "\u2200 {\u03b1 : Type u}, function.left_inverse topological_space.generate_from (\u03bb (t : topological_space \u03b1), {s : set \u03b1 | t.is_open s})", "decl_nm": "left_inverse_generate_from", "nl_statement_of_codex": "The function that maps a topological space to the set of open sets is a left inverse of the function that maps a set of open sets to the topology generated by that set."}
{"formal_statement": "theorem to_\u03b5_NFA_\u03b5_closure {\u03b1 : Type u} {\u03c3 : Type v} (M : NFA \u03b1 \u03c3) (S : set \u03c3) :\n\tM.to_\u03b5_NFA.\u03b5_closure S = S", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : NFA \u03b1 \u03c3) (S : set \u03c3), M.to_\u03b5_NFA.\u03b5_closure S = S", "decl_nm": "NFA.to_\u03b5_NFA_\u03b5_closure", "nl_statement_of_codex": "The $\\epsilon$-closure of a set $S$ in the $\\epsilon$-NFA obtained from an NFA $M$ is $S$."}
{"formal_statement": "theorem top_prod_top {M N : Type*} [add_zero_class M] [add_zero_class N] :\n\t\u22a4.prod \u22a4 = \u22a4", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N], \u22a4.prod \u22a4 = \u22a4", "decl_nm": "add_submonoid.top_prod_top", "nl_statement_of_codex": "The product of two topological spaces is topological."}
{"formal_statement": "theorem mem_range {R : Type u} {L : Type v} [comm_ring R] [lie_ring L]\n\t[lie_algebra R L] {L\u2082 : Type w} [lie_ring L\u2082] [lie_algebra R L\u2082] (f : L \u2192\u2097\u2045R\u2046 L\u2082)\n\t(x : L\u2082) :\n\tx \u2208 f.range \u2194 \u2203 (y : L), \u21d1f y = x", "decl_tp": "\u2200 {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] {L\u2082 : Type w} [_inst_4 : lie_ring L\u2082] [_inst_5 : lie_algebra R L\u2082] (f : L \u2192\u2097\u2045R\u2046 L\u2082) (x : L\u2082), x \u2208 f.range \u2194 \u2203 (y : L), \u21d1f y = x", "decl_nm": "lie_hom.mem_range", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $L$ and $L_2$ be Lie algebras over $R$, and let $f:L\\to L_2$ be a Lie algebra homomorphism. Then $x\\in f(L)$ if and only if there exists $y\\in L$ such that $f(y)=x$."}
{"formal_statement": "theorem trans {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E] [has_scalar \ud835\udd5c E]\n\t{A B C : set E} (hAB : is_extreme \ud835\udd5c A B) (hBC : is_extreme \ud835\udd5c B C) :\n\tis_extreme \ud835\udd5c A C", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_3 : has_scalar \ud835\udd5c E] {A B C : set E}, is_extreme \ud835\udd5c A B \u2192 is_extreme \ud835\udd5c B C \u2192 is_extreme \ud835\udd5c A C", "decl_nm": "is_extreme.trans", "nl_statement_of_codex": "Let $A, B, C$ be subsets of a vector space $E$ over an ordered field $K$. If $A$ is extreme in $B$ and $B$ is extreme in $C$, then $A$ is extreme in $C$."}
{"formal_statement": "theorem covariant_le_of_covariant_lt (M N : Type*) (\u03bc : M \u2192 N \u2192 N) [partial_order N]\n\t(h : covariant M N \u03bc has_lt.lt) :\n\tcovariant M N \u03bc has_le.le", "decl_tp": "\u2200 (M : Type u_1) (N : Type u_2) (\u03bc : M \u2192 N \u2192 N) [_inst_1 : partial_order N], covariant M N \u03bc has_lt.lt \u2192 covariant M N \u03bc has_le.le", "decl_nm": "covariant_le_of_covariant_lt", "nl_statement_of_codex": "If $\u03bc:M\\times N\\to N$ is a covariant functor that preserves the strict order on $N$, then it also preserves the weak order on $N$."}
{"formal_statement": "theorem min {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [linear_order \u03b2]\n\t{f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hf : is_local_min f a) (hg : is_local_min g a) :\n\tis_local_min (\u03bb (x : \u03b1), linear_order.min (f x) (g x)) a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}, is_local_min f a \u2192 is_local_min g a \u2192 is_local_min (\u03bb (x : \u03b1), linear_order.min (f x) (g x)) a", "decl_nm": "is_local_min.min", "nl_statement_of_codex": "Let $f,g:X\\to\\mathbb{R}$ be continuous functions on a topological space $X$. If $f$ and $g$ have local minima at $a\\in X$, then the function $h:X\\to\\mathbb{R}$ defined by $h(x)=\\min\\{f(x),g(x)\\}$ has a local minimum at $a$."}
{"formal_statement": "theorem tangent_cone_congr {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {x : E} {s t : set E} (h : nhds_within x s = nhds_within x t) :\n\ttangent_cone_at \ud835\udd5c s x = tangent_cone_at \ud835\udd5c t x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {x : E} {s t : set E}, nhds_within x s = nhds_within x t \u2192 tangent_cone_at \ud835\udd5c s x = tangent_cone_at \ud835\udd5c t x", "decl_nm": "tangent_cone_congr", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$. Let $x\\in E$ and let $s,t\\subset E$. If $s$ and $t$ have the same neighborhoods at $x$, then the tangent cones of $s$ and $t$ at $x$ are equal."}
{"formal_statement": "theorem is_coprime_of_irreducible_dvd {R : Type u} [comm_ring R] [is_domain R]\n\t[is_principal_ideal_ring R] [gcd_monoid R] {x y : R} (nonzero : \u00ac(x = 0 \u2227 y = 0)) :\n\t(\u2200 (z : R), irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y) \u2192 is_coprime x y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : is_principal_ideal_ring R] [_inst_4 : gcd_monoid R] {x y : R}, \u00ac(x = 0 \u2227 y = 0) \u2192 (\u2200 (z : R), irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y) \u2192 is_coprime x y", "decl_nm": "is_coprime_of_irreducible_dvd", "nl_statement_of_codex": "Let $R$ be a domain with a principal ideal ring. Let $x, y\\in R$ be nonzero. If $x$ is not divisible by any irreducible element that divides $y$, then $x$ and $y$ are coprime."}
{"formal_statement": "theorem integral_integral {\u03b1 \u03b2 E : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [normed_group E]\n\t[measurable_space E] [measure_theory.sigma_finite \u03bd] [topological_space.second_countable_topology E]\n\t[normed_space \u211d E] [complete_space E] [borel_space E] [measure_theory.sigma_finite \u03bc]\n\t{f : \u03b1 \u2192 \u03b2 \u2192 E} (hf : measure_theory.integrable (function.uncurry f) (\u03bc.prod \u03bd)) :\n\t\u222b (x : \u03b1), \u222b (y : \u03b2), f x y \u2202\u03bd \u2202\u03bc = \u222b (z : \u03b1 \u00d7 \u03b2), f z.fst z.snd \u2202\u03bc.prod \u03bd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_3} {E : Type u_6} [_inst_1 : measurable_space \u03b1] [_inst_3 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [_inst_6 : normed_group E] [_inst_7 : measurable_space E] [_inst_8 : measure_theory.sigma_finite \u03bd] [_inst_9 : topological_space.second_countable_topology E] [_inst_10 : normed_space \u211d E] [_inst_11 : complete_space E] [_inst_12 : borel_space E] [_inst_13 : measure_theory.sigma_finite \u03bc] {f : \u03b1 \u2192 \u03b2 \u2192 E}, measure_theory.integrable (function.uncurry f) (\u03bc.prod \u03bd) \u2192 \u222b (x : \u03b1), \u222b (y : \u03b2), f x y \u2202\u03bd \u2202\u03bc = \u222b (z : \u03b1 \u00d7 \u03b2), f z.fst z.snd \u2202\u03bc.prod \u03bd", "decl_nm": "measure_theory.integral_integral", "nl_statement_of_codex": "Let $E$ be a normed group, let $\\mu$ and $\\nu$ be measures on $\\alpha$ and $\\beta$, respectively.\nLet $f:\\alpha\\times\\beta\\to E$ be a function such that $f$ is integrable with respect to $\\mu\\times\\nu$.\nThen $\\int_{\\alpha}\\int_{\\beta}f(x,y)d\\nu(y)d\\mu(x)=\\int_{\\alpha\\times\\beta}f(x,y)d(\\mu\\times\\nu)(x,y)$."}
{"formal_statement": "theorem frontier_thickening_subset {\u03b1 : Type*} [pseudo_emetric_space \u03b1]\n\t(E : set \u03b1) {\u03b4 : \u211d} (\u03b4_pos : 0 < \u03b4) :\n\tfrontier (metric.thickening \u03b4 E) \u2286 {x : \u03b1 | emetric.inf_edist x E = ennreal.of_real \u03b4}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : pseudo_emetric_space \u03b1] (E : set \u03b1) {\u03b4 : \u211d}, 0 < \u03b4 \u2192 frontier (metric.thickening \u03b4 E) \u2286 {x : \u03b1 | emetric.inf_edist x E = ennreal.of_real \u03b4}", "decl_nm": "metric.frontier_thickening_subset", "nl_statement_of_codex": "Let $E$ be a subset of a pseudo-metric space $X$. Then the frontier of the $\\delta$-thickening of $E$ is contained in the set of points $x\\in X$ such that the infimum of the distance from $x$ to $E$ is equal to $\\delta$."}
{"formal_statement": "theorem update_inr_apply_inl {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type*} [decidable_eq (\u03b1 \u2295 \u03b2)]\n\t{f : \u03b1 \u2295 \u03b2 \u2192 \u03b3} {i : \u03b1} {j : \u03b2} {x : \u03b3} :\n\tfunction.update f (sum.inr j) x (sum.inl i) = f (sum.inl i)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type u_1} [_inst_1 : decidable_eq (\u03b1 \u2295 \u03b2)] {f : \u03b1 \u2295 \u03b2 \u2192 \u03b3} {i : \u03b1} {j : \u03b2} {x : \u03b3}, function.update f (sum.inr j) x (sum.inl i) = f (sum.inl i)", "decl_nm": "sum.update_inr_apply_inl", "nl_statement_of_codex": "Let $f:A\\cup B\\to C$ be a function. Then $f(a)=f(a)$ for all $a\\in A$."}
{"formal_statement": "theorem norm_incl {V : Type*} [semi_normed_group V] {V' : add_subgroup V}\n\t(x : \u21a5V') :\n\t\u2225\u21d1(normed_group_hom.incl V') x\u2225 = \u2225x\u2225", "decl_tp": "\u2200 {V : Type u_1} [_inst_1 : semi_normed_group V] {V' : add_subgroup V} (x : \u21a5V'), \u2225\u21d1(normed_group_hom.incl V') x\u2225 = \u2225x\u2225", "decl_nm": "normed_group_hom.norm_incl", "nl_statement_of_codex": "Let $V$ be a semi-normed group and let $V'$ be a subgroup of $V$. Then the norm of the inclusion map $V'\\to V$ is the identity map."}
{"formal_statement": "theorem mem_join_of_mem {\u03b1 : Type u} {a : \u03b1} {L : list (list \u03b1)} {l : list \u03b1}\n\t(lL : l \u2208 L) (al : a \u2208 l) :\n\ta \u2208 L.join", "decl_tp": "\u2200 {\u03b1 : Type u} {a : \u03b1} {L : list (list \u03b1)} {l : list \u03b1}, l \u2208 L \u2192 a \u2208 l \u2192 a \u2208 L.join", "decl_nm": "list.mem_join_of_mem", "nl_statement_of_codex": "Let $L$ be a list of lists of elements of $A$. If $l$ is an element of $L$ and $a$ is an element of $l$, then $a$ is an element of $L.join$."}
{"formal_statement": "theorem coe_not_mem_range_equiv (k : \u2115) :\n\t\u21d1(not_mem_range_equiv k) = \u03bb (i : {n // n \u2209 multiset.range k}), \u2191i - k", "decl_tp": "\u2200 (k : \u2115), \u21d1(not_mem_range_equiv k) = \u03bb (i : {n // n \u2209 multiset.range k}), \u2191i - k", "decl_nm": "coe_not_mem_range_equiv", "nl_statement_of_codex": "The function $f:\\{n\\in\\mathbb{N}\\mid n\\not\\in\\mathrm{range}(k)\\}\\to\\mathbb{N}$ defined by $f(n)=n-k$ is a bijection."}
{"formal_statement": "theorem Union_nonempty_self {\u03b1 : Type*} (s : set \u03b1) :\n\t(\u22c3 (h : s.nonempty), s) = s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : set \u03b1), (\u22c3 (h : s.nonempty), s) = s", "decl_nm": "set.Union_nonempty_self", "nl_statement_of_codex": "Let $s$ be a set. Then $\\bigcup_{h:s\\neq\\emptyset}s=s$."}
{"formal_statement": "theorem continuous {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t[semi_normed_group E] [semi_normed_group E\u2082] [module R E] [module R\u2082 E\u2082]\n\t(f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\tcontinuous \u21d1f", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082), continuous \u21d1f", "decl_nm": "linear_isometry.continuous", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $\\sigma:R\\to R'$ be a semiring homomorphism, let $E$ and $E'$ be semi-normed groups, let $R$ and $R'$ act on $E$ and $E'$ respectively, and let $f:E\\to E'$ be a linear map. Then $f$ is continuous."}
{"formal_statement": "theorem coe_inj {R : Type*} [comm_ring R] {x y : R} :\n\t\u2191x = \u2191y \u2194 x = y", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {x y : R}, \u2191x = \u2191y \u2194 x = y", "decl_nm": "quaternion.coe_inj", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then the map $R\\to R$ given by $x\\mapsto x$ is injective."}
{"formal_statement": "theorem lxor_right_inj {n m m' : \u2115} (h : n.lxor m = n.lxor m') :\n\tm = m'", "decl_tp": "\u2200 {n m m' : \u2115}, n.lxor m = n.lxor m' \u2192 m = m'", "decl_nm": "nat.lxor_right_inj", "nl_statement_of_codex": "Let $n,m,m'$ be natural numbers. If $n\\oplus m=n\\oplus m'$, then $m=m'$."}
{"formal_statement": "theorem add_map_seq {\u03b1 : Type u} (x y : free_add_magma \u03b1) :\n\thas_add.add <$> x <*> y = x + y", "decl_tp": "\u2200 {\u03b1 : Type u} (x y : free_add_magma \u03b1), has_add.add <$> x <*> y = x + y", "decl_nm": "free_add_magma.add_map_seq", "nl_statement_of_codex": "Let $x,y$ be free add magmas. Then $x+y$ is the free add magma generated by $x$ and $y$."}
{"formal_statement": "theorem compress_of_disjoint_of_le {\u03b1 : Type*} [generalized_boolean_algebra \u03b1]\n\t[decidable_rel disjoint] [decidable_rel has_le.le] {u v a : \u03b1} (hua : disjoint u a)\n\t(hva : v \u2264 a) :\n\tuv.compress u v a = (a \u2294 u) \\ v", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : generalized_boolean_algebra \u03b1] [_inst_2 : decidable_rel disjoint] [_inst_3 : decidable_rel has_le.le] {u v a : \u03b1}, disjoint u a \u2192 v \u2264 a \u2192 uv.compress u v a = (a \u2294 u) \\ v", "decl_nm": "uv.compress_of_disjoint_of_le", "nl_statement_of_codex": "Let $u,v,a$ be elements of a generalized boolean algebra. If $u$ and $a$ are disjoint and $v\\leq a$, then $u\\vee v\\wedge a=a\\vee u\\setminus v$."}
{"formal_statement": "theorem has_terminal_change_universe (C : Type u\u2081) [category_theory.category C]\n\t[h : category_theory.limits.has_limits_of_shape (category_theory.discrete pempty) C] :\n\tcategory_theory.limits.has_limits_of_shape (category_theory.discrete pempty) C", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] [h : category_theory.limits.has_limits_of_shape (category_theory.discrete pempty) C], category_theory.limits.has_limits_of_shape (category_theory.discrete pempty) C", "decl_nm": "category_theory.limits.has_terminal_change_universe", "nl_statement_of_codex": "Let $C$ be a category. If $C$ has limits of shape $\\emptyset$, then $C$ has limits of shape $\\emptyset$."}
{"formal_statement": "theorem le_nhds_Lim {\u03b1 : Type u} [topological_space \u03b1] {f : filter \u03b1} (h : \u2203 (a : \u03b1), f \u2264 nhds a) :\n\tf \u2264 nhds (Lim f)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {f : filter \u03b1} (h : \u2203 (a : \u03b1), f \u2264 nhds a), f \u2264 nhds (Lim f)", "decl_nm": "le_nhds_Lim", "nl_statement_of_codex": "Let $f$ be a filter on a topological space $X$. If $f$ converges to some point $a\\in X$, then $f$ converges to the limit of $f$."}
{"formal_statement": "theorem translate_preimage_left {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[module \ud835\udd5c E] {s : set E} (hs : convex \ud835\udd5c s) :\n\t\u2200 (z : E), convex \ud835\udd5c ((\u03bb (x : E), x + z) \u207b\u00b9' s)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : module \ud835\udd5c E] {s : set E}, convex \ud835\udd5c s \u2192 \u2200 (z : E), convex \ud835\udd5c ((\u03bb (x : E), x + z) \u207b\u00b9' s)", "decl_nm": "convex.translate_preimage_left", "nl_statement_of_codex": "Let $E$ be a vector space over an ordered field $K$ and let $s$ be a convex subset of $E$. Then the set $\\{x+z:x\\in s\\}$ is convex for each $z\\in E$."}
{"formal_statement": "theorem nndist_le {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2]\n\t{K : nnreal} {f : \u03b1 \u2192 \u03b2} (hf : lipschitz_with K f) :\n\t\u2200 (x y : \u03b1), has_nndist.nndist (f x) (f y) \u2264 K * has_nndist.nndist x y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2}, lipschitz_with K f \u2192 \u2200 (x y : \u03b1), has_nndist.nndist (f x) (f y) \u2264 K * has_nndist.nndist x y", "decl_nm": "lipschitz_with.nndist_le", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between pseudo-metric spaces. If $f$ is $K$-Lipschitz, then $d_Y(f(x),f(y))\\leq Kd_X(x,y)$ for all $x,y\\in X$."}
{"formal_statement": "theorem borel_eq_top_of_encodable {\u03b1 : Type*} [topological_space \u03b1] [t1_space \u03b1]\n\t[encodable \u03b1] :\n\tborel \u03b1 = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_2 : t1_space \u03b1] [_inst_3 : encodable \u03b1], borel \u03b1 = \u22a4", "decl_nm": "borel_eq_top_of_encodable", "nl_statement_of_codex": "If $X$ is a topological space and $X$ is encodable, then the Borel $\\sigma$-algebra on $X$ is the top $\\sigma$-algebra on $X$."}
{"formal_statement": "theorem ae_le_iff_absolutely_continuous {\u03b1 : Type*} {m0 : measurable_space \u03b1}\n\t{\u03bc \u03bd : measure_theory.measure \u03b1} :\n\t\u03bc.ae \u2264 \u03bd.ae \u2194 \u03bc.absolutely_continuous \u03bd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1}, \u03bc.ae \u2264 \u03bd.ae \u2194 \u03bc.absolutely_continuous \u03bd", "decl_nm": "measure_theory.measure.ae_le_iff_absolutely_continuous", "nl_statement_of_codex": "Let $\u03bc$ and $\u03bd$ be measures on a measurable space $\u03b1$. Then $\u03bc$ is absolutely continuous with respect to $\u03bd$ if and only if $\u03bc$ is almost everywhere less than or equal to $\u03bd$."}
{"formal_statement": "theorem to_structured_arrow_obj {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (F : C \u2964 D) (d : D) (X : (category_theory.costructured_arrow F d)\u1d52\u1d56) :\n\t(category_theory.costructured_arrow.to_structured_arrow F d).obj X = category_theory.structured_arrow.mk (opposite.unop X).hom.op", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C \u2964 D) (d : D) (X : (category_theory.costructured_arrow F d)\u1d52\u1d56), (category_theory.costructured_arrow.to_structured_arrow F d).obj X = category_theory.structured_arrow.mk (opposite.unop X).hom.op", "decl_nm": "category_theory.costructured_arrow.to_structured_arrow_obj", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ be a functor. Let $d$ be an object of $D$ and let $X$ be an object of the category of costructured arrows from $F$ to $d$. Then the object of the category of structured arrows from $F$ to $d$ corresponding to $X$ is the structured arrow with underlying morphism the opposite of the underlying morphism of $X$."}
{"formal_statement": "theorem zero_comp {R\u2081 R\u2082 R\u2083 M M\u2082 : Type*1} {M\u2083 : Type*2} [semiring R\u2081]\n\t[semiring R\u2082] [semiring R\u2083] [add_comm_monoid M] [add_comm_monoid M\u2082] [add_comm_monoid M\u2083]\n\t[module R\u2081 M] [module R\u2082 M\u2082] [module R\u2083 M\u2083] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083}\n\t{\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083} [ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n\t0.comp f = 0", "decl_tp": "\u2200 {R\u2081 : Type u_2} {R\u2082 : Type u_3} {R\u2083 : Type u_4} {M : Type u_9} {M\u2082 : Type u_11} {M\u2083 : Type u_12} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] [_inst_3 : semiring R\u2083] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_6 : add_comm_monoid M\u2083] [_inst_10 : module R\u2081 M] [_inst_11 : module R\u2082 M\u2082] [_inst_12 : module R\u2083 M\u2083] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083} [_inst_16 : ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082), 0.comp f = 0", "decl_nm": "linear_map.zero_comp", "nl_statement_of_codex": "Let $R_1, R_2, R_3$ be semirings, $M, M_2, M_3$ be add_comm_monoids, and $R_1, R_2, R_3$ act on $M, M_2, M_3$ respectively. Let $\\sigma_{12}:R_1\\to R_2$ and $\\sigma_{23}:R_2\\to R_3$ be ring homomorphisms. Then $\\sigma_{13}(0)\\circ f=0$."}
{"formal_statement": "theorem sum {R A : Type*} [comm_ring R] [comm_ring A] [algebra R A] {\u03b1 : Type*}\n\t{s : finset \u03b1} (f : \u03b1 \u2192 A) :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 is_integral R (f x)) \u2192 is_integral R (s.sum (\u03bb (x : \u03b1), f x))", "decl_tp": "\u2200 {R : Type u_1} {A : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_5 : algebra R A] {\u03b1 : Type u_3} {s : finset \u03b1} (f : \u03b1 \u2192 A), (\u2200 (x : \u03b1), x \u2208 s \u2192 is_integral R (f x)) \u2192 is_integral R (s.sum (\u03bb (x : \u03b1), f x))", "decl_nm": "is_integral.sum", "nl_statement_of_codex": "Let $R$ be a commutative ring, $A$ be a commutative $R$-algebra, and $s$ be a finite set. If $f:s\\to A$ is a function such that $f(x)$ is integral over $R$ for all $x\\in s$, then $\\sum_{x\\in s}f(x)$ is integral over $R$."}
{"formal_statement": "theorem integral_nonneg_of_ae_restrict {\u03b1 : Type*} [linear_order \u03b1] [measurable_space \u03b1]\n\t{f : \u03b1 \u2192 \u211d} {a b : \u03b1} {\u03bc : measure_theory.measure \u03b1} (hab : a \u2264 b) (hf : 0 \u2264\u1d50[\u03bc.restrict (set.Icc a b)] f) :\n\t0 \u2264 \u222b (u : \u03b1) in a..b, f u \u2202\u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] [_inst_2 : measurable_space \u03b1] {f : \u03b1 \u2192 \u211d} {a b : \u03b1} {\u03bc : measure_theory.measure \u03b1}, a \u2264 b \u2192 0 \u2264\u1d50[\u03bc.restrict (set.Icc a b)] f \u2192 0 \u2264 \u222b (u : \u03b1) in a..b, f u \u2202\u03bc", "decl_nm": "interval_integral.integral_nonneg_of_ae_restrict", "nl_statement_of_codex": "Let $f:\\mathbb{R}\\to\\mathbb{R}$ be a measurable function and let $a,b\\in\\mathbb{R}$ with $a\\leq b$. If $f\\geq 0$ almost everywhere on $[a,b]$, then $\\int_a^b f(x)dx\\geq 0$."}
{"formal_statement": "theorem default_eq_zero :\n\tinhabited.default \u2124 = 0", "decl_tp": "inhabited.default \u2124 = 0", "decl_nm": "int.default_eq_zero", "nl_statement_of_codex": "The default element of $\\mathbb{Z}$ is $0$."}
{"formal_statement": "theorem inv_apply_self {\u03b1 : Type u} (f : equiv.perm \u03b1) (x : \u03b1) :\n\t\u21d1f\u207b\u00b9 (\u21d1f x) = x", "decl_tp": "\u2200 {\u03b1 : Type u} (f : equiv.perm \u03b1) (x : \u03b1), \u21d1f\u207b\u00b9 (\u21d1f x) = x", "decl_nm": "equiv.perm.inv_apply_self", "nl_statement_of_codex": "Let $f$ be a permutation of a set $X$. Then $f^{-1}(f(x))=x$ for all $x\\in X$."}
{"formal_statement": "theorem l_sup {\u03b1 : Type u} {\u03b2 : Type v} {a\u2081 a\u2082 : \u03b1} [semilattice_sup \u03b1]\n\t[semilattice_sup \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : galois_connection l u) :\n\tl (a\u2081 \u2294 a\u2082) = l a\u2081 \u2294 l a\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {a\u2081 a\u2082 : \u03b1} [_inst_1 : semilattice_sup \u03b1] [_inst_2 : semilattice_sup \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}, galois_connection l u \u2192 l (a\u2081 \u2294 a\u2082) = l a\u2081 \u2294 l a\u2082", "decl_nm": "galois_connection.l_sup", "nl_statement_of_codex": "Let $l$ and $u$ be a Galois connection between two semilattices $A$ and $B$. Then $l(a_1\\vee a_2)=l(a_1)\\vee l(a_2)$."}
{"formal_statement": "theorem prod_product' {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [comm_monoid \u03b2]\n\t{s : finset \u03b3} {t : finset \u03b1} {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n\t(s.product t).prod (\u03bb (x : \u03b3 \u00d7 \u03b1), f x.fst x.snd) = s.prod (\u03bb (x : \u03b3), t.prod (\u03bb (y : \u03b1), f x y))", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [_inst_1 : comm_monoid \u03b2] {s : finset \u03b3} {t : finset \u03b1} {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2}, (s.product t).prod (\u03bb (x : \u03b3 \u00d7 \u03b1), f x.fst x.snd) = s.prod (\u03bb (x : \u03b3), t.prod (\u03bb (y : \u03b1), f x y))", "decl_nm": "finset.prod_product'", "nl_statement_of_codex": "Let $f:\\gamma\\times\\alpha\\to\\beta$ be a function. Then\n$$\\prod_{(x,y)\\in\\gamma\\times\\alpha}f(x,y)=\\prod_{x\\in\\gamma}\\prod_{y\\in\\alpha}f(x,y).$$"}
{"formal_statement": "theorem indicator_eventually_eq {\u03b1 M : Type*} [has_zero M] {s t : set \u03b1}\n\t{f g : \u03b1 \u2192 M} {l : filter \u03b1} (hf : f =\u1da0[l \u2293 filter.principal s] g) (hs : s =\u1da0[l] t) :\n\ts.indicator f =\u1da0[l] t.indicator g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_3} [_inst_1 : has_zero M] {s t : set \u03b1} {f g : \u03b1 \u2192 M} {l : filter \u03b1}, f =\u1da0[l \u2293 filter.principal s] g \u2192 s =\u1da0[l] t \u2192 s.indicator f =\u1da0[l] t.indicator g", "decl_nm": "indicator_eventually_eq", "nl_statement_of_codex": "Let $f,g:\\alpha\\to M$ be functions and let $s,t\\subset\\alpha$. If $f$ and $g$ are eventually equal on $s$ and $s$ and $t$ are eventually equal, then the indicator functions of $s$ and $t$ are eventually equal."}
{"formal_statement": "theorem mem_map_equiv {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t{f : M \u2243* N} {K : submonoid M} {x : N} :\n\tx \u2208 submonoid.map f.to_monoid_hom K \u2194 \u21d1(f.symm) x \u2208 K", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] {f : M \u2243* N} {K : submonoid M} {x : N}, x \u2208 submonoid.map f.to_monoid_hom K \u2194 \u21d1(f.symm) x \u2208 K", "decl_nm": "submonoid.mem_map_equiv", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity. Let $f:M\\to N$ be a monoid isomorphism. Let $K$ be a submonoid of $M$. Then $x\\in f(K)$ if and only if $f^{-1}(x)\\in K$."}
{"formal_statement": "theorem lim_map_\u03c0 {J : Type u\u2081} [category_theory.category J] {C : Type u}\n\t[category_theory.category C] {F G : J \u2964 C} [category_theory.limits.has_limit F]\n\t[category_theory.limits.has_limit G] (\u03b1 : F \u27f6 G) (j : J) :\n\tcategory_theory.limits.lim_map \u03b1 \u226b category_theory.limits.limit.\u03c0 G j = category_theory.limits.limit.\u03c0 F j \u226b \u03b1.app j", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u} [_inst_3 : category_theory.category C] {F G : J \u2964 C} [_inst_4 : category_theory.limits.has_limit F] [_inst_5 : category_theory.limits.has_limit G] (\u03b1 : F \u27f6 G) (j : J), category_theory.limits.lim_map \u03b1 \u226b category_theory.limits.limit.\u03c0 G j = category_theory.limits.limit.\u03c0 F j \u226b \u03b1.app j", "decl_nm": "category_theory.limits.lim_map_\u03c0", "nl_statement_of_codex": "Let $F, G:J\\to C$ be functors and let $\\alpha:F\\to G$ be a natural transformation. Then the diagram\n$$\\require{AMScd}\n\\begin{CD}\n\\lim F @>{\\lim \\alpha}>> \\lim G\\\\\n@V{\\pi_j}VV @VV{\\pi_j}V\\\\\nF(j) @>{\\alpha_j}>> G(j)\n\\end{CD}$$\ncommutes."}
{"formal_statement": "theorem dense_of_nonempty_smul_invariant (M : Type*) {\u03b1 : Type*} [monoid M]\n\t[topological_space \u03b1] [mul_action M \u03b1] [mul_action.is_minimal M \u03b1] {s : set \u03b1}\n\t(hne : s.nonempty) :\n\t(\u2200 (c : M), c \u2022 s \u2286 s) \u2192 dense s", "decl_tp": "\u2200 (M : Type u_1) {\u03b1 : Type u_3} [_inst_1 : monoid M] [_inst_3 : topological_space \u03b1] [_inst_4 : mul_action M \u03b1] [_inst_6 : mul_action.is_minimal M \u03b1] {s : set \u03b1}, s.nonempty \u2192 (\u2200 (c : M), c \u2022 s \u2286 s) \u2192 dense s", "decl_nm": "dense_of_nonempty_smul_invariant", "nl_statement_of_codex": "Let $M$ be a monoid acting on a topological space $X$ and let $s\\subset X$. If $s$ is nonempty and invariant under the action of $M$, then $s$ is dense in $X$."}
{"formal_statement": "theorem rpow_le_rpow_of_exponent_le {x : nnreal} {y z : \u211d} (hx : 1 \u2264 x)\n\t(hyz : y \u2264 z) :\n\tx ^ y \u2264 x ^ z", "decl_tp": "\u2200 {x : nnreal} {y z : \u211d}, 1 \u2264 x \u2192 y \u2264 z \u2192 x ^ y \u2264 x ^ z", "decl_nm": "nnreal.rpow_le_rpow_of_exponent_le", "nl_statement_of_codex": "Let $x,y,z$ be nonnegative real numbers such that $x\\geq 1$ and $y\\leq z$. Then $x^y\\leq x^z$."}
{"formal_statement": "theorem rev_list_reverse_aux {n : \u2115} {\u03b1 : Type u} {a : array n \u03b1} (i : \u2115)\n\t(h : i \u2264 n) (t : list \u03b1) :\n\t(d_array.iterate_aux a (\u03bb (_x : fin n), \u03bb (_x : \u03b1) (_y : list \u03b1), _x :: _y) i h list.nil).reverse_core t = d_array.rev_iterate_aux a (\u03bb (_x : fin n), \u03bb (_x : \u03b1)\n\t(_y : list \u03b1), _x :: _y) i h t", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : Type u} {a : array n \u03b1} (i : \u2115) (h : i \u2264 n) (t : list \u03b1), (d_array.iterate_aux a (\u03bb (_x : fin n), \u03bb (_x : \u03b1) (_y : list \u03b1), _x :: _y) i h list.nil).reverse_core t = d_array.rev_iterate_aux a (\u03bb (_x : fin n), \u03bb (_x : \u03b1) (_y : list \u03b1), _x :: _y) i h t", "decl_nm": "array.rev_list_reverse_aux", "nl_statement_of_codex": "Let $n$ be a natural number, let $a$ be an array of length $n$, and let $i$ be a natural number such that $i\\leq n$. Then the reverse of the list obtained by iterating the function $f$ on $a$ starting at $i$ is the list obtained by iterating $f$ on $a$ starting at $i$ in reverse order."}
{"formal_statement": "theorem disjoint_nhds_at_bot {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] [no_bot_order \u03b1] (x : \u03b1) :\n\tdisjoint (nhds x) filter.at_bot", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : no_bot_order \u03b1] (x : \u03b1), disjoint (nhds x) filter.at_bot", "decl_nm": "disjoint_nhds_at_bot", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and an order topology. If $X$ has no bottom element, then the filter of neighbourhoods of $x$ is disjoint from the filter of neighbourhoods of the bottom element."}
{"formal_statement": "theorem compl_bInter {\u03b1 \u03b2 : Type*} (s : set \u03b1) (t : \u03b1 \u2192 set \u03b2) :\n\t(\u22c2 (i : \u03b1) (H : i \u2208 s), t i)\u1d9c = \u22c3 (i : \u03b1) (H : i \u2208 s), (t i)\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (s : set \u03b1) (t : \u03b1 \u2192 set \u03b2), (\u22c2 (i : \u03b1) (H : i \u2208 s), t i)\u1d9c = \u22c3 (i : \u03b1) (H : i \u2208 s), (t i)\u1d9c", "decl_nm": "set.compl_bInter", "nl_statement_of_codex": "Let $s$ be a set and let $t$ be a function from $s$ to sets. Then the complement of the intersection of the sets $t(i)$ for $i\\in s$ is equal to the union of the complements of the sets $t(i)$ for $i\\in s$."}
{"formal_statement": "theorem maps_to_emetric_ball {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : isometry f) :\n\t\u2200 (x : \u03b1) (r : ennreal), set.maps_to f (emetric.ball x r) (emetric.ball (f x) r)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {f : \u03b1 \u2192 \u03b2}, isometry f \u2192 \u2200 (x : \u03b1) (r : ennreal), set.maps_to f (emetric.ball x r) (emetric.ball (f x) r)", "decl_nm": "isometry.maps_to_emetric_ball", "nl_statement_of_codex": "Let $f:X\\to Y$ be an isometry. Then $f$ maps the ball $B_X(x,r)$ to the ball $B_Y(f(x),r)$."}
{"formal_statement": "theorem single_op\u2082 {I : Type u} {f : I \u2192 Type v\u2081} [decidable_eq I] [\u03a0 (i : I), has_zero (f i)]\n\t{g\u2081 : I \u2192 Type*} {g\u2082 : I \u2192 Type*} [\u03a0 (i : I), has_zero (g\u2081 i)] [\u03a0 (i : I), has_zero (g\u2082 i)]\n\t(op : \u03a0 (i : I), g\u2081 i \u2192 g\u2082 i \u2192 f i) :\n\t(\u2200 (i : I), op i 0 0 = 0) \u2192 \u2200 (i : I) (x\u2081 : g\u2081 i) (x\u2082 : g\u2082 i), pi.single i (op i x\u2081 x\u2082) = \u03bb (j : I), op j (pi.single i x\u2081 j)\n\t(pi.single i x\u2082 j)", "decl_tp": "\u2200 {I : Type u} {f : I \u2192 Type v\u2081} [_inst_1 : decidable_eq I] [_inst_2 : \u03a0 (i : I), has_zero (f i)] {g\u2081 : I \u2192 Type u_1} {g\u2082 : I \u2192 Type u_2} [_inst_5 : \u03a0 (i : I), has_zero (g\u2081 i)] [_inst_6 : \u03a0 (i : I), has_zero (g\u2082 i)] (op : \u03a0 (i : I), g\u2081 i \u2192 g\u2082 i \u2192 f i), (\u2200 (i : I), op i 0 0 = 0) \u2192 \u2200 (i : I) (x\u2081 : g\u2081 i) (x\u2082 : g\u2082 i), pi.single i (op i x\u2081 x\u2082) = \u03bb (j : I), op j (pi.single i x\u2081 j) (pi.single i x\u2082 j)", "decl_nm": "pi.single_op\u2082", "nl_statement_of_codex": "Let $I$ be a type, let $f:I\\to\\mathbb{R}$ be a function, let $g_1, g_2:I\\to\\mathbb{R}$ be functions, and let $op:I\\to\\mathbb{R}^2\\to\\mathbb{R}$ be a function. Suppose that $op(i,0,0)=0$ for all $i\\in I$. Then for all $i\\in I$ and $x_1\\in g_1(i)$ and $x_2\\in g_2(i)$, we have $f(i)=op(i,x_"}
{"formal_statement": "theorem image_swap_eq_preimage_swap {\u03b1 : Type u} {\u03b2 : Type v} :\n\tset.image prod.swap = set.preimage prod.swap", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v}, set.image prod.swap = set.preimage prod.swap", "decl_nm": "set.image_swap_eq_preimage_swap", "nl_statement_of_codex": "The image of the swap map is the preimage of the swap map."}
{"formal_statement": "theorem const_sub {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} (hf : differentiable \ud835\udd5c f) :\n\t\u2200 (c : F), differentiable \ud835\udd5c (\u03bb (y : E), c - f y)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F}, differentiable \ud835\udd5c f \u2192 \u2200 (c : F), differentiable \ud835\udd5c (\u03bb (y : E), c - f y)", "decl_nm": "differentiable.const_sub", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be differentiable. Then the function $g:E\\to F$ defined by $g(x)=c-f(x)$ is differentiable for any $c\\in F$."}
{"formal_statement": "theorem nilpotent_iff_equiv_nilpotent {R : Type u} {L : Type v} {L' : Type w}\n\t[comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] :\n\t(L \u2243\u2097\u2045R\u2046 L') \u2192 (lie_algebra.is_nilpotent R L \u2194 lie_algebra.is_nilpotent R L')", "decl_tp": "\u2200 {R : Type u} {L : Type v} {L' : Type w} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'], (L \u2243\u2097\u2045R\u2046 L') \u2192 (lie_algebra.is_nilpotent R L \u2194 lie_algebra.is_nilpotent R L')", "decl_nm": "lie_equiv.nilpotent_iff_equiv_nilpotent", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $L$ and $L'$ be Lie algebras over $R$. If $L$ and $L'$ are isomorphic as Lie algebras, then $L$ is nilpotent if and only if $L'$ is nilpotent."}
{"formal_statement": "theorem find_eq_find_of_eqv {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t[decidable_rel lt] [is_strict_weak_order \u03b1 lt] {k\u2081 k\u2082 : \u03b1} (m : rbmap \u03b1 \u03b2 lt)\n\t(h : strict_weak_order.equiv k\u2081 k\u2082) :\n\tm.find k\u2081 = m.find k\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : decidable_rel lt] [_inst_2 : is_strict_weak_order \u03b1 lt] {k\u2081 k\u2082 : \u03b1} (m : rbmap \u03b1 \u03b2 lt), strict_weak_order.equiv k\u2081 k\u2082 \u2192 m.find k\u2081 = m.find k\u2082", "decl_nm": "rbmap.find_eq_find_of_eqv", "nl_statement_of_codex": "Let $m$ be a red-black map. If $k_1$ and $k_2$ are equivalent, then $m.find(k_1)=m.find(k_2)$."}
{"formal_statement": "theorem times_cont_mdiff_at_proj {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t[Is : smooth_manifold_with_corners I M] {n : with_top \u2115} {p : tangent_bundle I M} :\n\ttimes_cont_mdiff_at I.tangent I n (tangent_bundle.proj I M) p", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [Is : smooth_manifold_with_corners I M] {n : with_top \u2115} {p : tangent_bundle I M}, times_cont_mdiff_at I.tangent I n (tangent_bundle.proj I M) p", "decl_nm": "tangent_bundle.times_cont_mdiff_at_proj", "nl_statement_of_codex": "Let $I$ be a model with corners, $M$ a smooth manifold with corners modeled on $I$, and $n$ a natural number. Then the projection map $\\pi:TM\\to M$ is $n$-times continuously differentiable at each point of $TM$."}
{"formal_statement": "theorem supr_emptyset {\u03b1 \u03b2 : Type*} [complete_lattice \u03b1] {f : \u03b2 \u2192 \u03b1} :\n\t(\u2a06 (x : \u03b2) (H : x \u2208 \u2205), f x) = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : complete_lattice \u03b1] {f : \u03b2 \u2192 \u03b1}, (\u2a06 (x : \u03b2) (H : x \u2208 \u2205), f x) = \u22a5", "decl_nm": "supr_emptyset", "nl_statement_of_codex": "Let $f:B\\to A$ be a function. Then $\\sup_{x\\in\\emptyset}f(x)=\\bot$."}
{"formal_statement": "theorem of_not_dvd (M : Type*) {n p : \u2115} [add_monoid M] [has_one M] [char_p M p]\n\t(h : \u00acp \u2223 n) :\n\tne_zero \u2191n", "decl_tp": "\u2200 (M : Type u_2) {n p : \u2115} [_inst_1 : add_monoid M] [_inst_2 : has_one M] [_inst_3 : char_p M p], \u00acp \u2223 n \u2192 ne_zero \u2191n", "decl_nm": "ne_zero.of_not_dvd", "nl_statement_of_codex": "Let $M$ be a monoid with a unit element and characteristic $p$. If $p$ does not divide $n$, then $n$ is not zero."}
{"formal_statement": "theorem closed_embedding_coe_real :\n\tclosed_embedding coe", "decl_tp": "closed_embedding coe", "decl_nm": "int.closed_embedding_coe_real", "nl_statement_of_codex": "The map $\\mathbb{R}\\to\\mathbb{R}$ given by $x\\mapsto x$ is a closed embedding."}
{"formal_statement": "theorem infi_univ {\u03b1 \u03b2 : Type*} [complete_lattice \u03b1] {f : \u03b2 \u2192 \u03b1} :\n\t(\u2a05 (x : \u03b2) (H : x \u2208 set.univ), f x) = \u2a05 (x : \u03b2), f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : complete_lattice \u03b1] {f : \u03b2 \u2192 \u03b1}, (\u2a05 (x : \u03b2) (H : x \u2208 set.univ), f x) = \u2a05 (x : \u03b2), f x", "decl_nm": "infi_univ", "nl_statement_of_codex": "Let $X$ be a complete lattice and let $f:X\\to Y$ be a function. Then $\\inf_{x\\in X}f(x)=\\inf_{x\\in Y}f(x)$."}
{"formal_statement": "theorem univ_pi_Ico_ae_eq_Icc {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9] [\u03a0 (i : \u03b9), measurable_space (\u03b1 i)]\n\t{\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)} [\u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)]\n\t[\u03a0 (i : \u03b9), partial_order (\u03b1 i)] [\u2200 (i : \u03b9), measure_theory.has_no_atoms (\u03bc i)]\n\t{f g : \u03a0 (i : \u03b9), \u03b1 i} :\n\tset.univ.pi (\u03bb (i : \u03b9), set.Ico (f i) (g i)) =\u1d50[measure_theory.measure.pi \u03bc] set.Icc f g", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_3} [_inst_1 : fintype \u03b9] [_inst_3 : \u03a0 (i : \u03b9), measurable_space (\u03b1 i)] {\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)} [_inst_4 : \u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)] [_inst_5 : \u03a0 (i : \u03b9), partial_order (\u03b1 i)] [_inst_6 : \u2200 (i : \u03b9), measure_theory.has_no_atoms (\u03bc i)] {f g : \u03a0 (i : \u03b9), \u03b1 i}, set.univ.pi (\u03bb (i : \u03b9), set.Ico (f i) (g i)) =\u1d50[measure_theory.measure.pi \u03bc] set.Icc f g", "decl_nm": "measure_theory.measure.univ_pi_Ico_ae_eq_Icc", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be two functions. Then the set $\\{(x_1,\\ldots,x_n)\\in\\mathbb{R}^n:f(i)\\leq x_i\\leq g(i)\\text{ for all }i\\}$ is equal to the set $\\{(x_1,\\ldots,x_n)\\in\\mathbb{R}^n:f(i)\\leq x_i\\leq g(i)\\text{ for all }i\\}$ up to a set of measure zero."}
{"formal_statement": "theorem div (p : \u2115) [hp : fact (nat.prime p)] (q r : \u211a) :\n\tpadic_norm p (q / r) = padic_norm p q / padic_norm p r", "decl_tp": "\u2200 (p : \u2115) [hp : fact (nat.prime p)] (q r : \u211a), padic_norm p (q / r) = padic_norm p q / padic_norm p r", "decl_nm": "padic_norm.div", "nl_statement_of_codex": "Let $p$ be a prime. Then the $p$-adic norm of $q/r$ is equal to the $p$-adic norm of $q$ divided by the $p$-adic norm of $r$."}
{"formal_statement": "theorem amalgamate_map {C : Type u\u2081} [category_theory.category C] {J : category_theory.grothendieck_topology C}\n\t{A : Type u\u2082} [category_theory.category A] {E : A} {X : C} {P : C\u1d52\u1d56 \u2964 A}\n\t(hP : category_theory.presheaf.is_sheaf J P) (S : J.cover X) (x : \u03a0 (I : S.arrow), E \u27f6 P.obj (opposite.op I.Y))\n\t(hx : \u2200 (I : S.relation), x I.fst \u226b P.map I.g\u2081.op = x I.snd \u226b P.map I.g\u2082.op)\n\t(I : S.arrow) :\n\thP.amalgamate S x hx \u226b P.map I.f.op = x I", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {J : category_theory.grothendieck_topology C} {A : Type u\u2082} [_inst_3 : category_theory.category A] {E : A} {X : C} {P : C\u1d52\u1d56 \u2964 A} (hP : category_theory.presheaf.is_sheaf J P) (S : J.cover X) (x : \u03a0 (I : S.arrow), E \u27f6 P.obj (opposite.op I.Y)) (hx : \u2200 (I : S.relation), x I.fst \u226b P.map I.g\u2081.op = x I.snd \u226b P.map I.g\u2082.op) (I : S.arrow), hP.amalgamate S x hx \u226b P.map I.f.op = x I", "decl_nm": "category_theory.presheaf.is_sheaf.amalgamate_map", "nl_statement_of_codex": "Let $C$ be a category, $J$ a Grothendieck topology on $C$, $A$ a category, $E$ an object of $A$, $X$ an object of $C$, $P$ a presheaf on $C$ with values in $A$, and $S$ a cover of $X$. Suppose that $P$ is a sheaf on $C$ with respect to $J$. Let $x$ be a family of morphisms $x_I:E\\to P(I)$ for each $I\\in S$ such that $x_I\\circ P(f)=x_J\\circ P(g)$ for each $"}
{"formal_statement": "theorem differentiable_id {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] :\n\tdifferentiable \ud835\udd5c id", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E], differentiable \ud835\udd5c id", "decl_nm": "differentiable_id", "nl_statement_of_codex": "The identity function on a normed space is differentiable."}
{"formal_statement": "theorem lower_semicontinuous_at {\u03b1 : Type*} [topological_space \u03b1] {\u03b2 : Type*}\n\t[preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (h : lower_semicontinuous f) :\n\t\u2200 (x : \u03b1), lower_semicontinuous_at f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, lower_semicontinuous f \u2192 \u2200 (x : \u03b1), lower_semicontinuous_at f x", "decl_nm": "lower_semicontinuous.lower_semicontinuous_at", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f$ is lower semicontinuous, then $f$ is lower semicontinuous at each point."}
{"formal_statement": "theorem comp_left {\u03b1 : Type*} {f f' g : \u03b1 \u2192 \u03b1} (h : function.commute f g)\n\t(h' : function.commute f' g) :\n\tfunction.commute (f \u2218 f') g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f f' g : \u03b1 \u2192 \u03b1}, function.commute f g \u2192 function.commute f' g \u2192 function.commute (f \u2218 f') g", "decl_nm": "function.commute.comp_left", "nl_statement_of_codex": "Let $f,f',g:\\alpha\\to\\alpha$ be functions. If $f$ and $g$ commute and $f'$ and $g$ commute, then $f\\circ f'$ and $g$ commute."}
{"formal_statement": "theorem ne_of_apply_ne {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} (f : \u03b1 \u2192 \u03b2) {x y : \u03b1}\n\t(h : f x \u2260 f y) :\n\tx \u2260 y", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} (f : \u03b1 \u2192 \u03b2) {x y : \u03b1}, f x \u2260 f y \u2192 x \u2260 y", "decl_nm": "ne_of_apply_ne", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. If $f(x)\\neq f(y)$, then $x\\neq y$."}
{"formal_statement": "theorem add_apply {\u03b1 M : Type*} [add_zero_class M] (g\u2081 g\u2082 : \u03b1 \u2192\u2080 M) (a : \u03b1) :\n\t\u21d1(g\u2081 + g\u2082) a = \u21d1g\u2081 a + \u21d1g\u2082 a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : add_zero_class M] (g\u2081 g\u2082 : \u03b1 \u2192\u2080 M) (a : \u03b1), \u21d1(g\u2081 + g\u2082) a = \u21d1g\u2081 a + \u21d1g\u2082 a", "decl_nm": "finsupp.add_apply", "nl_statement_of_codex": "Let $M$ be an additive monoid with zero. Let $g_1, g_2:\\alpha\\to M$ be functions. Then $(g_1+g_2)(a)=g_1(a)+g_2(a)$."}
{"formal_statement": "theorem measurable_set {\u03b1 \u03b9 : Type*} {m : measurable_space \u03b1} [preorder \u03b9]\n\t{f : measure_theory.filtration \u03b9 m} {\u03c4 : \u03b1 \u2192 \u03b9} (h\u03c4 : measure_theory.is_stopping_time f \u03c4)\n\t(s : set \u03b1) :\n\tmeasurable_set s \u2194 \u2200 (i : \u03b9), measurable_set (s \u2229 {x : \u03b1 | \u03c4 x \u2264 i})", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_3} {m : measurable_space \u03b1} [_inst_2 : preorder \u03b9] {f : measure_theory.filtration \u03b9 m} {\u03c4 : \u03b1 \u2192 \u03b9} (h\u03c4 : measure_theory.is_stopping_time f \u03c4) (s : set \u03b1), measurable_set s \u2194 \u2200 (i : \u03b9), measurable_set (s \u2229 {x : \u03b1 | \u03c4 x \u2264 i})", "decl_nm": "measure_theory.is_stopping_time.measurable_set", "nl_statement_of_codex": "Let $X$ be a measurable space and let $f$ be a filtration on $X$. Let $\\tau$ be a stopping time for $f$. Then $s\\subset X$ is measurable if and only if $s\\cap\\{x\\in X\\mid \\tau(x)\\leq i\\}$ is measurable for all $i\\in I$."}
{"formal_statement": "theorem coe_mul_left\u2080 {G\u2080 : Type*} [measurable_space G\u2080] [group_with_zero G\u2080]\n\t[has_measurable_mul G\u2080] {g : G\u2080} (hg : g \u2260 0) :\n\t\u21d1(measurable_equiv.mul_left\u2080 g hg) = has_mul.mul g", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_2 : measurable_space G\u2080] [_inst_5 : group_with_zero G\u2080] [_inst_11 : has_measurable_mul G\u2080] {g : G\u2080} (hg : g \u2260 0), \u21d1(measurable_equiv.mul_left\u2080 g hg) = has_mul.mul g", "decl_nm": "measurable_equiv.coe_mul_left\u2080", "nl_statement_of_codex": "Let $G$ be a group with zero. Then the map $x\\mapsto gx$ is measurable if and only if $g\\neq 0$."}
{"formal_statement": "theorem coe_add {R : Type u} {M : Type v} [semiring R] [add_comm_monoid M]\n\t{module_M : module R M} {p : submodule R M} (x y : \u21a5p) :\n\t\u2191(x + y) = \u2191x + \u2191y", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] {module_M : module R M} {p : submodule R M} (x y : \u21a5p), \u2191(x + y) = \u2191x + \u2191y", "decl_nm": "submodule.coe_add", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ be an $R$-module, and $p$ be a submodule of $M$. Then the map $x\\mapsto \\bar{x}$ is a homomorphism of $R$-modules from $p$ to $M$."}
{"formal_statement": "theorem tendsto_at_bot_iff {\u03b1 \u03b2 : Type*} [normed_linear_ordered_field \u03b2]\n\t{u v : \u03b1 \u2192 \u03b2} {l : filter \u03b1} [order_topology \u03b2] (huv : asymptotics.is_equivalent u v l) :\n\t(filter.tendsto u l filter.at_bot \u2194 filter.tendsto v l filter.at_bot)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : normed_linear_ordered_field \u03b2] {u v : \u03b1 \u2192 \u03b2} {l : filter \u03b1} [_inst_2 : order_topology \u03b2], asymptotics.is_equivalent u v l \u2192 (filter.tendsto u l filter.at_bot \u2194 filter.tendsto v l filter.at_bot)", "decl_nm": "asymptotics.is_equivalent.tendsto_at_bot_iff", "nl_statement_of_codex": "Let $u,v:\\alpha\\to\\beta$ be functions. Then $u$ tends to $0$ as $x\\to\\infty$ if and only if $v$ tends to $0$ as $x\\to\\infty$."}
{"formal_statement": "theorem support_max {\u03b1 M : Type*} [has_zero M] [linear_order M] (f g : \u03b1 \u2192 M) :\n\tfunction.support (\u03bb (x : \u03b1), linear_order.max (f x) (g x)) \u2286 function.support f \u222a function.support g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] [_inst_4 : linear_order M] (f g : \u03b1 \u2192 M), function.support (\u03bb (x : \u03b1), linear_order.max (f x) (g x)) \u2286 function.support f \u222a function.support g", "decl_nm": "function.support_max", "nl_statement_of_codex": "Let $f,g:\\alpha\\to M$ be functions. Then the support of the function $x\\mapsto \\max\\{f(x),g(x)\\}$ is a subset of the union of the supports of $f$ and $g$."}
{"formal_statement": "theorem top_eq {\u03b1 \u03b2 \u03b3 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop}\n\t[is_well_order \u03b3 t] (e : r \u2243r s) :\n\t\u2200 (f : principal_seg r t) (g : principal_seg s t), f.top = g.top", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop} [_inst_1 : is_well_order \u03b3 t], r \u2243r s \u2192 \u2200 (f : principal_seg r t) (g : principal_seg s t), f.top = g.top", "decl_nm": "principal_seg.top_eq", "nl_statement_of_codex": "Let $r, s, t$ be relations on types $\u03b1, \u03b2, \u03b3$ respectively. Suppose that $t$ is a well-order. Let $e$ be an equivalence between $r$ and $s$. Then the top element of a principal segment of $r$ is equal to the top element of the corresponding principal segment of $s$."}
{"formal_statement": "theorem prod_eq_zero {\u03b9 : Type*} (f : \u03b9 \u2192 cardinal) :\n\tcardinal.prod f = 0 \u2194 \u2203 (i : \u03b9), f i = 0", "decl_tp": "\u2200 {\u03b9 : Type u_1} (f : \u03b9 \u2192 cardinal), cardinal.prod f = 0 \u2194 \u2203 (i : \u03b9), f i = 0", "decl_nm": "cardinal.prod_eq_zero", "nl_statement_of_codex": "The product of a family of cardinals is zero if and only if there is an index $i$ such that $f(i)=0$."}
{"formal_statement": "theorem of_type_monad_\u03bc_app (m : Type u \u2192 Type u) [monad m] [is_lawful_monad m]\n\t{\u03b1 : Type u} (a : m (m \u03b1)) :\n\t(category_theory.of_type_monad m).\u03bc.app \u03b1 a = mjoin a", "decl_tp": "\u2200 (m : Type u \u2192 Type u) [_inst_1 : monad m] [_inst_2 : is_lawful_monad m] {\u03b1 : Type u} (a : m (m \u03b1)), (category_theory.of_type_monad m).\u03bc.app \u03b1 a = mjoin a", "decl_nm": "category_theory.of_type_monad_\u03bc_app", "nl_statement_of_codex": "The monad multiplication $\\mu$ is the same as the monad join."}
{"formal_statement": "theorem maps_univ_to {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : set \u03b2) :\n\tset.maps_to f set.univ s \u2194 \u2200 (a : \u03b1), f a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : set \u03b2), set.maps_to f set.univ s \u2194 \u2200 (a : \u03b1), f a \u2208 s", "decl_nm": "set.maps_univ_to", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then $f$ maps $A$ onto $B$ if and only if $f(a)\\in B$ for all $a\\in A$."}
{"formal_statement": "theorem unfolds_head_eq {\u03b1 : Type u} (s : stream \u03b1) :\n\tstream.unfolds stream.head stream.tail s = s", "decl_tp": "\u2200 {\u03b1 : Type u} (s : stream \u03b1), stream.unfolds stream.head stream.tail s = s", "decl_nm": "stream.unfolds_head_eq", "nl_statement_of_codex": "The stream $s$ is equal to the stream that unfolds the head and tail of $s$."}
{"formal_statement": "theorem left_inverse_bij_inv {\u03b1 \u03b2 : Type*} [fintype \u03b1] [decidable_eq \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (f_bij : function.bijective f) :\n\tfunction.left_inverse (fintype.bij_inv f_bij) f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b2] {f : \u03b1 \u2192 \u03b2} (f_bij : function.bijective f), function.left_inverse (fintype.bij_inv f_bij) f", "decl_nm": "fintype.left_inverse_bij_inv", "nl_statement_of_codex": "Let $f:A\\to B$ be a bijection. Then $f^{-1}$ is a left inverse of $f$."}
{"formal_statement": "theorem card_repeat {\u03b1 : Type*} (a : \u03b1) (n : \u2115) :\n\t\u21d1multiset.card (multiset.repeat a n) = n", "decl_tp": "\u2200 {\u03b1 : Type u_1} (a : \u03b1) (n : \u2115), \u21d1multiset.card (multiset.repeat a n) = n", "decl_nm": "multiset.card_repeat", "nl_statement_of_codex": "The cardinality of the multiset $\\{a,\\ldots,a\\}$ is $n$."}
{"formal_statement": "theorem mem_support_C_mul_X_pow {R : Type u} [semiring R] {n a : \u2115} {c : R}\n\t(h : a \u2208 (\u21d1polynomial.C c * polynomial.X ^ n).support) :\n\ta = n", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {n a : \u2115} {c : R}, a \u2208 (\u21d1polynomial.C c * polynomial.X ^ n).support \u2192 a = n", "decl_nm": "polynomial.mem_support_C_mul_X_pow", "nl_statement_of_codex": "Let $R$ be a semiring, $n$ and $a$ be natural numbers, and $c$ be an element of $R$. If $a$ is in the support of $cX^n$, then $a=n$."}
{"formal_statement": "theorem lipschitz_on_with {E : Type*} [normed_group E] [normed_space \u211d E]\n\t(v : picard_lindelof E) {t : \u211d} (ht : t \u2208 set.Icc v.t_min v.t_max) :\n\tlipschitz_on_with v.L (\u21d1v t) (metric.closed_ball v.x\u2080 \u2191(v.R))", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] (v : picard_lindelof E) {t : \u211d}, t \u2208 set.Icc v.t_min v.t_max \u2192 lipschitz_on_with v.L (\u21d1v t) (metric.closed_ball v.x\u2080 \u2191(v.R))", "decl_nm": "picard_lindelof.lipschitz_on_with", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$. Let $v$ be a Picard-Lindel\u00f6f function on $E$. Then the function $v_t$ is Lipschitz on the closed ball of radius $R$ around $x_0$."}
{"formal_statement": "theorem faithful_of_comp {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t{F : C \u2964 D} {G : D \u2964 E} {H : C \u2964 E} [\u210b : category_theory.faithful H] :\n\t(F \u22d9 G \u2245 H) \u2192 category_theory.faithful F", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] {F : C \u2964 D} {G : D \u2964 E} {H : C \u2964 E} [\u210b : category_theory.faithful H], (F \u22d9 G \u2245 H) \u2192 category_theory.faithful F", "decl_nm": "category_theory.iso.faithful_of_comp", "nl_statement_of_codex": "Let $C, D, E$ be categories and let $F:C\\to D$, $G:D\\to E$, $H:C\\to E$ be functors. If $H$ is faithful and $F\\circ G\\cong H$, then $F$ is faithful."}
{"formal_statement": "theorem even_sub_one_of_prime_ne_two {p : \u2115} (hp : nat.prime p) (hodd : p \u2260 2) :\n\teven (p - 1)", "decl_tp": "\u2200 {p : \u2115}, nat.prime p \u2192 p \u2260 2 \u2192 even (p - 1)", "decl_nm": "nat.even_sub_one_of_prime_ne_two", "nl_statement_of_codex": "If $p$ is a prime number and $p\\neq 2$, then $p-1$ is even."}
{"formal_statement": "theorem mem_to_submodule {R : Type u} {A : Type v} [comm_semiring R] [semiring A]\n\t[algebra R A] (S : subalgebra R A) {x : A} :\n\tx \u2208 S.to_submodule \u2194 x \u2208 S", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] (S : subalgebra R A) {x : A}, x \u2208 S.to_submodule \u2194 x \u2208 S", "decl_nm": "subalgebra.mem_to_submodule", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a semiring, and $S$ a subalgebra of $A$ over $R$. Then $x\\in S$ if and only if $x\\in S$ as a submodule of $A$."}
{"formal_statement": "theorem add_right_apply {E : Type*} [semi_normed_group E] (x y : E) :\n\t\u21d1(isometric.add_right x) y = y + x", "decl_tp": "\u2200 {E : Type u_3} [_inst_1 : semi_normed_group E] (x y : E), \u21d1(isometric.add_right x) y = y + x", "decl_nm": "isometric.add_right_apply", "nl_statement_of_codex": "Let $E$ be a semi-normed group. Then the map $f:E\\to E$ defined by $f(y)=y+x$ is an isometry."}
{"formal_statement": "theorem size_balance_l {\u03b1 : Type*} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1}\n\t(hl : l.balanced) (hr : r.balanced) (sl : l.sized) (sr : r.sized) :\n\t((\u2203 (l' : \u2115), ordnode.raised l' l.size \u2227 ordnode.balanced_sz l' r.size) \u2228 \u2203 (r' : \u2115), ordnode.raised r.size r' \u2227 ordnode.balanced_sz l.size r') \u2192 (l.balance_l x r).size = l.size + r.size + 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1}, l.balanced \u2192 r.balanced \u2192 l.sized \u2192 r.sized \u2192 ((\u2203 (l' : \u2115), ordnode.raised l' l.size \u2227 ordnode.balanced_sz l' r.size) \u2228 \u2203 (r' : \u2115), ordnode.raised r.size r' \u2227 ordnode.balanced_sz l.size r') \u2192 (l.balance_l x r).size = l.size + r.size + 1", "decl_nm": "ordnode.size_balance_l", "nl_statement_of_codex": "Let $l, r$ be balanced ordered trees. If $l$ is raised or $r$ is lowered, then the size of the tree obtained by inserting $x$ into the left subtree of $l$ is the sum of the sizes of $l$ and $r$ plus one."}
{"formal_statement": "theorem to_arrow_map_left {C : Type u} [category_theory.category C] (X Y : category_theory.simplicial_object.augmented C)\n\t(\u03b7 : X \u27f6 Y) :\n\t(category_theory.simplicial_object.augmented.to_arrow.map \u03b7).left = (category_theory.simplicial_object.augmented.drop.map \u03b7).app (opposite.op (simplex_category.mk 0))", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (X Y : category_theory.simplicial_object.augmented C) (\u03b7 : X \u27f6 Y), (category_theory.simplicial_object.augmented.to_arrow.map \u03b7).left = (category_theory.simplicial_object.augmented.drop.map \u03b7).app (opposite.op (simplex_category.mk 0))", "decl_nm": "category_theory.simplicial_object.augmented.to_arrow_map_left", "nl_statement_of_codex": "Let $C$ be a category. Let $X$ and $Y$ be augmented simplicial objects in $C$. Let $\\eta:X\\to Y$ be a morphism of augmented simplicial objects. Then the left face map of $\\eta$ is the same as the application of $\\eta$ to the opposite of the $0$-simplex."}
{"formal_statement": "theorem of_free_monoid_comp_free_mk {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type u}\n\t[monad m] [is_lawful_monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b1) :\n\tmonoid.mfoldr.of_free_monoid f \u2218 traversable.free.mk = monoid.mfoldr.mk \u2218 f", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type u} [_inst_3 : monad m] [_inst_4 : is_lawful_monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b1), monoid.mfoldr.of_free_monoid f \u2218 traversable.free.mk = monoid.mfoldr.mk \u2218 f", "decl_nm": "traversable.mfoldr.of_free_monoid_comp_free_mk", "nl_statement_of_codex": "Let $f:B\\times A\\to M(A)$ be a function. Then the function $f$ induces a function $f':B\\to M(A)$ by $f'(b)=f(b,\\cdot)$."}
{"formal_statement": "theorem pred'_succ' (n : num) :\n\tn.succ'.pred' = n", "decl_tp": "\u2200 (n : num), n.succ'.pred' = n", "decl_nm": "pos_num.pred'_succ'", "nl_statement_of_codex": "The predecessor of the successor of $n$ is $n$."}
{"formal_statement": "theorem gcd_le_right (m : \u2115) {n : \u2115} (h : 0 < n) :\n\tm.gcd n \u2264 n", "decl_tp": "\u2200 (m : \u2115) {n : \u2115}, 0 < n \u2192 m.gcd n \u2264 n", "decl_nm": "nat.gcd_le_right", "nl_statement_of_codex": "The greatest common divisor of $m$ and $n$ is less than or equal to $n$."}
{"formal_statement": "theorem map_field_range {K : Type u} {L : Type v} {M : Type w} [field K]\n\t[field L] [field M] (g : L \u2192+* M) (f : K \u2192+* L) :\n\tsubfield.map g f.field_range = (g.comp f).field_range", "decl_tp": "\u2200 {K : Type u} {L : Type v} {M : Type w} [_inst_1 : field K] [_inst_2 : field L] [_inst_3 : field M] (g : L \u2192+* M) (f : K \u2192+* L), subfield.map g f.field_range = (g.comp f).field_range", "decl_nm": "ring_hom.map_field_range", "nl_statement_of_codex": "Let $K, L, M$ be fields and let $f:K\\to L$ and $g:L\\to M$ be field homomorphisms. Then $g(f(K))=g\\circ f(K)$."}
{"formal_statement": "theorem ext {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f g : \u03b1 \u21aa \u03b2} :\n\t(\u2200 (x : \u03b1), \u21d1f x = \u21d1g x) \u2192 f = g", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f g : \u03b1 \u21aa \u03b2}, (\u2200 (x : \u03b1), \u21d1f x = \u21d1g x) \u2192 f = g", "decl_nm": "function.embedding.ext", "nl_statement_of_codex": "Let $f,g:A\\to B$ be injective functions. If $f(x)=g(x)$ for all $x\\in A$, then $f=g$."}
{"formal_statement": "theorem succ {n : \u2115} {a : fin n} {a' b : \u2115} (h : tactic.norm_fin.normalize_fin_lt n a a')\n\t(e : a' + 1 = b) :\n\ttactic.norm_fin.normalize_fin_lt n.succ a.succ b", "decl_tp": "\u2200 {n : \u2115} {a : fin n} {a' b : \u2115}, tactic.norm_fin.normalize_fin_lt n a a' \u2192 a' + 1 = b \u2192 tactic.norm_fin.normalize_fin_lt n.succ a.succ b", "decl_nm": "tactic.norm_fin.normalize_fin_lt.succ", "nl_statement_of_codex": "Let $n$ be a natural number and let $a$ be a finite number less than $n$. Let $a'$ and $b$ be natural numbers such that $a'+1=b$. Then $a'$ is less than $n+1$ and $a+1$ is less than $b$."}
{"formal_statement": "theorem tsum_union_disjoint {\u03b1 \u03b2 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t[t2_space \u03b1] {f : \u03b2 \u2192 \u03b1} [has_continuous_add \u03b1] {s t : set \u03b2} (hd : disjoint s t)\n\t(hs : summable (f \u2218 coe)) :\n\t\u2211' (x : \u21a5(s \u222a t)), f \u2191x = \u2211' (x : \u21a5s), f \u2191x + \u2211' (x : \u21a5t), f \u2191x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : t2_space \u03b1] {f : \u03b2 \u2192 \u03b1} [_inst_4 : has_continuous_add \u03b1] {s t : set \u03b2}, disjoint s t \u2192 summable (f \u2218 coe) \u2192 summable (f \u2218 coe) \u2192 \u2211' (x : \u21a5(s \u222a t)), f \u2191x = \u2211' (x : \u21a5s), f \u2191x + \u2211' (x : \u21a5t), f \u2191x", "decl_nm": "tsum_union_disjoint", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{R}$ be a continuous function on a topological space $X$. Let $s,t\\subset X$ be disjoint sets such that $f$ is summable on $s$ and $t$. Then $f$ is summable on $s\\cup t$ and $\\sum_{x\\in s\\cup t}f(x)=\\sum_{x\\in s}f(x)+\\sum_{x\\in t}f(x)$."}
{"formal_statement": "theorem map_ne_one (A : Type*) {B : Type*} [comm_ring A] [ring B] [algebra A B]\n\t(x : B) [nontrivial B] {R : Type*} [semiring R] [nontrivial R] (f : A \u2192+* R) :\n\tpolynomial.map f (minpoly A x) \u2260 1", "decl_tp": "\u2200 (A : Type u_1) {B : Type u_2} [_inst_1 : comm_ring A] [_inst_2 : ring B] [_inst_3 : algebra A B] (x : B) [_inst_4 : nontrivial B] {R : Type u_3} [_inst_5 : semiring R] [_inst_6 : nontrivial R] (f : A \u2192+* R), polynomial.map f (minpoly A x) \u2260 1", "decl_nm": "minpoly.map_ne_one", "nl_statement_of_codex": "Let $A$ be a commutative ring, $B$ a ring, and $x\\in B$. Suppose that $B$ is nontrivial and that $A$ is an $A$-algebra. Let $R$ be a nontrivial semiring and let $f:A\\to R$ be a ring homomorphism. Then the minimal polynomial of $x$ over $A$ is not mapped to $1$ by $f$."}
{"formal_statement": "theorem sigma_congr_right_hom_apply {\u03b1 : Type*} (\u03b2 : \u03b1 \u2192 Type*) (F : \u03a0 (a : \u03b1), equiv.perm ((\u03bb (a : \u03b1), \u03b2 a) a)) :\n\t\u21d1(equiv.perm.sigma_congr_right_hom \u03b2) F = equiv.perm.sigma_congr_right F", "decl_tp": "\u2200 {\u03b1 : Type u_1} (\u03b2 : \u03b1 \u2192 Type u_2) (F : \u03a0 (a : \u03b1), equiv.perm ((\u03bb (a : \u03b1), \u03b2 a) a)), \u21d1(equiv.perm.sigma_congr_right_hom \u03b2) F = equiv.perm.sigma_congr_right F", "decl_nm": "equiv.perm.sigma_congr_right_hom_apply", "nl_statement_of_codex": "Let $F$ be a family of permutations of the sets $\\beta_a$ for $a\\in A$. Then the permutation of the disjoint union $\\bigsqcup_{a\\in A}\\beta_a$ induced by $F$ is the same as the permutation induced by the family of permutations $F$."}
{"formal_statement": "theorem decode_encode_bool (b : bool) :\n\tcomputability.decode_bool (computability.encode_bool b) = b", "decl_tp": "\u2200 (b : bool), computability.decode_bool (computability.encode_bool b) = b", "decl_nm": "computability.decode_encode_bool", "nl_statement_of_codex": "The function that encodes a boolean value is the inverse of the function that decodes a boolean value."}
{"formal_statement": "theorem le_pointwise_smul_iff\u2080 {M R : Type*} [group_with_zero M] [ring R]\n\t[mul_semiring_action M R] {a : M} (ha : a \u2260 0) :\n\t\u2200 {S T : subring R}, S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "decl_tp": "\u2200 {M : Type u_1} {R : Type u_2} [_inst_1 : group_with_zero M] [_inst_2 : ring R] [_inst_3 : mul_semiring_action M R] {a : M}, a \u2260 0 \u2192 \u2200 {S T : subring R}, S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "decl_nm": "subring.le_pointwise_smul_iff\u2080", "nl_statement_of_codex": "Let $M$ be a group with zero, let $R$ be a ring, and let $M$ act on $R$ by multiplication. Let $a\\in M$ be nonzero. Then for any subrings $S,T$ of $R$, $S\\leq aT$ if and only if $a^{-1}S\\leq T$."}
{"formal_statement": "theorem mem_to_subsemiring {R : Type u} {A : Type v} [comm_semiring R]\n\t[semiring A] [algebra R A] {S : subalgebra R A} {x : A} :\n\tx \u2208 S.to_subsemiring \u2194 x \u2208 S", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] {S : subalgebra R A} {x : A}, x \u2208 S.to_subsemiring \u2194 x \u2208 S", "decl_nm": "subalgebra.mem_to_subsemiring", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a semiring, and $S$ a subalgebra of $A$ over $R$. Then $x\\in S$ if and only if $x\\in S$."}
{"formal_statement": "theorem coe_neg {R : Type*} [semiring R] {M : Type*} [add_comm_monoid M]\n\t[module R M] {N' : Type*} [add_comm_group N'] [module R N'] {\u03b9 : Type*}\n\t[decidable_eq \u03b9] (g : alternating_map R M N' \u03b9) :\n\t\u2191-g = -\u2191g", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : semiring R] {M : Type u_2} [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {N' : Type u_5} [_inst_8 : add_comm_group N'] [_inst_9 : module R N'] {\u03b9 : Type u_6} [_inst_10 : decidable_eq \u03b9] (g : alternating_map R M N' \u03b9), \u2191-g = -\u2191g", "decl_nm": "alternating_map.coe_neg", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, $N'$ an $R$-module, and $\\iota$ a set. Let $g$ be an alternating map from $M^\\iota$ to $N'$. Then $-g$ is the alternating map from $M^\\iota$ to $N'$ given by $(-g)(x_1,\\ldots,x_n)=-g(x_1,\\ldots,x_n)$."}
{"formal_statement": "theorem traverse_mul' {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type u} [applicative m]\n\t(F : \u03b1 \u2192 m \u03b2) [is_lawful_applicative m] :\n\tfunction.comp (traversable.traverse F) \u2218 has_mul.mul = \u03bb (x y : free_semigroup \u03b1), has_mul.mul <$> traversable.traverse F x <*> traversable.traverse F y", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type u} [_inst_1 : applicative m] (F : \u03b1 \u2192 m \u03b2) [_inst_2 : is_lawful_applicative m], function.comp (traversable.traverse F) \u2218 has_mul.mul = \u03bb (x y : free_semigroup \u03b1), has_mul.mul <$> traversable.traverse F x <*> traversable.traverse F y", "decl_nm": "free_semigroup.traverse_mul'", "nl_statement_of_codex": "Let $F:\\alpha\\to m\\beta$ be a function. Then the function $f:\\mathbb{N}\\to m\\beta$ defined by $f(n)=F(n)$ is a multiplicative function."}
{"formal_statement": "theorem single_swap {\u03b1 M : Type*} [has_zero M] (a\u2081 a\u2082 : \u03b1) (b : M) :\n\t\u21d1(finsupp.single a\u2081 b) a\u2082 = \u21d1(finsupp.single a\u2082 b) a\u2081", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] (a\u2081 a\u2082 : \u03b1) (b : M), \u21d1(finsupp.single a\u2081 b) a\u2082 = \u21d1(finsupp.single a\u2082 b) a\u2081", "decl_nm": "finsupp.single_swap", "nl_statement_of_codex": "Let $a_1, a_2$ be elements of a set $A$ and let $b$ be an element of a monoid $M$. Then the finitely supported functions $f:A\\to M$ and $g:A\\to M$ defined by $f(a_1)=b$ and $f(a)=0$ for $a\\neq a_1$ and $g(a_2)=b$ and $g(a)=0$ for $a\\neq a_2$ are equal."}
{"formal_statement": "theorem abs_le_abs_re_add_abs_im (z : \u2102) :\n\tcomplex.abs z \u2264 |z.re| + |z.im|", "decl_tp": "\u2200 (z : \u2102), complex.abs z \u2264 |z.re| + |z.im|", "decl_nm": "complex.abs_le_abs_re_add_abs_im", "nl_statement_of_codex": "The absolute value of a complex number $z$ is less than or equal to the sum of the absolute values of its real and imaginary parts."}
{"formal_statement": "theorem append_right {\u03b1 : Type u} {l\u2081 l\u2082 : list \u03b1} (h : l\u2081 <+ l\u2082) :\n\t\u2200 (l : list \u03b1), l\u2081 ++ l <+ l\u2082 ++ l", "decl_tp": "\u2200 {\u03b1 : Type u} {l\u2081 l\u2082 : list \u03b1}, l\u2081 <+ l\u2082 \u2192 \u2200 (l : list \u03b1), l\u2081 ++ l <+ l\u2082 ++ l", "decl_nm": "list.sublist.append_right", "nl_statement_of_codex": "If $l_1$ is a prefix of $l_2$, then $l_1$ is a prefix of $l_2$ with any list $l$ appended to the right."}
{"formal_statement": "theorem map_eq_nil {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {l : list \u03b1} :\n\tlist.map f l = list.nil \u2194 l = list.nil", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {l : list \u03b1}, list.map f l = list.nil \u2194 l = list.nil", "decl_nm": "list.map_eq_nil", "nl_statement_of_codex": "The map of a list is the empty list if and only if the list is empty."}
{"formal_statement": "theorem id_to_affine_map {\ud835\udd5c V P : Type*} [normed_field \ud835\udd5c] [semi_normed_group V]\n\t[semi_normed_space \ud835\udd5c V] [pseudo_metric_space P] [semi_normed_add_torsor V P] :\n\taffine_isometry.id.to_affine_map = affine_map.id \ud835\udd5c P", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_2} {P : Type u_8} [_inst_1 : normed_field \ud835\udd5c] [_inst_2 : semi_normed_group V] [_inst_7 : semi_normed_space \ud835\udd5c V] [_inst_12 : pseudo_metric_space P] [_inst_17 : semi_normed_add_torsor V P], affine_isometry.id.to_affine_map = affine_map.id \ud835\udd5c P", "decl_nm": "affine_isometry.id_to_affine_map", "nl_statement_of_codex": "The identity map on an affine space is an affine map."}
{"formal_statement": "theorem div_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {s : set E} {x : E} {f : E \u2192 \ud835\udd5c} {n : with_top \u2115}\n\t{c : \ud835\udd5c} (hf : times_cont_diff_within_at \ud835\udd5c n f s x) :\n\ttimes_cont_diff_within_at \ud835\udd5c n (\u03bb (x : E), f x / c) s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {s : set E} {x : E} {f : E \u2192 \ud835\udd5c} {n : with_top \u2115} {c : \ud835\udd5c}, times_cont_diff_within_at \ud835\udd5c n f s x \u2192 times_cont_diff_within_at \ud835\udd5c n (\u03bb (x : E), f x / c) s x", "decl_nm": "times_cont_diff_within_at.div_const", "nl_statement_of_codex": "Let $E$ be a normed group and let $f:E\\to \\mathbb{K}$ be a function. If $f$ is $n$-times continuously differentiable at $x\\in E$, then the function $g:E\\to \\mathbb{K}$ defined by $g(x)=f(x)/c$ is $n$-times continuously differentiable at $x$."}
{"formal_statement": "theorem mop_hom {C : Type u\u2081} [category_theory.category C] {X Y : C} (f : X \u2245 Y) :\n\tf.mop.hom = f.hom.mop", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y : C} (f : X \u2245 Y), f.mop.hom = f.hom.mop", "decl_nm": "category_theory.iso.mop_hom", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y$ be objects of $C$. Let $f:X\\to Y$ be an isomorphism. Then $f^{-1}$ is an isomorphism."}
{"formal_statement": "theorem Icc_extend_left {\u03b1 \u03b2 : Type*} [linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b)\n\t(f : \u21a5(set.Icc a b) \u2192 \u03b2) :\n\tset.Icc_extend h f a = f \u27e8a, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : linear_order \u03b1] {a b : \u03b1} (h : a \u2264 b) (f : \u21a5(set.Icc a b) \u2192 \u03b2), set.Icc_extend h f a = f \u27e8a, _\u27e9", "decl_nm": "set.Icc_extend_left", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{R}$ with $a\\leq b$. Let $f:[a,b]\\to\\mathbb{R}$. Then $f(a)=f(a)$."}
{"formal_statement": "theorem dvd_gcd_mul_of_dvd_mul {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1]\n\t[gcd_monoid \u03b1] {m n k : \u03b1} (H : k \u2223 m * n) :\n\tk \u2223 gcd_monoid.gcd k m * n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : gcd_monoid \u03b1] {m n k : \u03b1}, k \u2223 m * n \u2192 k \u2223 gcd_monoid.gcd k m * n", "decl_nm": "dvd_gcd_mul_of_dvd_mul", "nl_statement_of_codex": "Let $m,n,k$ be elements of a gcd monoid. If $k$ divides $mn$, then $k$ divides $\\gcd(k,m)n$."}
{"formal_statement": "theorem exp_multiset_sum (s : multiset \u211d) :\n\treal.exp s.sum = (multiset.map real.exp s).prod", "decl_tp": "\u2200 (s : multiset \u211d), real.exp s.sum = (multiset.map real.exp s).prod", "decl_nm": "real.exp_multiset_sum", "nl_statement_of_codex": "The exponential of the sum of a multiset of real numbers is the product of the exponentials of the elements of the multiset."}
{"formal_statement": "theorem pth_root_pow_p' {R : Type u} [comm_semiring R] {p : \u2115} [fact (nat.prime p)]\n\t[char_p R p] [perfect_ring R p] (x : R) :\n\t\u21d1(pth_root R p) (x ^ p) = x", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {p : \u2115} [_inst_3 : fact (nat.prime p)] [_inst_4 : char_p R p] [_inst_5 : perfect_ring R p] (x : R), \u21d1(pth_root R p) (x ^ p) = x", "decl_nm": "pth_root_pow_p'", "nl_statement_of_codex": "Let $R$ be a commutative ring with characteristic $p$ and let $x\\in R$. Then $x^p$ is a $p$th root of $x$."}
{"formal_statement": "theorem union {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {s t : set \u03b1} {x : \u03b1} (hs : continuous_within_at f s x) (ht : continuous_within_at f t x) :\n\tcontinuous_within_at f (s \u222a t) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : set \u03b1} {x : \u03b1}, continuous_within_at f s x \u2192 continuous_within_at f t x \u2192 continuous_within_at f (s \u222a t) x", "decl_nm": "continuous_within_at.union", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Let $s,t\\subset X$ and $x\\in X$. If $f$ is continuous at $x$ on $s$ and on $t$, then $f$ is continuous at $x$ on $s\\cup t$."}
{"formal_statement": "theorem of_induct {J : Type u\u2081} [category_theory.category J] [nonempty J]\n\t{j\u2080 : J} :\n\t(\u2200 (p : set J), j\u2080 \u2208 p \u2192 (\u2200 {j\u2081 j\u2082 : J}, (j\u2081 \u27f6 j\u2082) \u2192 (j\u2081 \u2208 p \u2194 j\u2082 \u2208 p)) \u2192 \u2200 (j : J), j \u2208 p) \u2192 category_theory.is_connected J", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] [_inst_3 : nonempty J] {j\u2080 : J}, (\u2200 (p : set J), j\u2080 \u2208 p \u2192 (\u2200 {j\u2081 j\u2082 : J}, (j\u2081 \u27f6 j\u2082) \u2192 (j\u2081 \u2208 p \u2194 j\u2082 \u2208 p)) \u2192 \u2200 (j : J), j \u2208 p) \u2192 category_theory.is_connected J", "decl_nm": "category_theory.is_connected.of_induct", "nl_statement_of_codex": "Let $J$ be a nonempty category. Then $J$ is connected if and only if for every subset $p$ of $J$ containing $j_0$, if $j_1\\to j_2$ implies $j_1\\in p$ if and only if $j_2\\in p$, then $j\\in p$ for all $j\\in J$."}
{"formal_statement": "theorem traverse_mul' {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type u} [applicative m]\n\t(F : \u03b1 \u2192 m \u03b2) :\n\tfunction.comp (traversable.traverse F) \u2218 has_mul.mul = \u03bb (x y : free_magma \u03b1), has_mul.mul <$> traversable.traverse F x <*> traversable.traverse F y", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} {m : Type u \u2192 Type u} [_inst_1 : applicative m] (F : \u03b1 \u2192 m \u03b2), function.comp (traversable.traverse F) \u2218 has_mul.mul = \u03bb (x y : free_magma \u03b1), has_mul.mul <$> traversable.traverse F x <*> traversable.traverse F y", "decl_nm": "free_magma.traverse_mul'", "nl_statement_of_codex": "Let $F:\\alpha\\to m\\beta$ be a function. Then the function $f:\\mathbb{F}(\\alpha)\\to m\\mathbb{F}(\\beta)$ defined by $f(x)=F(x)$ is a homomorphism of monoids."}
{"formal_statement": "theorem mk_X {C : Type u} [category_theory.category C] {X Y Z : C} {f : X \u27f6 Y}\n\t{g : X \u27f6 Z} {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq_1 : f \u226b inl = g \u226b inr) :\n\t(category_theory.limits.pushout_cocone.mk inl inr eq_1).X = W", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq_1 : f \u226b inl = g \u226b inr), (category_theory.limits.pushout_cocone.mk inl inr eq_1).X = W", "decl_nm": "category_theory.limits.pushout_cocone.mk_X", "nl_statement_of_codex": "Let $C$ be a category. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$ and $g:X\\to Z$ be morphisms. Let $W$ be an object of $C$ and let $inl:Y\\to W$ and $inr:Z\\to W$ be morphisms such that $f\\circ inl=g\\circ inr$. Then the pushout of $f$ and $g$ is $W$."}
{"formal_statement": "theorem ne_zero {n : \u2115} (h : nat.prime n) :\n\tn \u2260 0", "decl_tp": "\u2200 {n : \u2115}, nat.prime n \u2192 n \u2260 0", "decl_nm": "nat.prime.ne_zero", "nl_statement_of_codex": "A prime number is not zero."}
{"formal_statement": "theorem revzip_map_fst {\u03b1 : Type u} (l : list \u03b1) :\n\tlist.map prod.fst l.revzip = l", "decl_tp": "\u2200 {\u03b1 : Type u} (l : list \u03b1), list.map prod.fst l.revzip = l", "decl_nm": "list.revzip_map_fst", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\\alpha$. Then the list of first components of the reversed zipped list of $l$ is $l$."}
{"formal_statement": "theorem re_le_abs {K : Type*} [is_R_or_C K] (z : K) :\n\t\u21d1is_R_or_C.re z \u2264 is_R_or_C.abs z", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K] (z : K), \u21d1is_R_or_C.re z \u2264 is_R_or_C.abs z", "decl_nm": "is_R_or_C.re_le_abs", "nl_statement_of_codex": "Let $K$ be a real or complex number. Then the real part of $K$ is less than or equal to the absolute value of $K$."}
{"formal_statement": "theorem apply_symm_apply {M N : Type*} [has_add M] [has_add N] (e : M \u2243+ N)\n\t(y : N) :\n\t\u21d1e (\u21d1(e.symm) y) = y", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : has_add M] [_inst_2 : has_add N] (e : M \u2243+ N) (y : N), \u21d1e (\u21d1(e.symm) y) = y", "decl_nm": "add_equiv.apply_symm_apply", "nl_statement_of_codex": "Let $M$ and $N$ be abelian groups and let $e:M\\to N$ be an isomorphism. Then $e(e^{-1}(y))=y$ for all $y\\in N$."}
{"formal_statement": "theorem bit0_lt_omega {c : cardinal} :\n\tbit0 c < cardinal.omega \u2194 c < cardinal.omega", "decl_tp": "\u2200 {c : cardinal}, bit0 c < cardinal.omega \u2194 c < cardinal.omega", "decl_nm": "cardinal.bit0_lt_omega", "nl_statement_of_codex": "$2c<\\omega$ if and only if $c<\\omega$."}
{"formal_statement": "theorem forall_or_of_or_forall {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {b : Prop} :\n\t(b \u2228 \u2200 (x : \u03b1), p x) \u2192 \u2200 (x : \u03b1), b \u2228 p x", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {b : Prop}, (b \u2228 \u2200 (x : \u03b1), p x) \u2192 \u2200 (x : \u03b1), b \u2228 p x", "decl_nm": "forall_or_of_or_forall", "nl_statement_of_codex": "If $b$ or $p(x)$ holds for all $x$, then $b$ or $p(x)$ holds for each $x$."}
{"formal_statement": "theorem sdiff_subset_sdiff {\u03b1 : Type*} [decidable_eq \u03b1] {s\u2081 s\u2082 t\u2081 t\u2082 : finset \u03b1}\n\t(h\u2081 : t\u2081 \u2286 t\u2082) (h\u2082 : s\u2082 \u2286 s\u2081) :\n\tt\u2081 \\ s\u2081 \u2286 t\u2082 \\ s\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {s\u2081 s\u2082 t\u2081 t\u2082 : finset \u03b1}, t\u2081 \u2286 t\u2082 \u2192 s\u2082 \u2286 s\u2081 \u2192 t\u2081 \\ s\u2081 \u2286 t\u2082 \\ s\u2082", "decl_nm": "finset.sdiff_subset_sdiff", "nl_statement_of_codex": "Let $A, B, C, D$ be finite sets. If $C\\subset D$ and $B\\subset A$, then $C\\setminus A\\subset D\\setminus B$."}
{"formal_statement": "theorem one_div_one_div {G\u2080 : Type*} [group_with_zero G\u2080] (a : G\u2080) :\n\t1 / (1 / a) = a", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] (a : G\u2080), 1 / (1 / a) = a", "decl_nm": "one_div_one_div", "nl_statement_of_codex": "Let $G$ be a group with zero. Then $1/(1/a)=a$ for all $a\\in G$."}
{"formal_statement": "theorem Union_subset {\u03b9 : Type*} {I : box_integral.box \u03b9} {\u03c0 : box_integral.prepartition I}\n\t(h : \u03c0.is_partition) :\n\t\u2200 (\u03c0\u2081 : box_integral.prepartition I), \u03c0\u2081.Union \u2286 \u03c0.Union", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} {\u03c0 : box_integral.prepartition I}, \u03c0.is_partition \u2192 \u2200 (\u03c0\u2081 : box_integral.prepartition I), \u03c0\u2081.Union \u2286 \u03c0.Union", "decl_nm": "box_integral.prepartition.is_partition.Union_subset", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $\\pi$ be a partition of $I$. Then for any prepartition $\\pi_1$ of $I$, $\\pi_1\\cup\\pi$ is a partition of $I$."}
{"formal_statement": "theorem comp\u2082 {X : Type*} [topological_space X] {Y\u2081 Y\u2082 Z : Type*} {f : X \u2192 Y\u2081}\n\t{g : X \u2192 Y\u2082} (hf : is_locally_constant f) (hg : is_locally_constant g) :\n\t\u2200 (h : Y\u2081 \u2192 Y\u2082 \u2192 Z), is_locally_constant (\u03bb (x : X), h (f x) (g x))", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {Y\u2081 : Type u_2} {Y\u2082 : Type u_3} {Z : Type u_4} {f : X \u2192 Y\u2081} {g : X \u2192 Y\u2082}, is_locally_constant f \u2192 is_locally_constant g \u2192 \u2200 (h : Y\u2081 \u2192 Y\u2082 \u2192 Z), is_locally_constant (\u03bb (x : X), h (f x) (g x))", "decl_nm": "is_locally_constant.comp\u2082", "nl_statement_of_codex": "Let $X$ be a topological space, let $Y_1, Y_2, Z$ be topological spaces, and let $f:X\\to Y_1$ and $g:X\\to Y_2$. If $f$ and $g$ are locally constant, then the function $h:Y_1\\times Y_2\\to Z$ is locally constant."}
{"formal_statement": "theorem associated_of_dvd {\u03b1 : Type*} [cancel_monoid_with_zero \u03b1] {p q : \u03b1}\n\t(p_irr : irreducible p) (q_irr : irreducible q) (dvd : p \u2223 q) :\n\tassociated p q", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_monoid_with_zero \u03b1] {p q : \u03b1}, irreducible p \u2192 irreducible q \u2192 p \u2223 q \u2192 associated p q", "decl_nm": "irreducible.associated_of_dvd", "nl_statement_of_codex": "If $p$ and $q$ are irreducible elements of a commutative monoid with zero and $p$ divides $q$, then $p$ and $q$ are associated."}
{"formal_statement": "theorem strict_convex_empty {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [topological_space E]\n\t[add_comm_monoid E] [has_scalar \ud835\udd5c E] :\n\tstrict_convex \ud835\udd5c \u2205", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : topological_space E] [_inst_4 : add_comm_monoid E] [_inst_6 : has_scalar \ud835\udd5c E], strict_convex \ud835\udd5c \u2205", "decl_nm": "strict_convex_empty", "nl_statement_of_codex": "The empty set is strictly convex."}
{"formal_statement": "theorem vec_mul_diagonal {m : Type*} {\u03b1 : Type v} [non_unital_non_assoc_semiring \u03b1]\n\t[fintype m] [decidable_eq m] (v w : m \u2192 \u03b1) (x : m) :\n\tmatrix.vec_mul v (matrix.diagonal w) x = v x * w x", "decl_tp": "\u2200 {m : Type u_2} {\u03b1 : Type v} [_inst_1 : non_unital_non_assoc_semiring \u03b1] [_inst_2 : fintype m] [_inst_3 : decidable_eq m] (v w : m \u2192 \u03b1) (x : m), matrix.vec_mul v (matrix.diagonal w) x = v x * w x", "decl_nm": "matrix.vec_mul_diagonal", "nl_statement_of_codex": "Let $v,w:m\\to\\alpha$ be functions. Then the product of the vector $v$ and the diagonal matrix with entries $w$ is the vector whose $x$-th entry is $v(x)w(x)$."}
{"formal_statement": "theorem univ_bool :\n\tfinset.univ = {bool.tt, bool.ff}", "decl_tp": "finset.univ = {bool.tt, bool.ff}", "decl_nm": "fintype.univ_bool", "nl_statement_of_codex": "The universe of the type `bool` is $\\{true, false\\}$."}
{"formal_statement": "theorem add_self (G : pgame) [G.impartial] :\n\t(G + G).first_loses", "decl_tp": "\u2200 (G : pgame) [_inst_1 : G.impartial], (G + G).first_loses", "decl_nm": "pgame.impartial.add_self", "nl_statement_of_codex": "If $G$ is an impartial game, then the first player loses the game $G+G$."}
{"formal_statement": "theorem iso_colimit_cocone_\u03b9_inv {J : Type u\u2081} [category_theory.category J]\n\t{C : Type u} [category_theory.category C] {F : J \u2964 C} [category_theory.limits.has_colimit F]\n\t(t : category_theory.limits.colimit_cocone F) (j : J) :\n\tt.cocone.\u03b9.app j \u226b (category_theory.limits.colimit.iso_colimit_cocone t).inv = category_theory.limits.colimit.\u03b9 F j", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u} [_inst_3 : category_theory.category C] {F : J \u2964 C} [_inst_4 : category_theory.limits.has_colimit F] (t : category_theory.limits.colimit_cocone F) (j : J), t.cocone.\u03b9.app j \u226b (category_theory.limits.colimit.iso_colimit_cocone t).inv = category_theory.limits.colimit.\u03b9 F j", "decl_nm": "category_theory.limits.colimit.iso_colimit_cocone_\u03b9_inv", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor and let $t$ be a colimit cocone of $F$. Then the morphism $t.cocone.\u03b9.app j\\circ (category_theory.limits.colimit.iso_colimit_cocone t)^{-1}$ is equal to the morphism $category_theory.limits.colimit.\u03b9 F j$."}
{"formal_statement": "theorem factors {X : Type*} [topological_space X] {\u03b1 : Type*} (f : locally_constant X \u03b1) :\n\t\u21d1(f.locally_constant_lift) \u2218 f.discrete_quotient.proj = \u21d1f", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {\u03b1 : Type u_2} (f : locally_constant X \u03b1), \u21d1(f.locally_constant_lift) \u2218 f.discrete_quotient.proj = \u21d1f", "decl_nm": "locally_constant.factors", "nl_statement_of_codex": "Let $X$ be a topological space and let $f:X\\to\\alpha$ be a locally constant function. Then the locally constant lift of $f$ is the composition of $f$ with the projection map from the discrete quotient of $X$."}
{"formal_statement": "theorem ulower_down {\u03b1 : Type*} [primcodable \u03b1] :\n\tprimrec ulower.down", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], primrec ulower.down", "decl_nm": "primrec.ulower_down", "nl_statement_of_codex": "The function ulower.down is primitive recursive."}
{"formal_statement": "theorem mem_Sup_of_mem {G : Type*} [add_group G] {S : set (add_subgroup G)}\n\t{s : add_subgroup G} (hs : s \u2208 S) :\n\t\u2200 {x : G}, x \u2208 s \u2192 x \u2208 has_Sup.Sup S", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {S : set (add_subgroup G)} {s : add_subgroup G}, s \u2208 S \u2192 \u2200 {x : G}, x \u2208 s \u2192 x \u2208 has_Sup.Sup S", "decl_nm": "add_subgroup.mem_Sup_of_mem", "nl_statement_of_codex": "Let $G$ be an additive group and let $S$ be a set of subgroups of $G$. Let $s$ be a subgroup of $G$ such that $s\\in S$. Then for each $x\\in s$, $x\\in \\sup S$."}
{"formal_statement": "theorem to_Algebra_iso_inv {R : Type u} [comm_ring R] {X\u2081 X\u2082 : Type u}\n\t{g\u2081 : ring X\u2081} {g\u2082 : ring X\u2082} {m\u2081 : algebra R X\u2081} {m\u2082 : algebra R X\u2082}\n\t(e : X\u2081 \u2243\u2090[R] X\u2082) :\n\te.to_Algebra_iso.inv = \u2191(e.symm)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] {X\u2081 X\u2082 : Type u} {g\u2081 : ring X\u2081} {g\u2082 : ring X\u2082} {m\u2081 : algebra R X\u2081} {m\u2082 : algebra R X\u2082} (e : X\u2081 \u2243\u2090[R] X\u2082), e.to_Algebra_iso.inv = \u2191(e.symm)", "decl_nm": "alg_equiv.to_Algebra_iso_inv", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $X_1$ and $X_2$ be $R$-algebras, and let $e:X_1\\to X_2$ be an isomorphism of $R$-algebras. Then $e^{-1}$ is an isomorphism of $R$-algebras."}
{"formal_statement": "theorem false {\u03b1 : Type*} [infinite \u03b1] (h : fintype \u03b1) :\n\tfalse", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : infinite \u03b1], fintype \u03b1 \u2192 false", "decl_nm": "fintype.false", "nl_statement_of_codex": "If $\\alpha$ is an infinite type and $h$ is a finite type, then $h$ is false."}
{"formal_statement": "theorem inv_symm_left_iff {G : Type u} [group G] {a x y : G} :\n\tsemiconj_by a\u207b\u00b9 y x \u2194 semiconj_by a x y", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] {a x y : G}, semiconj_by a\u207b\u00b9 y x \u2194 semiconj_by a x y", "decl_nm": "semiconj_by.inv_symm_left_iff", "nl_statement_of_codex": "Let $G$ be a group and let $a,x,y\\in G$. Then $x$ is conjugate to $y$ by $a^{-1}$ if and only if $x$ is conjugate to $y$ by $a$."}
{"formal_statement": "theorem Iio_mem_nhds {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_closed_topology \u03b1] {a b : \u03b1} (h : a < b) :\n\tset.Iio b \u2208 nhds a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_closed_topology \u03b1] {a b : \u03b1}, a < b \u2192 set.Iio b \u2208 nhds a", "decl_nm": "Iio_mem_nhds", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and the order topology. Let $a,b\\in X$ with $a<b$. Then $(a,b)$ is a neighborhood of $a$."}
{"formal_statement": "theorem coe_Ioi {\u03b1 : Type*} [preorder \u03b1] [order_top \u03b1] [locally_finite_order \u03b1]\n\t(a : \u03b1) :\n\t\u2191(finset.Ioi a) = set.Ioi a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : order_top \u03b1] [_inst_3 : locally_finite_order \u03b1] (a : \u03b1), \u2191(finset.Ioi a) = set.Ioi a", "decl_nm": "finset.coe_Ioi", "nl_statement_of_codex": "Let $a$ be a locally finite preorder. Then the set of all elements less than $a$ is equal to the set of all elements less than or equal to $a$."}
{"formal_statement": "theorem min {\u03b1 : Type u} {\u03b2 : Type v} [linear_order \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n\t{s : set \u03b1} (hf : is_max_on f s a) (hg : is_max_on g s a) :\n\tis_max_on (\u03bb (x : \u03b1), linear_order.min (f x) (g x)) s a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : linear_order \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : set \u03b1}, is_max_on f s a \u2192 is_max_on g s a \u2192 is_max_on (\u03bb (x : \u03b1), linear_order.min (f x) (g x)) s a", "decl_nm": "is_max_on.min", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be functions where $Y$ is a linear order. If $f$ and $g$ are maxima on $X$, then $\\min(f,g)$ is a maximum on $X$."}
{"formal_statement": "theorem adjoin_union {R : Type u} {A : Type v} [comm_semiring R] [semiring A]\n\t[algebra R A] (s t : set A) :\n\talgebra.adjoin R (s \u222a t) = algebra.adjoin R s \u2294 algebra.adjoin R t", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_4 : algebra R A] (s t : set A), algebra.adjoin R (s \u222a t) = algebra.adjoin R s \u2294 algebra.adjoin R t", "decl_nm": "algebra.adjoin_union", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $A$ be an $R$-algebra. Let $s,t\\subset A$. Then $R[s\\cup t]=R[s]\\oplus R[t]$."}
{"formal_statement": "theorem star_mul' {R : Type u} [comm_monoid R] [star_monoid R] (x y : R) :\n\thas_star.star (x * y) = has_star.star x * has_star.star y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_monoid R] [_inst_2 : star_monoid R] (x y : R), has_star.star (x * y) = has_star.star x * has_star.star y", "decl_nm": "star_mul'", "nl_statement_of_codex": "Let $R$ be a commutative monoid with a star operation. Then the star operation is multiplicative."}
{"formal_statement": "theorem preimage_ceil_singleton {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t(m : \u2124) :\n\tint.ceil \u207b\u00b9' {m} = set.Ioc (\u2191m - 1) \u2191m", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] (m : \u2124), int.ceil \u207b\u00b9' {m} = set.Ioc (\u2191m - 1) \u2191m", "decl_nm": "int.preimage_ceil_singleton", "nl_statement_of_codex": "The preimage of the singleton set $\\{m\\}$ under the ceiling function is the open interval $(m-1,m)$."}
{"formal_statement": "theorem from_blocks_apply\u2081\u2082 {l m n o \u03b1 : Type*} (A : matrix n l \u03b1) (B : matrix n m \u03b1)\n\t(C : matrix o l \u03b1) (D : matrix o m \u03b1) (i : n) (j : m) :\n\tA.from_blocks B C D (sum.inl i) (sum.inr j) = B i j", "decl_tp": "\u2200 {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {\u03b1 : Type u_9} (A : matrix n l \u03b1) (B : matrix n m \u03b1) (C : matrix o l \u03b1) (D : matrix o m \u03b1) (i : n) (j : m), A.from_blocks B C D (sum.inl i) (sum.inr j) = B i j", "decl_nm": "matrix.from_blocks_apply\u2081\u2082", "nl_statement_of_codex": "Let $A, B, C, D$ be matrices. Then the $(i,j)$-entry of the matrix $A\\oplus B$ is the $(i,j)$-entry of $B$."}
{"formal_statement": "theorem lower_semicontinuous_on {\u03b1 : Type*} [topological_space \u03b1] {s : set \u03b1}\n\t{\u03b3 : Type*} [linear_order \u03b3] [topological_space \u03b3] [order_topology \u03b3]\n\t{f : \u03b1 \u2192 \u03b3} (h : continuous_on f s) :\n\tlower_semicontinuous_on f s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {s : set \u03b1} {\u03b3 : Type u_3} [_inst_3 : linear_order \u03b3] [_inst_4 : topological_space \u03b3] [_inst_5 : order_topology \u03b3] {f : \u03b1 \u2192 \u03b3}, continuous_on f s \u2192 lower_semicontinuous_on f s", "decl_nm": "continuous_on.lower_semicontinuous_on", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous function between topological spaces $X$ and $Y$. Then $f$ is lower semicontinuous."}
{"formal_statement": "theorem mem_carrier {R : Type u} {M : Type v} [semiring R] [add_comm_monoid M]\n\t{module_M : module R M} (p : submodule R M) {x : M} :\n\tx \u2208 p.carrier \u2194 x \u2208 \u2191p", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] {module_M : module R M} (p : submodule R M) {x : M}, x \u2208 p.carrier \u2194 x \u2208 \u2191p", "decl_nm": "submodule.mem_carrier", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ be an $R$-module, and $p$ be a submodule of $M$. Then $x\\in p$ if and only if $x\\in p$."}
{"formal_statement": "theorem singleton_ne_empty {\u03b1 : Type*} (a : \u03b1) :\n\t{a} \u2260 \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} (a : \u03b1), {a} \u2260 \u2205", "decl_nm": "finset.singleton_ne_empty", "nl_statement_of_codex": "The singleton set $\\{a\\}$ is not empty."}
{"formal_statement": "theorem comap_surjective_of_injective {L : first_order.language} {M N : Type*}\n\t[L.Structure M] [L.Structure N] {f : L.hom M N} (hf : function.injective \u21d1f) :\n\tfunction.surjective (first_order.language.substructure.comap f)", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] {f : L.hom M N}, function.injective \u21d1f \u2192 function.surjective (first_order.language.substructure.comap f)", "decl_nm": "first_order.language.substructure.comap_surjective_of_injective", "nl_statement_of_codex": "Let $L$ be a first-order language, let $M$ and $N$ be $L$-structures, and let $f:M\\to N$ be an $L$-homomorphism. If $f$ is injective, then the induced map $f^*:N\\to M$ is surjective."}
{"formal_statement": "theorem mul_add_one (a b : ordinal) :\n\ta * (b + 1) = a * b + a", "decl_tp": "\u2200 (a b : ordinal), a * (b + 1) = a * b + a", "decl_nm": "ordinal.mul_add_one", "nl_statement_of_codex": "For all ordinals $a$ and $b$, $a(b+1)=ab+a$."}
{"formal_statement": "theorem surjective {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t(e : \u03b1 \u2243\u1d50 \u03b2) :\n\tfunction.surjective \u21d1e", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] (e : \u03b1 \u2243\u1d50 \u03b2), function.surjective \u21d1e", "decl_nm": "measurable_equiv.surjective", "nl_statement_of_codex": "Let $e:X\\to Y$ be a measurable bijection. Then $e$ is surjective."}
{"formal_statement": "theorem length_erase_of_mem {\u03b1 : Type u} [decidable_eq \u03b1] {a : \u03b1} {l : list \u03b1}\n\t(h : a \u2208 l) :\n\t(l.erase a).length = l.length.pred", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {l : list \u03b1}, a \u2208 l \u2192 (l.erase a).length = l.length.pred", "decl_nm": "list.length_erase_of_mem", "nl_statement_of_codex": "Let $l$ be a list of elements of a type $\u03b1$ and let $a$ be an element of $\u03b1$. If $a$ is in $l$, then the length of $l$ with $a$ erased is one less than the length of $l$."}
{"formal_statement": "theorem map_add_right_Ioc {\u03b1 : Type*} [ordered_cancel_add_comm_monoid \u03b1]\n\t[has_exists_add_of_le \u03b1] [locally_finite_order \u03b1] (a b c : \u03b1) :\n\tmultiset.map (\u03bb (x : \u03b1), x + c) (multiset.Ioc a b) = multiset.Ioc (a + c)\n\t(b + c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_cancel_add_comm_monoid \u03b1] [_inst_2 : has_exists_add_of_le \u03b1] [_inst_3 : locally_finite_order \u03b1] (a b c : \u03b1), multiset.map (\u03bb (x : \u03b1), x + c) (multiset.Ioc a b) = multiset.Ioc (a + c) (b + c)", "decl_nm": "multiset.map_add_right_Ioc", "nl_statement_of_codex": "Let $\u03b1$ be an ordered commutative monoid with $0$ and let $a, b, c\\in \u03b1$. Then\n$\\{x+c\\mid a\\le x\\le b\\}=\\{a+c, a+c+1, \\ldots, b+c\\}$."}
{"formal_statement": "theorem pairwise_disjoint_on_bool {\u03b1 : Type*} [semilattice_inf \u03b1] [order_bot \u03b1]\n\t{a b : \u03b1} :\n\tpairwise (disjoint on \u03bb (c : bool), cond c a b) \u2194 disjoint a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {a b : \u03b1}, pairwise (disjoint on \u03bb (c : bool), cond c a b) \u2194 disjoint a b", "decl_nm": "pairwise_disjoint_on_bool", "nl_statement_of_codex": "Let $a,b$ be elements of a semilattice with infimum. Then $a$ and $b$ are disjoint if and only if the sets $\\{a,b\\}$ and $\\{b,a\\}$ are pairwise disjoint."}
{"formal_statement": "theorem hom_of_le_le_of_hom {X : Type u} [preorder X] {x y : X} (h : x \u27f6 y) :\n\t_.hom = h", "decl_tp": "\u2200 {X : Type u} [_inst_1 : preorder X] {x y : X} (h : x \u27f6 y), _.hom = h", "decl_nm": "category_theory.hom_of_le_le_of_hom", "nl_statement_of_codex": "Let $X$ be a preorder and let $x,y\\in X$. If $x\\leq y$, then the homomorphism $x\\to y$ is the identity."}
{"formal_statement": "theorem apply_coe {\u03b1 : Type u} {\u03b2 : Type v} [omega_complete_partial_order \u03b1]\n\t[omega_complete_partial_order \u03b2] (f : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1) :\n\t\u21d1omega_complete_partial_order.continuous_hom.prod.apply f = \u21d1(f.fst) f.snd", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : omega_complete_partial_order \u03b1] [_inst_2 : omega_complete_partial_order \u03b2] (f : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1), \u21d1omega_complete_partial_order.continuous_hom.prod.apply f = \u21d1(f.fst) f.snd", "decl_nm": "omega_complete_partial_order.continuous_hom.prod.apply_coe", "nl_statement_of_codex": "Let $f:\\alpha\\to\\beta$ be a continuous function and let $x\\in\\alpha$. Then $\\omega$-limit of $f$ at $x$ is equal to the $\\omega$-limit of $f$ at $x$."}
{"formal_statement": "theorem coe_distrib_mul_action_hom_mk {R : Type u} {A : Type v} {B : Type w}\n\t[monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A]\n\t[non_unital_non_assoc_semiring B] [distrib_mul_action R B] (f : non_unital_alg_hom R A B)\n\t(h\u2081 : \u2200 (m : R) (x : A), \u21d1f (m \u2022 x) = m \u2022 \u21d1f x) (h\u2082 : \u21d1f 0 = 0) (h\u2083 : \u2200 (x y : A), \u21d1f (x + y) = \u21d1f x + \u21d1f y)\n\t(h\u2084 : \u2200 (x y : A), \u21d1f (x * y) = \u21d1f x * \u21d1f y) :\n\t\u2191{to_fun := \u21d1f, map_smul' := h\u2081, map_zero' := h\u2082, map_add' := h\u2083, map_mul' := h\u2084} = {to_fun := \u21d1f, map_smul' := h\u2081, map_zero' := h\u2082, map_add' := h\u2083}", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : monoid R] [_inst_2 : non_unital_non_assoc_semiring A] [_inst_3 : distrib_mul_action R A] [_inst_4 : non_unital_non_assoc_semiring B] [_inst_5 : distrib_mul_action R B] (f : non_unital_alg_hom R A B) (h\u2081 : \u2200 (m : R) (x : A), \u21d1f (m \u2022 x) = m \u2022 \u21d1f x) (h\u2082 : \u21d1f 0 = 0) (h\u2083 : \u2200 (x y : A), \u21d1f (x + y) = \u21d1f x + \u21d1f y) (h\u2084 : \u2200 (x y : A), \u21d1f (x * y) = \u21d1f x * \u21d1f y), \u2191{to_fun := \u21d1f, map_smul' := h\u2081, map_zero' := h\u2082, map_add' := h\u2083, map_mul' := h\u2084} = {to_fun := \u21d1f, map_smul' := h\u2081, map_zero' := h\u2082, map_add' := h\u2083}", "decl_nm": "non_unital_alg_hom.coe_distrib_mul_action_hom_mk", "nl_statement_of_codex": "Let $R$ be a monoid, $A$ and $B$ be non-unital non-associative semirings, and $f:A\\to B$ be a non-unital algebra homomorphism. Then the map $f$ is a distributive multiplication action homomorphism if and only if $f$ is a distributive multiplication action homomorphism."}
{"formal_statement": "theorem continuous_map_of_unique_apply {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] [unique \u03b1] (b : \u03b2) (a : \u03b1) :\n\t\u21d1(\u21d1homeomorph.continuous_map_of_unique b) a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_4 : unique \u03b1] (b : \u03b2) (a : \u03b1), \u21d1(\u21d1homeomorph.continuous_map_of_unique b) a = b", "decl_nm": "homeomorph.continuous_map_of_unique_apply", "nl_statement_of_codex": "Let $\u03b1$ and $\u03b2$ be topological spaces. If $\u03b1$ is unique, then the continuous map $\u03b1\\to \u03b2$ sending each point of $\u03b1$ to $b$ is a homeomorphism."}
{"formal_statement": "theorem localize {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1} (hf : is_extr_on f s a) :\n\tis_local_extr_on f s a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1}, is_extr_on f s a \u2192 is_local_extr_on f s a", "decl_nm": "is_extr_on.localize", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Let $s\\subset X$ and $a\\in X$. If $f$ has a local extremum at $a$ on $s$, then $f$ has a local extremum at $a$."}
{"formal_statement": "theorem preimage_swap_prod {\u03b1 \u03b2 : Type*} {s : set \u03b1} {t : set \u03b2} :\n\tprod.swap \u207b\u00b9' t.prod s = s.prod t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : set \u03b1} {t : set \u03b2}, prod.swap \u207b\u00b9' t.prod s = s.prod t", "decl_nm": "set.preimage_swap_prod", "nl_statement_of_codex": "Let $s$ and $t$ be subsets of sets $A$ and $B$, respectively. Then $(A\\times B)\\setminus (s\\times t) = (A\\setminus s)\\times (B\\setminus t)$."}
{"formal_statement": "theorem iso_iff {C : Type u} [category_theory.category C] {P Q : C} :\n\t(P \u2245 Q) \u2192 (category_theory.projective P \u2194 category_theory.projective Q)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {P Q : C}, (P \u2245 Q) \u2192 (category_theory.projective P \u2194 category_theory.projective Q)", "decl_nm": "category_theory.projective.iso_iff", "nl_statement_of_codex": "Let $C$ be a category. Two objects $P$ and $Q$ are isomorphic if and only if $P$ is projective if and only if $Q$ is projective."}
{"formal_statement": "theorem add_left_embedding_apply {G : Type*} [add_left_cancel_semigroup G]\n\t(g h : G) :\n\t\u21d1(add_left_embedding g) h = g + h", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_left_cancel_semigroup G] (g h : G), \u21d1(add_left_embedding g) h = g + h", "decl_nm": "add_left_embedding_apply", "nl_statement_of_codex": "Let $G$ be an additive left-cancellative semigroup. Then the map $g\\mapsto g+h$ is an embedding."}
{"formal_statement": "theorem of_option_eq_get {\u03b1 : Type*} (o : option \u03b1) :\n\tpart.of_option o = {dom := \u21a5(o.is_some), get := option.get o}", "decl_tp": "\u2200 {\u03b1 : Type u_1} (o : option \u03b1), part.of_option o = {dom := \u21a5(o.is_some), get := option.get o}", "decl_nm": "part.of_option_eq_get", "nl_statement_of_codex": "Let $o$ be an option. Then the partial function $f$ defined by $f(x)=o$ is equal to the partial function $g$ defined by $g(x)=o.get$."}
{"formal_statement": "theorem neg_inj {a b : ereal} (h : -a = -b) :\n\ta = b", "decl_tp": "\u2200 {a b : ereal}, -a = -b \u2192 a = b", "decl_nm": "ereal.neg_inj", "nl_statement_of_codex": "If $-a= -b$, then $a=b$."}
{"formal_statement": "theorem zero_locus_bUnion {R : Type u} [comm_ring R] (s : set (set R)) :\n\tprime_spectrum.zero_locus (\u22c3 (s' : set R) (H : s' \u2208 s), s') = \u22c2 (s' : set R)\n\t(H : s' \u2208 s), prime_spectrum.zero_locus s'", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] (s : set (set R)), prime_spectrum.zero_locus (\u22c3 (s' : set R) (H : s' \u2208 s), s') = \u22c2 (s' : set R) (H : s' \u2208 s), prime_spectrum.zero_locus s'", "decl_nm": "prime_spectrum.zero_locus_bUnion", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then the zero locus of the union of a family of ideals of $R$ is the intersection of the zero loci of the ideals in the family."}
{"formal_statement": "theorem smul_hadamard {\u03b1 m n R : Type*} (A B : matrix m n \u03b1) [has_mul \u03b1]\n\t[has_scalar R \u03b1] [is_scalar_tower R \u03b1 \u03b1] (k : R) :\n\t(k \u2022 A).hadamard B = k \u2022 A.hadamard B", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : Type u_4} {n : Type u_5} {R : Type u_6} (A B : matrix m n \u03b1) [_inst_1 : has_mul \u03b1] [_inst_2 : has_scalar R \u03b1] [_inst_3 : is_scalar_tower R \u03b1 \u03b1] (k : R), (k \u2022 A).hadamard B = k \u2022 A.hadamard B", "decl_nm": "matrix.smul_hadamard", "nl_statement_of_codex": "Let $A$ and $B$ be matrices of the same size. Then the Hadamard product of $kA$ and $B$ is equal to $k$ times the Hadamard product of $A$ and $B$."}
{"formal_statement": "theorem uniform_add_group {G : Type*} [add_comm_group G] (B : add_group_filter_basis G) :\n\tuniform_add_group G", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_comm_group G] (B : add_group_filter_basis G), uniform_add_group G", "decl_nm": "add_group_filter_basis.uniform_add_group", "nl_statement_of_codex": "Let $G$ be an additive commutative group. Then $G$ is a uniform additive group."}
{"formal_statement": "theorem integral_dirac' {\u03b1 E : Type*} [normed_group E] [topological_space.second_countable_topology E]\n\t[normed_space \u211d E] [complete_space E] [measurable_space E] [borel_space E]\n\t[measurable_space \u03b1] (f : \u03b1 \u2192 E) (a : \u03b1) (hfm : measurable f) :\n\t\u222b (x : \u03b1), f x \u2202measure_theory.measure.dirac a = f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} [_inst_1 : normed_group E] [_inst_2 : topological_space.second_countable_topology E] [_inst_3 : normed_space \u211d E] [_inst_4 : complete_space E] [_inst_5 : measurable_space E] [_inst_6 : borel_space E] [_inst_18 : measurable_space \u03b1] (f : \u03b1 \u2192 E) (a : \u03b1), measurable f \u2192 \u222b (x : \u03b1), f x \u2202measure_theory.measure.dirac a = f a", "decl_nm": "measure_theory.integral_dirac'", "nl_statement_of_codex": "Let $E$ be a complete normed space and let $f:X\\to E$ be a measurable function. Then $\\int_X f(x)d\\delta_a(x)=f(a)$."}
{"formal_statement": "theorem infi_insert {\u03b1 \u03b2 : Type*} [complete_lattice \u03b2] [decidable_eq \u03b1]\n\t(a : \u03b1) (s : finset \u03b1) (t : \u03b1 \u2192 \u03b2) :\n\t(\u2a05 (x : \u03b1) (H : x \u2208 has_insert.insert a s), t x) = t a \u2293 \u2a05 (x : \u03b1) (H : x \u2208 s), t x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : complete_lattice \u03b2] [_inst_2 : decidable_eq \u03b1] (a : \u03b1) (s : finset \u03b1) (t : \u03b1 \u2192 \u03b2), (\u2a05 (x : \u03b1) (H : x \u2208 has_insert.insert a s), t x) = t a \u2293 \u2a05 (x : \u03b1) (H : x \u2208 s), t x", "decl_nm": "finset.infi_insert", "nl_statement_of_codex": "Let $t:A\\to B$ be a function where $A$ is a set and $B$ is a complete lattice. Then $\\inf_{x\\in A}t(x)=\\inf_{x\\in A\\setminus\\{a\\}}t(x)\\wedge t(a)$."}
{"formal_statement": "theorem or_iff_left_iff_imp {a b : Prop} :\n\ta \u2228 b \u2194 a \u2194 b \u2192 a", "decl_tp": "\u2200 {a b : Prop}, a \u2228 b \u2194 a \u2194 b \u2192 a", "decl_nm": "or_iff_left_iff_imp", "nl_statement_of_codex": "$a\\lor b$ if and only if $a$ if and only if $b$ implies $a$."}
{"formal_statement": "theorem cocompact_le_coclosed_compact {\u03b1 : Type u} [topological_space \u03b1] :\n\tfilter.cocompact \u03b1 \u2264 filter.coclosed_compact \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1], filter.cocompact \u03b1 \u2264 filter.coclosed_compact \u03b1", "decl_nm": "filter.cocompact_le_coclosed_compact", "nl_statement_of_codex": "The cocompact filter on a topological space is contained in the coclosed-compact filter."}
{"formal_statement": "theorem zero_ne_one {n : \u2115} :\n\t0 \u2260 1", "decl_tp": "\u2200 {n : \u2115}, 0 \u2260 1", "decl_nm": "fin.zero_ne_one", "nl_statement_of_codex": "$0\\neq 1$."}
{"formal_statement": "theorem tsub_pos_iff_not_le {\u03b1 : Type*} [canonically_ordered_add_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b : \u03b1} :\n\t0 < a - b \u2194 \u00aca \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : canonically_ordered_add_monoid \u03b1] [_inst_2 : has_sub \u03b1] [_inst_3 : has_ordered_sub \u03b1] {a b : \u03b1}, 0 < a - b \u2194 \u00aca \u2264 b", "decl_nm": "tsub_pos_iff_not_le", "nl_statement_of_codex": "Let $a, b$ be elements of a canonically ordered additive monoid. Then $0<a-b$ if and only if $a\\leq b$."}
{"formal_statement": "theorem lift_assoc {\u03b1 \u03b2 \u03b3 : Type*} {f : filter \u03b1} {g : set \u03b1 \u2192 filter \u03b2}\n\t{h : set \u03b2 \u2192 filter \u03b3} (hg : monotone g) :\n\t(f.lift g).lift h = f.lift (\u03bb (s : set \u03b1), (g s).lift h)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : filter \u03b1} {g : set \u03b1 \u2192 filter \u03b2} {h : set \u03b2 \u2192 filter \u03b3}, monotone g \u2192 (f.lift g).lift h = f.lift (\u03bb (s : set \u03b1), (g s).lift h)", "decl_nm": "filter.lift_assoc", "nl_statement_of_codex": "Let $f$ be a filter on a set $A$, and let $g:A\\to B$ and $h:B\\to C$ be functions. Then $(f\\circ g)\\circ h = f\\circ (g\\circ h)$."}
{"formal_statement": "theorem map_prod {R : Type u} {A : Type v} {B : Type w} [comm_semiring R]\n\t[comm_semiring A] [comm_semiring B] [algebra R A] [algebra R B] (\u03c6 : A \u2192\u2090[R] B)\n\t{\u03b9 : Type*} (f : \u03b9 \u2192 A) (s : finset \u03b9) :\n\t\u21d1\u03c6 (s.prod (\u03bb (x : \u03b9), f x)) = s.prod (\u03bb (x : \u03b9), \u21d1\u03c6 (f x))", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring A] [_inst_3 : comm_semiring B] [_inst_4 : algebra R A] [_inst_5 : algebra R B] (\u03c6 : A \u2192\u2090[R] B) {\u03b9 : Type u_1} (f : \u03b9 \u2192 A) (s : finset \u03b9), \u21d1\u03c6 (s.prod (\u03bb (x : \u03b9), f x)) = s.prod (\u03bb (x : \u03b9), \u21d1\u03c6 (f x))", "decl_nm": "alg_hom.map_prod", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $A$ and $B$ be $R$-algebras, and let $\\phi:A\\to B$ be an $R$-algebra homomorphism. Let $f:\\mathbb{N}\\to A$ and let $S$ be a finite subset of $\\mathbb{N}$. Then $\\phi(\\prod_{x\\in S}f(x))=\\prod_{x\\in S}\\phi(f(x))$."}
{"formal_statement": "theorem cases_on {\u03b1 : Type u} {P : with_zero \u03b1 \u2192 Prop} (x : with_zero \u03b1) :\n\tP 0 \u2192 (\u2200 (a : \u03b1), P \u2191a) \u2192 P x", "decl_tp": "\u2200 {\u03b1 : Type u} {P : with_zero \u03b1 \u2192 Prop} (x : with_zero \u03b1), P 0 \u2192 (\u2200 (a : \u03b1), P \u2191a) \u2192 P x", "decl_nm": "with_zero.cases_on", "nl_statement_of_codex": "Let $P$ be a property of elements of $A$ with zero. Then $P(0)$ and $P(a)$ for all $a\\in A$ imply $P(x)$ for all $x\\in A$ with zero."}
{"formal_statement": "theorem const_inv_mul {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {c : \u03b1} [division_ring \u03b1]\n\t(h : function.periodic f c) :\n\t\u2200 (a : \u03b1), function.periodic (\u03bb (x : \u03b1), f (a\u207b\u00b9 * x)) (a * c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {c : \u03b1} [_inst_1 : division_ring \u03b1], function.periodic f c \u2192 \u2200 (a : \u03b1), function.periodic (\u03bb (x : \u03b1), f (a\u207b\u00b9 * x)) (a * c)", "decl_nm": "function.periodic.const_inv_mul", "nl_statement_of_codex": "Let $f:A\\to B$ be a periodic function with period $c$. Then for any $a\\in A$, the function $g:A\\to B$ defined by $g(x)=f(a^{-1}x)$ is periodic with period $ac$."}
{"formal_statement": "theorem tendsto_at_bot_embedding {\u03b1 \u03b2 \u03b3 : Type*} [preorder \u03b2] [preorder \u03b3]\n\t{f : \u03b1 \u2192 \u03b2} {e : \u03b2 \u2192 \u03b3} {l : filter \u03b1} :\n\t(\u2200 (b\u2081 b\u2082 : \u03b2), e b\u2081 \u2264 e b\u2082 \u2194 b\u2081 \u2264 b\u2082) \u2192 (\u2200 (c : \u03b3), \u2203 (b : \u03b2), e b \u2264 c) \u2192 (filter.tendsto (e \u2218 f) l filter.at_bot \u2194 filter.tendsto f l filter.at_bot)", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} {\u03b3 : Type u_5} [_inst_1 : preorder \u03b2] [_inst_2 : preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {e : \u03b2 \u2192 \u03b3} {l : filter \u03b1}, (\u2200 (b\u2081 b\u2082 : \u03b2), e b\u2081 \u2264 e b\u2082 \u2194 b\u2081 \u2264 b\u2082) \u2192 (\u2200 (c : \u03b3), \u2203 (b : \u03b2), e b \u2264 c) \u2192 (filter.tendsto (e \u2218 f) l filter.at_bot \u2194 filter.tendsto f l filter.at_bot)", "decl_nm": "filter.tendsto_at_bot_embedding", "nl_statement_of_codex": "Let $f:A\\to B$ and $e:B\\to C$ be functions. If $e$ is an embedding and $e(B)$ is cofinal in $C$, then $f$ tends to $-\\infty$ if and only if $e\\circ f$ tends to $-\\infty$."}
{"formal_statement": "theorem smooth_on_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {s : set M} {c : M'} :\n\tsmooth_on I I' (\u03bb (x : M), c) s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {s : set M} {c : M'}, smooth_on I I' (\u03bb (x : M), c) s", "decl_nm": "smooth_on_const", "nl_statement_of_codex": "Let $M$ and $M'$ be smooth manifolds and let $c\\in M'$. Then the function $f:M\\to M'$ defined by $f(x)=c$ is smooth."}
{"formal_statement": "theorem le_card_of_inj_on_range {\u03b1 : Type*} {s : finset \u03b1} {n : \u2115} (f : \u2115 \u2192 \u03b1) :\n\t(\u2200 (i : \u2115), i < n \u2192 f i \u2208 s) \u2192 (\u2200 (i : \u2115), i < n \u2192 \u2200 (j : \u2115), j < n \u2192 f i = f j \u2192 i = j) \u2192 n \u2264 s.card", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : finset \u03b1} {n : \u2115} (f : \u2115 \u2192 \u03b1), (\u2200 (i : \u2115), i < n \u2192 f i \u2208 s) \u2192 (\u2200 (i : \u2115), i < n \u2192 \u2200 (j : \u2115), j < n \u2192 f i = f j \u2192 i = j) \u2192 n \u2264 s.card", "decl_nm": "finset.le_card_of_inj_on_range", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:\\{0,\\ldots,n-1\\}\\to s$ be a function. If $f$ is injective, then $n\\leq |s|$."}
{"formal_statement": "theorem complete_space_coe {\u03b1 : Type*} [uniform_space \u03b1] [complete_space \u03b1]\n\t{s : set \u03b1} (hs : is_closed s) :\n\tcomplete_space \u21a5s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] [_inst_4 : complete_space \u03b1] {s : set \u03b1}, is_closed s \u2192 complete_space \u21a5s", "decl_nm": "is_closed.complete_space_coe", "nl_statement_of_codex": "Let $X$ be a complete uniform space and let $A$ be a closed subset of $X$. Then $A$ is a complete uniform space."}
{"formal_statement": "theorem map_zsmul' {M N : Type*} [sub_neg_monoid M] [sub_neg_monoid N]\n\t(f : M \u2192+ N) :\n\t(\u2200 (x : M), \u21d1f (-x) = -\u21d1f x) \u2192 \u2200 (a : M) (n : \u2124), \u21d1f (n \u2022 a) = n \u2022 \u21d1f a", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : sub_neg_monoid M] [_inst_2 : sub_neg_monoid N] (f : M \u2192+ N), (\u2200 (x : M), \u21d1f (-x) = -\u21d1f x) \u2192 \u2200 (a : M) (n : \u2124), \u21d1f (n \u2022 a) = n \u2022 \u21d1f a", "decl_nm": "add_monoid_hom.map_zsmul'", "nl_statement_of_codex": "Let $M$ and $N$ be sub-neg-monoids and let $f:M\\to N$ be a monoid homomorphism. If $f(-x)=-f(x)$ for all $x\\in M$, then $f(n\\cdot x)=n\\cdot f(x)$ for all $n\\in\\mathbb{Z}$ and $x\\in M$."}
{"formal_statement": "theorem le_inf'_iff {\u03b1 \u03b2 : Type*} [semilattice_inf \u03b1] {s : finset \u03b2} (H : s.nonempty)\n\t(f : \u03b2 \u2192 \u03b1) {a : \u03b1} :\n\ta \u2264 s.inf' H f \u2194 \u2200 (b : \u03b2), b \u2208 s \u2192 a \u2264 f b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semilattice_inf \u03b1] {s : finset \u03b2} (H : s.nonempty) (f : \u03b2 \u2192 \u03b1) {a : \u03b1}, a \u2264 s.inf' H f \u2194 \u2200 (b : \u03b2), b \u2208 s \u2192 a \u2264 f b", "decl_nm": "finset.le_inf'_iff", "nl_statement_of_codex": "Let $s$ be a nonempty finite set and let $f:s\\to \\alpha$ be a function. Then $a\\leq \\inf_{b\\in s} f(b)$ if and only if $a\\leq f(b)$ for all $b\\in s$."}
{"formal_statement": "theorem mk_lt_mk (n k : \u2115) (hn : 0 < n) (hk : 0 < k) :\n\t\u27e8n, hn\u27e9 < \u27e8k, hk\u27e9 \u2194 n < k", "decl_tp": "\u2200 (n k : \u2115) (hn : 0 < n) (hk : 0 < k), \u27e8n, hn\u27e9 < \u27e8k, hk\u27e9 \u2194 n < k", "decl_nm": "pnat.mk_lt_mk", "nl_statement_of_codex": "For all $n, k\\in\\mathbb{N}$, $n<k$ if and only if $\\langle n, n>0\\rangle<\\langle k, k>0\\rangle$."}
{"formal_statement": "theorem mrange_inr' {M N : Type*} [mul_one_class M] [mul_one_class N] :\n\t(monoid_hom.inr M N).mrange = submonoid.comap (monoid_hom.fst M N) \u22a5", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N], (monoid_hom.inr M N).mrange = submonoid.comap (monoid_hom.fst M N) \u22a5", "decl_nm": "submonoid.mrange_inr'", "nl_statement_of_codex": "The image of the monoid homomorphism $M\\to M\\times N$ is the kernel of the monoid homomorphism $M\\times N\\to N$."}
{"formal_statement": "theorem Icc_subset {\u03b1 : Type v} [linear_order \u03b1] [topological_space \u03b1]\n\t[order_closed_topology \u03b1] {s : set \u03b1} (hs : is_connected s) (ha : a \u2208 s)\n\t(hb : b \u2208 s) :\n\t\u2200 {a b : \u03b1},   set.Icc a b \u2286 s", "decl_tp": "\u2200 {\u03b1 : Type v} [_inst_2 : linear_order \u03b1] [_inst_3 : topological_space \u03b1] [_inst_4 : order_closed_topology \u03b1] {s : set \u03b1}, is_connected s \u2192 \u2200 {a b : \u03b1}, a \u2208 s \u2192 b \u2208 s \u2192 set.Icc a b \u2286 s", "decl_nm": "is_connected.Icc_subset", "nl_statement_of_codex": "Let $s$ be a connected subset of $\\mathbb{R}$. Then $[a,b]\\subset s$ for all $a,b\\in s$."}
{"formal_statement": "theorem triangle_assoc_comp_left {B : Type u} [category_theory.bicategory B]\n\t{a b c : B} (f : a \u27f6 b) (g : b \u27f6 c) :\n\t(category_theory.bicategory.associator f (\ud835\udfd9 b) g).hom \u226b category_theory.bicategory.whisker_left f (category_theory.bicategory.left_unitor g).hom = category_theory.bicategory.whisker_right (category_theory.bicategory.right_unitor f).hom g", "decl_tp": "\u2200 {B : Type u} [_inst_1 : category_theory.bicategory B] {a b c : B} (f : a \u27f6 b) (g : b \u27f6 c), (category_theory.bicategory.associator f (\ud835\udfd9 b) g).hom \u226b category_theory.bicategory.whisker_left f (category_theory.bicategory.left_unitor g).hom = category_theory.bicategory.whisker_right (category_theory.bicategory.right_unitor f).hom g", "decl_nm": "category_theory.bicategory.triangle_assoc_comp_left", "nl_statement_of_codex": "The following diagram commutes:\n\\begin{tikzcd}\na \\arrow[r, "}
{"formal_statement": "theorem exists_iso_map {C : Type u\u2081} [category_theory.category C] {X Y : C}\n\t[category_theory.limits.has_images C] (f : X \u27f6 Y) [category_theory.mono f] :\n\tcategory_theory.subobject.exists f = category_theory.subobject.map f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y : C} [_inst_3 : category_theory.limits.has_images C] (f : X \u27f6 Y) [_inst_4 : category_theory.mono f], category_theory.subobject.exists f = category_theory.subobject.map f", "decl_nm": "category_theory.subobject.exists_iso_map", "nl_statement_of_codex": "Let $C$ be a category and let $f:X\\to Y$ be a monomorphism. Then there is an isomorphism between the subobject of $Y$ defined by $f$ and the image of $f$."}
{"formal_statement": "theorem sin_of_real_im (x : \u211d) :\n\t(complex.sin \u2191x).im = 0", "decl_tp": "\u2200 (x : \u211d), (complex.sin \u2191x).im = 0", "decl_nm": "complex.sin_of_real_im", "nl_statement_of_codex": "The imaginary part of $\\sin x$ is $0$."}
{"formal_statement": "theorem frontier_Ioo {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] [densely_ordered \u03b1] {a b : \u03b1} (h : a < b) :\n\tfrontier (set.Ioo a b) = {a, b}", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : densely_ordered \u03b1] {a b : \u03b1}, a < b \u2192 frontier (set.Ioo a b) = {a, b}", "decl_nm": "frontier_Ioo", "nl_statement_of_codex": "Let $a<b$ be real numbers. Then the frontier of the open interval $(a,b)$ is the set $\\{a,b\\}$."}
{"formal_statement": "theorem le_cInf_image {\u03b1 \u03b2 : Type*} [preorder \u03b1] [conditionally_complete_lattice \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (h_mono : monotone f) (hs : s.nonempty) (hB : B \u2208 lower_bounds s) :\n\t\u2200 {s : set \u03b1},  \u2200 {B : \u03b1},  f B \u2264 has_Inf.Inf (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : conditionally_complete_lattice \u03b2] {f : \u03b1 \u2192 \u03b2}, monotone f \u2192 \u2200 {s : set \u03b1}, s.nonempty \u2192 \u2200 {B : \u03b1}, B \u2208 lower_bounds s \u2192 f B \u2264 has_Inf.Inf (f '' s)", "decl_nm": "monotone.le_cInf_image", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function between partially ordered sets. Let $S\\subset A$ be nonempty and let $B\\in A$ be a lower bound for $S$. Then $f(B)\\leq \\inf_{a\\in S}f(a)$."}
{"formal_statement": "theorem comap_top {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] (f : L.hom M N) :\n\tfirst_order.language.substructure.comap f \u22a4 = \u22a4", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] (f : L.hom M N), first_order.language.substructure.comap f \u22a4 = \u22a4", "decl_nm": "first_order.language.substructure.comap_top", "nl_statement_of_codex": "Let $L$ be a first-order language, let $M$ and $N$ be $L$-structures, and let $f:M\\to N$ be an $L$-homomorphism. Then $f$ is surjective."}
{"formal_statement": "theorem ae_cover_Iio {\u03b1 \u03b9 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t{l : filter \u03b9} [linear_order \u03b1] [topological_space \u03b1] [order_closed_topology \u03b1]\n\t[opens_measurable_space \u03b1] {b : \u03b9 \u2192 \u03b1} (hb : filter.tendsto b l filter.at_top) :\n\t\u2200 [no_top_order \u03b1], measure_theory.ae_cover \u03bc l (\u03bb (i : \u03b9), set.Iio (b i))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {l : filter \u03b9} [_inst_2 : linear_order \u03b1] [_inst_3 : topological_space \u03b1] [_inst_4 : order_closed_topology \u03b1] [_inst_5 : opens_measurable_space \u03b1] {b : \u03b9 \u2192 \u03b1}, filter.tendsto b l filter.at_top \u2192 \u2200 [_inst_6 : no_top_order \u03b1], measure_theory.ae_cover \u03bc l (\u03bb (i : \u03b9), set.Iio (b i))", "decl_nm": "measure_theory.ae_cover_Iio", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and the order topology. Let $\u03bc$ be a measure on $X$. Let $b:I\\to X$ be a function such that $b(i)\\to\\infty$ as $i\\to\\infty$. Then the sets $[b(i),\\infty)$ cover $X$ almost everywhere."}
{"formal_statement": "theorem map_decode_iff {\u03b1 \u03b2 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2]\n\t[primcodable \u03c3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} :\n\tprimrec\u2082 (\u03bb (a : \u03b1) (n : \u2115), option.map (f a) (encodable.decode \u03b2 n)) \u2194 primrec\u2082 f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03c3 : Type u_5} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_5 : primcodable \u03c3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3}, primrec\u2082 (\u03bb (a : \u03b1) (n : \u2115), option.map (f a) (encodable.decode \u03b2 n)) \u2194 primrec\u2082 f", "decl_nm": "primrec.map_decode_iff", "nl_statement_of_codex": "Let $f:\\alpha\\times\\beta\\to\\sigma$ be a function. Then $f$ is primitive recursive if and only if the function\n$g:\\alpha\\times\\mathbb{N}\\to\\sigma$ defined by $g(a,n)=f(a,d)$ if $d$ is the unique element of $\\beta$ such that $n=\\mathrm{encode}(d)$ and $g(a,n)=\\mathrm{none}$ otherwise is primitive recursive."}
{"formal_statement": "theorem times_cont_mdiff_at_one {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {x : M} {n : with_top \u2115} [has_one M'] :\n\ttimes_cont_mdiff_at I I' n 1 x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {x : M} {n : with_top \u2115} [_inst_22 : has_one M'], times_cont_mdiff_at I I' n 1 x", "decl_nm": "times_cont_mdiff_at_one", "nl_statement_of_codex": "Let $E, E'$ be normed spaces over a nondiscrete normed field $K$, and let $I, I'$ be models with corners.\nThen the function $f(x)=x^n$ is $n$-times continuously differentiable at $1$."}
{"formal_statement": "theorem tendsto_at_bot_of_add_bdd_below_left {\u03b1 \u03b2 : Type*} [ordered_cancel_add_comm_monoid \u03b2]\n\t{l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (C : \u03b2) :\n\t(\u2200 (x : \u03b1), C \u2264 f x) \u2192 filter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_bot \u2192 filter.tendsto g l filter.at_bot", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : ordered_cancel_add_comm_monoid \u03b2] {l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (C : \u03b2), (\u2200 (x : \u03b1), C \u2264 f x) \u2192 filter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_bot \u2192 filter.tendsto g l filter.at_bot", "decl_nm": "filter.tendsto_at_bot_of_add_bdd_below_left", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions and let $C\\in\\beta$. If $C\\leq f(x)$ for all $x\\in\\alpha$, then if $f(x)+g(x)\\to-\\infty$ as $x\\to\\infty$, then $g(x)\\to-\\infty$ as $x\\to\\infty$."}
{"formal_statement": "theorem and_dioph {\u03b1 : Type u} {S S' : set (\u03b1 \u2192 \u2115)} (d : dioph S) (d' : dioph S') :\n\tdioph (\u03bb (v : \u03b1 \u2192 \u2115), S v \u2227 S' v)", "decl_tp": "\u2200 {\u03b1 : Type u} {S S' : set (\u03b1 \u2192 \u2115)}, dioph S \u2192 dioph S' \u2192 dioph (\u03bb (v : \u03b1 \u2192 \u2115), S v \u2227 S' v)", "decl_nm": "dioph.and_dioph", "nl_statement_of_codex": "If $S$ and $S'$ are Diophantine sets, then $S\\cap S'$ is Diophantine."}
{"formal_statement": "theorem le_of_le_of_eq {\u03b1 : Type*} [ordered_semiring \u03b1] {a b : \u03b1} (ha : a \u2264 0)\n\t(hb : b = 0) :\n\ta + b \u2264 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_semiring \u03b1] {a b : \u03b1}, a \u2264 0 \u2192 b = 0 \u2192 a + b \u2264 0", "decl_nm": "linarith.le_of_le_of_eq", "nl_statement_of_codex": "Let $R$ be an ordered semiring. If $a\\leq 0$ and $b=0$, then $a+b\\leq 0$."}
{"formal_statement": "theorem esymm_zero (\u03c3 R : Type*) [comm_semiring R] [fintype \u03c3] :\n\tmv_polynomial.esymm \u03c3 R 0 = 1", "decl_tp": "\u2200 (\u03c3 : Type u_1) (R : Type u_2) [_inst_1 : comm_semiring R] [_inst_3 : fintype \u03c3], mv_polynomial.esymm \u03c3 R 0 = 1", "decl_nm": "mv_polynomial.esymm_zero", "nl_statement_of_codex": "The elementary symmetric polynomial of degree $0$ is $1$."}
{"formal_statement": "theorem function_commute_mul_left {G : Type*} [semigroup G] {a b : G} (h : commute a b) :\n\tfunction.commute (has_mul.mul a) (has_mul.mul b)", "decl_tp": "\u2200 {G : Type u_3} [_inst_1 : semigroup G] {a b : G}, commute a b \u2192 function.commute (has_mul.mul a) (has_mul.mul b)", "decl_nm": "commute.function_commute_mul_left", "nl_statement_of_codex": "If $a$ and $b$ commute, then the functions $x\\mapsto ax$ and $x\\mapsto bx$ commute."}
{"formal_statement": "theorem mul_bot {R : Type u} [comm_semiring R] (I : ideal R) :\n\tI * \u22a5 = \u22a5", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] (I : ideal R), I * \u22a5 = \u22a5", "decl_nm": "ideal.mul_bot", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $I$ be an ideal of $R$. Then $I\\cdot 0=0$."}
{"formal_statement": "theorem inr_fst_assoc {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{P Q : C} (self : category_theory.limits.binary_bicone P Q) {X' : C} (f' : P \u27f6 X') :\n\tself.inr \u226b self.fst \u226b f' = 0 \u226b f'", "decl_tp": "\u2200 {C : Type u} [_inst_2 : category_theory.category C] [_inst_3 : category_theory.limits.has_zero_morphisms C] {P Q : C} (self : category_theory.limits.binary_bicone P Q) {X' : C} (f' : P \u27f6 X'), self.inr \u226b self.fst \u226b f' = 0 \u226b f'", "decl_nm": "category_theory.limits.binary_bicone.inr_fst_assoc", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $P, Q$ be objects of $C$ and let $self$ be a binary bicone from $P$ to $Q$. Let $X'$ be an object of $C$ and let $f':P\\to X'$. Then $self.inr\\circ self.fst\\circ f'=0\\circ f'$."}
{"formal_statement": "theorem line_map_apply_ring' {k : Type*} [ring k] (a b c : k) :\n\t\u21d1(affine_map.line_map a b) c = c * (b - a) + a", "decl_tp": "\u2200 {k : Type u_1} [_inst_1 : ring k] (a b c : k), \u21d1(affine_map.line_map a b) c = c * (b - a) + a", "decl_nm": "affine_map.line_map_apply_ring'", "nl_statement_of_codex": "Let $a,b,c$ be elements of a ring $k$. Then the image of $c$ under the affine map $x\\mapsto c(b-a)+a$ is $c(b-a)+a$."}
{"formal_statement": "theorem snd {\u03b1 \u03b2 \u03b3 : Type*} [measurable_space \u03b1] [measurable_space \u03b2] [measurable_space \u03b3]\n\t{\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [measure_theory.sigma_finite \u03bd]\n\t{f : \u03b2 \u2192 \u03b3} (hf : ae_measurable f \u03bd) :\n\tae_measurable (\u03bb (z : \u03b1 \u00d7 \u03b2), f z.snd) (\u03bc.prod \u03bd)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_3} {\u03b3 : Type u_5} [_inst_1 : measurable_space \u03b1] [_inst_3 : measurable_space \u03b2] [_inst_5 : measurable_space \u03b3] {\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [_inst_8 : measure_theory.sigma_finite \u03bd] {f : \u03b2 \u2192 \u03b3}, ae_measurable f \u03bd \u2192 ae_measurable (\u03bb (z : \u03b1 \u00d7 \u03b2), f z.snd) (\u03bc.prod \u03bd)", "decl_nm": "ae_measurable.snd", "nl_statement_of_codex": "Let $X$ and $Y$ be measurable spaces and let $\\mu$ be a measure on $X$ and $\\nu$ be a sigma-finite measure on $Y$.\nLet $f:Y\\to Z$ be a measurable function. Then the function $g:X\\times Y\\to Z$ defined by $g(x,y)=f(y)$ is measurable."}
{"formal_statement": "theorem comp_apply {M N P : Type*} [has_zero M] [has_zero N] [has_zero P]\n\t(g : zero_hom N P) (f : zero_hom M N) (x : M) :\n\t\u21d1(g.comp f) x = \u21d1g (\u21d1f x)", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_1 : has_zero M] [_inst_2 : has_zero N] [_inst_3 : has_zero P] (g : zero_hom N P) (f : zero_hom M N) (x : M), \u21d1(g.comp f) x = \u21d1g (\u21d1f x)", "decl_nm": "zero_hom.comp_apply", "nl_statement_of_codex": "Let $M, N, P$ be sets with zero elements. Let $f:M\\to N$ and $g:N\\to P$ be zero homomorphisms. Then $(g\\circ f)(x)=g(f(x))$."}
{"formal_statement": "theorem results_of_terminates {\u03b1 : Type u} (s : computation \u03b1) [T : s.terminates] :\n\ts.results s.get s.length", "decl_tp": "\u2200 {\u03b1 : Type u} (s : computation \u03b1) [T : s.terminates], s.results s.get s.length", "decl_nm": "computation.results_of_terminates", "nl_statement_of_codex": "If a computation terminates, then the results of the computation are the results of the computation."}
{"formal_statement": "theorem eq_zero_of_ne_zero_of_mul_right_eq_zero {M : Type*} [monoid_with_zero M]\n\t[no_zero_divisors M] {x y : M} (hnx : x \u2260 0) (hxy : y * x = 0) :\n\ty = 0", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid_with_zero M] [_inst_4 : no_zero_divisors M] {x y : M}, x \u2260 0 \u2192 y * x = 0 \u2192 y = 0", "decl_nm": "eq_zero_of_ne_zero_of_mul_right_eq_zero", "nl_statement_of_codex": "Let $M$ be a monoid with zero and no zero divisors. Let $x, y\\in M$. If $x\\neq 0$ and $y\\cdot x=0$, then $y=0$."}
{"formal_statement": "theorem id {\u03b1 : Type u} [semiring \u03b1] :\n\tis_semiring_hom id", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semiring \u03b1], is_semiring_hom id", "decl_nm": "is_semiring_hom.id", "nl_statement_of_codex": "The identity function is a semiring homomorphism."}
{"formal_statement": "theorem infi_mul_of_ne {\u03b9 : Sort u_1} {f : \u03b9 \u2192 ennreal} {x : ennreal} (h0 : x \u2260 0)\n\t(h : x \u2260 \u22a4) :\n\t(infi f * x = \u2a05 (i : \u03b9), f i * x)", "decl_tp": "\u2200 {\u03b9 : Sort u_1} {f : \u03b9 \u2192 ennreal} {x : ennreal}, x \u2260 0 \u2192 x \u2260 \u22a4 \u2192 (infi f * x = \u2a05 (i : \u03b9), f i * x)", "decl_nm": "ennreal.infi_mul_of_ne", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\mathbb{R}$ be a function. Then $\\inf f\\cdot x=\\inf (f\\cdot x)$."}
{"formal_statement": "theorem associated_map_mk {\u03b1 : Type*} [comm_monoid \u03b1] {f : associates \u03b1 \u2192* \u03b1}\n\t(hinv : function.right_inverse \u21d1f associates.mk) :\n\t\u2200 (a : \u03b1), associated a (\u21d1f (associates.mk a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {f : associates \u03b1 \u2192* \u03b1}, function.right_inverse \u21d1f associates.mk \u2192 \u2200 (a : \u03b1), associated a (\u21d1f (associates.mk a))", "decl_nm": "associates.associated_map_mk", "nl_statement_of_codex": "Let $f:A\\to R$ be a map from the set of associates of $R$ to $R$. If $f$ is a right inverse of the map $a\\mapsto [a]$, then $f$ maps each associate of $a$ to $a$."}
{"formal_statement": "theorem rank_matrix' (R : Type u) [ring R] [strong_rank_condition R] (n : Type v)\n\t[fintype n] (m : Type v) [fintype m] :\n\tmodule.rank R (matrix n m R) = (cardinal.mk n * cardinal.mk m).lift", "decl_tp": "\u2200 (R : Type u) [_inst_1 : ring R] [_inst_2 : strong_rank_condition R] (n : Type v) [_inst_9 : fintype n] (m : Type v) [_inst_10 : fintype m], module.rank R (matrix n m R) = (cardinal.mk n * cardinal.mk m).lift", "decl_nm": "module.free.rank_matrix'", "nl_statement_of_codex": "The rank of the free module of rank $n\\times m$ over a ring $R$ is $nm$."}
{"formal_statement": "theorem is_O_with_neg_left {\u03b1 F E' : Type*} [has_norm F] [normed_group E']\n\t{c : \u211d} {g : \u03b1 \u2192 F} {f' : \u03b1 \u2192 E'} {l : filter \u03b1} :\n\tasymptotics.is_O_with c (\u03bb (x : \u03b1), -f' x) g l \u2194 asymptotics.is_O_with c f' g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {c : \u211d} {g : \u03b1 \u2192 F} {f' : \u03b1 \u2192 E'} {l : filter \u03b1}, asymptotics.is_O_with c (\u03bb (x : \u03b1), -f' x) g l \u2194 asymptotics.is_O_with c f' g l", "decl_nm": "asymptotics.is_O_with_neg_left", "nl_statement_of_codex": "Let $f':X\\to E'$ be a function and let $g:X\\to F$ be a function. Then $f'$ is $O(g)$ if and only if $-f'$ is $O(g)$."}
{"formal_statement": "theorem inter_left {\u03b1 : Type u} [topological_space \u03b1] {s t : set \u03b1} (ht : is_compact t)\n\t(hs : is_closed s) :\n\tis_compact (s \u2229 t)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s t : set \u03b1}, is_compact t \u2192 is_closed s \u2192 is_compact (s \u2229 t)", "decl_nm": "is_compact.inter_left", "nl_statement_of_codex": "Let $X$ be a topological space and let $s,t\\subset X$. If $t$ is compact and $s$ is closed, then $s\\cap t$ is compact."}
{"formal_statement": "theorem ball_subset_closed_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x : \u03b1}\n\t{\u03b5 : \u211d} :\n\tmetric.ball x \u03b5 \u2286 metric.closed_ball x \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d}, metric.ball x \u03b5 \u2286 metric.closed_ball x \u03b5", "decl_nm": "metric.ball_subset_closed_ball", "nl_statement_of_codex": "The open ball of radius $\\epsilon$ centered at $x$ is contained in the closed ball of radius $\\epsilon$ centered at $x$."}
{"formal_statement": "theorem card_fintype_Ioc_of_le (a b : \u2124) (h : a \u2264 b) :\n\t\u2191(fintype.card \u21a5(set.Ioc a b)) = b - a", "decl_tp": "\u2200 (a b : \u2124), a \u2264 b \u2192 \u2191(fintype.card \u21a5(set.Ioc a b)) = b - a", "decl_nm": "int.card_fintype_Ioc_of_le", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{Z}$ with $a\\leq b$. Then the cardinality of the set $\\{a,a+1,\\ldots,b\\}$ is $b-a$."}
{"formal_statement": "theorem presheaf_to_Type_obj (X : Top) {T : Type v} {U : (topological_space.opens \u21a5X)\u1d52\u1d56} :\n\t(X.presheaf_to_Type T).obj U = (\u21a5(opposite.unop U) \u2192 T)", "decl_tp": "\u2200 (X : Top) {T : Type v} {U : (topological_space.opens \u21a5X)\u1d52\u1d56}, (X.presheaf_to_Type T).obj U = (\u21a5(opposite.unop U) \u2192 T)", "decl_nm": "Top.presheaf_to_Type_obj", "nl_statement_of_codex": "Let $X$ be a topological space and let $T$ be a type. Then the object of the presheaf $X\\to T$ at an open set $U$ is the set of functions from $U$ to $T$."}
{"formal_statement": "theorem map_equiv_symm_apply {R : Type u} {S : Type v} [semiring R] [semiring S]\n\t(e : R \u2243+* S) (\u1fb0 : polynomial S) :\n\t\u21d1((polynomial.map_equiv e).symm) \u1fb0 = polynomial.map \u2191(e.symm) \u1fb0", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : semiring R] [_inst_2 : semiring S] (e : R \u2243+* S) (\u1fb0 : polynomial S), \u21d1((polynomial.map_equiv e).symm) \u1fb0 = polynomial.map \u2191(e.symm) \u1fb0", "decl_nm": "polynomial.map_equiv_symm_apply", "nl_statement_of_codex": "Let $R$ and $S$ be semirings and let $e:R\\to S$ be an additive equivalence. Then for any polynomial $p$ over $S$,\n$e^{-1}(p)=e^{-1}(p)$."}
{"formal_statement": "theorem aeval_tower_X {R : Type u} {S : Type v} {A' : Type*} [comm_semiring A']\n\t[comm_semiring R] [comm_semiring S] [algebra S R] [algebra S A'] (g : R \u2192\u2090[S] A')\n\t(y : A') :\n\t\u21d1(polynomial.aeval_tower g y) polynomial.X = y", "decl_tp": "\u2200 {R : Type u} {S : Type v} {A' : Type u_1} [_inst_1 : comm_semiring A'] [_inst_3 : comm_semiring R] [_inst_8 : comm_semiring S] [_inst_9 : algebra S R] [_inst_10 : algebra S A'] (g : R \u2192\u2090[S] A') (y : A'), \u21d1(polynomial.aeval_tower g y) polynomial.X = y", "decl_nm": "polynomial.aeval_tower_X", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $S$ be a commutative semiring, let $A'$ be a commutative semiring, let $g:R\\to A'$ be an $S$-algebra homomorphism, and let $y\\in A'$. Then the polynomial $X$ evaluated at $y$ is $y$."}
{"formal_statement": "theorem coe_eq_one {\u03b1 : Type u} [has_one \u03b1] {a : \u03b1} :\n\t\u2191a = 1 \u2194 a = 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_one \u03b1] {a : \u03b1}, \u2191a = 1 \u2194 a = 1", "decl_nm": "with_top.coe_eq_one", "nl_statement_of_codex": "Let $\u03b1$ be a type with a multiplicative identity $1$. Then $a=1$ if and only if $\u2191a=1$."}
{"formal_statement": "theorem sin_pi_div_four :\n\treal.sin (real.pi / 4) = real.sqrt 2 / 2", "decl_tp": "real.sin (real.pi / 4) = real.sqrt 2 / 2", "decl_nm": "real.sin_pi_div_four", "nl_statement_of_codex": "$\\sin(\\pi/4)=\\sqrt{2}/2$."}
{"formal_statement": "theorem coprime_zero_right (n : \u2115) :\n\tn.coprime 0 \u2194 n = 1", "decl_tp": "\u2200 (n : \u2115), n.coprime 0 \u2194 n = 1", "decl_nm": "nat.coprime_zero_right", "nl_statement_of_codex": "$n$ is coprime to $0$ if and only if $n=1$."}
{"formal_statement": "theorem map_sub {R S M M\u2082 : Type*1} [semiring R] [semiring S] [add_comm_group M]\n\t[add_comm_group M\u2082] {module_M : module R M} {module_M\u2082 : module S M\u2082}\n\t{\u03c3 : R \u2192+* S} (f : M \u2192\u209b\u2097[\u03c3] M\u2082) (x y : M) :\n\t\u21d1f (x - y) = \u21d1f x - \u21d1f y", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_6} {M : Type u_9} {M\u2082 : Type u_11} [_inst_1 : semiring R] [_inst_2 : semiring S] [_inst_3 : add_comm_group M] [_inst_4 : add_comm_group M\u2082] {module_M : module R M} {module_M\u2082 : module S M\u2082} {\u03c3 : R \u2192+* S} (f : M \u2192\u209b\u2097[\u03c3] M\u2082) (x y : M), \u21d1f (x - y) = \u21d1f x - \u21d1f y", "decl_nm": "linear_map.map_sub", "nl_statement_of_codex": "Let $R$ and $S$ be semirings, let $M$ and $M_2$ be abelian groups, let $\u03c3:R\\to S$ be a ring homomorphism, and let $f:M\\to M_2$ be a linear map. Then $f(x-y)=f(x)-f(y)$."}
{"formal_statement": "theorem generate_from_eq_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9] [h : \u03a0 (i : \u03b9), measurable_space (\u03b1 i)]\n\t{C : \u03a0 (i : \u03b9), set (set (\u03b1 i))} :\n\t(\u2200 (i : \u03b9), measurable_space.generate_from (C i) = h i) \u2192 (\u2200 (i : \u03b9), is_countably_spanning (C i)) \u2192 measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_3} [_inst_1 : fintype \u03b9] [h : \u03a0 (i : \u03b9), measurable_space (\u03b1 i)] {C : \u03a0 (i : \u03b9), set (set (\u03b1 i))}, (\u2200 (i : \u03b9), measurable_space.generate_from (C i) = h i) \u2192 (\u2200 (i : \u03b9), is_countably_spanning (C i)) \u2192 measurable_space.generate_from (set.univ.pi '' set.univ.pi C) = measurable_space.pi", "decl_nm": "generate_from_eq_pi", "nl_statement_of_codex": "Let $\\{X_i\\}_{i\\in I}$ be a family of measurable spaces. If $\\sigma(X_i)=\\mathcal{B}(X_i)$ for all $i\\in I$ and $\\mathcal{B}(X_i)$ is countably spanning for all $i\\in I$, then $\\sigma(X)=\\mathcal{B}(X)$."}
{"formal_statement": "theorem of_set_symm {\u03b1 : Type u} (s : set \u03b1) [decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)] :\n\t(pequiv.of_set s).symm = pequiv.of_set s", "decl_tp": "\u2200 {\u03b1 : Type u} (s : set \u03b1) [_inst_1 : decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)], (pequiv.of_set s).symm = pequiv.of_set s", "decl_nm": "pequiv.of_set_symm", "nl_statement_of_codex": "The inverse of the partial equivalence relation on a set $S$ is the same as the partial equivalence relation on $S$."}
{"formal_statement": "theorem nonempty_of_affine_span_eq_top (k V P : Type*) [ring k] [add_comm_group V]\n\t[module k V] [S : add_torsor V P] {s : set P} (h : affine_span k s = \u22a4) :\n\ts.nonempty", "decl_tp": "\u2200 (k : Type u_1) (V : Type u_2) (P : Type u_3) [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [S : add_torsor V P] {s : set P}, affine_span k s = \u22a4 \u2192 s.nonempty", "decl_nm": "affine_subspace.nonempty_of_affine_span_eq_top", "nl_statement_of_codex": "Let $k$ be a ring, $V$ a $k$-module, and $P$ an affine space over $V$. Let $s$ be a subset of $P$. If the affine span of $s$ is $P$, then $s$ is nonempty."}
{"formal_statement": "theorem zpow_lt_iff_lt {K : Type*} [linear_ordered_field K] {x : K} (hx : 1 < x) :\n\t\u2200 {m n : \u2124}, x ^ m < x ^ n \u2194 m < n", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : linear_ordered_field K] {x : K}, 1 < x \u2192 \u2200 {m n : \u2124}, x ^ m < x ^ n \u2194 m < n", "decl_nm": "zpow_lt_iff_lt", "nl_statement_of_codex": "Let $K$ be a linear ordered field and let $x\\in K$ with $x>1$. Then $x^m<x^n$ if and only if $m<n$."}
{"formal_statement": "theorem pointwise_smul_le_iff\u2080 {\u03b1 G : Type*} [group G] [group_with_zero \u03b1]\n\t[mul_distrib_mul_action \u03b1 G] {a : \u03b1} (ha : a \u2260 0) :\n\t\u2200 {S T : subgroup G}, a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_2} [_inst_1 : group G] [_inst_3 : group_with_zero \u03b1] [_inst_4 : mul_distrib_mul_action \u03b1 G] {a : \u03b1}, a \u2260 0 \u2192 \u2200 {S T : subgroup G}, a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "decl_nm": "subgroup.pointwise_smul_le_iff\u2080", "nl_statement_of_codex": "Let $G$ be a group and let $a\\in\\mathbb{Z}$. Then $aS\\leq T$ if and only if $S\\leq a^{-1}T$."}
{"formal_statement": "theorem to_local_homeomorph_target {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] (f : \u03b1 \u2192 \u03b2) (h : open_embedding f) [nonempty \u03b1] :\n\t(open_embedding.to_local_homeomorph f h).to_local_equiv.target = set.range f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (f : \u03b1 \u2192 \u03b2) (h : open_embedding f) [_inst_5 : nonempty \u03b1], (open_embedding.to_local_homeomorph f h).to_local_equiv.target = set.range f", "decl_nm": "open_embedding.to_local_homeomorph_target", "nl_statement_of_codex": "Let $f:X\\to Y$ be an open embedding. Then the target of the local homeomorphism $f:X\\to f(X)$ is $f(X)$."}
{"formal_statement": "theorem symm {X : Type*} [topological_space X] (S : discrete_quotient X)\n\t(x y : X) :\n\tS.rel x y \u2192 S.rel y x", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] (S : discrete_quotient X) (x y : X), S.rel x y \u2192 S.rel y x", "decl_nm": "discrete_quotient.symm", "nl_statement_of_codex": "Let $X$ be a topological space and let $S$ be a discrete quotient of $X$. Then the relation $S$ is symmetric."}
{"formal_statement": "theorem choose_le_central_binom (r n : \u2115) :\n\t(2 * n).choose r \u2264 n.central_binom", "decl_tp": "\u2200 (r n : \u2115), (2 * n).choose r \u2264 n.central_binom", "decl_nm": "nat.choose_le_central_binom", "nl_statement_of_codex": "For all $r,n\\in\\mathbb{N}$, the number of ways to choose $r$ elements from a set of $2n$ elements is less than or equal to the number of ways to choose $r$ elements from a set of $n$ elements."}
{"formal_statement": "theorem is_compact {\u03b1 : Type u} [topological_space \u03b1] {s : set \u03b1} (hs : s.subsingleton) :\n\tis_compact s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, s.subsingleton \u2192 is_compact s", "decl_nm": "set.subsingleton.is_compact", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a singleton subset of $X$. Then $A$ is compact."}
{"formal_statement": "theorem forall {\u03b1 : Type*} {f : sym2 \u03b1 \u2192 Prop} :\n\t(\u2200 (x : sym2 \u03b1), f x) \u2194 \u2200 (x y : \u03b1), f \u27e6(x, y)\u27e7", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : sym2 \u03b1 \u2192 Prop}, (\u2200 (x : sym2 \u03b1), f x) \u2194 \u2200 (x y : \u03b1), f \u27e6(x, y)\u27e7", "decl_nm": "sym2.forall", "nl_statement_of_codex": "For all $x,y\\in\\alpha$, $f(x,y)$ holds if and only if $f(y,x)$ holds."}
{"formal_statement": "theorem vadd_mem_orbit_vadd (\u03b1 : Type u) {\u03b2 : Type v} [add_group \u03b1] [add_action \u03b1 \u03b2]\n\t(g h : \u03b1) (a : \u03b2) :\n\tg +\u1d65 a \u2208 add_action.orbit \u03b1 (h +\u1d65 a)", "decl_tp": "\u2200 (\u03b1 : Type u) {\u03b2 : Type v} [_inst_1 : add_group \u03b1] [_inst_2 : add_action \u03b1 \u03b2] (g h : \u03b1) (a : \u03b2), g +\u1d65 a \u2208 add_action.orbit \u03b1 (h +\u1d65 a)", "decl_nm": "add_action.vadd_mem_orbit_vadd", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then for all $g,h\\in G$ and $x\\in X$, $gx$ is in the orbit of $hx$."}
{"formal_statement": "theorem map_const {\u03b1 : Type u} {\u03b2 : Type v} (l : list \u03b1) (b : \u03b2) :\n\tlist.map (function.const \u03b1 b) l = list.repeat b l.length", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (l : list \u03b1) (b : \u03b2), list.map (function.const \u03b1 b) l = list.repeat b l.length", "decl_nm": "list.map_const", "nl_statement_of_codex": "Let $l$ be a list of elements of $A$ and let $b$ be an element of $B$. Then the list obtained by applying the constant function $A\\to B$ to each element of $l$ is the list of $b$'s of length $l$."}
{"formal_statement": "theorem horner_def' {\u03b1 : Type*} [comm_semiring \u03b1] (a x : \u03b1) (n : \u2115) (b : \u03b1) :\n\ttactic.ring.horner a x n b = x ^ n * a + b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_semiring \u03b1] (a x : \u03b1) (n : \u2115) (b : \u03b1), tactic.ring.horner a x n b = x ^ n * a + b", "decl_nm": "tactic.ring.horner_def'", "nl_statement_of_codex": "The polynomial $a_nx^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0$ can be written as $x^n\\cdot a_n+b$."}
{"formal_statement": "theorem multiset_sum_mem {G : Type*} [add_comm_group G] (K : add_subgroup G)\n\t(g : multiset G) :\n\t(\u2200 (a : G), a \u2208 g \u2192 a \u2208 K) \u2192 g.sum \u2208 K", "decl_tp": "\u2200 {G : Type u_1} [_inst_3 : add_comm_group G] (K : add_subgroup G) (g : multiset G), (\u2200 (a : G), a \u2208 g \u2192 a \u2208 K) \u2192 g.sum \u2208 K", "decl_nm": "add_subgroup.multiset_sum_mem", "nl_statement_of_codex": "Let $G$ be an abelian group and let $K$ be a subgroup of $G$. Let $g$ be a multiset of elements of $G$. If each element of $g$ is in $K$, then the sum of the elements of $g$ is in $K$."}
{"formal_statement": "theorem one_le_blocks_fun {n : \u2115} (c : composition n) (i : fin c.length) :\n\t1 \u2264 c.blocks_fun i", "decl_tp": "\u2200 {n : \u2115} (c : composition n) (i : fin c.length), 1 \u2264 c.blocks_fun i", "decl_nm": "composition.one_le_blocks_fun", "nl_statement_of_codex": "Let $c$ be a composition of $n$. Then the $i$-th block of $c$ is at least $1$."}
{"formal_statement": "theorem coe_eq_zero {r : nnreal} :\n\t\u2191r = 0 \u2194 r = 0", "decl_tp": "\u2200 {r : nnreal}, \u2191r = 0 \u2194 r = 0", "decl_nm": "ennreal.coe_eq_zero", "nl_statement_of_codex": "The nonnegative real number $r$ is equal to $0$ if and only if the real number $r$ is equal to $0$."}
{"formal_statement": "theorem frequently_const {\u03b1 : Type u} {f : filter \u03b1} [f.ne_bot] {p : Prop} :\n\t(\u2203\u1da0 (x : \u03b1) in f, p) \u2194 p", "decl_tp": "\u2200 {\u03b1 : Type u} {f : filter \u03b1} [_inst_1 : f.ne_bot] {p : Prop}, (\u2203\u1da0 (x : \u03b1) in f, p) \u2194 p", "decl_nm": "filter.frequently_const", "nl_statement_of_codex": "If $f$ is a non-empty filter on $X$, then $f$ is frequently $p$ if and only if $p$ is true."}
{"formal_statement": "theorem one_half_lt_one :\n\t2\u207b\u00b9 < 1", "decl_tp": "2\u207b\u00b9 < 1", "decl_nm": "ennreal.one_half_lt_one", "nl_statement_of_codex": "$\\frac{1}{2}<1$."}
{"formal_statement": "theorem differentiable_on_id {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {s : set E} :\n\tdifferentiable_on \ud835\udd5c id s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {s : set E}, differentiable_on \ud835\udd5c id s", "decl_nm": "differentiable_on_id", "nl_statement_of_codex": "The identity function $id:E\\to E$ is differentiable on any set $s\\subset E$."}
{"formal_statement": "theorem decode {\u03b1 : Type*} [primcodable \u03b1] :\n\tprimrec (encodable.decode \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], primrec (encodable.decode \u03b1)", "decl_nm": "primrec.decode", "nl_statement_of_codex": "The function decode is primitive recursive."}
{"formal_statement": "theorem pairwise_singleton {\u03b1 : Type*} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) :\n\tlist.pairwise R [a]", "decl_tp": "\u2200 {\u03b1 : Type u_1} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1), list.pairwise R [a]", "decl_nm": "list.pairwise_singleton", "nl_statement_of_codex": "The list $[a]$ is pairwise $R$."}
{"formal_statement": "theorem attach_bound_apply_coe {X : Type*} [topological_space X] [compact_space X]\n\t(f : C(X, \u211d)) (x : X) :\n\t\u2191(\u21d1(f.attach_bound) x) = \u21d1f x", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] [_inst_2 : compact_space X] (f : C(X, \u211d)) (x : X), \u2191(\u21d1(f.attach_bound) x) = \u21d1f x", "decl_nm": "continuous_map.attach_bound_apply_coe", "nl_statement_of_codex": "Let $X$ be a compact topological space and let $f:X\\to\\mathbb{R}$. Then $f$ is bounded if and only if $f$ is continuous."}
{"formal_statement": "theorem code_supp_succ (k : turing.partrec_to_TM2.cont') :\n\tturing.partrec_to_TM2.code_supp turing.to_partrec.code.succ k = turing.partrec_to_TM2.tr_stmts\u2081 (turing.partrec_to_TM2.tr_normal turing.to_partrec.code.succ k) \u222a turing.partrec_to_TM2.cont_supp k", "decl_tp": "\u2200 (k : turing.partrec_to_TM2.cont'), turing.partrec_to_TM2.code_supp turing.to_partrec.code.succ k = turing.partrec_to_TM2.tr_stmts\u2081 (turing.partrec_to_TM2.tr_normal turing.to_partrec.code.succ k) \u222a turing.partrec_to_TM2.cont_supp k", "decl_nm": "turing.partrec_to_TM2.code_supp_succ", "nl_statement_of_codex": "The support of the code of the successor function is the union of the support of the code of the successor function and the support of the continuation."}
{"formal_statement": "theorem comp_apply {M N P : Type*} [has_one M] [has_one N] [has_one P]\n\t(g : one_hom N P) (f : one_hom M N) (x : M) :\n\t\u21d1(g.comp f) x = \u21d1g (\u21d1f x)", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_1 : has_one M] [_inst_2 : has_one N] [_inst_3 : has_one P] (g : one_hom N P) (f : one_hom M N) (x : M), \u21d1(g.comp f) x = \u21d1g (\u21d1f x)", "decl_nm": "one_hom.comp_apply", "nl_statement_of_codex": "Let $M, N, P$ be monoids. Let $f:M\\to N$ and $g:N\\to P$ be monoid homomorphisms. Then $g\\circ f:M\\to P$ is a monoid homomorphism and $(g\\circ f)(x)=g(f(x))$ for all $x\\in M$."}
{"formal_statement": "theorem deriv_limit (f : ordinal \u2192 ordinal) {o : ordinal} :\n\to.is_limit \u2192 ordinal.deriv f o = o.bsup (\u03bb (a : ordinal) (_x : a < o), ordinal.deriv f a)", "decl_tp": "\u2200 (f : ordinal \u2192 ordinal) {o : ordinal}, o.is_limit \u2192 ordinal.deriv f o = o.bsup (\u03bb (a : ordinal) (_x : a < o), ordinal.deriv f a)", "decl_nm": "ordinal.deriv_limit", "nl_statement_of_codex": "Let $f$ be a function from ordinals to ordinals. If $o$ is a limit ordinal, then the derivative of $f$ at $o$ is the supremum of the derivatives of $f$ at all ordinals less than $o$."}
{"formal_statement": "theorem mem_nhds_right {\u03b1 : Type*} [uniform_space \u03b1] (y : \u03b1) {s : set (\u03b1 \u00d7 \u03b1)}\n\t(y : \u03b1) :\n\ts \u2208 uniformity  {x : \u03b1 | (x, y) \u2208 s} \u2208 nhds y", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] (y : \u03b1) {s : set (\u03b1 \u00d7 \u03b1)}, s \u2208 uniformity \u03b1 \u2192 {x : \u03b1 | (x, y) \u2208 s} \u2208 nhds y", "decl_nm": "mem_nhds_right", "nl_statement_of_codex": "Let $X$ be a uniform space and let $y\\in X$. Then the set $\\{(x,y)\\in X\\times X\\mid (x,y)\\in s\\}$ is a neighborhood of $y$."}
{"formal_statement": "theorem lintegral_tendsto_of_countably_generated {\u03b1 \u03b9 : Type*} [measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {l : filter \u03b9} [l.is_countably_generated]\n\t{\u03c6 : \u03b9 \u2192 set \u03b1} (h\u03c6 : measure_theory.ae_cover \u03bc l \u03c6) (hfm : ae_measurable f \u03bc) :\n\t\u2200 {f : \u03b1 \u2192 ennreal},  filter.tendsto (\u03bb (i : \u03b9), \u222b\u207b (x : \u03b1) in \u03c6 i, f x \u2202\u03bc) l (nhds (\u222b\u207b (x : \u03b1), f x \u2202\u03bc))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {l : filter \u03b9} [_inst_2 : l.is_countably_generated] {\u03c6 : \u03b9 \u2192 set \u03b1}, measure_theory.ae_cover \u03bc l \u03c6 \u2192 \u2200 {f : \u03b1 \u2192 ennreal}, ae_measurable f \u03bc \u2192 filter.tendsto (\u03bb (i : \u03b9), \u222b\u207b (x : \u03b1) in \u03c6 i, f x \u2202\u03bc) l (nhds (\u222b\u207b (x : \u03b1), f x \u2202\u03bc))", "decl_nm": "measure_theory.ae_cover.lintegral_tendsto_of_countably_generated", "nl_statement_of_codex": "Let $\u03b1$ be a measurable space and let $\u03bc$ be a measure on $\u03b1$. Let $l$ be a countably generated filter on $\u03b1$ and let $\\phi:l\\to\\mathcal{P}(\u03b1)$ be a function such that $\\phi(l)$ is a cover of $\u03b1$ up to a set of measure zero. Then for any measurable function $f:\u03b1\\to\\mathbb{R}$, the sequence of integrals $\\int_{\\phi(l)}f\\,d\\mu$ converges to $\\int_\u03b1 f\\,d\\mu$."}
{"formal_statement": "theorem to_finset_reverse {\u03b1 : Type*} [decidable_eq \u03b1] {l : list \u03b1} :\n\tl.reverse.to_finset = l.to_finset", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {l : list \u03b1}, l.reverse.to_finset = l.to_finset", "decl_nm": "list.to_finset_reverse", "nl_statement_of_codex": "The finset corresponding to the reverse of a list is the same as the finset corresponding to the list."}
{"formal_statement": "theorem mem_prod {M N : Type*} [mul_one_class M] [mul_one_class N] {s : submonoid M}\n\t{t : submonoid N} {p : M \u00d7 N} :\n\tp \u2208 s.prod t \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] {s : submonoid M} {t : submonoid N} {p : M \u00d7 N}, p \u2208 s.prod t \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t", "decl_nm": "submonoid.mem_prod", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity. Let $s$ be a submonoid of $M$ and let $t$ be a submonoid of $N$. Then $(x,y)\\in s\\times t$ if and only if $x\\in s$ and $y\\in t$."}
{"formal_statement": "theorem explicit_cokernel_desc_norm_noninc {X Y Z : SemiNormedGroup} {f : X \u27f6 Y}\n\t{g : Y \u27f6 Z} {cond : f \u226b g = 0} (hg : normed_group_hom.norm_noninc g) :\n\tnormed_group_hom.norm_noninc (SemiNormedGroup.explicit_cokernel_desc cond)", "decl_tp": "\u2200 {X Y Z : SemiNormedGroup} {f : X \u27f6 Y} {g : Y \u27f6 Z} {cond : f \u226b g = 0}, normed_group_hom.norm_noninc g \u2192 normed_group_hom.norm_noninc (SemiNormedGroup.explicit_cokernel_desc cond)", "decl_nm": "SemiNormedGroup.explicit_cokernel_desc_norm_noninc", "nl_statement_of_codex": "Let $X, Y, Z$ be seminormed groups and let $f:X\\to Y$ and $g:Y\\to Z$ be seminormed group homomorphisms.\nSuppose that $f\\circ g=0$. If $g$ is non-increasing, then the cokernel of $f$ is non-increasing."}
{"formal_statement": "theorem sub {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {f g : E \u2192 F}\n\t{x : E} (hf : differentiable_at \ud835\udd5c f x) (hg : differentiable_at \ud835\udd5c g x) :\n\tdifferentiable_at \ud835\udd5c (\u03bb (y : E), f y - g y) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f g : E \u2192 F} {x : E}, differentiable_at \ud835\udd5c f x \u2192 differentiable_at \ud835\udd5c g x \u2192 differentiable_at \ud835\udd5c (\u03bb (y : E), f y - g y) x", "decl_nm": "differentiable_at.sub", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f,g:E\\to F$ be differentiable at $x\\in E$. Then $f-g$ is differentiable at $x$."}
{"formal_statement": "theorem Inf_mem {s : set ordinal} (hs : s.nonempty) :\n\thas_Inf.Inf s \u2208 s", "decl_tp": "\u2200 {s : set ordinal}, s.nonempty \u2192 has_Inf.Inf s \u2208 s", "decl_nm": "ordinal.Inf_mem", "nl_statement_of_codex": "The infimum of a nonempty set of ordinals is an element of the set."}
{"formal_statement": "theorem comp_apply {R : Type u} {A : Type v} {B : Type w} {C : Type w\u2081}\n\t[monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A]\n\t[non_unital_non_assoc_semiring B] [distrib_mul_action R B] [non_unital_non_assoc_semiring C]\n\t[distrib_mul_action R C] (f : non_unital_alg_hom R B C) (g : non_unital_alg_hom R A B)\n\t(x : A) :\n\t\u21d1(f.comp g) x = \u21d1f (\u21d1g x)", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} {C : Type w\u2081} [_inst_1 : monoid R] [_inst_2 : non_unital_non_assoc_semiring A] [_inst_3 : distrib_mul_action R A] [_inst_4 : non_unital_non_assoc_semiring B] [_inst_5 : distrib_mul_action R B] [_inst_6 : non_unital_non_assoc_semiring C] [_inst_7 : distrib_mul_action R C] (f : non_unital_alg_hom R B C) (g : non_unital_alg_hom R A B) (x : A), \u21d1(f.comp g) x = \u21d1f (\u21d1g x)", "decl_nm": "non_unital_alg_hom.comp_apply", "nl_statement_of_codex": "Let $R$ be a monoid, $A, B, C$ be non-unital non-associative semirings, and $f:B\\to C$ and $g:A\\to B$ be non-unital algebra homomorphisms. Then $(f\\circ g)(x)=f(g(x))$."}
{"formal_statement": "theorem nonempty {P : Type*} [preorder P] (F : order.pfilter P) :\n\t\u2191F.nonempty", "decl_tp": "\u2200 {P : Type u_1} [_inst_1 : preorder P] (F : order.pfilter P), \u2191F.nonempty", "decl_nm": "order.pfilter.nonempty", "nl_statement_of_codex": "Let $P$ be a preorder and let $F$ be a filter on $P$. Then $F$ is nonempty."}
{"formal_statement": "theorem convex_lt {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[linear_ordered_add_comm_monoid \u03b2] [has_scalar \ud835\udd5c E] {s : set E} {f : E \u2192 \u03b2}\n\t(hf : quasiconvex_on \ud835\udd5c s f) :\n\t\u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | f x < r}", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : linear_ordered_add_comm_monoid \u03b2] [_inst_5 : has_scalar \ud835\udd5c E] {s : set E} {f : E \u2192 \u03b2}, quasiconvex_on \ud835\udd5c s f \u2192 \u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | f x < r}", "decl_nm": "quasiconvex_on.convex_lt", "nl_statement_of_codex": "Let $E$ be a vector space over a field $K$ and let $f:E\\to \\mathbb{R}$ be a quasiconvex function. Then the set $\\{x\\in E: f(x)<r\\}$ is convex for all $r\\in \\mathbb{R}$."}
{"formal_statement": "theorem mem {\u03b1 : Type*} {s : set \u03b1} (p : \u21a5s) :\n\t\u2191p \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : set \u03b1} (p : \u21a5s), \u2191p \u2208 s", "decl_nm": "subtype.mem", "nl_statement_of_codex": "Let $s$ be a set and let $p$ be a point in $s$. Then $p$ is an element of $s$."}
{"formal_statement": "theorem lift_symm_apply (R : Type*) [comm_semiring R] {M : Type*} [add_comm_monoid M]\n\t[module R M] {A : Type*} [semiring A] [algebra R A] (F : tensor_algebra R M \u2192\u2090[R] A) :\n\t\u21d1((tensor_algebra.lift R).symm) F = F.to_linear_map.comp (tensor_algebra.\u03b9 R)", "decl_tp": "\u2200 (R : Type u_1) [_inst_1 : comm_semiring R] {M : Type u_2} [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {A : Type u_3} [_inst_4 : semiring A] [_inst_5 : algebra R A] (F : tensor_algebra R M \u2192\u2090[R] A), \u21d1((tensor_algebra.lift R).symm) F = F.to_linear_map.comp (tensor_algebra.\u03b9 R)", "decl_nm": "tensor_algebra.lift_symm_apply", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ an $R$-module, $A$ an $R$-algebra, and $F:T(M)\\to A$ an $R$-algebra homomorphism. Then $F\\circ\\iota=\\widetilde{F}$."}
{"formal_statement": "theorem include_right_apply {R : Type u} [comm_semiring R] {A : Type v\u2081}\n\t[semiring A] [algebra R A] {B : Type v\u2082} [semiring B] [algebra R B] (b : B) :\n\t\u21d1algebra.tensor_product.include_right b = 1 \u2297\u209c[R] b", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {A : Type v\u2081} [_inst_2 : semiring A] [_inst_3 : algebra R A] {B : Type v\u2082} [_inst_4 : semiring B] [_inst_5 : algebra R B] (b : B), \u21d1algebra.tensor_product.include_right b = 1 \u2297\u209c[R] b", "decl_nm": "algebra.tensor_product.include_right_apply", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be $R$-algebras. Then the map $\u21d1algebra.tensor_product.include_right b$ is the map $1\\otimes b$."}
{"formal_statement": "theorem frequently_map {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {m : \u03b1 \u2192 \u03b2}\n\t{P : \u03b2 \u2192 Prop} :\n\t(\u2203\u1da0 (b : \u03b2) in filter.map m f, P b) \u2194 \u2203\u1da0 (a : \u03b1) in f, P (m a)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {m : \u03b1 \u2192 \u03b2} {P : \u03b2 \u2192 Prop}, (\u2203\u1da0 (b : \u03b2) in filter.map m f, P b) \u2194 \u2203\u1da0 (a : \u03b1) in f, P (m a)", "decl_nm": "filter.frequently_map", "nl_statement_of_codex": "Let $f$ be a filter on a set $A$ and let $m:A\\to B$ be a function. Then $m$ is frequently $P$ if and only if $f$ is frequently $P\\circ m$."}
{"formal_statement": "theorem star_zero (R : Type u) [add_monoid R] [star_add_monoid R] :\n\thas_star.star 0 = 0", "decl_tp": "\u2200 (R : Type u) [_inst_1 : add_monoid R] [_inst_2 : star_add_monoid R], has_star.star 0 = 0", "decl_nm": "star_zero", "nl_statement_of_codex": "The star operation on an additive monoid is zero if and only if the star operation on the additive monoid is zero."}
{"formal_statement": "theorem sub {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f g : \ud835\udd5c \u2192 F} {f' g' : F} {x : \ud835\udd5c} {L : filter \ud835\udd5c} (hf : has_deriv_at_filter f f' x L)\n\t(hg : has_deriv_at_filter g g' x L) :\n\thas_deriv_at_filter (\u03bb (x : \ud835\udd5c), f x - g x) (f' - g') x L", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f g : \ud835\udd5c \u2192 F} {f' g' : F} {x : \ud835\udd5c} {L : filter \ud835\udd5c}, has_deriv_at_filter f f' x L \u2192 has_deriv_at_filter g g' x L \u2192 has_deriv_at_filter (\u03bb (x : \ud835\udd5c), f x - g x) (f' - g') x L", "decl_nm": "has_deriv_at_filter.sub", "nl_statement_of_codex": "Let $f,g:\\mathbb{R}\\to\\mathbb{R}$ be differentiable at $x$. Then $f-g$ is differentiable at $x$ and $(f-g)'(x)=f'(x)-g'(x)$."}
{"formal_statement": "theorem gc_map_comap {\u03b1 : Type u} {\u03b2 : Type v} (m : \u03b1 \u2192 \u03b2) :\n\tgalois_connection (filter.map m) (filter.comap m)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (m : \u03b1 \u2192 \u03b2), galois_connection (filter.map m) (filter.comap m)", "decl_nm": "filter.gc_map_comap", "nl_statement_of_codex": "Let $m:A\\to B$ be a function. Then the map $m$ induces a Galois connection between the filter of subsets of $A$ and the filter of subsets of $B$."}
{"formal_statement": "theorem coe_set_eq {R : Type u} {L : Type v} [comm_ring R] [lie_ring L]\n\t[lie_algebra R L] (L\u2081' L\u2082' : lie_subalgebra R L) :\n\t\u2191L\u2081' = \u2191L\u2082' \u2194 L\u2081' = L\u2082'", "decl_tp": "\u2200 {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] (L\u2081' L\u2082' : lie_subalgebra R L), \u2191L\u2081' = \u2191L\u2082' \u2194 L\u2081' = L\u2082'", "decl_nm": "lie_subalgebra.coe_set_eq", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $L$ be a Lie algebra over $R$. Let $L_1'$ and $L_2'$ be Lie subalgebras of $L$. Then $L_1'=L_2'$ if and only if $L_1'$ and $L_2'$ are equal as subsets of $L$."}
{"formal_statement": "theorem empty_mul {\u03b1 : Type u} {n' o' : Type*} [semiring \u03b1] [fintype n']\n\t(A : matrix (fin 0) n' \u03b1) (B : matrix n' o' \u03b1) :\n\tA.mul B = matrix.vec_empty", "decl_tp": "\u2200 {\u03b1 : Type u} {n' : Type u_2} {o' : Type u_3} [_inst_1 : semiring \u03b1] [_inst_2 : fintype n'] (A : matrix (fin 0) n' \u03b1) (B : matrix n' o' \u03b1), A.mul B = matrix.vec_empty", "decl_nm": "matrix.empty_mul", "nl_statement_of_codex": "The product of a $0\\times n$ matrix and an $n\\times o$ matrix is the empty matrix."}
{"formal_statement": "theorem mul {\u03b9 R S : Type*} [set_like S R] [has_add \u03b9] [has_mul R] {A : \u03b9 \u2192 S}\n\t[set_like.has_graded_mul A] {a b : R} (\u1fb0 : set_like.is_homogeneous A a)\n\t(\u1fb0 : set_like.is_homogeneous A b) :\n\tset_like.is_homogeneous A (a * b)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {R : Type u_2} {S : Type u_3} [_inst_1 : set_like S R] [_inst_2 : has_add \u03b9] [_inst_3 : has_mul R] {A : \u03b9 \u2192 S} [_inst_4 : set_like.has_graded_mul A] {a b : R}, set_like.is_homogeneous A a \u2192 set_like.is_homogeneous A b \u2192 set_like.is_homogeneous A (a * b)", "decl_nm": "set_like.is_homogeneous.mul", "nl_statement_of_codex": "Let $A$ be a graded set of $R$-modules. If $a$ and $b$ are homogeneous elements of $A$, then $ab$ is homogeneous."}
{"formal_statement": "theorem mem_closed_ball {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x y : \u03b1}\n\t{\u03b5 : \u211d} :\n\ty \u2208 metric.closed_ball x \u03b5 \u2194 has_dist.dist y x \u2264 \u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x y : \u03b1} {\u03b5 : \u211d}, y \u2208 metric.closed_ball x \u03b5 \u2194 has_dist.dist y x \u2264 \u03b5", "decl_nm": "metric.mem_closed_ball", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x,y\\in X$. Then $y\\in\\overline{B}(x,\\epsilon)$ if and only if $d(x,y)\\leq\\epsilon$."}
{"formal_statement": "theorem right_wins_of_equiv_iff {G H : pgame} (h : G.equiv H) :\n\t(G.right_wins \u2194 H.right_wins)", "decl_tp": "\u2200 {G H : pgame}, G.equiv H \u2192 (G.right_wins \u2194 H.right_wins)", "decl_nm": "pgame.right_wins_of_equiv_iff", "nl_statement_of_codex": "If $G$ and $H$ are equivalent games, then $G$ is a right-win if and only if $H$ is a right-win."}
{"formal_statement": "theorem of_mem_supp {n : \u2115} {F : typevec n \u2192 Type v} [mvfunctor F] {\u03b1 : typevec n}\n\t{x : F \u03b1} {p : \u03a0 \u2983i : fin2 n\u2984, \u03b1 i \u2192 Prop} (h : mvfunctor.liftp p x) (hy : y \u2208 mvfunctor.supp x i) :\n\t\u2200 (i : fin2 n) (y : \u03b1 i),  p y", "decl_tp": "\u2200 {n : \u2115} {F : typevec n \u2192 Type v} [_inst_1 : mvfunctor F] {\u03b1 : typevec n} {x : F \u03b1} {p : \u03a0 \u2983i : fin2 n\u2984, \u03b1 i \u2192 Prop}, mvfunctor.liftp p x \u2192 \u2200 (i : fin2 n) (y : \u03b1 i), y \u2208 mvfunctor.supp x i \u2192 p y", "decl_nm": "mvfunctor.of_mem_supp", "nl_statement_of_codex": "Let $F$ be a multivariate functor. Let $x\\in F(\\alpha)$ and let $p:\\alpha\\to\\mathbb{B}$ be a predicate. If $x$ satisfies $p$, then $x$ is supported on the set $\\{y\\in\\alpha\\mid p(y)=true\\}$."}
{"formal_statement": "theorem map_iso_inv {J : Type v} [decidable_eq J] {C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_zero_morphisms C] [fintype J] {f g : J \u2192 C}\n\t[category_theory.limits.has_finite_biproducts C] (p : \u03a0 (b : J), f b \u2245 g b) :\n\t(category_theory.limits.biproduct.map_iso p).inv = category_theory.limits.biproduct.map (\u03bb (b : J), (p b).inv)", "decl_tp": "\u2200 {J : Type v} [_inst_1 : decidable_eq J] {C : Type u} [_inst_2 : category_theory.category C] [_inst_3 : category_theory.limits.has_zero_morphisms C] [_inst_4 : fintype J] {f g : J \u2192 C} [_inst_5 : category_theory.limits.has_finite_biproducts C] (p : \u03a0 (b : J), f b \u2245 g b), (category_theory.limits.biproduct.map_iso p).inv = category_theory.limits.biproduct.map (\u03bb (b : J), (p b).inv)", "decl_nm": "category_theory.limits.biproduct.map_iso_inv", "nl_statement_of_codex": "Let $C$ be a category with finite biproducts and let $f,g:J\\to C$ be two functors. If $p:f\\to g$ is a natural isomorphism, then the inverse of the induced isomorphism $f\\oplus g\\to g\\oplus f$ is the induced isomorphism $g\\oplus f\\to f\\oplus g$."}
{"formal_statement": "theorem append_nil {\u03b1 : Type*} (xs : lazy_list \u03b1) :\n\txs.append (\u03bb (\u00ab_\u00bb : unit), lazy_list.nil) = xs", "decl_tp": "\u2200 {\u03b1 : Type u_1} (xs : lazy_list \u03b1), xs.append (\u03bb (\u00ab_\u00bb : unit), lazy_list.nil) = xs", "decl_nm": "lazy_list.append_nil", "nl_statement_of_codex": "For any lazy list $xs$, $xs$ appended to the empty lazy list is $xs$."}
{"formal_statement": "theorem interior_compl {\u03b1 : Type u} [topological_space \u03b1] {s : set \u03b1} (h : dense s) :\n\tinterior s\u1d9c = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, dense s \u2192 interior s\u1d9c = \u2205", "decl_nm": "dense.interior_compl", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a dense subset of $X$. Then the interior of the complement of $A$ is empty."}
{"formal_statement": "theorem omega_power_omega :\n\tcardinal.omega ^ cardinal.omega = cardinal.continuum", "decl_tp": "cardinal.omega ^ cardinal.omega = cardinal.continuum", "decl_nm": "cardinal.omega_power_omega", "nl_statement_of_codex": "$\\omega^\\omega=2^\\omega$."}
{"formal_statement": "theorem coeff_X_pow_self {R : Type u} [semiring R] (n : \u2115) :\n\t(polynomial.X ^ n).coeff n = 1", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (n : \u2115), (polynomial.X ^ n).coeff n = 1", "decl_nm": "polynomial.coeff_X_pow_self", "nl_statement_of_codex": "The coefficient of $X^n$ in $X^n$ is $1$."}
{"formal_statement": "theorem comp {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [preorder \u03b1] [preorder \u03b2]\n\t[preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : strict_mono g) (hf : strict_mono f) :\n\tstrict_mono (g \u2218 f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}, strict_mono g \u2192 strict_mono f \u2192 strict_mono (g \u2218 f)", "decl_nm": "strict_mono.comp", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be strict monotone functions. Then $g\\circ f:A\\to C$ is strict monotone."}
{"formal_statement": "theorem directed_Sup_lt_of_lt {\u03b1 : Type*} [complete_lattice \u03b1] {k : \u03b1}\n\t(hk : complete_lattice.is_compact_element k) (hemp : s.nonempty) (hdir : directed_on has_le.le s) :\n\t\u2200 {s : set \u03b1},   (\u2200 (x : \u03b1), x \u2208 s \u2192 x < k) \u2192 has_Sup.Sup s < k", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_2 : complete_lattice \u03b1] {k : \u03b1}, complete_lattice.is_compact_element k \u2192 \u2200 {s : set \u03b1}, s.nonempty \u2192 directed_on has_le.le s \u2192 (\u2200 (x : \u03b1), x \u2208 s \u2192 x < k) \u2192 has_Sup.Sup s < k", "decl_nm": "complete_lattice.is_compact_element.directed_Sup_lt_of_lt", "nl_statement_of_codex": "Let $k$ be a compact element of a complete lattice $L$. Let $s$ be a directed set in $L$. If $s$ is nonempty and $x<k$ for all $x\\in s$, then $\\sup s<k$."}
{"formal_statement": "theorem convex_univ {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_scalar \ud835\udd5c E] :\n\tconvex \ud835\udd5c set.univ", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : has_scalar \ud835\udd5c E], convex \ud835\udd5c set.univ", "decl_nm": "convex_univ", "nl_statement_of_codex": "The set $\\mathbb{R}^n$ is convex."}
{"formal_statement": "theorem add_def {\u03b1 : Type*} (xs ys : list \u03b1) :\n\txs + ys = xs ++ ys", "decl_tp": "\u2200 {\u03b1 : Type u_1} (xs ys : list \u03b1), xs + ys = xs ++ ys", "decl_nm": "free_add_monoid.add_def", "nl_statement_of_codex": "The notation $xs+ys$ is defined to be $xs++ys$."}
{"formal_statement": "theorem exists_of_lift_rel_right {\u03b1 : Type u} {\u03b2 : Type v} {R : \u03b1 \u2192 \u03b2 \u2192 Prop}\n\t{s : wseq \u03b1} {t : wseq \u03b2} (H : wseq.lift_rel R s t) (h : b \u2208 t) :\n\t\u2200 {b : \u03b2},  (\u2203 {a : \u03b1}, a \u2208 s \u2227 R a b)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s : wseq \u03b1} {t : wseq \u03b2}, wseq.lift_rel R s t \u2192 \u2200 {b : \u03b2}, b \u2208 t \u2192 (\u2203 {a : \u03b1}, a \u2208 s \u2227 R a b)", "decl_nm": "wseq.exists_of_lift_rel_right", "nl_statement_of_codex": "Let $s$ and $t$ be well-ordered sequences of types $\u03b1$ and $\u03b2$, respectively. Suppose that $s$ and $t$ are related by $R$. Then for each $b\\in t$ there is an $a\\in s$ such that $R(a,b)$."}
{"formal_statement": "theorem map_comap_le {\u03b1 : Type u} {\u03b2 : Type v} {g : filter \u03b2} {m : \u03b1 \u2192 \u03b2} :\n\tfilter.map m (filter.comap m g) \u2264 g", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {g : filter \u03b2} {m : \u03b1 \u2192 \u03b2}, filter.map m (filter.comap m g) \u2264 g", "decl_nm": "filter.map_comap_le", "nl_statement_of_codex": "Let $m:A\\to B$ be a function. Then the filter of preimages of open sets in $B$ is finer than the filter of open sets in $A$."}
{"formal_statement": "theorem mul_add {m n o : Type*} {\u03b1 : Type v} [non_unital_non_assoc_semiring \u03b1]\n\t[fintype n] (L : matrix m n \u03b1) (M N : matrix n o \u03b1) :\n\tL.mul (M + N) = L.mul M + L.mul N", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} {o : Type u_4} {\u03b1 : Type v} [_inst_1 : non_unital_non_assoc_semiring \u03b1] [_inst_2 : fintype n] (L : matrix m n \u03b1) (M N : matrix n o \u03b1), L.mul (M + N) = L.mul M + L.mul N", "decl_nm": "matrix.mul_add", "nl_statement_of_codex": "Let $L$ be an $m\\times n$ matrix over a non-unital non-associative semiring $R$. Then $L(M+N)=LM+LN$."}
{"formal_statement": "theorem smul_eq_mul {\u03b9 : Type*} {A : \u03b9 \u2192 Type*} [add_monoid \u03b9] [graded_monoid.ghas_mul A]\n\t(a b : A 0) :\n\ta \u2022 b = a * b", "decl_tp": "\u2200 {\u03b9 : Type u_1} {A : \u03b9 \u2192 Type u_2} [_inst_1 : add_monoid \u03b9] [_inst_2 : graded_monoid.ghas_mul A] (a b : A 0), a \u2022 b = a * b", "decl_nm": "graded_monoid.grade_zero.smul_eq_mul", "nl_statement_of_codex": "Let $A$ be a graded monoid. Then the multiplication on $A_0$ is the same as the multiplication on $A$."}
{"formal_statement": "theorem prod_empty {\u03b2 : Type u} {\u03b1 : Type v} [comm_monoid \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\t\u2205.prod (\u03bb (x : \u03b1), f x) = 1", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : comm_monoid \u03b2] {f : \u03b1 \u2192 \u03b2}, \u2205.prod (\u03bb (x : \u03b1), f x) = 1", "decl_nm": "finset.prod_empty", "nl_statement_of_codex": "The product of the empty family of elements of a commutative monoid is the identity element."}
{"formal_statement": "theorem insert_nil {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) :\n\thas_insert.insert a list.nil = [a]", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1), has_insert.insert a list.nil = [a]", "decl_nm": "list.insert_nil", "nl_statement_of_codex": "The list obtained by inserting an element $a$ into the empty list is the list containing only $a$."}
{"formal_statement": "theorem integral_undef {\u03b1 E : Type*} [normed_group E] [topological_space.second_countable_topology E]\n\t[normed_space \u211d E] [complete_space E] [measurable_space E] [borel_space E]\n\t{f : \u03b1 \u2192 E} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (h : \u00acmeasure_theory.integrable f \u03bc) :\n\t\u222b (a : \u03b1), f a \u2202\u03bc = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} [_inst_1 : normed_group E] [_inst_2 : topological_space.second_countable_topology E] [_inst_3 : normed_space \u211d E] [_inst_4 : complete_space E] [_inst_5 : measurable_space E] [_inst_6 : borel_space E] {f : \u03b1 \u2192 E} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}, \u00acmeasure_theory.integrable f \u03bc \u2192 \u222b (a : \u03b1), f a \u2202\u03bc = 0", "decl_nm": "measure_theory.integral_undef", "nl_statement_of_codex": "Let $E$ be a complete normed space and let $f:X\\to E$ be a measurable function. If $f$ is not integrable, then $\\int_X f\\,d\\mu=0$."}
{"formal_statement": "theorem specializes_iff_eq {\u03b1 : Type*} [topological_space \u03b1] [t1_space \u03b1]\n\t{x y : \u03b1} :\n\tx \u2933 y \u2194 x = y", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_3 : t1_space \u03b1] {x y : \u03b1}, x \u2933 y \u2194 x = y", "decl_nm": "specializes_iff_eq", "nl_statement_of_codex": "Let $X$ be a topological space. Then $x\\rightsquigarrow y$ if and only if $x=y$."}
{"formal_statement": "theorem pure_sets {\u03b1 : Type u} (a : \u03b1) :\n\t(has_pure.pure a).sets = {s : set \u03b1 | a \u2208 s}", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1), (has_pure.pure a).sets = {s : set \u03b1 | a \u2208 s}", "decl_nm": "filter.pure_sets", "nl_statement_of_codex": "The sets of the pure state $a$ are the sets containing $a$."}
{"formal_statement": "theorem quot_equiv_of_eq_bot_symm_apply {R M : Type*} [ring R] [add_comm_group M]\n\t[module R M] (p : submodule R M) (hp : p = \u22a5) (x : M) :\n\t\u21d1((p.quot_equiv_of_eq_bot hp).symm) x = submodule.quotient.mk x", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] (p : submodule R M) (hp : p = \u22a5) (x : M), \u21d1((p.quot_equiv_of_eq_bot hp).symm) x = submodule.quotient.mk x", "decl_nm": "submodule.quot_equiv_of_eq_bot_symm_apply", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, and $p$ a submodule of $M$. If $p=\\{0\\}$, then the map $M\\to M/p$ given by $x\\mapsto x+p$ is an inverse to the quotient map $M/p\\to M$."}
{"formal_statement": "theorem lt_wf {\u03b1 : Type*} :\n\twell_founded has_lt.lt", "decl_tp": "\u2200 {\u03b1 : Type u_1}, well_founded has_lt.lt", "decl_nm": "finset.lt_wf", "nl_statement_of_codex": "The relation $<$ on a type $\\alpha$ is well-founded."}
{"formal_statement": "theorem sup_adj {V : Type u} {G : simple_graph V} {H\u2081 H\u2082 : G.subgraph}\n\t{v w : V} :\n\t(H\u2081 \u2294 H\u2082).adj v w \u2194 H\u2081.adj v w \u2228 H\u2082.adj v w", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {H\u2081 H\u2082 : G.subgraph} {v w : V}, (H\u2081 \u2294 H\u2082).adj v w \u2194 H\u2081.adj v w \u2228 H\u2082.adj v w", "decl_nm": "simple_graph.subgraph.sup_adj", "nl_statement_of_codex": "Let $G$ be a simple graph and let $H_1, H_2$ be subgraphs of $G$. Then $v$ is adjacent to $w$ in $H_1\\cup H_2$ if and only if $v$ is adjacent to $w$ in $H_1$ or $v$ is adjacent to $w$ in $H_2$."}
{"formal_statement": "theorem tan_inj_of_lt_of_lt_pi_div_two {x y : \u211d} (hx\u2081 : -(real.pi / 2) < x)\n\t(hx\u2082 : x < real.pi / 2) (hy\u2081 : -(real.pi / 2) < y) (hy\u2082 : y < real.pi / 2)\n\t(hxy : real.tan x = real.tan y) :\n\tx = y", "decl_tp": "\u2200 {x y : \u211d}, -(real.pi / 2) < x \u2192 x < real.pi / 2 \u2192 -(real.pi / 2) < y \u2192 y < real.pi / 2 \u2192 real.tan x = real.tan y \u2192 x = y", "decl_nm": "real.tan_inj_of_lt_of_lt_pi_div_two", "nl_statement_of_codex": "If $x, y\\in (-\\pi/2, \\pi/2)$ and $\\tan x=\\tan y$, then $x=y$."}
{"formal_statement": "theorem unit_eq_unit {C : Type u} :\n\tcategory_theory.free_monoidal_category.unit = \ud835\udfd9_ (category_theory.free_monoidal_category C)", "decl_tp": "\u2200 {C : Type u}, category_theory.free_monoidal_category.unit = \ud835\udfd9_ (category_theory.free_monoidal_category C)", "decl_nm": "category_theory.free_monoidal_category.unit_eq_unit", "nl_statement_of_codex": "The unit of the free monoidal category on $C$ is the identity functor."}
{"formal_statement": "theorem cast_pred_zero {n : \u2115} :\n\t0.cast_pred = 0", "decl_tp": "\u2200 {n : \u2115}, 0.cast_pred = 0", "decl_nm": "fin.cast_pred_zero", "nl_statement_of_codex": "The cast of $0$ to the predecessor type is $0$."}
{"formal_statement": "theorem cycle_of_apply_self {\u03b1 : Type*} [decidable_eq \u03b1] [fintype \u03b1] (f : equiv.perm \u03b1)\n\t(x : \u03b1) :\n\t\u21d1(f.cycle_of x) x = \u21d1f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] (f : equiv.perm \u03b1) (x : \u03b1), \u21d1(f.cycle_of x) x = \u21d1f x", "decl_nm": "equiv.perm.cycle_of_apply_self", "nl_statement_of_codex": "Let $f$ be a permutation of a finite set $X$. Then $f$ is equal to the product of the disjoint cycles of $f$."}
{"formal_statement": "theorem norm_of_real {K : Type*} [is_R_or_C K] (z : \u211d) :\n\t\u2225\u2191z\u2225 = \u2225z\u2225", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K] (z : \u211d), \u2225\u2191z\u2225 = \u2225z\u2225", "decl_nm": "is_R_or_C.norm_of_real", "nl_statement_of_codex": "The norm of a real number is equal to its absolute value."}
{"formal_statement": "theorem symm_apply_apply {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w} [comm_semiring R]\n\t[semiring A\u2081] [semiring A\u2082] [algebra R A\u2081] [algebra R A\u2082] (e : A\u2081 \u2243\u2090[R] A\u2082)\n\t(x : A\u2081) :\n\t\u21d1(e.symm) (\u21d1e x) = x", "decl_tp": "\u2200 {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A\u2081] [_inst_3 : semiring A\u2082] [_inst_5 : algebra R A\u2081] [_inst_6 : algebra R A\u2082] (e : A\u2081 \u2243\u2090[R] A\u2082) (x : A\u2081), \u21d1(e.symm) (\u21d1e x) = x", "decl_nm": "alg_equiv.symm_apply_apply", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A_1$ and $A_2$ be semirings, and $e:A_1\\to A_2$ be an $R$-algebra isomorphism. Then $e^{-1}(e(x))=x$ for all $x\\in A_1$."}
{"formal_statement": "theorem section_comp_right_assoc {C : Type u} [category_theory.category C]\n\t{A B : C} (f g : A \u27f6 B) [category_theory.is_reflexive_pair f g] {X' : C}\n\t(f' : B \u27f6 X') :\n\tcategory_theory.common_section f g \u226b g \u226b f' = f'", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {A B : C} (f g : A \u27f6 B) [_inst_3 : category_theory.is_reflexive_pair f g] {X' : C} (f' : B \u27f6 X'), category_theory.common_section f g \u226b g \u226b f' = f'", "decl_nm": "category_theory.section_comp_right_assoc", "nl_statement_of_codex": "Let $C$ be a category. Let $A, B, X'$ be objects of $C$ and let $f, g:A\\to B$ and $f':B\\to X'$ be morphisms.\nSuppose that $f$ and $g$ have a common section. Then $f'\\circ g\\circ s=f'$ where $s$ is the common section."}
{"formal_statement": "theorem symm_symm {\u03b1 \u03b2 : Type*} [has_le \u03b1] [has_le \u03b2] (e : \u03b1 \u2243o \u03b2) :\n\te.symm.symm = e", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_le \u03b1] [_inst_2 : has_le \u03b2] (e : \u03b1 \u2243o \u03b2), e.symm.symm = e", "decl_nm": "order_iso.symm_symm", "nl_statement_of_codex": "The inverse of the inverse of an order isomorphism is the original order isomorphism."}
{"formal_statement": "theorem is_group_hom {\u03b1 : Type u} {\u03b2 : Type v} [add_group \u03b1] [add_group \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : is_add_group_hom f) :\n\tis_group_hom f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : add_group \u03b1] [_inst_2 : add_group \u03b2] {f : \u03b1 \u2192 \u03b2}, is_add_group_hom f \u2192 is_group_hom f", "decl_nm": "multiplicative.is_group_hom", "nl_statement_of_codex": "If $f:G\\to H$ is a group homomorphism, then $f$ is a group homomorphism."}
{"formal_statement": "theorem right_inverse {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n\t(h : function.left_inverse g f) :\n\tfunction.right_inverse f g", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}, function.left_inverse g f \u2192 function.right_inverse f g", "decl_nm": "function.left_inverse.right_inverse", "nl_statement_of_codex": "If $g$ is a left inverse of $f$, then $f$ is a right inverse of $g$."}
{"formal_statement": "theorem of_real_prod_of_nonneg {\u03b1 : Type*} {s : finset \u03b1} {f : \u03b1 \u2192 \u211d} :\n\t(\u2200 (i : \u03b1), i \u2208 s \u2192 0 \u2264 f i) \u2192 ennreal.of_real (s.prod (\u03bb (i : \u03b1), f i)) = s.prod (\u03bb (i : \u03b1), ennreal.of_real (f i))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : finset \u03b1} {f : \u03b1 \u2192 \u211d}, (\u2200 (i : \u03b1), i \u2208 s \u2192 0 \u2264 f i) \u2192 ennreal.of_real (s.prod (\u03bb (i : \u03b1), f i)) = s.prod (\u03bb (i : \u03b1), ennreal.of_real (f i))", "decl_nm": "ennreal.of_real_prod_of_nonneg", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to\\mathbb{R}$. If $f(i)\\geq 0$ for all $i\\in s$, then $\\prod_{i\\in s}f(i)=\\prod_{i\\in s}\\mathrm{of\\_real}(f(i))$."}
{"formal_statement": "theorem inf_edist_empty {\u03b1 : Type u} [pseudo_emetric_space \u03b1] {x : \u03b1} :\n\temetric.inf_edist x \u2205 = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] {x : \u03b1}, emetric.inf_edist x \u2205 = \u22a4", "decl_nm": "emetric.inf_edist_empty", "nl_statement_of_codex": "The infimum of the empty set is the top element."}
{"formal_statement": "theorem rat_add_iff {p x : \u211d} {r : \u211a} :\n\tliouville_with p (\u2191r + x) \u2194 liouville_with p x", "decl_tp": "\u2200 {p x : \u211d} {r : \u211a}, liouville_with p (\u2191r + x) \u2194 liouville_with p x", "decl_nm": "liouville_with.rat_add_iff", "nl_statement_of_codex": "Let $p$ be a prime number and let $x,r\\in\\mathbb{R}$. Then $x$ is a Liouville number with respect to $p$ if and only if $x+r$ is a Liouville number with respect to $p$."}
{"formal_statement": "theorem floor_sub_nat {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t(a : \u03b1) (n : \u2115) :\n\t\u230aa - \u2191n\u230b = \u230aa\u230b - \u2191n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] (a : \u03b1) (n : \u2115), \u230aa - \u2191n\u230b = \u230aa\u230b - \u2191n", "decl_nm": "int.floor_sub_nat", "nl_statement_of_codex": "Let $a$ be a real number and $n$ a natural number. Then $\\lfloor a-n\\rfloor=\\lfloor a\\rfloor-n$."}
{"formal_statement": "theorem map_nat_cast {R S : Type*} [non_assoc_semiring R] [non_assoc_semiring S]\n\t(f : R \u2192+* S) (n : \u2115) :\n\t\u21d1f \u2191n = \u2191n", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (f : R \u2192+* S) (n : \u2115), \u21d1f \u2191n = \u2191n", "decl_nm": "ring_hom.map_nat_cast", "nl_statement_of_codex": "Let $R$ and $S$ be non-associative semirings and let $f:R\\to S$ be a ring homomorphism. Then $f(n)=n$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem app_zsmul {C D : Type*} [category_theory.category C] [category_theory.category D]\n\t[category_theory.preadditive D] {F G : C \u2964 D} (X : C) (\u03b1 : F \u27f6 G) (n : \u2124) :\n\t(n \u2022 \u03b1).app X = n \u2022 \u03b1.app X", "decl_tp": "\u2200 {C : Type u_1} {D : Type u_2} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.category D] [_inst_3 : category_theory.preadditive D] {F G : C \u2964 D} (X : C) (\u03b1 : F \u27f6 G) (n : \u2124), (n \u2022 \u03b1).app X = n \u2022 \u03b1.app X", "decl_nm": "category_theory.nat_trans.app_zsmul", "nl_statement_of_codex": "Let $C$ and $D$ be categories, and let $F, G:C\\to D$ be functors. Let $X$ be an object of $C$ and let $\\alpha:F\\to G$ be a natural transformation. Then $(n\\cdot\\alpha)_X=n\\cdot\\alpha_X$."}
{"formal_statement": "theorem prod_of_fn {\u03b2 : Type*} [comm_monoid \u03b2] {n : \u2115} (f : fin n \u2192 \u03b2) :\n\t(list.of_fn f).prod = finset.univ.prod (\u03bb (i : fin n), f i)", "decl_tp": "\u2200 {\u03b2 : Type u_2} [_inst_1 : comm_monoid \u03b2] {n : \u2115} (f : fin n \u2192 \u03b2), (list.of_fn f).prod = finset.univ.prod (\u03bb (i : fin n), f i)", "decl_nm": "fin.prod_of_fn", "nl_statement_of_codex": "Let $f: \\{0,\\ldots,n-1\\}\\to \\beta$ be a function. Then $\\prod_{i=0}^{n-1} f(i) = \\prod_{i\\in \\{0,\\ldots,n-1\\}} f(i)$."}
{"formal_statement": "theorem eventually_eq_of_mem_source {E : Type uE} [normed_group E] [normed_space \u211d E]\n\t[finite_dimensional \u211d E] {H : Type uH} [topological_space H] {I : model_with_corners \u211d E H}\n\t{M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]\n\t{c : M} (f : smooth_bump_function I c) {x : M} (hx : x \u2208 (charted_space.chart_at H c).to_local_equiv.source) :\n\t\u21d1f =\u1da0[nhds x] \u21d1(f.to_times_cont_diff_bump) \u2218 \u21d1(ext_chart_at I c)", "decl_tp": "\u2200 {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] [_inst_3 : finite_dimensional \u211d E] {H : Type uH} [_inst_4 : topological_space H] {I : model_with_corners \u211d E H} {M : Type uM} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) {x : M}, x \u2208 (charted_space.chart_at H c).to_local_equiv.source \u2192 \u21d1f =\u1da0[nhds x] \u21d1(f.to_times_cont_diff_bump) \u2218 \u21d1(ext_chart_at I c)", "decl_nm": "smooth_bump_function.eventually_eq_of_mem_source", "nl_statement_of_codex": "Let $E$ be a finite dimensional normed space over $\\mathbb{R}$ and let $M$ be a smooth manifold with corners modelled on $E$. Let $f$ be a smooth bump function on $M$ and let $x$ be a point in the domain of the chart of $M$ at $c$. Then $f$ is eventually equal to the composition of the smooth bump function $f$ with the chart map at $c$."}
{"formal_statement": "theorem star_sub {R : Type u} [add_group R] [star_add_monoid R] (r s : R) :\n\thas_star.star (r - s) = has_star.star r - has_star.star s", "decl_tp": "\u2200 {R : Type u} [_inst_1 : add_group R] [_inst_2 : star_add_monoid R] (r s : R), has_star.star (r - s) = has_star.star r - has_star.star s", "decl_nm": "star_sub", "nl_statement_of_codex": "Let $R$ be a star-additive monoid. Then $*(r-s)=*r-*s$."}
{"formal_statement": "theorem of_real_nat_cast {K : Type*} [is_R_or_C K] (n : \u2115) :\n\t\u2191\u2191n = \u2191n", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K] (n : \u2115), \u2191\u2191n = \u2191n", "decl_nm": "is_R_or_C.of_real_nat_cast", "nl_statement_of_codex": "The map $n\\mapsto \\mathbb{R}(n)$ is the identity map on $\\mathbb{N}$."}
{"formal_statement": "theorem factorial_mul_pow_sub_le_factorial {n m : \u2115} (hnm : n \u2264 m) :\n\tn.factorial * n ^ (m - n) \u2264 m.factorial", "decl_tp": "\u2200 {n m : \u2115}, n \u2264 m \u2192 n.factorial * n ^ (m - n) \u2264 m.factorial", "decl_nm": "nat.factorial_mul_pow_sub_le_factorial", "nl_statement_of_codex": "For all $n,m\\in\\mathbb{N}$ with $n\\leq m$, we have $n!\\cdot n^{m-n}\\leq m!$."}
{"formal_statement": "theorem length_merge_sort {\u03b1 : Type uu} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [decidable_rel r]\n\t(l : list \u03b1) :\n\t(list.merge_sort r l).length = l.length", "decl_tp": "\u2200 {\u03b1 : Type uu} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [_inst_1 : decidable_rel r] (l : list \u03b1), (list.merge_sort r l).length = l.length", "decl_nm": "list.length_merge_sort", "nl_statement_of_codex": "The length of the list obtained by sorting a list $l$ is the same as the length of $l$."}
{"formal_statement": "theorem image2_image_left {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : set \u03b1} {t : set \u03b2} (f : \u03b3 \u2192 \u03b2 \u2192 \u03b4)\n\t(g : \u03b1 \u2192 \u03b3) :\n\tset.image2 f (g '' s) t = set.image2 (\u03bb (a : \u03b1) (b : \u03b2), f (g a) b) s t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} {s : set \u03b1} {t : set \u03b2} (f : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b3), set.image2 f (g '' s) t = set.image2 (\u03bb (a : \u03b1) (b : \u03b2), f (g a) b) s t", "decl_nm": "set.image2_image_left", "nl_statement_of_codex": "Let $f:\\gamma\\times\\beta\\to\\delta$, $g:\\alpha\\to\\gamma$, $s\\subset\\alpha$, and $t\\subset\\beta$. Then\n$f(g(s)\\times t)=f(s\\times t)$."}
{"formal_statement": "theorem min_eq_left_iff {\u03b1 : Type u} [linear_order \u03b1] {a b : \u03b1} :\n\tlinear_order.min a b = a \u2194 a \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b : \u03b1}, linear_order.min a b = a \u2194 a \u2264 b", "decl_nm": "min_eq_left_iff", "nl_statement_of_codex": "Let $a, b$ be elements of a linear order. Then $\\min(a,b)=a$ if and only if $a\\leq b$."}
{"formal_statement": "theorem id_to_linear_map {R E : Type*} [semiring R] [semi_normed_group E]\n\t[module R E] :\n\tlinear_isometry.id.to_linear_map = linear_map.id", "decl_tp": "\u2200 {R : Type u_1} {E : Type u_5} [_inst_1 : semiring R] [_inst_25 : semi_normed_group E] [_inst_29 : module R E], linear_isometry.id.to_linear_map = linear_map.id", "decl_nm": "linear_isometry.id_to_linear_map", "nl_statement_of_codex": "The identity map on a semi-normed group is a linear isometry."}
{"formal_statement": "theorem is_glb_singleton {\u03b1 : Type u} [preorder \u03b1] {a : \u03b1} :\n\tis_glb {a} a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a : \u03b1}, is_glb {a} a", "decl_nm": "is_glb_singleton", "nl_statement_of_codex": "The element $a$ is the greatest lower bound of the singleton set $\\{a\\}$."}
{"formal_statement": "theorem mem_image {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192. \u03b2) (y : \u03b2) (s : set \u03b1) :\n\ty \u2208 f.image s \u2194 \u2203 (x : \u03b1) (H : x \u2208 s), y \u2208 f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192. \u03b2) (y : \u03b2) (s : set \u03b1), y \u2208 f.image s \u2194 \u2203 (x : \u03b1) (H : x \u2208 s), y \u2208 f x", "decl_nm": "pfun.mem_image", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $s\\subset A$. Then $y\\in f(s)$ if and only if there is an $x\\in s$ such that $y\\in f(x)$."}
{"formal_statement": "theorem to_matrix_transpose_apply {\u03b9 \u03b9' R M : Type*} [comm_ring R] [add_comm_group M]\n\t[module R M] (e : basis \u03b9 R M) (v : \u03b9' \u2192 M) (j : \u03b9') :\n\t(e.to_matrix v).transpose j = \u21d1(\u21d1(e.repr) (v j))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b9' : Type u_2} {R : Type u_5} {M : Type u_6} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] (e : basis \u03b9 R M) (v : \u03b9' \u2192 M) (j : \u03b9'), (e.to_matrix v).transpose j = \u21d1(\u21d1(e.repr) (v j))", "decl_nm": "basis.to_matrix_transpose_apply", "nl_statement_of_codex": "Let $M$ be a $R$-module and let $e$ be a basis of $M$. Let $v:\\mathbb{N}\\to M$ be a function. Then the $j$-th column of the matrix $e.to\\_matrix(v)$ is the vector $e.repr(v(j))$."}
{"formal_statement": "theorem map_injective_of_injective {M N : Type*} [add_zero_class M] [add_zero_class N]\n\t{f : M \u2192+ N} (hf : function.injective \u21d1f) :\n\tfunction.injective (add_submonoid.map f)", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] {f : M \u2192+ N}, function.injective \u21d1f \u2192 function.injective (add_submonoid.map f)", "decl_nm": "add_submonoid.map_injective_of_injective", "nl_statement_of_codex": "Let $M$ and $N$ be additive monoids with zero. Let $f:M\\to N$ be a group homomorphism. If $f$ is injective, then $f$ is injective as a map from $M$ to $N$."}
{"formal_statement": "theorem right {\u03b1 : Type*} [preorder \u03b1] {s : \u2115} {l : ordnode \u03b1} {x : \u03b1}\n\t{r : ordnode \u03b1} (H : (ordnode.node s l x r).valid) :\n\tr.valid", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {s : \u2115} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1}, (ordnode.node s l x r).valid \u2192 r.valid", "decl_nm": "ordnode.valid.right", "nl_statement_of_codex": "Let $l$ and $r$ be valid ordered nodes. Then the right child of the ordered node $l\\bullet x\\bullet r$ is valid."}
{"formal_statement": "theorem prod_neg_index {\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} [dec : decidable_eq \u03b9]\n\t[\u03a0 (i : \u03b9), add_group (\u03b2 i)] [\u03a0 (i : \u03b9) (x : \u03b2 i), decidable (x \u2260 0)]\n\t[comm_monoid \u03b3] {g : \u03a0\u2080 (i : \u03b9), \u03b2 i} {h : \u03a0 (i : \u03b9), \u03b2 i \u2192 \u03b3} :\n\t(\u2200 (i : \u03b9), h i 0 = 1) \u2192 (-g).prod h = g.prod (\u03bb (i : \u03b9) (b : \u03b2 i), h i (-b))", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} [dec : decidable_eq \u03b9] [_inst_1 : \u03a0 (i : \u03b9), add_group (\u03b2 i)] [_inst_2 : \u03a0 (i : \u03b9) (x : \u03b2 i), decidable (x \u2260 0)] [_inst_3 : comm_monoid \u03b3] {g : \u03a0\u2080 (i : \u03b9), \u03b2 i} {h : \u03a0 (i : \u03b9), \u03b2 i \u2192 \u03b3}, (\u2200 (i : \u03b9), h i 0 = 1) \u2192 (-g).prod h = g.prod (\u03bb (i : \u03b9) (b : \u03b2 i), h i (-b))", "decl_nm": "dfinsupp.prod_neg_index", "nl_statement_of_codex": "Let $g$ be a finitely supported function from a set $I$ to a set of abelian groups $B_i$. Let $h$ be a function from $I$ to a commutative monoid $M$. Then $h(g) = h(-g)$."}
{"formal_statement": "theorem mono_sublist {\u03b1 : Type*} {l : list \u03b1} {x : \u03b1} {l' : list \u03b1} (hx : list.duplicate x l)\n\t(h : l <+ l') :\n\tlist.duplicate x l'", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : list \u03b1} {x : \u03b1} {l' : list \u03b1}, list.duplicate x l \u2192 l <+ l' \u2192 list.duplicate x l'", "decl_nm": "list.duplicate.mono_sublist", "nl_statement_of_codex": "Let $l$ be a list of elements of $A$ and let $x$ be an element of $A$. If $x$ occurs in $l$ and $l$ is a sublist of $l'$, then $x$ occurs in $l'$."}
{"formal_statement": "theorem upper_semicontinuous_within_at {\u03b1 : Type*} [topological_space \u03b1]\n\t{x : \u03b1} {s : set \u03b1} {\u03b3 : Type*} [linear_order \u03b3] [topological_space \u03b3]\n\t[order_topology \u03b3] {f : \u03b1 \u2192 \u03b3} (h : continuous_within_at f s x) :\n\tupper_semicontinuous_within_at f s x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {x : \u03b1} {s : set \u03b1} {\u03b3 : Type u_3} [_inst_3 : linear_order \u03b3] [_inst_4 : topological_space \u03b3] [_inst_5 : order_topology \u03b3] {f : \u03b1 \u2192 \u03b3}, continuous_within_at f s x \u2192 upper_semicontinuous_within_at f s x", "decl_nm": "continuous_within_at.upper_semicontinuous_within_at", "nl_statement_of_codex": "Let $X$ be a topological space, $Y$ a topological linear order, and $f:X\\to Y$. If $f$ is continuous at $x\\in X$, then $f$ is upper semicontinuous at $x$."}
{"formal_statement": "theorem to_submonoid_injective {R : Type u} [non_assoc_semiring R] :\n\tfunction.injective subsemiring.to_submonoid", "decl_tp": "\u2200 {R : Type u} [_inst_1 : non_assoc_semiring R], function.injective subsemiring.to_submonoid", "decl_nm": "subsemiring.to_submonoid_injective", "nl_statement_of_codex": "The map from a subsemiring of a non-associative semiring to its submonoid is injective."}
{"formal_statement": "theorem ediam_image_le_of_le {X Y : Type*} [pseudo_emetric_space X] [pseudo_emetric_space Y]\n\t{C r : nnreal} {f : X \u2192 Y} {s : set X} (hf : holder_on_with C r f s) (hd : emetric.diam s \u2264 d) :\n\t\u2200 {d : ennreal},  emetric.diam (f '' s) \u2264 \u2191C * d ^ \u2191r", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : pseudo_emetric_space X] [_inst_2 : pseudo_emetric_space Y] {C r : nnreal} {f : X \u2192 Y} {s : set X}, holder_on_with C r f s \u2192 \u2200 {d : ennreal}, emetric.diam s \u2264 d \u2192 emetric.diam (f '' s) \u2264 \u2191C * d ^ \u2191r", "decl_nm": "holder_on_with.ediam_image_le_of_le", "nl_statement_of_codex": "Let $X$ and $Y$ be pseudo-metric spaces, let $C,r\\in\\mathbb{R}^+$, let $f:X\\to Y$, and let $s\\subset X$.\nIf $f$ is $C$-H\u00f6lder continuous on $s$ with exponent $r$, then for all $d\\in\\mathbb{R}^+$, the diameter of $f(s)$ is at most $Cd^r$."}
{"formal_statement": "theorem digits_eq_nil_iff_eq_zero {b n : \u2115} :\n\tb.digits n = list.nil \u2194 n = 0", "decl_tp": "\u2200 {b n : \u2115}, b.digits n = list.nil \u2194 n = 0", "decl_nm": "nat.digits_eq_nil_iff_eq_zero", "nl_statement_of_codex": "The digits of $n$ in base $b$ are empty if and only if $n=0$."}
{"formal_statement": "theorem complete_space {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] [complete_space \u03b2] (e : \u03b1 \u2243\u1d62 \u03b2) :\n\tcomplete_space \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] [_inst_4 : complete_space \u03b2], \u03b1 \u2243\u1d62 \u03b2 \u2192 complete_space \u03b1", "decl_nm": "isometric.complete_space", "nl_statement_of_codex": "If $e:\u03b1\\to \u03b2$ is an isometry between pseudo-metric spaces $\u03b1$ and $\u03b2$, and $\u03b2$ is complete, then $\u03b1$ is complete."}
{"formal_statement": "theorem zero_apply {M N : Type*} [add_zero_class M] [add_zero_class N]\n\t(x : M) :\n\t\u21d10 x = 0", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (x : M), \u21d10 x = 0", "decl_nm": "add_monoid_hom.zero_apply", "nl_statement_of_codex": "Let $M$ and $N$ be additive monoids with zero. Then the zero function $0:M\\to N$ is the zero function."}
{"formal_statement": "theorem mem_image_elim_on {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}\n\t{C : \u03b2 \u2192 Prop} {y : \u03b2} (h_y : y \u2208 f '' s) :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 C (f x)) \u2192 C y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {C : \u03b2 \u2192 Prop} {y : \u03b2}, y \u2208 f '' s \u2192 (\u2200 (x : \u03b1), x \u2208 s \u2192 C (f x)) \u2192 C y", "decl_nm": "set.mem_image_elim_on", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $C$ be a property of elements of $B$. If $y\\in f(A)$ and $C(f(x))$ holds for all $x\\in A$, then $C(y)$ holds."}
{"formal_statement": "theorem ext_on_range {R R\u2082 M M\u2082 : Type*2} {\u03b9 : Type*7} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [module R M]\n\t[module R\u2082 M\u2082] {v : \u03b9 \u2192 M} {f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hv : submodule.span R (set.range v) = \u22a4) :\n\t(\u2200 (i : \u03b9), \u21d1f (v i) = \u21d1g (v i)) \u2192 f = g", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} {\u03b9 : Type u_17} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [_inst_8 : module R M] [_inst_9 : module R\u2082 M\u2082] {v : \u03b9 \u2192 M} {f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}, submodule.span R (set.range v) = \u22a4 \u2192 (\u2200 (i : \u03b9), \u21d1f (v i) = \u21d1g (v i)) \u2192 f = g", "decl_nm": "linear_map.ext_on_range", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $M$ and $M'$ be $R$-modules, and let $\u03c3:R\\to R'$ be a semiring homomorphism.\nLet $v:I\\to M$ be a family of elements of $M$. If the $R$-span of the range of $v$ is the whole of $M$, then two\nlinear maps $f,g:M\\to M'$ are equal if and only if $f(v(i))=g(v(i))$ for all $i\\in I$."}
{"formal_statement": "theorem mem_top {G : Type*} [add_group G] (x : G) :\n\tx \u2208 \u22a4", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] (x : G), x \u2208 \u22a4", "decl_nm": "add_subgroup.mem_top", "nl_statement_of_codex": "Every element of an additive group is in the topology."}
{"formal_statement": "theorem not_mem_support_iff {R : Type u} {\u03c3 : Type*} [comm_semiring R]\n\t{p : mv_polynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115} :\n\tm \u2209 p.support \u2194 mv_polynomial.coeff m p = 0", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] {p : mv_polynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115}, m \u2209 p.support \u2194 mv_polynomial.coeff m p = 0", "decl_nm": "mv_polynomial.not_mem_support_iff", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $p$ be a multivariate polynomial over $R$. Then $m$ is not in the support of $p$ if and only if the coefficient of $m$ in $p$ is zero."}
{"formal_statement": "theorem comp_symm_equiv' {p : \u2115} [fact (nat.prime p)] {R : Type u\u2081} [comm_semiring R]\n\t[char_p R p] {P : Type u\u2083} [comm_semiring P] [char_p P p] [perfect_ring P p]\n\t{\u03c0 : P \u2192+* R} (m : perfection_map p \u03c0) :\n\t\u03c0.comp \u2191(m.equiv.symm) = perfection.coeff R p 0", "decl_tp": "\u2200 {p : \u2115} [_inst_1 : fact (nat.prime p)] {R : Type u\u2081} [_inst_2 : comm_semiring R] [_inst_3 : char_p R p] {P : Type u\u2083} [_inst_4 : comm_semiring P] [_inst_5 : char_p P p] [_inst_6 : perfect_ring P p] {\u03c0 : P \u2192+* R} (m : perfection_map p \u03c0), \u03c0.comp \u2191(m.equiv.symm) = perfection.coeff R p 0", "decl_nm": "perfection_map.comp_symm_equiv'", "nl_statement_of_codex": "Let $p$ be a prime number, let $R$ be a commutative semiring of characteristic $p$, and let $P$ be a perfect ring of characteristic $p$. Let $\\pi:P\\to R$ be a ring homomorphism. Then $\\pi\\circ\\pi^\\sharp=\\pi_0$."}
{"formal_statement": "theorem inv'_symm_apply (G : Type*) [group G] :\n\t\u21d1((mul_equiv.inv' G).symm) = \u21d1((equiv.trans (equiv.inv G) mul_opposite.op_equiv).symm)", "decl_tp": "\u2200 (G : Type u_1) [_inst_1 : group G], \u21d1((mul_equiv.inv' G).symm) = \u21d1((equiv.trans (equiv.inv G) mul_opposite.op_equiv).symm)", "decl_nm": "mul_equiv.inv'_symm_apply", "nl_statement_of_codex": "The inverse of the inverse of a group $G$ is the opposite group of $G$."}
{"formal_statement": "theorem lt_succ_sqrt' (n : \u2115) :\n\tn < (nat.sqrt n).succ ^ 2", "decl_tp": "\u2200 (n : \u2115), n < (nat.sqrt n).succ ^ 2", "decl_nm": "nat.lt_succ_sqrt'", "nl_statement_of_codex": "For any natural number $n$, $n<(\\sqrt{n}+1)^2$."}
{"formal_statement": "theorem coe_map {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (l : list \u03b1) :\n\tmultiset.map f \u2191l = \u2191(list.map f l)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2) (l : list \u03b1), multiset.map f \u2191l = \u2191(list.map f l)", "decl_nm": "multiset.coe_map", "nl_statement_of_codex": "The multiset map of a function $f$ applied to a list $l$ is equal to the list map of $f$ applied to $l$."}
{"formal_statement": "theorem add_tsub_le_left {\u03b1 : Type*} [preorder \u03b1] [add_comm_monoid \u03b1] [has_sub \u03b1]\n\t[has_ordered_sub \u03b1] {a b : \u03b1} :\n\ta + b - a \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : add_comm_monoid \u03b1] [_inst_3 : has_sub \u03b1] [_inst_4 : has_ordered_sub \u03b1] {a b : \u03b1}, a + b - a \u2264 b", "decl_nm": "add_tsub_le_left", "nl_statement_of_codex": "Let $a, b$ be elements of a preordered additive commutative monoid with a subtraction operation. Then $a+b-a\\leq b$."}
{"formal_statement": "theorem image_sub_le_mul_sub_of_deriv_le {f : \u211d \u2192 \u211d} (hf : differentiable \u211d f)\n\t(hxy : x \u2264 y) :\n\t\u2200 {C : \u211d}, (\u2200 (x : \u211d), deriv f x \u2264 C) \u2192 \u2200 \u2983x y : \u211d\u2984,  f y - f x \u2264 C * (y - x)", "decl_tp": "\u2200 {f : \u211d \u2192 \u211d}, differentiable \u211d f \u2192 \u2200 {C : \u211d}, (\u2200 (x : \u211d), deriv f x \u2264 C) \u2192 \u2200 \u2983x y : \u211d\u2984, x \u2264 y \u2192 f y - f x \u2264 C * (y - x)", "decl_nm": "image_sub_le_mul_sub_of_deriv_le", "nl_statement_of_codex": "Let $f:\\mathbb{R}\\to\\mathbb{R}$ be differentiable. If $x\\leq y$, then for any constant $C$ such that $f'(x)\\leq C$ for all $x$, we have $f(y)-f(x)\\leq C(y-x)$."}
{"formal_statement": "theorem neg_one_lt_gold_conj :\n\t-1 < golden_conj", "decl_tp": "-1 < golden_conj", "decl_nm": "neg_one_lt_gold_conj", "nl_statement_of_codex": "$-1$ is less than the golden ratio."}
{"formal_statement": "theorem coeff_update_ne {R : Type u} [semiring R] (p : polynomial R) {n : \u2115}\n\t(a : R) {i : \u2115} (h : i \u2260 n) :\n\t(p.update n a).coeff i = p.coeff i", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (p : polynomial R) {n : \u2115} (a : R) {i : \u2115}, i \u2260 n \u2192 (p.update n a).coeff i = p.coeff i", "decl_nm": "polynomial.coeff_update_ne", "nl_statement_of_codex": "Let $p$ be a polynomial over a semiring $R$ and let $n$ be a natural number. Let $a$ be an element of $R$. Then the coefficient of $p$ at $i$ is equal to the coefficient of $p$ at $i$ if $i$ is not equal to $n$."}
{"formal_statement": "theorem sum_apply {R R\u2082 M M\u2082 : Type*2} {\u03b9 : Type*7} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t(t : finset \u03b9) (f : \u03b9 \u2192 (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)) (b : M) :\n\t\u21d1(t.sum (\u03bb (d : \u03b9), f d)) b = t.sum (\u03bb (d : \u03b9), \u21d1(f d) b)", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} {\u03b9 : Type u_17} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_5 : add_comm_monoid M] [_inst_7 : add_comm_monoid M\u2082] [_inst_10 : module R M] [_inst_12 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (t : finset \u03b9) (f : \u03b9 \u2192 (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)) (b : M), \u21d1(t.sum (\u03bb (d : \u03b9), f d)) b = t.sum (\u03bb (d : \u03b9), \u21d1(f d) b)", "decl_nm": "linear_map.sum_apply", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, $M$ and $M'$ be $R$- and $R'$-modules, respectively, and $\\sigma:R\\to R'$ be a ring homomorphism. Let $t$ be a finite set, $f:t\\to M\\to M'$ be a function, and $b\\in M$. Then $\\sum_{d\\in t} f(d)(b)=\\sum_{d\\in t} f(d)(b)$."}
{"formal_statement": "theorem swap_apply_self {\u03b1 : Sort u} [decidable_eq \u03b1] (i j a : \u03b1) :\n\t\u21d1(equiv.swap i j) (\u21d1(equiv.swap i j) a) = a", "decl_tp": "\u2200 {\u03b1 : Sort u} [_inst_1 : decidable_eq \u03b1] (i j a : \u03b1), \u21d1(equiv.swap i j) (\u21d1(equiv.swap i j) a) = a", "decl_nm": "equiv.swap_apply_self", "nl_statement_of_codex": "Let $i, j$ be elements of a set $A$ such that $i\\neq j$. Then the function $f:A\\to A$ defined by $f(i)=j$ and $f(j)=i$ is an involution."}
{"formal_statement": "theorem bicompl {\u03b1 \u03b2 \u03b3 \u03b4 \u03b4' : Type*} [uniform_space \u03b1] [uniform_space \u03b2]\n\t[uniform_space \u03b3] [uniform_space \u03b4] [uniform_space \u03b4'] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n\t{ga : \u03b4 \u2192 \u03b1} {gb : \u03b4' \u2192 \u03b2} (hf : uniform_continuous\u2082 f) (hga : uniform_continuous ga)\n\t(hgb : uniform_continuous gb) :\n\tuniform_continuous\u2082 (function.bicompl f ga gb)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} {\u03b4' : Type u_6} [_inst_1 : uniform_space \u03b1] [_inst_2 : uniform_space \u03b2] [_inst_3 : uniform_space \u03b3] [_inst_4 : uniform_space \u03b4] [_inst_5 : uniform_space \u03b4'] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ga : \u03b4 \u2192 \u03b1} {gb : \u03b4' \u2192 \u03b2}, uniform_continuous\u2082 f \u2192 uniform_continuous ga \u2192 uniform_continuous gb \u2192 uniform_continuous\u2082 (function.bicompl f ga gb)", "decl_nm": "uniform_continuous\u2082.bicompl", "nl_statement_of_codex": "Let $f:X\\times Y\\to Z$ be a uniformly continuous function. Let $g:W\\to X$ and $h:W'\\to Y$ be uniformly continuous functions. Then the function $f\\circ (g,h):W\\times W'\\to Z$ is uniformly continuous."}
{"formal_statement": "theorem tsum_even_add_odd {\u03b1 : Type*} [add_comm_monoid \u03b1] [topological_space \u03b1]\n\t[t2_space \u03b1] [has_continuous_add \u03b1] {f : \u2115 \u2192 \u03b1} (he : summable (\u03bb (k : \u2115), f (2 * k)))\n\t(ho : summable (\u03bb (k : \u2115), f (2 * k + 1))) :\n\t\u2211' (k : \u2115), f (2 * k) + \u2211' (k : \u2115), f (2 * k + 1) = \u2211' (k : \u2115), f k", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : t2_space \u03b1] [_inst_4 : has_continuous_add \u03b1] {f : \u2115 \u2192 \u03b1}, summable (\u03bb (k : \u2115), f (2 * k)) \u2192 summable (\u03bb (k : \u2115), f (2 * k + 1)) \u2192 \u2211' (k : \u2115), f (2 * k) + \u2211' (k : \u2115), f (2 * k + 1) = \u2211' (k : \u2115), f k", "decl_nm": "tsum_even_add_odd", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\alpha$ be a function. If the series $\\sum_{k\\in\\mathbb{N}}f(2k)$ and $\\sum_{k\\in\\mathbb{N}}f(2k+1)$ converge, then the series $\\sum_{k\\in\\mathbb{N}}f(k)$ converges and $\\sum_{k\\in\\mathbb{N}}f(2k)+\\sum_{k\\in\\mathbb{N}}f(2k+1)=\\sum_{k\\in\\mathbb{N}}f(k)$."}
{"formal_statement": "theorem tan_add' {x y : \u211d} :\n\t((\u2200 (k : \u2124), x \u2260 (2 * \u2191k + 1) * real.pi / 2) \u2227 \u2200 (l : \u2124), y \u2260 (2 * \u2191l + 1) * real.pi / 2) \u2192 real.tan (x + y) = (real.tan x + real.tan y) / (1 - real.tan x * real.tan y)", "decl_tp": "\u2200 {x y : \u211d}, ((\u2200 (k : \u2124), x \u2260 (2 * \u2191k + 1) * real.pi / 2) \u2227 \u2200 (l : \u2124), y \u2260 (2 * \u2191l + 1) * real.pi / 2) \u2192 real.tan (x + y) = (real.tan x + real.tan y) / (1 - real.tan x * real.tan y)", "decl_nm": "real.tan_add'", "nl_statement_of_codex": "Let $x, y\\in\\mathbb{R}$. If $x$ and $y$ are not equal to $(2k+1)\\pi/2$ for any integer $k$, then $\\tan(x+y)=(\\tan x+\\tan y)/(1-\\tan x\\tan y)$."}
{"formal_statement": "theorem bdd_above {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} [\u03a0 (i : \u03b1), normed_group (E i)]\n\t{f : \u03a0 (i : \u03b1), E i} (hf : mem_\u2113p f \u22a4) :\n\tbdd_above (set.range (\u03bb (i : \u03b1), \u2225f i\u2225))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : \u03b1 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b1), normed_group (E i)] {f : \u03a0 (i : \u03b1), E i}, mem_\u2113p f \u22a4 \u2192 bdd_above (set.range (\u03bb (i : \u03b1), \u2225f i\u2225))", "decl_nm": "mem_\u2113p.bdd_above", "nl_statement_of_codex": "Let $E$ be a family of normed groups. If $f:E\\to\\mathbb{R}$ is in $\\ell^\\infty(E)$, then the set $\\{\\|f(i)\\|:i\\in E\\}$ is bounded above."}
{"formal_statement": "theorem unique_has_zero {\u03b1 : Type*} [unique \u03b1] [has_zero \u03b1] :\n\tinhabited.default \u03b1 = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : unique \u03b1] [_inst_2 : has_zero \u03b1], inhabited.default \u03b1 = 0", "decl_nm": "unique_has_zero", "nl_statement_of_codex": "If $\u03b1$ is a type with a unique element and a zero element, then the unique element is the zero element."}
{"formal_statement": "theorem is_O {\u03b1 E F : Type*} [has_norm E] [has_norm F] {c : \u211d} {f : \u03b1 \u2192 E}\n\t{g : \u03b1 \u2192 F} {l : filter \u03b1} (h : asymptotics.is_O_with c f g l) :\n\tasymptotics.is_O f g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {c : \u211d} {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : filter \u03b1}, asymptotics.is_O_with c f g l \u2192 asymptotics.is_O f g l", "decl_nm": "asymptotics.is_O_with.is_O", "nl_statement_of_codex": "Let $f,g:\\alpha\\to E,F$ be functions and let $l$ be a filter on $\\alpha$. If $f$ is $O(g)$ with constant $c$, then $f$ is $O(g)$."}
{"formal_statement": "theorem inr__obj (C : Type u\u2081) [category_theory.category C] (D : Type u\u2081)\n\t[category_theory.category D] (X : D) :\n\t(category_theory.sum.inr_ C D).obj X = sum.inr X", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] (D : Type u\u2081) [_inst_2 : category_theory.category D] (X : D), (category_theory.sum.inr_ C D).obj X = sum.inr X", "decl_nm": "category_theory.sum.inr__obj", "nl_statement_of_codex": "The object part of the functor $C\\sqcup D\\to D$ is the inclusion $D\\to C\\sqcup D$."}
{"formal_statement": "theorem nat_add_mk {m : \u2115} (n i : \u2115) (hi : i < m) :\n\t\u21d1(fin.nat_add n) \u27e8i, hi\u27e9 = \u27e8n + i, _\u27e9", "decl_tp": "\u2200 {m : \u2115} (n i : \u2115) (hi : i < m), \u21d1(fin.nat_add n) \u27e8i, hi\u27e9 = \u27e8n + i, _\u27e9", "decl_nm": "fin.nat_add_mk", "nl_statement_of_codex": "Let $m, n, i$ be natural numbers with $i<m$. Then $\\overline{n+i}=\\overline{n}+\\overline{i}$."}
{"formal_statement": "theorem index_eq_card {G : Type*} [group G] (H : subgroup G) [fintype (G \u29f8 H)] :\n\tH.index = fintype.card (G \u29f8 H)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (H : subgroup G) [_inst_2 : fintype (G \u29f8 H)], H.index = fintype.card (G \u29f8 H)", "decl_nm": "subgroup.index_eq_card", "nl_statement_of_codex": "Let $G$ be a group and let $H$ be a subgroup of $G$. Then the index of $H$ in $G$ is equal to the cardinality of the quotient group $G/H$."}
{"formal_statement": "theorem coe_unit_of_invertible {\u03b1 : Type u} [monoid \u03b1] (a : \u03b1) [invertible a] :\n\t\u2191(unit_of_invertible a) = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] (a : \u03b1) [_inst_2 : invertible a], \u2191(unit_of_invertible a) = a", "decl_nm": "coe_unit_of_invertible", "nl_statement_of_codex": "Let $\u03b1$ be a monoid and let $a\\in \u03b1$. If $a$ is invertible, then $a$ is a unit."}
{"formal_statement": "theorem norm_image_sub_le_of_norm_deriv_le_segment {E : Type*} [normed_group E]\n\t[normed_space \u211d E] {f : \u211d \u2192 E} {a b C : \u211d} (hf : differentiable_on \u211d f (set.Icc a b)) :\n\t(\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 \u2225deriv_within f (set.Icc a b) x\u2225 \u2264 C) \u2192 \u2200 (x : \u211d), x \u2208 set.Icc a b \u2192 \u2225f x - f a\u2225 \u2264 C * (x - a)", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : \u211d \u2192 E} {a b C : \u211d}, differentiable_on \u211d f (set.Icc a b) \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 \u2225deriv_within f (set.Icc a b) x\u2225 \u2264 C) \u2192 \u2200 (x : \u211d), x \u2208 set.Icc a b \u2192 \u2225f x - f a\u2225 \u2264 C * (x - a)", "decl_nm": "norm_image_sub_le_of_norm_deriv_le_segment", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ and let $f: \\mathbb{R}\\to E$. Suppose that $f$ is differentiable on the interval $[a,b]$. If the norm of the derivative of $f$ is bounded by $C$ on the interval $(a,b)$, then the norm of $f(x)-f(a)$ is bounded by $C(x-a)$ for all $x\\in [a,b]$."}
{"formal_statement": "theorem weighted_sum_squares_apply {S R\u2081 : Type*} [comm_ring R\u2081] {\u03b9 : Type*}\n\t[fintype \u03b9] [monoid S] [distrib_mul_action S R\u2081] [smul_comm_class S R\u2081 R\u2081]\n\t(w : \u03b9 \u2192 S) (v : \u03b9 \u2192 R\u2081) :\n\t\u21d1(quadratic_form.weighted_sum_squares R\u2081 w) v = finset.univ.sum (\u03bb (i : \u03b9), w i \u2022 (v i * v i))", "decl_tp": "\u2200 {S : Type u_1} {R\u2081 : Type u_4} [_inst_3 : comm_ring R\u2081] {\u03b9 : Type u_6} [_inst_8 : fintype \u03b9] [_inst_9 : monoid S] [_inst_10 : distrib_mul_action S R\u2081] [_inst_11 : smul_comm_class S R\u2081 R\u2081] (w : \u03b9 \u2192 S) (v : \u03b9 \u2192 R\u2081), \u21d1(quadratic_form.weighted_sum_squares R\u2081 w) v = finset.univ.sum (\u03bb (i : \u03b9), w i \u2022 (v i * v i))", "decl_nm": "quadratic_form.weighted_sum_squares_apply", "nl_statement_of_codex": "Let $S$ be a commutative monoid, let $R_1$ be a commutative ring, let $\\iota$ be a finite type, let $w:\\iota\\to S$ and let $v:\\iota\\to R_1$. Then the weighted sum of squares of $v$ is equal to the sum of the products of $w$ and the squares of $v$."}
{"formal_statement": "theorem U_one (R : Type*) [comm_ring R] :\n\tpolynomial.chebyshev.U R 1 = 2 * polynomial.X", "decl_tp": "\u2200 (R : Type u_1) [_inst_1 : comm_ring R], polynomial.chebyshev.U R 1 = 2 * polynomial.X", "decl_nm": "polynomial.chebyshev.U_one", "nl_statement_of_codex": "The Chebyshev polynomial $U_1$ is equal to $2X$."}
{"formal_statement": "theorem smooth {E : Type uE} [normed_group E] [normed_space \u211d E] [finite_dimensional \u211d E]\n\t{H : Type uH} [topological_space H] {I : model_with_corners \u211d E H} {M : Type uM}\n\t[topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]\n\t{c : M} (f : smooth_bump_function I c) [t2_space M] [smooth_manifold_with_corners I M] :\n\tsmooth I (model_with_corners_self \u211d \u211d) \u21d1f", "decl_tp": "\u2200 {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] [_inst_3 : finite_dimensional \u211d E] {H : Type uH} [_inst_4 : topological_space H] {I : model_with_corners \u211d E H} {M : Type uM} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {c : M} (f : smooth_bump_function I c) [_inst_8 : t2_space M] [_inst_9 : smooth_manifold_with_corners I M], smooth I (model_with_corners_self \u211d \u211d) \u21d1f", "decl_nm": "smooth_bump_function.smooth", "nl_statement_of_codex": "Let $M$ be a smooth manifold with corners. Let $f:M\\to\\mathbb{R}$ be a smooth bump function. Then $f$ is smooth."}
{"formal_statement": "theorem map_div {K : Type u} {K' : Type*} [division_ring K] [division_ring K']\n\t(g : K \u2192+* K') (x y : K) :\n\t\u21d1g (x / y) = \u21d1g x / \u21d1g y", "decl_tp": "\u2200 {K : Type u} {K' : Type u_2} [_inst_1 : division_ring K] [_inst_4 : division_ring K'] (g : K \u2192+* K') (x y : K), \u21d1g (x / y) = \u21d1g x / \u21d1g y", "decl_nm": "ring_hom.map_div", "nl_statement_of_codex": "Let $K$ and $K'$ be division rings and let $g:K\\to K'$ be a ring homomorphism. Then $g(x/y)=g(x)/g(y)$."}
{"formal_statement": "theorem coe_int_mem {K : Type u} [field K] (s : subfield K) (n : \u2124) :\n\t\u2191n \u2208 s", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K) (n : \u2124), \u2191n \u2208 s", "decl_nm": "subfield.coe_int_mem", "nl_statement_of_codex": "If $s$ is a subfield of $K$, then $n\\in\\mathbb{Z}$ is in $s$."}
{"formal_statement": "theorem vsub_singleton {G P : Type*} [add_group G] [T : add_torsor G P]\n\t(s : set P) (p : P) :\n\ts -\u1d65 {p} = (\u03bb (_x : P), _x -\u1d65 p) '' s", "decl_tp": "\u2200 {G : Type u_1} {P : Type u_2} [_inst_1 : add_group G] [T : add_torsor G P] (s : set P) (p : P), s -\u1d65 {p} = (\u03bb (_x : P), _x -\u1d65 p) '' s", "decl_nm": "set.vsub_singleton", "nl_statement_of_codex": "Let $G$ be an abelian group, $P$ a $G$-torsor, and $s$ a subset of $P$. Then $s-\\{p\\}$ is the image of $s$ under the map $x\\mapsto x-p$."}
{"formal_statement": "theorem comp {\u03b9 : Sort u_1} {\u03b9' : Sort u_2} {\u03b1 : Type*} [complete_lattice \u03b1]\n\t{s : \u03b9 \u2192 \u03b1} (hs : complete_lattice.independent s) (hf : function.injective f)\n\t(i : \u03b9') :\n\t\u2200 (f :  \u03b9),  complete_lattice.independent (s \u2218 f)", "decl_tp": "\u2200 {\u03b9 : Sort u_1} {\u03b9' : Sort u_2} {\u03b1 : Type u_3} [_inst_2 : complete_lattice \u03b1] {s : \u03b9 \u2192 \u03b1}, complete_lattice.independent s \u2192 \u2200 (f : \u03b9' \u2192 \u03b9), function.injective f \u2192 complete_lattice.independent (s \u2218 f)", "decl_nm": "complete_lattice.independent.comp", "nl_statement_of_codex": "Let $s$ be a family of subsets of a complete lattice $L$. If $s$ is independent, then the family $s\\circ f$ is independent for any injective function $f$."}
{"formal_statement": "theorem not_mem_iff_inf_principal_compl {\u03b1 : Type*} {f : filter \u03b1} {s : set \u03b1} :\n\ts \u2209 f \u2194 (f \u2293 filter.principal s\u1d9c).ne_bot", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : filter \u03b1} {s : set \u03b1}, s \u2209 f \u2194 (f \u2293 filter.principal s\u1d9c).ne_bot", "decl_nm": "filter.not_mem_iff_inf_principal_compl", "nl_statement_of_codex": "Let $f$ be a filter on a set $X$ and let $s\\subset X$. Then $s\\notin f$ if and only if $f\\cap s^c\\neq\\emptyset$."}
{"formal_statement": "theorem add_subgroup_topological_closure {G : Type w} [topological_space G]\n\t[add_group G] [topological_add_group G] (s : add_subgroup G) :\n\ts \u2264 s.topological_closure", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : add_group G] [_inst_3 : topological_add_group G] (s : add_subgroup G), s \u2264 s.topological_closure", "decl_nm": "add_subgroup.add_subgroup_topological_closure", "nl_statement_of_codex": "Let $G$ be a topological group. Then the closure of an additive subgroup $S$ of $G$ contains $S$."}
{"formal_statement": "theorem div_left_apply {G : Type*} [group G] (a b : G) :\n\t\u21d1(equiv.div_left a) b = a / b", "decl_tp": "\u2200 {G : Type u_7} [_inst_1 : group G] (a b : G), \u21d1(equiv.div_left a) b = a / b", "decl_nm": "equiv.div_left_apply", "nl_statement_of_codex": "The function $f:G\\to G$ defined by $f(x)=a/x$ is a group homomorphism."}
{"formal_statement": "theorem ne_zero {M\u2080 : Type*} [monoid_with_zero M\u2080] [nontrivial M\u2080] {a : M\u2080}\n\t(ha : is_unit a) :\n\ta \u2260 0", "decl_tp": "\u2200 {M\u2080 : Type u_1} [_inst_1 : monoid_with_zero M\u2080] [_inst_2 : nontrivial M\u2080] {a : M\u2080}, is_unit a \u2192 a \u2260 0", "decl_nm": "is_unit.ne_zero", "nl_statement_of_codex": "Let $M$ be a nontrivial monoid with zero. If $a\\in M$ is a unit, then $a\\neq 0$."}
{"formal_statement": "theorem erase_none_empty {\u03b1 : Type*} :\n\t\u21d1finset.erase_none \u2205 = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1}, \u21d1finset.erase_none \u2205 = \u2205", "decl_nm": "finset.erase_none_empty", "nl_statement_of_codex": "The set of non-`none` elements of the empty set is the empty set."}
{"formal_statement": "theorem mop_comp {C : Type u\u2081} [category_theory.category C] {X Y Z : C}\n\t{f : X \u27f6 Y} {g : Y \u27f6 Z} :\n\t(f \u226b g).mop = f.mop \u226b g.mop", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z}, (f \u226b g).mop = f.mop \u226b g.mop", "decl_nm": "category_theory.mop_comp", "nl_statement_of_codex": "Let $C$ be a category. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$ and $g:Y\\to Z$ be morphisms in $C$. Then the morphism $g\\circ f:X\\to Z$ is the composition of the morphisms $f^\\vee:Y\\to X$ and $g^\\vee:Z\\to Y$."}
{"formal_statement": "theorem frontier_cthickening_subset {\u03b1 : Type*} [pseudo_emetric_space \u03b1]\n\t(E : set \u03b1) {\u03b4 : \u211d} :\n\tfrontier (metric.cthickening \u03b4 E) \u2286 {x : \u03b1 | emetric.inf_edist x E = ennreal.of_real \u03b4}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : pseudo_emetric_space \u03b1] (E : set \u03b1) {\u03b4 : \u211d}, frontier (metric.cthickening \u03b4 E) \u2286 {x : \u03b1 | emetric.inf_edist x E = ennreal.of_real \u03b4}", "decl_nm": "metric.frontier_cthickening_subset", "nl_statement_of_codex": "Let $E$ be a subset of a pseudo-metric space $X$ and let $\\delta>0$. Then the frontier of the $\\delta$-thickening of $E$ is contained in the set of points $x\\in X$ such that the infimum of the distance from $x$ to $E$ is $\\delta$."}
{"formal_statement": "theorem card_fintype (K : Type*) (V : Type u) [division_ring K] [add_comm_group V]\n\t[module K V] [fintype K] [fintype V] :\n\t\u2203 (n : \u2115), fintype.card V = fintype.card K ^ n", "decl_tp": "\u2200 (K : Type u_4) (V : Type u) [_inst_1 : division_ring K] [_inst_2 : add_comm_group V] [_inst_4 : module K V] [_inst_6 : fintype K] [_inst_7 : fintype V], \u2203 (n : \u2115), fintype.card V = fintype.card K ^ n", "decl_nm": "vector_space.card_fintype", "nl_statement_of_codex": "Let $K$ be a division ring and $V$ be a $K$-vector space. Then $V$ is finite dimensional."}
{"formal_statement": "theorem lt_supr_iff {\u03b1 : Type*} {\u03b9 : Sort u_4} [complete_linear_order \u03b1]\n\t{a : \u03b1} {f : \u03b9 \u2192 \u03b1} :\n\ta < supr f \u2194 \u2203 (i : \u03b9), a < f i", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_4} [_inst_1 : complete_linear_order \u03b1] {a : \u03b1} {f : \u03b9 \u2192 \u03b1}, a < supr f \u2194 \u2203 (i : \u03b9), a < f i", "decl_nm": "lt_supr_iff", "nl_statement_of_codex": "Let $f:\\mathbb{I}\\to\\mathbb{A}$ be a function where $\\mathbb{A}$ is a complete linear order. Then $a<\\sup f$ if and only if there is an $i\\in\\mathbb{I}$ such that $a<f(i)$."}
{"formal_statement": "theorem support_C_mul_X_pow_nonzero {R : Type u} [semiring R] {c : R} {n : \u2115}\n\t(h : c \u2260 0) :\n\t(\u21d1polynomial.C c * polynomial.X ^ n).support = {n}", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {c : R} {n : \u2115}, c \u2260 0 \u2192 (\u21d1polynomial.C c * polynomial.X ^ n).support = {n}", "decl_nm": "polynomial.support_C_mul_X_pow_nonzero", "nl_statement_of_codex": "The support of $cX^n$ is $\\{n\\}$."}
{"formal_statement": "theorem diff_inter {\u03b1 : Type u} {s t u : set \u03b1} :\n\ts \\ (t \u2229 u) = s \\ t \u222a s \\ u", "decl_tp": "\u2200 {\u03b1 : Type u} {s t u : set \u03b1}, s \\ (t \u2229 u) = s \\ t \u222a s \\ u", "decl_nm": "set.diff_inter", "nl_statement_of_codex": "$(S\\setminus (T\\cap U))=(S\\setminus T)\\cup (S\\setminus U)$."}
{"formal_statement": "theorem one_div_strict_anti_on {\u03b1 : Type*} [linear_ordered_field \u03b1] :\n\tstrict_anti_on (\u03bb (x : \u03b1), 1 / x) (set.Ioi 0)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1], strict_anti_on (\u03bb (x : \u03b1), 1 / x) (set.Ioi 0)", "decl_nm": "one_div_strict_anti_on", "nl_statement_of_codex": "The function $f(x)=1/x$ is strictly anti-monotone on the set $(0,\\infty)$."}
{"formal_statement": "theorem coprod_obj_obj {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C]\n\t{A : C} (\u1fb0 g : category_theory.over A) :\n\t\u1fb0.coprod_obj.obj g = category_theory.over.mk (category_theory.limits.coprod.desc \u1fb0.hom g.hom)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_binary_coproducts C] {A : C} (\u1fb0 g : category_theory.over A), \u1fb0.coprod_obj.obj g = category_theory.over.mk (category_theory.limits.coprod.desc \u1fb0.hom g.hom)", "decl_nm": "category_theory.over.coprod_obj_obj", "nl_statement_of_codex": "Let $C$ be a category with binary coproducts. Let $A$ be an object of $C$ and let $g$ be a morphism over $A$. Then the coproduct of $A$ and $g$ is the morphism over $A$ whose domain is the coproduct of the domain of $A$ and the domain of $g$ and whose codomain is the coproduct of the codomain of $A$ and the codomain of $g$."}
{"formal_statement": "theorem coe_lp_submodule {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p : ennreal} [\u03a0 (i : \u03b1), normed_group (E i)]\n\t{\ud835\udd5c : Type*} [normed_field \ud835\udd5c] [\u03a0 (i : \u03b1), normed_space \ud835\udd5c (E i)] :\n\t(lp.lp_submodule E p \ud835\udd5c).to_add_subgroup = lp E p", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : \u03b1 \u2192 Type u_2} {p : ennreal} [_inst_1 : \u03a0 (i : \u03b1), normed_group (E i)] {\ud835\udd5c : Type u_3} [_inst_2 : normed_field \ud835\udd5c] [_inst_3 : \u03a0 (i : \u03b1), normed_space \ud835\udd5c (E i)], (lp.lp_submodule E p \ud835\udd5c).to_add_subgroup = lp E p", "decl_nm": "lp.coe_lp_submodule", "nl_statement_of_codex": "The additive subgroup of $l^p$-summable sequences is equal to the $l^p$-space."}
{"formal_statement": "theorem map_dmatrix_apply {m n : Type*} [fintype m] [fintype n] {\u03b1 : m \u2192 n \u2192 Type v}\n\t[\u03a0 (i : m) (j : n), add_monoid (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w} [\u03a0 (i : m)\n\t(j : n), add_monoid (\u03b2 i j)] (f : \u03a0 \u2983i : m\u2984 \u2983j : n\u2984, \u03b1 i j \u2192+ \u03b2 i j) (M : dmatrix m n \u03b1) :\n\t\u21d1(add_monoid_hom.map_dmatrix f) M = M.map (\u03bb (i : m) (j : n), \u21d1f)", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} [_inst_2 : fintype m] [_inst_3 : fintype n] {\u03b1 : m \u2192 n \u2192 Type v} [_inst_5 : \u03a0 (i : m) (j : n), add_monoid (\u03b1 i j)] {\u03b2 : m \u2192 n \u2192 Type w} [_inst_6 : \u03a0 (i : m) (j : n), add_monoid (\u03b2 i j)] (f : \u03a0 \u2983i : m\u2984 \u2983j : n\u2984, \u03b1 i j \u2192+ \u03b2 i j) (M : dmatrix m n \u03b1), \u21d1(add_monoid_hom.map_dmatrix f) M = M.map (\u03bb (i : m) (j : n), \u21d1f)", "decl_nm": "add_monoid_hom.map_dmatrix_apply", "nl_statement_of_codex": "Let $m,n$ be finite types, let $\\alpha_{ij}$ and $\\beta_{ij}$ be additive monoids for all $i\\in m$ and $j\\in n$, and let $f_{ij}:\\alpha_{ij}\\to\\beta_{ij}$ be additive monoid homomorphisms for all $i\\in m$ and $j\\in n$. Then the map $f:\\bigoplus_{i\\in m}\\bigoplus_{j\\in n}\\alpha_{ij}\\to\\bigoplus_{i\\in m}\\bigoplus_{j\\in n}\\beta_{ij}$ defined by $f(x_{ij})=(f_{"}
{"formal_statement": "theorem mem_weight_space {R : Type u} {L : Type v} [comm_ring R] [lie_ring L]\n\t[lie_algebra R L] (M : Type w) [add_comm_group M] [module R M] [lie_ring_module L M]\n\t[lie_module R L M] [lie_algebra.is_nilpotent R L] (\u03c7 : L \u2192 R) (m : M) :\n\tm \u2208 lie_module.weight_space M \u03c7 \u2194 m \u2208 lie_module.pre_weight_space M \u03c7", "decl_tp": "\u2200 {R : Type u} {L : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] (M : Type w) [_inst_5 : add_comm_group M] [_inst_6 : module R M] [_inst_7 : lie_ring_module L M] [_inst_8 : lie_module R L M] [_inst_9 : lie_algebra.is_nilpotent R L] (\u03c7 : L \u2192 R) (m : M), m \u2208 lie_module.weight_space M \u03c7 \u2194 m \u2208 lie_module.pre_weight_space M \u03c7", "decl_nm": "lie_module.mem_weight_space", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a Lie $R$-module. Then $m\\in M$ is in the weight space of $M$ with respect to $\\chi$ if and only if $m$ is in the pre-weight space of $M$ with respect to $\\chi$."}
{"formal_statement": "theorem mem_adjoin_integral_self {R : Type*} [comm_ring R] (S : submonoid R)\n\t{P : Type*} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P)\n\t(hx : is_integral R x) :\n\tx \u2208 fractional_ideal.adjoin_integral S x hx", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (S : submonoid R) {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P] [loc : is_localization S P] (x : P) (hx : is_integral R x), x \u2208 fractional_ideal.adjoin_integral S x hx", "decl_nm": "fractional_ideal.mem_adjoin_integral_self", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ a submonoid of $R$, $P$ a commutative ring, and $x\\in P$. Suppose that $P$ is an $R$-algebra, $S$ is the set of non-zero-divisors of $P$, and $x$ is integral over $R$. Then $x\\in\\langle x\\rangle_S$."}
{"formal_statement": "theorem disjoint_self_iff_empty {\u03b1 : Type*} [decidable_eq \u03b1] (s : finset \u03b1) :\n\tdisjoint s s \u2194 s = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s : finset \u03b1), disjoint s s \u2194 s = \u2205", "decl_nm": "finset.disjoint_self_iff_empty", "nl_statement_of_codex": "A finite set $S$ is disjoint from itself if and only if $S$ is empty."}
{"formal_statement": "theorem subst_into_add {\u03b1 : Type*} [has_add \u03b1] (l r tl tr t : \u03b1) (prl : l = tl)\n\t(prr : r = tr) (prt : tl + tr = t) :\n\tl + r = t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_add \u03b1] (l r tl tr t : \u03b1), l = tl \u2192 r = tr \u2192 tl + tr = t \u2192 l + r = t", "decl_nm": "norm_num.subst_into_add", "nl_statement_of_codex": "Let $l, r, tl, tr, t$ be elements of a type with addition. If $l=tl$, $r=tr$, and $tl+tr=t$, then $l+r=t$."}
{"formal_statement": "theorem self_dvd_abs {\u03b1 : Type u} [ring \u03b1] [linear_order \u03b1] (a : \u03b1) :\n\ta \u2223 |a|", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : ring \u03b1] [_inst_2 : linear_order \u03b1] (a : \u03b1), a \u2223 |a|", "decl_nm": "self_dvd_abs", "nl_statement_of_codex": "Let $a$ be an element of a ring $R$ with a linear order. Then $a$ divides $|a|$."}
{"formal_statement": "theorem insert_nth_comp_succ_above {n : \u2115} {\u03b2 : Type v} (i : fin (n + 1))\n\t(x : \u03b2) (p : fin n \u2192 \u03b2) :\n\ti.insert_nth x p \u2218 \u21d1(i.succ_above) = p", "decl_tp": "\u2200 {n : \u2115} {\u03b2 : Type v} (i : fin (n + 1)) (x : \u03b2) (p : fin n \u2192 \u03b2), i.insert_nth x p \u2218 \u21d1(i.succ_above) = p", "decl_nm": "fin.insert_nth_comp_succ_above", "nl_statement_of_codex": "Let $n$ be a natural number, let $i$ be an element of $[n+1]$, let $x$ be an element of a type $\\beta$, and let $p$ be a function from $[n]$ to $\\beta$. Then the composition of the function $i.insert_nth x p$ with the function $i.succ_above$ is equal to $p$."}
{"formal_statement": "theorem tendsto_nhds_iff {\u03b1 \u03b2 : Type*} [topological_space \u03b1] {m : \u03b2 \u2192 \u03b1}\n\t{f : filter \u03b2} (F : f.realizer) (R : ctop.realizer \u03b1) {a : \u03b1} :\n\tfilter.tendsto m f (nhds a) \u2194 \u2200 (t : R.\u03c3), a \u2208 \u21d1(R.F) t \u2192 (\u2203 (s : F.\u03c3), \u2200 (x : \u03b2), x \u2208 \u21d1(F.F) s \u2192 m x \u2208 \u21d1(R.F) t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] {m : \u03b2 \u2192 \u03b1} {f : filter \u03b2} (F : f.realizer) (R : ctop.realizer \u03b1) {a : \u03b1}, filter.tendsto m f (nhds a) \u2194 \u2200 (t : R.\u03c3), a \u2208 \u21d1(R.F) t \u2192 (\u2203 (s : F.\u03c3), \u2200 (x : \u03b2), x \u2208 \u21d1(F.F) s \u2192 m x \u2208 \u21d1(R.F) t)", "decl_nm": "ctop.realizer.tendsto_nhds_iff", "nl_statement_of_codex": "Let $X$ be a topological space, let $Y$ be a topological space, let $m:Y\\to X$, let $f$ be a filter on $Y$, let $F$ be a realizer of $f$, let $R$ be a realizer of $X$, let $a\\in X$. Then $m$ tends to $a$ along $f$ if and only if for every open set $U$ containing $a$, there is an open set $V$ such that $m(V)\\subset U$."}
{"formal_statement": "theorem uniform_continuous_inf_nndist_pt {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t(s : set \u03b1) :\n\tuniform_continuous (\u03bb (x : \u03b1), metric.inf_nndist x s)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] (s : set \u03b1), uniform_continuous (\u03bb (x : \u03b1), metric.inf_nndist x s)", "decl_nm": "metric.uniform_continuous_inf_nndist_pt", "nl_statement_of_codex": "The function $f:X\\to\\mathbb{R}$ defined by $f(x)=\\inf\\{d(x,y):y\\in s\\}$ is uniformly continuous."}
{"formal_statement": "theorem op_zpow {M : Type u} [div_inv_monoid M] (x : M) (z : \u2124) :\n\tmul_opposite.op (x ^ z) = mul_opposite.op x ^ z", "decl_tp": "\u2200 {M : Type u} [_inst_1 : div_inv_monoid M] (x : M) (z : \u2124), mul_opposite.op (x ^ z) = mul_opposite.op x ^ z", "decl_nm": "mul_opposite.op_zpow", "nl_statement_of_codex": "Let $M$ be a monoid with inverses. Then $(-x)^z = (-x)^z$ for all $x\\in M$ and $z\\in\\mathbb{Z}$."}
{"formal_statement": "theorem sup_eq_iff_inf_eq {\u03b1 : Type u} [lattice \u03b1] {a b : \u03b1} :\n\ta \u2294 b = b \u2194 a \u2293 b = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] {a b : \u03b1}, a \u2294 b = b \u2194 a \u2293 b = a", "decl_nm": "sup_eq_iff_inf_eq", "nl_statement_of_codex": "Let $L$ be a lattice. Then $a\\vee b=b$ if and only if $a\\wedge b=a$."}
{"formal_statement": "theorem mono_left {\u03b1 : Type u} {\u03b2 : Type v} {r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n\t{x y : \u03b1 \u2295 \u03b2} (h : sum.lex r\u2081 s x y) :\n\t(\u2200 (a b : \u03b1), r\u2081 a b \u2192 r\u2082 a b) \u2192  sum.lex r\u2082 s x y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {x y : \u03b1 \u2295 \u03b2}, (\u2200 (a b : \u03b1), r\u2081 a b \u2192 r\u2082 a b) \u2192 sum.lex r\u2081 s x y \u2192 sum.lex r\u2082 s x y", "decl_nm": "sum.lex.mono_left", "nl_statement_of_codex": "Let $r_1, r_2$ be relations on $\\alpha$ and $s$ be a relation on $\\beta$. If $x, y$ are elements of $\\alpha\\oplus\\beta$ and $x\\leq_1 y$, then $x\\leq_2 y$."}
{"formal_statement": "theorem linear_independent_singleton {R M : Type*} [ring R] [nontrivial R]\n\t[add_comm_group M] [module R M] [no_zero_smul_divisors R M] {x : M} (hx : x \u2260 0) :\n\tlinear_independent R (\u03bb (x_1 : \u21a5{x}), \u2191x_1)", "decl_tp": "\u2200 {R : Type u_3} {M : Type u_5} [_inst_1 : ring R] [_inst_2 : nontrivial R] [_inst_3 : add_comm_group M] [_inst_5 : module R M] [_inst_6 : no_zero_smul_divisors R M] {x : M}, x \u2260 0 \u2192 linear_independent R (\u03bb (x_1 : \u21a5{x}), \u2191x_1)", "decl_nm": "linear_independent_singleton", "nl_statement_of_codex": "Let $R$ be a nontrivial ring, $M$ an $R$-module, and $x\\in M$. If $x\\neq 0$, then the singleton set $\\{x\\}$ is linearly independent."}
{"formal_statement": "theorem add_pow_two {R : Type u\u2081} [comm_semiring R] (a b : R) :\n\t(a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2", "decl_tp": "\u2200 {R : Type u\u2081} [_inst_1 : comm_semiring R] (a b : R), (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2", "decl_nm": "add_pow_two", "nl_statement_of_codex": "For all $a,b\\in R$, $(a+b)^2=a^2+2ab+b^2$."}
{"formal_statement": "theorem is_glb_cinfi {\u03b1 : Type*} {\u03b9 : Sort u_3} [conditionally_complete_lattice \u03b1]\n\t[nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (H : bdd_below (set.range f)) :\n\tis_glb (set.range f) (\u2a05 (i : \u03b9), f i)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_3} [_inst_1 : conditionally_complete_lattice \u03b1] [_inst_2 : nonempty \u03b9] {f : \u03b9 \u2192 \u03b1}, bdd_below (set.range f) \u2192 is_glb (set.range f) (\u2a05 (i : \u03b9), f i)", "decl_nm": "is_glb_cinfi", "nl_statement_of_codex": "Let $f:I\\to A$ be a family of elements of a conditionally complete lattice $A$. If $f$ is bounded below, then $\\inf f$ is the greatest lower bound of $f$."}
{"formal_statement": "theorem liftp_preservation_iff_uniform {n : \u2115} {F : typevec n \u2192 Type*}\n\t[mvfunctor F] [q : mvqpf F] :\n\tq.liftp_preservation \u2194 q.is_uniform", "decl_tp": "\u2200 {n : \u2115} {F : typevec n \u2192 Type u_1} [_inst_1 : mvfunctor F] [q : mvqpf F], q.liftp_preservation \u2194 q.is_uniform", "decl_nm": "mvqpf.liftp_preservation_iff_uniform", "nl_statement_of_codex": "Let $F$ be a functor from $\\mathbb{N}$ to the category of types. Then $F$ is a uniform functor if and only if $F$ preserves liftings."}
{"formal_statement": "theorem congr_hom {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t{A B C : V} {f : A \u27f6 B} {g : B \u27f6 C} (w : f \u226b g = 0) {f' : A \u27f6 B} {g' : B \u27f6 C}\n\t(w' : f' \u226b g' = 0) [category_theory.limits.has_kernels V] [category_theory.limits.has_cokernels V]\n\t[category_theory.limits.has_images V] [category_theory.limits.has_image_maps V]\n\t(pf : f = f') (pg : g = g') :\n\t(homology.congr w w' pf pg).hom = homology.map w w' {left := \ud835\udfd9 (category_theory.arrow.mk f).left, right := \ud835\udfd9 (category_theory.arrow.mk f).right, w' := _}\n\t{left := \ud835\udfd9 (category_theory.arrow.mk g).left, right := \ud835\udfd9 (category_theory.arrow.mk g).right, w' := _} _", "decl_tp": "\u2200 {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {A B C : V} {f : A \u27f6 B} {g : B \u27f6 C} (w : f \u226b g = 0) {f' : A \u27f6 B} {g' : B \u27f6 C} (w' : f' \u226b g' = 0) [_inst_3 : category_theory.limits.has_kernels V] [_inst_4 : category_theory.limits.has_cokernels V] [_inst_5 : category_theory.limits.has_images V] [_inst_6 : category_theory.limits.has_image_maps V] (pf : f = f') (pg : g = g'), (homology.congr w w' pf pg).hom = homology.map w w' {left := \ud835\udfd9 (category_theory.arrow.mk f).left, right := \ud835\udfd9 (category_theory.arrow.mk f).right, w' := _} {left := \ud835\udfd9 (category_theory.arrow.mk g).left, right := \ud835\udfd9 (category_theory.arrow.mk g).right, w' := _} _", "decl_nm": "homology.congr_hom", "nl_statement_of_codex": "Let $V$ be a category with zero morphisms. Let $A, B, C$ be objects of $V$ and let $f:A\\to B$ and $g:B\\to C$ be morphisms. Suppose that $f\\circ g=0$. Let $f':A\\to B$ and $g':B\\to C$ be morphisms such that $f'\\circ g'=0$. Suppose that $f=f'$ and $g=g'$. Then the morphism $f\\circ g$ is homotopic to the morphism $f'\\circ g'$."}
{"formal_statement": "theorem tsum_le_tsum_of_inj {\u03b1 \u03b2 \u03b3 : Type*} [ordered_add_comm_monoid \u03b1]\n\t[topological_space \u03b1] [order_closed_topology \u03b1] {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1}\n\t(i : \u03b2 \u2192 \u03b3) (hi : function.injective i) (hf : summable f) (hg : summable g) :\n\t(\u2200 (c : \u03b3), c \u2209 set.range i \u2192 0 \u2264 g c) \u2192 (\u2200 (b : \u03b2), f b \u2264 g (i b)) \u2192   tsum f \u2264 tsum g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : ordered_add_comm_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_closed_topology \u03b1] {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1} (i : \u03b2 \u2192 \u03b3), function.injective i \u2192 (\u2200 (c : \u03b3), c \u2209 set.range i \u2192 0 \u2264 g c) \u2192 (\u2200 (b : \u03b2), f b \u2264 g (i b)) \u2192 summable f \u2192 summable g \u2192 tsum f \u2264 tsum g", "decl_nm": "tsum_le_tsum_of_inj", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{R}$ be summable functions. If $f(n)\\leq g(n)$ for all $n\\in\\mathbb{N}$ and $g(n)\\geq 0$ for all $n\\notin\\mathbb{N}$, then $\\sum_{n=1}^\\infty f(n)\\leq\\sum_{n=1}^\\infty g(n)$."}
{"formal_statement": "theorem dense_of_nonempty_vadd_invariant (M : Type*) {\u03b1 : Type*} [add_monoid M]\n\t[topological_space \u03b1] [add_action M \u03b1] [add_action.is_minimal M \u03b1] {s : set \u03b1}\n\t(hne : s.nonempty) :\n\t(\u2200 (c : M), c +\u1d65 s \u2286 s) \u2192 dense s", "decl_tp": "\u2200 (M : Type u_1) {\u03b1 : Type u_3} [_inst_1 : add_monoid M] [_inst_3 : topological_space \u03b1] [_inst_4 : add_action M \u03b1] [_inst_6 : add_action.is_minimal M \u03b1] {s : set \u03b1}, s.nonempty \u2192 (\u2200 (c : M), c +\u1d65 s \u2286 s) \u2192 dense s", "decl_nm": "dense_of_nonempty_vadd_invariant", "nl_statement_of_codex": "Let $M$ be a topological space and let $s$ be a nonempty subset of $M$. If $s$ is invariant under the action of $M$, then $s$ is dense in $M$."}
{"formal_statement": "theorem integrable_on_add_measure {\u03b1 E : Type*} [measurable_space \u03b1] [normed_group E]\n\t[measurable_space E] {f : \u03b1 \u2192 E} {s : set \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1} :\n\tmeasure_theory.integrable_on f s (\u03bc + \u03bd) \u2194 measure_theory.integrable_on f s \u03bc \u2227 measure_theory.integrable_on f s \u03bd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : normed_group E] [_inst_3 : measurable_space E] {f : \u03b1 \u2192 E} {s : set \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1}, measure_theory.integrable_on f s (\u03bc + \u03bd) \u2194 measure_theory.integrable_on f s \u03bc \u2227 measure_theory.integrable_on f s \u03bd", "decl_nm": "measure_theory.integrable_on_add_measure", "nl_statement_of_codex": "Let $f:X\\to E$ be a measurable function on a measurable space $X$. Let $\\mu$ and $\\nu$ be measures on $X$. Then $f$ is integrable with respect to $\\mu+\\nu$ if and only if $f$ is integrable with respect to $\\mu$ and $\\nu$."}
{"formal_statement": "theorem coe_sub {\u03b1 : Type*} [decidable_eq \u03b1] (s t : list \u03b1) :\n\t\u2191s - \u2191t = \u2191(s.diff t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s t : list \u03b1), \u2191s - \u2191t = \u2191(s.diff t)", "decl_nm": "multiset.coe_sub", "nl_statement_of_codex": "The difference of two lists is the list of elements in the first list that are not in the second list."}
{"formal_statement": "theorem map_dfinsupp_sum {R R\u2082 M M\u2082 : Type*2} {\u03b9 : Type*7} [semiring R]\n\t[semiring R\u2082] [add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082]\n\t{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c4\u2081\u2082 \u03c4\u2082\u2081] [ring_hom_inv_pair \u03c4\u2082\u2081 \u03c4\u2081\u2082]\n\t{\u03b3 : \u03b9 \u2192 Type*0} [decidable_eq \u03b9] [\u03a0 (i : \u03b9), has_zero (\u03b3 i)] [\u03a0 (i : \u03b9)\n\t(x : \u03b3 i), decidable (x \u2260 0)] (f : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (t : \u03a0\u2080 (i : \u03b9), \u03b3 i)\n\t(g : \u03a0 (i : \u03b9), \u03b3 i \u2192 M) :\n\t\u21d1f (t.sum g) = t.sum (\u03bb (i : \u03b9) (d : \u03b3 i), \u21d1f (g i d))", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} {\u03b9 : Type u_17} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_3 : add_comm_monoid M] [_inst_4 : add_comm_monoid M\u2082] [_inst_5 : module R M] [_inst_6 : module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [_inst_7 : ring_hom_inv_pair \u03c4\u2081\u2082 \u03c4\u2082\u2081] [_inst_8 : ring_hom_inv_pair \u03c4\u2082\u2081 \u03c4\u2081\u2082] {\u03b3 : \u03b9 \u2192 Type u_20} [_inst_9 : decidable_eq \u03b9] [_inst_10 : \u03a0 (i : \u03b9), has_zero (\u03b3 i)] [_inst_11 : \u03a0 (i : \u03b9) (x : \u03b3 i), decidable (x \u2260 0)] (f : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (t : \u03a0\u2080 (i : \u03b9), \u03b3 i) (g : \u03a0 (i : \u03b9), \u03b3 i \u2192 M), \u21d1f (t.sum g) = t.sum (\u03bb (i : \u03b9) (d : \u03b3 i), \u21d1f (g i d))", "decl_nm": "linear_equiv.map_dfinsupp_sum", "nl_statement_of_codex": "Let $R, R_2, M, M_2$ be semirings, $\u03c4_{12}:R\\to R_2$ and $\u03c4_{21}:R_2\\to R$ be ring homomorphisms such that $\u03c4_{12}\\circ \u03c4_{21}=id_{R_2}$ and $\u03c4_{21}\\circ \u03c4_{12}=id_R$. Let $f:M\\to M_2$ be a linear map such that $f\\circ \u03c4_{21}=\u03c4_{12}\\circ f$. Let $t$ be a finitely supported function from $\\mathbb{N}$ to $R$ and $g$ be a function from $\\"}
{"formal_statement": "theorem right_coset_mem_right_coset {\u03b1 : Type*} [group \u03b1] (s : subgroup \u03b1)\n\t{a : \u03b1} (ha : a \u2208 s) :\n\tright_coset \u2191s a = \u2191s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : group \u03b1] (s : subgroup \u03b1) {a : \u03b1}, a \u2208 s \u2192 right_coset \u2191s a = \u2191s", "decl_nm": "right_coset_mem_right_coset", "nl_statement_of_codex": "Let $G$ be a group and let $S$ be a subgroup of $G$. Then the right coset $Sa$ is equal to $S$ if $a\\in S$."}
{"formal_statement": "theorem snd_surjective {\u03b1 \u03b2 : Type*} [h : nonempty \u03b1] :\n\tfunction.surjective prod.snd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [h : nonempty \u03b1], function.surjective prod.snd", "decl_nm": "prod.snd_surjective", "nl_statement_of_codex": "The second projection $\\pi_2: \\alpha\\times\\beta\\to\\beta$ is surjective."}
{"formal_statement": "theorem bitraverse_comp {t : Type l_1 \u2192 Type l_1 \u2192 Type l_1} [bitraversable t]\n\t[self : is_lawful_bitraversable t] {F G : Type l_1 \u2192 Type l_1} [_inst_1_1 : applicative F]\n\t[applicative G] [is_lawful_applicative F] [is_lawful_applicative G] {\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' : Type l_1}\n\t(f : \u03b2 \u2192 F \u03b3) (f' : \u03b2' \u2192 F \u03b3') (g : \u03b1 \u2192 G \u03b2) (g' : \u03b1' \u2192 G \u03b2') :\n\tbitraversable.bitraverse (functor.comp.mk \u2218 functor.map f \u2218 g) (functor.comp.mk \u2218 functor.map f' \u2218 g') = functor.comp.mk \u2218 functor.map (bitraversable.bitraverse f f') \u2218 bitraversable.bitraverse g g'", "decl_tp": "\u2200 {t : Type l_1 \u2192 Type l_1 \u2192 Type l_1} [_inst_1 : bitraversable t] [self : is_lawful_bitraversable t] {F G : Type l_1 \u2192 Type l_1} [_inst_1_1 : applicative F] [_inst_2 : applicative G] [_inst_3 : is_lawful_applicative F] [_inst_4 : is_lawful_applicative G] {\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' : Type l_1} (f : \u03b2 \u2192 F \u03b3) (f' : \u03b2' \u2192 F \u03b3') (g : \u03b1 \u2192 G \u03b2) (g' : \u03b1' \u2192 G \u03b2'), bitraversable.bitraverse (functor.comp.mk \u2218 functor.map f \u2218 g) (functor.comp.mk \u2218 functor.map f' \u2218 g') = functor.comp.mk \u2218 functor.map (bitraversable.bitraverse f f') \u2218 bitraversable.bitraverse g g'", "decl_nm": "is_lawful_bitraversable.bitraverse_comp", "nl_statement_of_codex": "Let $t$ be a bitraversable type. Let $F$ and $G$ be applicative functors. Let $f:B\\to F(C)$ and $f':B'\\to F(C')$ be functions. Let $g:A\\to G(B)$ and $g':A'\\to G(B')$ be functions. Then the following equality holds:\n$$\\mathrm{bitraverse}(f\\circ g,f'\\circ g')=\\mathrm{bitraverse}(f,f')\\circ\\mathrm{bitraverse}(g,g')$$"}
{"formal_statement": "theorem is_sheaf_for_top_sieve {C : Type u\u2081} [category_theory.category C]\n\t{X : C} (P : C\u1d52\u1d56 \u2964 Type w) :\n\tcategory_theory.presieve.is_sheaf_for P \u21d1\u22a4", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X : C} (P : C\u1d52\u1d56 \u2964 Type w), category_theory.presieve.is_sheaf_for P \u21d1\u22a4", "decl_nm": "category_theory.presieve.is_sheaf_for_top_sieve", "nl_statement_of_codex": "The presheaf $P$ is a sheaf for the top sieve on $X$."}
{"formal_statement": "theorem nil_kunion {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {l : list (sigma \u03b2)} :\n\tlist.nil.kunion l = l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] {l : list (sigma \u03b2)}, list.nil.kunion l = l", "decl_nm": "list.nil_kunion", "nl_statement_of_codex": "The disjoint union of the empty list and a list $l$ is $l$."}
{"formal_statement": "theorem not_mem_Ici {\u03b1 : Type u} [linear_order \u03b1] {a c : \u03b1} :\n\tc \u2209 set.Ici a \u2194 c < a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a c : \u03b1}, c \u2209 set.Ici a \u2194 c < a", "decl_nm": "set.not_mem_Ici", "nl_statement_of_codex": "Let $a, c$ be elements of a linear order $X$. Then $c\\notin [a,\\infty)$ if and only if $c<a$."}
{"formal_statement": "theorem head_desc {J : Type v} {C : Type u} [category_theory.category C]\n\t{B : C} {objs : J \u2192 C} (arrows : \u03a0 (j : J), B \u27f6 objs j) [category_theory.limits.has_wide_pushout B objs arrows]\n\t{X : C} (f : B \u27f6 X) (fs : \u03a0 (j : J), objs j \u27f6 X) (w : \u2200 (j : J), arrows j \u226b fs j = f) :\n\tcategory_theory.limits.wide_pushout.head arrows \u226b category_theory.limits.wide_pushout.desc f fs w = f", "decl_tp": "\u2200 {J : Type v} {C : Type u} [_inst_1 : category_theory.category C] {B : C} {objs : J \u2192 C} (arrows : \u03a0 (j : J), B \u27f6 objs j) [_inst_2 : category_theory.limits.has_wide_pushout B objs arrows] {X : C} (f : B \u27f6 X) (fs : \u03a0 (j : J), objs j \u27f6 X) (w : \u2200 (j : J), arrows j \u226b fs j = f), category_theory.limits.wide_pushout.head arrows \u226b category_theory.limits.wide_pushout.desc f fs w = f", "decl_nm": "category_theory.limits.wide_pushout.head_desc", "nl_statement_of_codex": "Let $C$ be a category and let $B$ be an object of $C$. Let $J$ be a type and let $objs:J\\to C$ be a function.\nLet $arrows:J\\to C(B,objs(j))$ be a function. Suppose that $C$ has wide pushouts. Let $X$ be an object of $C$ and let $f:B\\to X$ and $fs:J\\to C(objs(j),X)$ be functions.\nLet $w:J\\to C(arrows(j),fs(j))$ be a function. Then the head of the wide pushout of $"}
{"formal_statement": "theorem empty_prod {\u03b1 \u03b2 : Type*} {t : set \u03b2} :\n\t\u2205.prod t = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {t : set \u03b2}, \u2205.prod t = \u2205", "decl_nm": "set.empty_prod", "nl_statement_of_codex": "The product of the empty set with any set is the empty set."}
{"formal_statement": "theorem log {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{n : with_top \u2115} (hf : times_cont_diff \u211d n f) :\n\t(\u2200 (x : E), f x \u2260 0) \u2192 times_cont_diff \u211d n (\u03bb (x : E), real.log (f x))", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {n : with_top \u2115}, times_cont_diff \u211d n f \u2192 (\u2200 (x : E), f x \u2260 0) \u2192 times_cont_diff \u211d n (\u03bb (x : E), real.log (f x))", "decl_nm": "times_cont_diff.log", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ and let $f:E\\to\\mathbb{R}$. If $f$ is $n$ times continuously differentiable, then the function $x\\mapsto \\log(f(x))$ is $n$ times continuously differentiable."}
{"formal_statement": "theorem inverse_associator_map_inr_inr (C : Type u) [category_theory.category C]\n\t(D : Type u) [category_theory.category D] (E : Type u) [category_theory.category E]\n\t{X Y : E} (f : sum.inr (sum.inr X) \u27f6 sum.inr (sum.inr Y)) :\n\t(category_theory.sum.inverse_associator C D E).map f = f", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] (D : Type u) [_inst_2 : category_theory.category D] (E : Type u) [_inst_3 : category_theory.category E] {X Y : E} (f : sum.inr (sum.inr X) \u27f6 sum.inr (sum.inr Y)), (category_theory.sum.inverse_associator C D E).map f = f", "decl_nm": "category_theory.sum.inverse_associator_map_inr_inr", "nl_statement_of_codex": "The inverse associator map on the right-hand side of the coproduct of two categories is the identity."}
{"formal_statement": "theorem closure_eq_of_le {L : first_order.language} {M : Type*} [L.Structure M]\n\t{S : L.substructure M} {s : set M} (h\u2081 : s \u2286 \u2191S) (h\u2082 : S \u2264 \u21d1(first_order.language.substructure.closure L) s) :\n\t\u21d1(first_order.language.substructure.closure L) s = S", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} [_inst_1 : L.Structure M] {S : L.substructure M} {s : set M}, s \u2286 \u2191S \u2192 S \u2264 \u21d1(first_order.language.substructure.closure L) s \u2192 \u21d1(first_order.language.substructure.closure L) s = S", "decl_nm": "first_order.language.substructure.closure_eq_of_le", "nl_statement_of_codex": "Let $L$ be a first-order language, $M$ a $L$-structure, and $S$ a substructure of $M$. Let $s$ be a subset of $M$. If $s\\subset S$ and $S$ is the smallest substructure of $M$ containing $s$, then $S$ is the closure of $s$."}
{"formal_statement": "theorem eq_bot {\u03b1 : Type u} [semilattice_inf \u03b1] [order_bot \u03b1] {a b : \u03b1}\n\t(h : disjoint a b) :\n\ta \u2293 b = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {a b : \u03b1}, disjoint a b \u2192 a \u2293 b = \u22a5", "decl_nm": "disjoint.eq_bot", "nl_statement_of_codex": "Let $A$ be a semilattice with bottom and let $a,b\\in A$. If $a$ and $b$ are disjoint, then $a\\wedge b=\\bot$."}
{"formal_statement": "theorem comp_id {M N : Type*} [add_zero_class M] [add_zero_class N] (f : M \u2192+ N) :\n\tf.comp (add_monoid_hom.id M) = f", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (f : M \u2192+ N), f.comp (add_monoid_hom.id M) = f", "decl_nm": "add_monoid_hom.comp_id", "nl_statement_of_codex": "Let $M$ and $N$ be additive monoids. Let $f:M\\to N$ be an additive monoid homomorphism. Then $f\\circ\\mathrm{id}_M=f$."}
{"formal_statement": "theorem image_to_kernel_as_boundaries_to_cycles {\u03b9 : Type*} {V : Type u}\n\t[category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t{c : complex_shape \u03b9} [category_theory.limits.has_zero_object V] [category_theory.limits.has_kernels V]\n\t[category_theory.limits.has_images V] (C : homological_complex V c) (i : \u03b9)\n\t(h : C.boundaries i \u2264 C.cycles i) :\n\t(C.boundaries i).of_le (C.cycles i) h = C.boundaries_to_cycles i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} [_inst_3 : category_theory.limits.has_zero_object V] [_inst_4 : category_theory.limits.has_kernels V] [_inst_5 : category_theory.limits.has_images V] (C : homological_complex V c) (i : \u03b9) (h : C.boundaries i \u2264 C.cycles i), (C.boundaries i).of_le (C.cycles i) h = C.boundaries_to_cycles i", "decl_nm": "homological_complex.image_to_kernel_as_boundaries_to_cycles", "nl_statement_of_codex": "Let $C$ be a homological complex. Then the image of the map $C_i\\to C_{i-1}$ is equal to the kernel of the map $C_{i-1}\\to C_i$."}
{"formal_statement": "theorem maps_to_union {\u03b1 : Type u} {\u03b2 : Type v} {s\u2081 s\u2082 : set \u03b1} {t : set \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} :\n\tset.maps_to f (s\u2081 \u222a s\u2082) t \u2194 set.maps_to f s\u2081 t \u2227 set.maps_to f s\u2082 t", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s\u2081 s\u2082 : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2}, set.maps_to f (s\u2081 \u222a s\u2082) t \u2194 set.maps_to f s\u2081 t \u2227 set.maps_to f s\u2082 t", "decl_nm": "set.maps_to_union", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then $f$ maps $A_1\\cup A_2$ to $B$ if and only if $f$ maps $A_1$ to $B$ and $f$ maps $A_2$ to $B$."}
{"formal_statement": "theorem le_abs {\u03b1 : Type u} [lattice \u03b1] [add_comm_group \u03b1] (a : \u03b1) :\n\ta \u2264 |a|", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : add_comm_group \u03b1] (a : \u03b1), a \u2264 |a|", "decl_nm": "lattice_ordered_comm_group.le_abs", "nl_statement_of_codex": "Let $L$ be a lattice with a norm. Then $a\\leq |a|$ for all $a\\in L$."}
{"formal_statement": "theorem antivary_on_const_right {\u03b9 \u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2]\n\t(f : \u03b9 \u2192 \u03b1) (b : \u03b2) (s : set \u03b9) :\n\tantivary_on f (function.const \u03b9 b) s", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] (f : \u03b9 \u2192 \u03b1) (b : \u03b2) (s : set \u03b9), antivary_on f (function.const \u03b9 b) s", "decl_nm": "antivary_on_const_right", "nl_statement_of_codex": "Let $f:\\iota\\to\\alpha$ and $b:\\beta$. Then $f$ is anti-varying on $b$."}
{"formal_statement": "theorem of_dist_le' {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1] [pseudo_metric_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {K : \u211d} :\n\t(\u2200 (x y : \u03b1), has_dist.dist (f x) (f y) \u2264 K * has_dist.dist x y) \u2192 lipschitz_with K.to_nnreal f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] {f : \u03b1 \u2192 \u03b2} {K : \u211d}, (\u2200 (x y : \u03b1), has_dist.dist (f x) (f y) \u2264 K * has_dist.dist x y) \u2192 lipschitz_with K.to_nnreal f", "decl_nm": "lipschitz_with.of_dist_le'", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between pseudo-metric spaces. If $f$ is $K$-Lipschitz, then $f$ is Lipschitz with constant $K$."}
{"formal_statement": "theorem injective_of_quotient_stabilizer (\u03b1 : Type u) {\u03b2 : Type v} [add_group \u03b1]\n\t[add_action \u03b1 \u03b2] (x : \u03b2) :\n\tfunction.injective (add_action.of_quotient_stabilizer \u03b1 x)", "decl_tp": "\u2200 (\u03b1 : Type u) {\u03b2 : Type v} [_inst_1 : add_group \u03b1] [_inst_2 : add_action \u03b1 \u03b2] (x : \u03b2), function.injective (add_action.of_quotient_stabilizer \u03b1 x)", "decl_nm": "add_action.injective_of_quotient_stabilizer", "nl_statement_of_codex": "Let $G$ be an additive group acting on a set $X$. Then the map $G/G_x\\to X$ given by $gG_x\\mapsto gx$ is injective."}
{"formal_statement": "theorem le_induced_generate_from {\u03b1 \u03b2 : Type*} [t : topological_space \u03b1]\n\t{b : set (set \u03b2)} {f : \u03b1 \u2192 \u03b2} :\n\t(\u2200 (a : set \u03b2), a \u2208 b \u2192 is_open (f \u207b\u00b9' a)) \u2192 t \u2264 topological_space.induced f (topological_space.generate_from b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [t : topological_space \u03b1] {b : set (set \u03b2)} {f : \u03b1 \u2192 \u03b2}, (\u2200 (a : set \u03b2), a \u2208 b \u2192 is_open (f \u207b\u00b9' a)) \u2192 t \u2264 topological_space.induced f (topological_space.generate_from b)", "decl_nm": "le_induced_generate_from", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f^{-1}(U)$ is open in $X$ for every open set $U$ in $Y$, then $f$ is continuous."}
{"formal_statement": "theorem min_le_iff {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} :\n\tlinear_order.min a b \u2264 c \u2194 a \u2264 c \u2228 b \u2264 c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, linear_order.min a b \u2264 c \u2194 a \u2264 c \u2228 b \u2264 c", "decl_nm": "min_le_iff", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order. Then $min(a,b)\\leq c$ if and only if $a\\leq c$ or $b\\leq c$."}
{"formal_statement": "theorem has_strict_deriv_at_symm {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t(f : local_homeomorph \ud835\udd5c \ud835\udd5c) {a f' : \ud835\udd5c} (ha : a \u2208 f.to_local_equiv.target)\n\t(hf' : f' \u2260 0) (htff' : has_strict_deriv_at \u21d1f f' (\u21d1(f.symm) a)) :\n\thas_strict_deriv_at \u21d1(f.symm) f'\u207b\u00b9 a", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] (f : local_homeomorph \ud835\udd5c \ud835\udd5c) {a f' : \ud835\udd5c}, a \u2208 f.to_local_equiv.target \u2192 f' \u2260 0 \u2192 has_strict_deriv_at \u21d1f f' (\u21d1(f.symm) a) \u2192 has_strict_deriv_at \u21d1(f.symm) f'\u207b\u00b9 a", "decl_nm": "local_homeomorph.has_strict_deriv_at_symm", "nl_statement_of_codex": "Let $f:U\\to V$ be a local homeomorphism between open subsets of $\\mathbb{R}^n$. Let $a\\in U$ and $f'(a)\\neq 0$. If $f$ has a strict derivative at $a$, then $f^{-1}$ has a strict derivative at $f(a)$."}
{"formal_statement": "theorem Monad_to_Mon_map_hom (C : Type u) [category_theory.category C]\n\t(_x _x_1 : category_theory.monad C) (f : _x \u27f6 _x_1) :\n\t((category_theory.Monad.Monad_to_Mon C).map f).hom = f.to_nat_trans", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] (_x _x_1 : category_theory.monad C) (f : _x \u27f6 _x_1), ((category_theory.Monad.Monad_to_Mon C).map f).hom = f.to_nat_trans", "decl_nm": "category_theory.Monad.Monad_to_Mon_map_hom", "nl_statement_of_codex": "Let $C$ be a category and let $T,T'$ be monads on $C$. Let $f:T\\to T'$ be a morphism of monads. Then the induced morphism of monoids $f_*:T_*\\to T'_*$ is given by $f_*(x)=f(x)$."}
{"formal_statement": "theorem lt_iterate_pos_iff (f : circle_deg1_lift) {x : \u211d} {m : \u2124} {n : \u2115}\n\t(hn : 0 < n) :\n\t(x + \u2191n * \u2191m < \u21d1f^[n] x \u2194 x + \u2191m < \u21d1f x)", "decl_tp": "\u2200 (f : circle_deg1_lift) {x : \u211d} {m : \u2124} {n : \u2115}, 0 < n \u2192 (x + \u2191n * \u2191m < \u21d1f^[n] x \u2194 x + \u2191m < \u21d1f x)", "decl_nm": "circle_deg1_lift.lt_iterate_pos_iff", "nl_statement_of_codex": "Let $f$ be a circle degree 1 lift. Then for all $x\\in\\mathbb{R}$, $m\\in\\mathbb{Z}$, and $n\\in\\mathbb{N}$,\n$x+n\\cdot m<f^n(x)$ if and only if $x+m<f(x)$."}
{"formal_statement": "theorem is_complemented_of_is_atomistic {\u03b1 : Type*} [complete_lattice \u03b1]\n\t[is_modular_lattice \u03b1] [is_compactly_generated \u03b1] [is_atomistic \u03b1] :\n\tis_complemented \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : complete_lattice \u03b1] [_inst_2 : is_modular_lattice \u03b1] [_inst_3 : is_compactly_generated \u03b1] [_inst_4 : is_atomistic \u03b1], is_complemented \u03b1", "decl_nm": "is_complemented_of_is_atomistic", "nl_statement_of_codex": "If $L$ is a complete modular lattice that is compactly generated and atomistic, then $L$ is complemented."}
{"formal_statement": "theorem symm_image_eq_preimage {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {H : Type*} [topological_space H] {G : Type*} [topological_space G]\n\t{I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type*}\n\t[topological_space M] [charted_space H M] {N : Type*0} [topological_space N]\n\t[charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n) (s : set N) :\n\t\u21d1(h.symm) '' s = \u21d1h \u207b\u00b9' s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space \ud835\udd5c F] {H : Type u_5} [_inst_8 : topological_space H] {G : Type u_7} [_inst_10 : topological_space G] {I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M] {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n) (s : set N), \u21d1(h.symm) '' s = \u21d1h \u207b\u00b9' s", "decl_nm": "diffeomorph.symm_image_eq_preimage", "nl_statement_of_codex": "Let $I$ and $J$ be models with corners, let $M$ and $N$ be manifolds, and let $h:I\\to J$ be a diffeomorphism. Then the image of $h$ is the preimage of the image of the inverse of $h$."}
{"formal_statement": "theorem move_right {x : pgame} (o : x.numeric) :\n\t\u2200 (j : x.right_moves), (x.move_right j).numeric", "decl_tp": "\u2200 {x : pgame}, x.numeric \u2192 \u2200 (j : x.right_moves), (x.move_right j).numeric", "decl_nm": "pgame.numeric.move_right", "nl_statement_of_codex": "If $x$ is a position in the game Nim, then the position $x$ can be moved to the right by $j$ positions if and only if the position $x$ can be moved to the right by $j$ positions."}
{"formal_statement": "theorem to_nnreal_pos {a : ennreal} (ha\u2080 : a \u2260 0) (ha_top : a \u2260 \u22a4) :\n\t0 < a.to_nnreal", "decl_tp": "\u2200 {a : ennreal}, a \u2260 0 \u2192 a \u2260 \u22a4 \u2192 0 < a.to_nnreal", "decl_nm": "ennreal.to_nnreal_pos", "nl_statement_of_codex": "If $a$ is a nonzero element of $\\overline{\\mathbb{R}}_{\\geq 0}$ that is not $\\infty$, then $a$ is a positive real number."}
{"formal_statement": "theorem mono_lie_left {R : Type u} {L : Type v} {M : Type w} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M]\n\t[lie_module R L M] (N : lie_submodule R L M) (I J : lie_ideal R L) (h : I \u2264 J) :\n\t\u2045I,N\u2046 \u2264 \u2045J,N\u2046", "decl_tp": "\u2200 {R : Type u} {L : Type v} {M : Type w} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : module R M] [_inst_6 : lie_ring_module L M] [_inst_7 : lie_module R L M] (N : lie_submodule R L M) (I J : lie_ideal R L), I \u2264 J \u2192 \u2045I,N\u2046 \u2264 \u2045J,N\u2046", "decl_nm": "lie_submodule.mono_lie_left", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ a Lie $R$-module. Let $N$ be a Lie submodule of $M$, and let $I$ and $J$ be Lie ideals of $L$. If $I\\leq J$, then $[I,N]\\leq [J,N]$."}
{"formal_statement": "theorem Liminf_eq_of_le_nhds {\u03b1 : Type u} [conditionally_complete_linear_order \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] {f : filter \u03b1} {a : \u03b1} [f.ne_bot]\n\t(h : f \u2264 nhds a) :\n\tf.Liminf = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] {f : filter \u03b1} {a : \u03b1} [_inst_4 : f.ne_bot], f \u2264 nhds a \u2192 f.Liminf = a", "decl_nm": "Liminf_eq_of_le_nhds", "nl_statement_of_codex": "Let $f$ be a filter on a conditionally complete linear order $X$. If $f$ is a neighborhood filter of $a$, then $\\liminf f=a$."}
{"formal_statement": "theorem times_cont_diff_on_of_subsingleton {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} [subsingleton F] {n : with_top \u2115} :\n\ttimes_cont_diff_on \ud835\udd5c n f s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} [_inst_8 : subsingleton F] {n : with_top \u2115}, times_cont_diff_on \ud835\udd5c n f s", "decl_nm": "times_cont_diff_on_of_subsingleton", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be a function. If $F$ is a singleton, then $f$ is $n$-times continuously differentiable on $E$."}
{"formal_statement": "theorem le_of_pred_le_pred {\u03b1 : Type*} [preorder \u03b1] [pred_order \u03b1] [no_bot_order \u03b1]\n\t{a b : \u03b1} :\n\tpred_order.pred a \u2264 pred_order.pred b \u2192 a \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : pred_order \u03b1] [_inst_3 : no_bot_order \u03b1] {a b : \u03b1}, pred_order.pred a \u2264 pred_order.pred b \u2192 a \u2264 b", "decl_nm": "le_of_pred_le_pred", "nl_statement_of_codex": "Let $a, b$ be elements of a preorder $P$ with a predecessor function. If $pred(a)\\leq pred(b)$, then $a\\leq b$."}
{"formal_statement": "theorem snd_comp_inl {M N : Type*} [mul_one_class M] [mul_one_class N] :\n\t(monoid_hom.snd M N).comp (monoid_hom.inl M N) = 1", "decl_tp": "\u2200 {M : Type u_5} {N : Type u_6} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N], (monoid_hom.snd M N).comp (monoid_hom.inl M N) = 1", "decl_nm": "monoid_hom.snd_comp_inl", "nl_statement_of_codex": "The composition of the second projection and the first injection is the identity."}
{"formal_statement": "theorem arrow_\u03b9 {J : Type v} {C : Type u} [category_theory.category C]\n\t{B : C} {objs : J \u2192 C} (arrows : \u03a0 (j : J), B \u27f6 objs j) [category_theory.limits.has_wide_pushout B objs arrows]\n\t(j : J) :\n\tarrows j \u226b category_theory.limits.wide_pushout.\u03b9 arrows j = category_theory.limits.wide_pushout.head arrows", "decl_tp": "\u2200 {J : Type v} {C : Type u} [_inst_1 : category_theory.category C] {B : C} {objs : J \u2192 C} (arrows : \u03a0 (j : J), B \u27f6 objs j) [_inst_2 : category_theory.limits.has_wide_pushout B objs arrows] (j : J), arrows j \u226b category_theory.limits.wide_pushout.\u03b9 arrows j = category_theory.limits.wide_pushout.head arrows", "decl_nm": "category_theory.limits.wide_pushout.arrow_\u03b9", "nl_statement_of_codex": "Let $C$ be a category and let $B$ be an object of $C$. Let $J$ be a type and let $objs:J\\to C$ be a function. Let $arrows:J\\to C(B,objs(j))$ be a function. Suppose that $C$ has wide pushouts. Then the composition of $arrows(j)$ with the canonical morphism from $objs(j)$ to the wide pushout of $B$ and $objs$ along $arrows$ is equal to the canonical morphism from $B$ to the wide pushout of $B$ and $objs$ along $arrows$."}
{"formal_statement": "theorem Ico_mem_nhds_within_Ioi {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_closed_topology \u03b1] {a b c : \u03b1} (H : b \u2208 set.Ico a c) :\n\tset.Ico a c \u2208 nhds_within b (set.Ioi b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_closed_topology \u03b1] {a b c : \u03b1}, b \u2208 set.Ico a c \u2192 set.Ico a c \u2208 nhds_within b (set.Ioi b)", "decl_nm": "Ico_mem_nhds_within_Ioi", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order $X$ with the order topology. If $b\\in [a,c]$, then $[a,c]$ is a neighborhood of $b$ in $X\\setminus \\{b\\}$."}
{"formal_statement": "theorem mem_comap {G : Type*} [group G] [topological_space G] {N : Type*}\n\t[group N] [topological_space N] {H : open_subgroup N} {f : G \u2192* N} {hf : continuous \u21d1f}\n\t{x : G} :\n\tx \u2208 open_subgroup.comap f hf H \u2194 \u21d1f x \u2208 H", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] [_inst_2 : topological_space G] {N : Type u_2} [_inst_3 : group N] [_inst_4 : topological_space N] {H : open_subgroup N} {f : G \u2192* N} {hf : continuous \u21d1f} {x : G}, x \u2208 open_subgroup.comap f hf H \u2194 \u21d1f x \u2208 H", "decl_nm": "open_subgroup.mem_comap", "nl_statement_of_codex": "Let $G$ and $N$ be topological groups and let $f:G\\to N$ be a continuous homomorphism. Let $H$ be an open subgroup of $N$. Then $x\\in f^{-1}(H)$ if and only if $f(x)\\in H$."}
{"formal_statement": "theorem foldl_rec_on_nil {\u03b1 : Type u} {\u03b2 : Type v} {C : \u03b2 \u2192 Sort u_1} (op : \u03b2 \u2192 \u03b1 \u2192 \u03b2)\n\t(b : \u03b2) (hb : C b) (hl : \u03a0 (b : \u03b2), C b \u2192 \u03a0 (a : \u03b1), a \u2208 list.nil \u2192 C (op b a)) :\n\tlist.nil.foldl_rec_on op b hb hl = hb", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {C : \u03b2 \u2192 Sort u_1} (op : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b : \u03b2) (hb : C b) (hl : \u03a0 (b : \u03b2), C b \u2192 \u03a0 (a : \u03b1), a \u2208 list.nil \u2192 C (op b a)), list.nil.foldl_rec_on op b hb hl = hb", "decl_nm": "list.foldl_rec_on_nil", "nl_statement_of_codex": "The foldl function on the empty list is the identity function."}
{"formal_statement": "theorem lt_mul_of_lt_of_one_le {\u03b1 : Type*} [mul_one_class \u03b1] [preorder \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] {a b c : \u03b1} (hbc : b < c)\n\t(ha : 1 \u2264 a) :\n\tb < c * a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : mul_one_class \u03b1] [_inst_2 : preorder \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] {a b c : \u03b1}, b < c \u2192 1 \u2264 a \u2192 b < c * a", "decl_nm": "lt_mul_of_lt_of_one_le", "nl_statement_of_codex": "Let $a, b, c$ be elements of a preordered monoid with $1$. If $b<c$ and $1\\leq a$, then $b<ca$."}
{"formal_statement": "theorem neg_succ_of_nat_mod (m : \u2115) {b : \u2124} (bpos : 0 < b) :\n\t-[1+ m] % b = b - 1 - \u2191m % b", "decl_tp": "\u2200 (m : \u2115) {b : \u2124}, 0 < b \u2192 -[1+ m] % b = b - 1 - \u2191m % b", "decl_nm": "int.neg_succ_of_nat_mod", "nl_statement_of_codex": "Let $m$ be a natural number and let $b$ be a positive integer. Then $-1-m\\equiv b-1-m\\pmod{b}$."}
{"formal_statement": "theorem differentiable_on_congr {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f f\u2081 : E \u2192 F} {s : set E} :\n\t(\u2200 (x : E), x \u2208 s \u2192 f\u2081 x = f x) \u2192 (differentiable_on \ud835\udd5c f\u2081 s \u2194 differentiable_on \ud835\udd5c f s)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f f\u2081 : E \u2192 F} {s : set E}, (\u2200 (x : E), x \u2208 s \u2192 f\u2081 x = f x) \u2192 (differentiable_on \ud835\udd5c f\u2081 s \u2194 differentiable_on \ud835\udd5c f s)", "decl_nm": "differentiable_on_congr", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f, f_1:E\\to F$ be functions and let $s\\subset E$. Then $f$ is differentiable on $s$ if and only if $f_1$ is differentiable on $s$."}
{"formal_statement": "theorem add_one_le_succ (c : cardinal) :\n\tc + 1 \u2264 c.succ", "decl_tp": "\u2200 (c : cardinal), c + 1 \u2264 c.succ", "decl_nm": "cardinal.add_one_le_succ", "nl_statement_of_codex": "For any cardinal $c$, $c+1\\leq c^+$."}
{"formal_statement": "theorem nodup_iff_forall_not_duplicate {\u03b1 : Type*} {l : list \u03b1} :\n\tl.nodup \u2194 \u2200 (x : \u03b1), \u00aclist.duplicate x l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : list \u03b1}, l.nodup \u2194 \u2200 (x : \u03b1), \u00aclist.duplicate x l", "decl_nm": "list.nodup_iff_forall_not_duplicate", "nl_statement_of_codex": "A list $l$ has no duplicates if and only if for all $x\\in l$, $x$ is not a duplicate in $l$."}
{"formal_statement": "theorem mul_left\u2080_apply {\u03b1 : Type*} [linear_ordered_field \u03b1] (a : \u03b1) (ha : 0 < a)\n\t(\u1fb0 : \u03b1) :\n\t\u21d1(order_iso.mul_left\u2080 a ha) \u1fb0 = a * \u1fb0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] (a : \u03b1) (ha : 0 < a) (\u1fb0 : \u03b1), \u21d1(order_iso.mul_left\u2080 a ha) \u1fb0 = a * \u1fb0", "decl_nm": "order_iso.mul_left\u2080_apply", "nl_statement_of_codex": "The map $x\\mapsto ax$ is an order isomorphism from $(0,\\infty)$ to $(a,\\infty)$."}
{"formal_statement": "theorem prod_symm {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] [topological_space \u03b4] (e : local_homeomorph \u03b1 \u03b2)\n\t(e' : local_homeomorph \u03b3 \u03b4) :\n\t(e.prod e').symm = e.symm.prod e'.symm", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] [_inst_4 : topological_space \u03b4] (e : local_homeomorph \u03b1 \u03b2) (e' : local_homeomorph \u03b3 \u03b4), (e.prod e').symm = e.symm.prod e'.symm", "decl_nm": "local_homeomorph.prod_symm", "nl_statement_of_codex": "The inverse of the product of two local homeomorphisms is the product of the inverses."}
{"formal_statement": "theorem bounded_iff_exists_norm_le {E : Type*} [semi_normed_group E] {s : set E} :\n\tmetric.bounded s \u2194 \u2203 (R : \u211d), \u2200 (x : E), x \u2208 s \u2192 \u2225x\u2225 \u2264 R", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : semi_normed_group E] {s : set E}, metric.bounded s \u2194 \u2203 (R : \u211d), \u2200 (x : E), x \u2208 s \u2192 \u2225x\u2225 \u2264 R", "decl_nm": "bounded_iff_exists_norm_le", "nl_statement_of_codex": "A set $S$ of a semi-normed group $E$ is bounded if and only if there is a real number $R$ such that $\\|x\\|\\leq R$ for all $x\\in S$."}
{"formal_statement": "theorem odd_sub' {m n : \u2115} (h : n \u2264 m) :\n\t(odd (m - n) \u2194 (odd n \u2194 even m))", "decl_tp": "\u2200 {m n : \u2115}, n \u2264 m \u2192 (odd (m - n) \u2194 (odd n \u2194 even m))", "decl_nm": "nat.odd_sub'", "nl_statement_of_codex": "If $n\\leq m$, then $m-n$ is odd if and only if $n$ is odd if and only if $m$ is even."}
{"formal_statement": "theorem pow_left_inj {R : Type*} [linear_ordered_semiring R] {x y : R}\n\t{n : \u2115} (Hxpos : 0 \u2264 x) (Hypos : 0 \u2264 y) (Hnpos : 0 < n) :\n\t(x ^ n = y ^ n \u2194 x = y)", "decl_tp": "\u2200 {R : Type u_4} [_inst_1 : linear_ordered_semiring R] {x y : R} {n : \u2115}, 0 \u2264 x \u2192 0 \u2264 y \u2192 0 < n \u2192 (x ^ n = y ^ n \u2194 x = y)", "decl_nm": "pow_left_inj", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring. Let $x, y\\in R$ and $n\\in\\mathbb{N}$. If $x, y\\geq 0$ and $n>0$, then $x^n=y^n$ if and only if $x=y$."}
{"formal_statement": "theorem union {\u03b1 : Type*} [topological_space \u03b1] {s t : set \u03b1} (hs : is_G\u03b4 s)\n\t(ht : is_G\u03b4 t) :\n\tis_G\u03b4 (s \u222a t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {s t : set \u03b1}, is_G\u03b4 s \u2192 is_G\u03b4 t \u2192 is_G\u03b4 (s \u222a t)", "decl_nm": "is_G\u03b4.union", "nl_statement_of_codex": "Let $X$ be a topological space. If $S$ and $T$ are $G_\\delta$ sets, then $S\\cup T$ is a $G_\\delta$ set."}
{"formal_statement": "theorem smul_apply {R R\u2082 S\u2083 : Type*} [semiring R] [semiring R\u2082] [monoid S\u2083]\n\t[topological_space S\u2083] {M : Type*} [topological_space M] [add_comm_monoid M]\n\t[module R M] {M\u2082 : Type*} [topological_space M\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (c : S\u2083) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M) [distrib_mul_action S\u2083 M\u2082]\n\t[has_continuous_smul S\u2083 M\u2082] [smul_comm_class R\u2082 S\u2083 M\u2082] :\n\t\u21d1(c \u2022 f) x = c \u2022 \u21d1f x", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {S\u2083 : Type u_5} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_5 : monoid S\u2083] [_inst_7 : topological_space S\u2083] {M : Type u_6} [_inst_8 : topological_space M] [_inst_9 : add_comm_monoid M] [_inst_10 : module R M] {M\u2082 : Type u_7} [_inst_11 : topological_space M\u2082] [_inst_12 : add_comm_monoid M\u2082] [_inst_13 : module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} (c : S\u2083) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M) [_inst_30 : distrib_mul_action S\u2083 M\u2082] [_inst_31 : has_continuous_smul S\u2083 M\u2082] [_inst_32 : smul_comm_class R\u2082 S\u2083 M\u2082], \u21d1(c \u2022 f) x = c \u2022 \u21d1f x", "decl_nm": "continuous_linear_map.smul_apply", "nl_statement_of_codex": "Let $R, R_2, S_3$ be semirings, $M, M_2$ be $R$-modules, and $\u03c3_{12}:R\\to R_2$ be a semiring homomorphism.\nLet $c\\in S_3$ and $f:M\\to M_2$ be a linear map. Then $c\\cdot f$ is a linear map and $(c\\cdot f)(x)=c\\cdot f(x)$."}
{"formal_statement": "theorem mem_closure {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] {a : \u03b1} {s : set \u03b1} (ha : is_glb s a) (hs : s.nonempty) :\n\ta \u2208 closure s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_3 : linear_order \u03b1] [_inst_5 : order_topology \u03b1] {a : \u03b1} {s : set \u03b1}, is_glb s a \u2192 s.nonempty \u2192 a \u2208 closure s", "decl_nm": "is_glb.mem_closure", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and the order topology. Let $s$ be a nonempty subset of $X$ and let $a$ be the greatest lower bound of $s$. Then $a$ is in the closure of $s$."}
{"formal_statement": "theorem convex_gt {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[ordered_cancel_add_comm_monoid \u03b2] [module \ud835\udd5c E] [module \ud835\udd5c \u03b2] [ordered_smul \ud835\udd5c \u03b2]\n\t{s : set E} {f : E \u2192 \u03b2} (hf : concave_on \ud835\udd5c s f) :\n\t\u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | r < f x}", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : ordered_cancel_add_comm_monoid \u03b2] [_inst_5 : module \ud835\udd5c E] [_inst_6 : module \ud835\udd5c \u03b2] [_inst_7 : ordered_smul \ud835\udd5c \u03b2] {s : set E} {f : E \u2192 \u03b2}, concave_on \ud835\udd5c s f \u2192 \u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | r < f x}", "decl_nm": "concave_on.convex_gt", "nl_statement_of_codex": "Let $E$ be a vector space over an ordered field $K$ and let $f:E\\to K$ be a concave function. Then the set $\\{x\\in E\\mid r<f(x)\\}$ is convex for all $r\\in K$."}
{"formal_statement": "theorem inv_down {\u03b1 : Type u} {x : ulift \u03b1} [has_inv \u03b1] :\n\tx\u207b\u00b9.down = (x.down)\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u} {x : ulift \u03b1} [_inst_1 : has_inv \u03b1], x\u207b\u00b9.down = (x.down)\u207b\u00b9", "decl_nm": "ulift.inv_down", "nl_statement_of_codex": "Let $x$ be an element of the unary lift of a type $\u03b1$ with an inverse. Then the inverse of $x$ is the unary lift of the inverse of $x$."}
{"formal_statement": "theorem eqv (\u03b1 : Type*) [denumerable \u03b1] :\n\t(denumerable.eqv \u03b1).computable", "decl_tp": "\u2200 (\u03b1 : Type u_1) [_inst_1 : denumerable \u03b1], (denumerable.eqv \u03b1).computable", "decl_nm": "computable.eqv", "nl_statement_of_codex": "The equivalence relation on a denumerable type is computable."}
{"formal_statement": "theorem mem_filter_of_mem {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [decidable_pred p]\n\t{a : \u03b1} {l : multiset \u03b1} (m : a \u2208 l) (h : p a) :\n\ta \u2208 multiset.filter p l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {p : \u03b1 \u2192 Prop} [_inst_1 : decidable_pred p] {a : \u03b1} {l : multiset \u03b1}, a \u2208 l \u2192 p a \u2192 a \u2208 multiset.filter p l", "decl_nm": "multiset.mem_filter_of_mem", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a type $\u03b1$. Let $a$ be an element of $\u03b1$ and let $l$ be a multiset of elements of $\u03b1$. If $a$ is an element of $l$ and $p(a)$ is true, then $a$ is an element of the multiset $l$ filtered by $p$."}
{"formal_statement": "theorem continuous_quotient_lift {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] {s : setoid \u03b1} {f : \u03b1 \u2192 \u03b2} (hs : \u2200 (a b : \u03b1), a \u2248 b \u2192 f a = f b)\n\t(h : continuous f) :\n\tcontinuous (quotient.lift f hs)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {s : setoid \u03b1} {f : \u03b1 \u2192 \u03b2} (hs : \u2200 (a b : \u03b1), a \u2248 b \u2192 f a = f b), continuous f \u2192 continuous (quotient.lift f hs)", "decl_nm": "continuous_quotient_lift", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous function between topological spaces $X$ and $Y$. Let $R$ be an equivalence relation on $X$ such that $f$ is constant on each equivalence class. Then the induced function $f':X/R\\to Y$ is continuous."}
{"formal_statement": "theorem smul_mem_pointwise_smul_iff\u2080 {M R : Type*} [group_with_zero M]\n\t[ring R] [mul_semiring_action M R] {a : M} (ha : a \u2260 0) :\n\t\u2200 (S : subring R) (x : R), a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "decl_tp": "\u2200 {M : Type u_1} {R : Type u_2} [_inst_1 : group_with_zero M] [_inst_2 : ring R] [_inst_3 : mul_semiring_action M R] {a : M}, a \u2260 0 \u2192 \u2200 (S : subring R) (x : R), a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "decl_nm": "subring.smul_mem_pointwise_smul_iff\u2080", "nl_statement_of_codex": "Let $M$ be a group with zero, let $R$ be a ring, and let $M$ act on $R$ by multiplication. Let $a\\in M$ be nonzero. Then $a\\cdot x\\in a\\cdot S$ if and only if $x\\in S$ for any subring $S$ of $R$."}
{"formal_statement": "theorem mk_right {T : Type u} [category_theory.category T] {X Y : T} (f : X \u27f6 Y) :\n\t(category_theory.arrow.mk f).right = Y", "decl_tp": "\u2200 {T : Type u} [_inst_1 : category_theory.category T] {X Y : T} (f : X \u27f6 Y), (category_theory.arrow.mk f).right = Y", "decl_nm": "category_theory.arrow.mk_right", "nl_statement_of_codex": "Let $T$ be a category and let $X, Y$ be objects of $T$. Then the right object of the morphism $f:X\\to Y$ is $Y$."}
{"formal_statement": "theorem char_zero_R_or_C {K : Type*} [is_R_or_C K] :\n\tchar_zero K", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K], char_zero K", "decl_nm": "is_R_or_C.char_zero_R_or_C", "nl_statement_of_codex": "The characteristic of $\\mathbb{R}$ or $\\mathbb{C}$ is zero."}
{"formal_statement": "theorem times_cont_mdiff_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{n : with_top \u2115} {f : E \u2192 E'} {x : E} :\n\ttimes_cont_diff_at \ud835\udd5c n f x \u2192 times_cont_mdiff_at (model_with_corners_self \ud835\udd5c E)\n\t(model_with_corners_self \ud835\udd5c E') n f x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {n : with_top \u2115} {f : E \u2192 E'} {x : E}, times_cont_diff_at \ud835\udd5c n f x \u2192 times_cont_mdiff_at (model_with_corners_self \ud835\udd5c E) (model_with_corners_self \ud835\udd5c E') n f x", "decl_nm": "times_cont_diff_at.times_cont_mdiff_at", "nl_statement_of_codex": "Let $E$ and $E'$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to E'$ and $x\\in E$. If $f$ is $n$-times continuously differentiable at $x$, then $f$ is $n$-times continuously differentiable at $x$ in the sense of model spaces."}
{"formal_statement": "theorem braided_functor_to_monoidal_functor {M : Type u} [comm_monoid M]\n\t{N : Type u} [comm_monoid N] (F : M \u2192* N) :\n\t(category_theory.discrete.braided_functor F).to_monoidal_functor = category_theory.discrete.monoidal_functor F", "decl_tp": "\u2200 {M : Type u} [_inst_10 : comm_monoid M] {N : Type u} [_inst_11 : comm_monoid N] (F : M \u2192* N), (category_theory.discrete.braided_functor F).to_monoidal_functor = category_theory.discrete.monoidal_functor F", "decl_nm": "category_theory.discrete.braided_functor_to_monoidal_functor", "nl_statement_of_codex": "The braided functor $F:M\\to N$ is equal to the monoidal functor $F:M\\to N$."}
{"formal_statement": "theorem mul_div_cancel (a : \u2124) {b : \u2124} (H : b \u2260 0) :\n\ta * b / b = a", "decl_tp": "\u2200 (a : \u2124) {b : \u2124}, b \u2260 0 \u2192 a * b / b = a", "decl_nm": "int.mul_div_cancel", "nl_statement_of_codex": "For any $a,b\\in\\mathbb{Z}$ with $b\\neq 0$, we have $a\\cdot b/b=a$."}
{"formal_statement": "theorem subset_interior {\u03b1 : Type u} [topological_space \u03b1] (K : compact_exhaustion \u03b1) \u2983m n : \u2115\u2984 (h : m < n) :\n\t\u21d1K m \u2286 interior (\u21d1K n)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] (K : compact_exhaustion \u03b1) \u2983m n : \u2115\u2984, m < n \u2192 \u21d1K m \u2286 interior (\u21d1K n)", "decl_nm": "compact_exhaustion.subset_interior", "nl_statement_of_codex": "Let $K$ be a compact exhaustion of a topological space $X$. Then for all $m,n\\in\\mathbb{N}$ with $m<n$, the set $K_m$ is contained in the interior of $K_n$."}
{"formal_statement": "theorem ite_ne_right_iff {\u03b1 : Sort u_1} {P : Prop} [decidable P] {a b : \u03b1}\n\t(h : a \u2260 b) :\n\t(ite P a b \u2260 b \u2194 P)", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {P : Prop} [_inst_1 : decidable P] {a b : \u03b1}, a \u2260 b \u2192 (ite P a b \u2260 b \u2194 P)", "decl_nm": "ne.ite_ne_right_iff", "nl_statement_of_codex": "Let $P$ be a proposition and let $a, b$ be elements of a type $\u03b1$. If $a\\neq b$, then $a=b$ if and only if $P$."}
{"formal_statement": "theorem not_mem_affine_span_diff {k V P : Type*} [ring k] [add_comm_group V]\n\t[module k V] [add_torsor V P] {\u03b9 : Type*} [nontrivial k] {p : \u03b9 \u2192 P} (ha : affine_independent k p) :\n\t\u2200 (i : \u03b9) (s : set \u03b9), p i \u2209 affine_span k (p '' (s \\ {i}))", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [_inst_4 : add_torsor V P] {\u03b9 : Type u_4} [_inst_5 : nontrivial k] {p : \u03b9 \u2192 P}, affine_independent k p \u2192 \u2200 (i : \u03b9) (s : set \u03b9), p i \u2209 affine_span k (p '' (s \\ {i}))", "decl_nm": "affine_independent.not_mem_affine_span_diff", "nl_statement_of_codex": "Let $P$ be an affine space over a field $k$ and let $p:I\\to P$ be a family of points. If $p$ is affinely independent, then for each $i\\in I$ the point $p(i)$ is not in the affine span of the points $p(j)$ for $j\\in I\\setminus\\{i\\}$."}
{"formal_statement": "theorem flip_comp_evaluation_hom_app {A : Type u\u2081} [category_theory.category A]\n\t{B : Type u\u2082} [category_theory.category B] {C : Type u\u2083} [category_theory.category C]\n\t(F : A \u2964 B \u2964 C) (a : A) (X : B) :\n\t(category_theory.flip_comp_evaluation F a).hom.app X = \ud835\udfd9 ((F.obj a).obj X)", "decl_tp": "\u2200 {A : Type u\u2081} [_inst_1 : category_theory.category A] {B : Type u\u2082} [_inst_2 : category_theory.category B] {C : Type u\u2083} [_inst_3 : category_theory.category C] (F : A \u2964 B \u2964 C) (a : A) (X : B), (category_theory.flip_comp_evaluation F a).hom.app X = \ud835\udfd9 ((F.obj a).obj X)", "decl_nm": "category_theory.flip_comp_evaluation_hom_app", "nl_statement_of_codex": "Let $A, B, C$ be categories and let $F:A\\to B\\to C$ be a functor. Then for any $a\\in A$ and $X\\in B$, the functor $F(a,-):B\\to C$ is the identity functor on $B$."}
{"formal_statement": "theorem set_integral_map {\u03b1 E : Type*} [measurable_space \u03b1] [normed_group E]\n\t[measurable_space E] {\u03bc : measure_theory.measure \u03b1} [borel_space E] [topological_space.second_countable_topology E]\n\t[complete_space E] [normed_space \u211d E] [topological_space \u03b1] [borel_space \u03b1]\n\t{\u03b2 : Type*} [measurable_space \u03b2] [topological_space \u03b2] [borel_space \u03b2]\n\t{g : \u03b1 \u2192 \u03b2} {f : \u03b2 \u2192 E} (s : set \u03b2) (hg : closed_embedding g) :\n\t\u222b (y : \u03b2) in s, f y \u2202\u21d1(measure_theory.measure.map g) \u03bc = \u222b (x : \u03b1) in g \u207b\u00b9' s, f (g x) \u2202\u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : normed_group E] [_inst_3 : measurable_space E] {\u03bc : measure_theory.measure \u03b1} [_inst_4 : borel_space E] [_inst_5 : topological_space.second_countable_topology E] [_inst_6 : complete_space E] [_inst_7 : normed_space \u211d E] [_inst_8 : topological_space \u03b1] [_inst_9 : borel_space \u03b1] {\u03b2 : Type u_2} [_inst_10 : measurable_space \u03b2] [_inst_11 : topological_space \u03b2] [_inst_12 : borel_space \u03b2] {g : \u03b1 \u2192 \u03b2} {f : \u03b2 \u2192 E} (s : set \u03b2), closed_embedding g \u2192 \u222b (y : \u03b2) in s, f y \u2202\u21d1(measure_theory.measure.map g) \u03bc = \u222b (x : \u03b1) in g \u207b\u00b9' s, f (g x) \u2202\u03bc", "decl_nm": "closed_embedding.set_integral_map", "nl_statement_of_codex": "Let $g:X\\to Y$ be a closed embedding of topological spaces. Let $f:Y\\to E$ be a function, where $E$ is a normed group. Then the integral of $f$ over $Y$ is equal to the integral of $f\\circ g$ over $X$."}
{"formal_statement": "theorem bUnion_self {\u03b1 : Type*} (s : set \u03b1) :\n\t(\u22c3 (x : \u03b1) (H : x \u2208 s), s) = s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : set \u03b1), (\u22c3 (x : \u03b1) (H : x \u2208 s), s) = s", "decl_nm": "set.bUnion_self", "nl_statement_of_codex": "The union of a set with itself is the set itself."}
{"formal_statement": "theorem app_naturality {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t{F G : C \u2964 D \u2964 E} (T : F \u27f6 G) (X : C) {Y Z : D} (f : Y \u27f6 Z) :\n\t(F.obj X).map f \u226b (T.app X).app Z = (T.app X).app Y \u226b (G.obj X).map f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] {F G : C \u2964 D \u2964 E} (T : F \u27f6 G) (X : C) {Y Z : D} (f : Y \u27f6 Z), (F.obj X).map f \u226b (T.app X).app Z = (T.app X).app Y \u226b (G.obj X).map f", "decl_nm": "category_theory.nat_trans.app_naturality", "nl_statement_of_codex": "Let $C, D, E$ be categories and let $F, G:C\\to D\\to E$ be functors. Let $T:F\\to G$ be a natural transformation. Then for any $X\\in C$ and $f:Y\\to Z$ in $D$, the following diagram commutes:\n\\[\n\\begin{tikzcd}\nF(X)(Y) \\arrow[r, "}
{"formal_statement": "theorem functoriality_counit_app_hom {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G)\n\t{J : Type u} [category_theory.category J] (K : J \u2964 C) (c : category_theory.limits.cocone (K \u22d9 F)) :\n\t((adj.functoriality_counit K).app c).hom = adj.counit.app c.X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) {J : Type u} [_inst_3 : category_theory.category J] (K : J \u2964 C) (c : category_theory.limits.cocone (K \u22d9 F)), ((adj.functoriality_counit K).app c).hom = adj.counit.app c.X", "decl_nm": "category_theory.adjunction.functoriality_counit_app_hom", "nl_statement_of_codex": "Let $F:C\\to D$ and $G:D\\to C$ be adjoint functors. Let $K:J\\to C$ be a functor. Then the counit of the adjunction\n$F\\dashv G$ applied to the cocone $K\\circ F$ is the same as the counit of the adjunction applied to the object $K\\circ F$."}
{"formal_statement": "theorem integrable_on_const {\u03b1 E : Type*} [measurable_space \u03b1] [normed_group E]\n\t[measurable_space E] {s : set \u03b1} {\u03bc : measure_theory.measure \u03b1} {C : E} :\n\tmeasure_theory.integrable_on (\u03bb (_x : \u03b1), C) s \u03bc \u2194 C = 0 \u2228 \u21d1\u03bc s < \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : normed_group E] [_inst_3 : measurable_space E] {s : set \u03b1} {\u03bc : measure_theory.measure \u03b1} {C : E}, measure_theory.integrable_on (\u03bb (_x : \u03b1), C) s \u03bc \u2194 C = 0 \u2228 \u21d1\u03bc s < \u22a4", "decl_nm": "measure_theory.integrable_on_const", "nl_statement_of_codex": "Let $E$ be a normed group, let $s$ be a measurable set, and let $\\mu$ be a measure on $E$. Then the constant function $f(x)=C$ is integrable on $s$ if and only if $C=0$ or $\\mu(s)<\\infty$."}
{"formal_statement": "theorem bot_eq_empty {\u03b1 : Type u} :\n\t\u22a5 = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u}, \u22a5 = \u2205", "decl_nm": "finset.bot_eq_empty", "nl_statement_of_codex": "The empty set is the bottom element of the lattice of sets."}
{"formal_statement": "theorem map_apply_coe {n : Type u} [decidable_eq n] [fintype n] {R : Type v}\n\t[comm_ring R] {S : Type*} [comm_ring S] (f : R \u2192+* S) (g : matrix.special_linear_group n R) :\n\t\u2191(\u21d1(matrix.special_linear_group.map f) g) = \u21d1(f.map_matrix) \u2191g", "decl_tp": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {R : Type v} [_inst_3 : comm_ring R] {S : Type u_1} [_inst_4 : comm_ring S] (f : R \u2192+* S) (g : matrix.special_linear_group n R), \u2191(\u21d1(matrix.special_linear_group.map f) g) = \u21d1(f.map_matrix) \u2191g", "decl_nm": "matrix.special_linear_group.map_apply_coe", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings, and let $f:R\\to S$ be a ring homomorphism. Then the map $f$ induces a map\n$\\operatorname{SL}_n(R)\\to\\operatorname{SL}_n(S)$."}
{"formal_statement": "theorem head'_append {\u03b1 : Type u} {s t : list \u03b1} {x : \u03b1} (h : x \u2208 s.head') :\n\tx \u2208 (s ++ t).head'", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : list \u03b1} {x : \u03b1}, x \u2208 s.head' \u2192 x \u2208 (s ++ t).head'", "decl_nm": "list.head'_append", "nl_statement_of_codex": "Let $s$ and $t$ be lists of elements of a type $\u03b1$. If $x$ is the first element of $s$, then $x$ is the first element of $s++t$."}
{"formal_statement": "theorem angle_eq_right {V P : Type*} [inner_product_space \u211d V] [metric_space P]\n\t[normed_add_torsor V P] (p1 p2 : P) :\n\teuclidean_geometry.angle p1 p2 p2 = real.pi / 2", "decl_tp": "\u2200 {V : Type u_1} {P : Type u_2} [_inst_1 : inner_product_space \u211d V] [_inst_2 : metric_space P] [_inst_3 : normed_add_torsor V P] (p1 p2 : P), euclidean_geometry.angle p1 p2 p2 = real.pi / 2", "decl_nm": "euclidean_geometry.angle_eq_right", "nl_statement_of_codex": "The angle between two points $p_1$ and $p_2$ is $\\pi/2$ if $p_1$ and $p_2$ are the same point."}
{"formal_statement": "theorem as_string_eq {l : list char} {s : string} :\n\tl.as_string = s \u2194 l = s.to_list", "decl_tp": "\u2200 {l : list char} {s : string}, l.as_string = s \u2194 l = s.to_list", "decl_nm": "list.as_string_eq", "nl_statement_of_codex": "A list of characters is equal to a string if and only if the list is equal to the list of characters of the string."}
{"formal_statement": "theorem ne_univ {\u03b1 : Type u} [topological_space \u03b1] [noncompact_space \u03b1]\n\t{s : set \u03b1} (hs : is_compact s) :\n\ts \u2260 set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : noncompact_space \u03b1] {s : set \u03b1}, is_compact s \u2192 s \u2260 set.univ", "decl_nm": "is_compact.ne_univ", "nl_statement_of_codex": "Let $X$ be a non-compact topological space. If $S$ is a compact subset of $X$, then $S$ is not equal to $X$."}
{"formal_statement": "theorem to_fun_eq_coe {\u03b9 M : Type*} [add_comm_monoid M] {I\u2080 : with_top (box_integral.box \u03b9)}\n\t(f : box_integral.box_additive_map \u03b9 M I\u2080) :\n\tf.to_fun = \u21d1f", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : Type u_2} [_inst_1 : add_comm_monoid M] {I\u2080 : with_top (box_integral.box \u03b9)} (f : box_integral.box_additive_map \u03b9 M I\u2080), f.to_fun = \u21d1f", "decl_nm": "box_integral.box_additive_map.to_fun_eq_coe", "nl_statement_of_codex": "Let $f$ be a box-additive map from $\\mathbb{N}^n$ to $M$. Then $f$ is equal to its coe."}
{"formal_statement": "theorem form_perm_eq_self_of_not_mem {\u03b1 : Type*} [decidable_eq \u03b1] (s : cycle \u03b1)\n\t(h : s.nodup) (x : \u03b1) (hx : x \u2209 s) :\n\t\u21d1(s.form_perm h) x = x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s : cycle \u03b1) (h : s.nodup) (x : \u03b1), x \u2209 s \u2192 \u21d1(s.form_perm h) x = x", "decl_nm": "cycle.form_perm_eq_self_of_not_mem", "nl_statement_of_codex": "Let $s$ be a cycle of elements of a set $X$. If $s$ has no repeated elements and $x\\in X$ is not in $s$, then $x$ is fixed by the permutation $s$."}
{"formal_statement": "theorem snorm_mono {\u03b1 F G : Type*} {m0 : measurable_space \u03b1} {p : ennreal}\n\t{\u03bc : measure_theory.measure \u03b1} [normed_group F] [normed_group G] {f : \u03b1 \u2192 F}\n\t{g : \u03b1 \u2192 G} :\n\t(\u2200 (x : \u03b1), \u2225f x\u2225 \u2264 \u2225g x\u2225) \u2192 measure_theory.snorm f p \u03bc \u2264 measure_theory.snorm g p \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_3} {G : Type u_4} {m0 : measurable_space \u03b1} {p : ennreal} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : normed_group F] [_inst_4 : normed_group G] {f : \u03b1 \u2192 F} {g : \u03b1 \u2192 G}, (\u2200 (x : \u03b1), \u2225f x\u2225 \u2264 \u2225g x\u2225) \u2192 measure_theory.snorm f p \u03bc \u2264 measure_theory.snorm g p \u03bc", "decl_nm": "measure_theory.snorm_mono", "nl_statement_of_codex": "Let $F$ and $G$ be normed groups. Let $f,g:\\alpha\\to F$ be measurable functions. If $\\|f(x)\\|\\leq \\|g(x)\\|$ for all $x\\in\\alpha$, then $\\|f\\|_p\\leq \\|g\\|_p$."}
{"formal_statement": "theorem times_cont_mdiff_within_at_zero {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {s : set M} {x : M} {n : with_top \u2115} [has_zero M'] :\n\ttimes_cont_mdiff_within_at I I' n 0 s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {s : set M} {x : M} {n : with_top \u2115} [_inst_22 : has_zero M'], times_cont_mdiff_within_at I I' n 0 s x", "decl_nm": "times_cont_mdiff_within_at_zero", "nl_statement_of_codex": "Let $E, E'$ be normed spaces over a nondiscrete normed field $K$, and let $M, M'$ be manifolds over $E, E'$ respectively.\nLet $I, I'$ be models for $M, M'$ respectively. Then the $n$-th derivative of the function $f:M\\to M'$ given by $f(x)=0$ is continuous at $0$."}
{"formal_statement": "theorem zero (n : \u2115) :\n\ttactic.norm_fin.normalize_fin (n + 1) 0 0", "decl_tp": "\u2200 (n : \u2115), tactic.norm_fin.normalize_fin (n + 1) 0 0", "decl_nm": "tactic.norm_fin.normalize_fin.zero", "nl_statement_of_codex": "The normalization of $0$ is $0$."}
{"formal_statement": "theorem times_cont_diff_at_fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {p : E \u00d7 F} {n : with_top \u2115} :\n\ttimes_cont_diff_at \ud835\udd5c n prod.fst p", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {p : E \u00d7 F} {n : with_top \u2115}, times_cont_diff_at \ud835\udd5c n prod.fst p", "decl_nm": "times_cont_diff_at_fst", "nl_statement_of_codex": "The projection map $\\pi_1:E\\times F\\to E$ is $n$-times continuously differentiable at $p$."}
{"formal_statement": "theorem inf {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E] [linear_ordered_add_comm_monoid \u03b2]\n\t[has_scalar \ud835\udd5c E] {s : set E} {f g : E \u2192 \u03b2} (hf : quasiconcave_on \ud835\udd5c s f)\n\t(hg : quasiconcave_on \ud835\udd5c s g) :\n\tquasiconcave_on \ud835\udd5c s (f \u2293 g)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : linear_ordered_add_comm_monoid \u03b2] [_inst_5 : has_scalar \ud835\udd5c E] {s : set E} {f g : E \u2192 \u03b2}, quasiconcave_on \ud835\udd5c s f \u2192 quasiconcave_on \ud835\udd5c s g \u2192 quasiconcave_on \ud835\udd5c s (f \u2293 g)", "decl_nm": "quasiconcave_on.inf", "nl_statement_of_codex": "Let $E$ be a vector space over a field $K$ and let $f,g:E\\to\\mathbb{R}$ be quasiconcave functions. Then the function $f\\wedge g:E\\to\\mathbb{R}$ defined by $(f\\wedge g)(x)=\\min\\{f(x),g(x)\\}$ is quasiconcave."}
{"formal_statement": "theorem subtype_equiv_codomain_symm_apply_eq {X Y : Type*} [decidable_eq X]\n\t{x : X} (f : {x' // x' \u2260 x} \u2192 Y) (y : Y) :\n\t\u2191(\u21d1((equiv.subtype_equiv_codomain f).symm) y) x = y", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : decidable_eq X] {x : X} (f : {x' // x' \u2260 x} \u2192 Y) (y : Y), \u2191(\u21d1((equiv.subtype_equiv_codomain f).symm) y) x = y", "decl_nm": "equiv.subtype_equiv_codomain_symm_apply_eq", "nl_statement_of_codex": "Let $X$ and $Y$ be types, let $x\\in X$, and let $f:X\\setminus\\{x\\}\\to Y$. Then the inverse of the function $f$ is given by $f^{-1}(y)=\\{x\\}$."}
{"formal_statement": "theorem is_O_congr {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{E : Type*} [has_norm E] {F : Type*} [has_norm F] (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2}\n\t{f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} :\n\tasymptotics.is_O f g (nhds b) \u2194 asymptotics.is_O (f \u2218 \u21d1e) (g \u2218 \u21d1e) (nhds (\u21d1(e.symm) b))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {E : Type u_3} [_inst_3 : has_norm E] {F : Type u_4} [_inst_4 : has_norm F] (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2} {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F}, asymptotics.is_O f g (nhds b) \u2194 asymptotics.is_O (f \u2218 \u21d1e) (g \u2218 \u21d1e) (nhds (\u21d1(e.symm) b))", "decl_nm": "homeomorph.is_O_congr", "nl_statement_of_codex": "Let $e:X\\to Y$ be a homeomorphism between topological spaces $X$ and $Y$. Let $f,g:Y\\to E$ be functions. Then $f$ is $O(g)$ at $b\\in Y$ if and only if $f\\circ e$ is $O(g\\circ e)$ at $e^{-1}(b)$."}
{"formal_statement": "theorem map_add {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (x y : free_add_magma \u03b1) :\n\tfree_add_magma.map f (x + y) = free_add_magma.map f x + free_add_magma.map f y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (x y : free_add_magma \u03b1), free_add_magma.map f (x + y) = free_add_magma.map f x + free_add_magma.map f y", "decl_nm": "free_add_magma.map_add", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Then $f(x+y)=f(x)+f(y)$ for all $x,y\\in A$."}
{"formal_statement": "theorem mem_comap {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S]\n\t{s : subsemiring S} {f : R \u2192+* S} {x : R} :\n\tx \u2208 subsemiring.comap f s \u2194 \u21d1f x \u2208 s", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] {s : subsemiring S} {f : R \u2192+* S} {x : R}, x \u2208 subsemiring.comap f s \u2194 \u21d1f x \u2208 s", "decl_nm": "subsemiring.mem_comap", "nl_statement_of_codex": "Let $R$ and $S$ be non-associative semirings, let $s$ be a subsemiring of $S$, and let $f:R\\to S$ be a semiring homomorphism. Then $x\\in\\mathrm{comap}(f,s)$ if and only if $f(x)\\in s$."}
{"formal_statement": "theorem append_sublist_append_left {\u03b1 : Type u} {l\u2081 l\u2082 : list \u03b1} (l : list \u03b1) :\n\tl ++ l\u2081 <+ l ++ l\u2082 \u2194 l\u2081 <+ l\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {l\u2081 l\u2082 : list \u03b1} (l : list \u03b1), l ++ l\u2081 <+ l ++ l\u2082 \u2194 l\u2081 <+ l\u2082", "decl_nm": "list.append_sublist_append_left", "nl_statement_of_codex": "Let $l_1, l_2, l$ be lists. Then $l_1$ is a sublist of $l_2$ if and only if $l_1$ is a sublist of $l_2$."}
{"formal_statement": "theorem add_neg_equiv_unit_iso_hom {C : Type u} {A : Type*} [category_theory.category C]\n\t[add_group A] (F : category_theory.monoidal_functor (category_theory.discrete A)\n\t(C \u2964 C)) (n : A) :\n\t(category_theory.add_neg_equiv F n).unit_iso.hom = (category_theory.unit_of_tensor_iso_unit F n (-n)\n\t(category_theory.eq_to_iso _)).inv", "decl_tp": "\u2200 {C : Type u} {A : Type u_1} [_inst_1 : category_theory.category C] [_inst_2 : add_group A] (F : category_theory.monoidal_functor (category_theory.discrete A) (C \u2964 C)) (n : A), (category_theory.add_neg_equiv F n).unit_iso.hom = (category_theory.unit_of_tensor_iso_unit F n (-n) (category_theory.eq_to_iso _)).inv", "decl_nm": "category_theory.add_neg_equiv_unit_iso_hom", "nl_statement_of_codex": "Let $C$ be a category, $A$ an additive group, and $F:A\\to C$ a monoidal functor. Then the homomorphism of the unit isomorphism of the additive inverse equivalence of $F$ and $n$ is the inverse of the unit of the tensor isomorphism of $F$ and $n$ and $-n$."}
{"formal_statement": "theorem trans_symm_self {\u03b1 \u03b2 : Type*} (e : local_equiv \u03b1 \u03b2) :\n\te.symm.trans e \u2248 local_equiv.of_set e.target", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : local_equiv \u03b1 \u03b2), e.symm.trans e \u2248 local_equiv.of_set e.target", "decl_nm": "local_equiv.trans_symm_self", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Then $e^{-1}:Y\\to X$ is a local homeomorphism."}
{"formal_statement": "theorem frontier_eq {\u03b1 : Type u} [topological_space \u03b1] {s : set \u03b1} (hs : is_open s) :\n\tfrontier s = closure s \\ s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, is_open s \u2192 frontier s = closure s \\ s", "decl_nm": "is_open.frontier_eq", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be an open subset of $X$. Then the frontier of $A$ is equal to the closure of $A$ minus $A$."}
{"formal_statement": "theorem mul_lt_mul_left {\u03b1 : Type u} [linear_ordered_semiring \u03b1] {a b c : \u03b1}\n\t(h : 0 < c) :\n\t(c * a < c * b \u2194 a < b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_semiring \u03b1] {a b c : \u03b1}, 0 < c \u2192 (c * a < c * b \u2194 a < b)", "decl_nm": "mul_lt_mul_left", "nl_statement_of_codex": "Let $R$ be a linearly ordered semiring. Then for all $a,b,c\\in R$ with $c>0$, we have $c\\cdot a<c\\cdot b$ if and only if $a<b$."}
{"formal_statement": "theorem of_card {p : \u2115} {G : Type*} [group G] [fintype G] {n : \u2115} (hG : fintype.card G = p ^ n) :\n\tis_p_group p G", "decl_tp": "\u2200 {p : \u2115} {G : Type u_1} [_inst_1 : group G] [_inst_2 : fintype G] {n : \u2115}, fintype.card G = p ^ n \u2192 is_p_group p G", "decl_nm": "is_p_group.of_card", "nl_statement_of_codex": "Let $G$ be a finite group of order $p^n$. Then $G$ is a $p$-group."}
{"formal_statement": "theorem is_unit_pos_pow_iff {M : Type u} [monoid M] {m : M} {n : \u2115} (h : 0 < n) :\n\t(is_unit (m ^ n) \u2194 is_unit m)", "decl_tp": "\u2200 {M : Type u} [_inst_1 : monoid M] {m : M} {n : \u2115}, 0 < n \u2192 (is_unit (m ^ n) \u2194 is_unit m)", "decl_nm": "is_unit_pos_pow_iff", "nl_statement_of_codex": "Let $M$ be a monoid and let $m\\in M$. Then $m^n$ is a unit if and only if $m$ is a unit."}
{"formal_statement": "theorem perm_inv_maps_to_iff_maps_to {\u03b1 : Type u} {f : equiv.perm \u03b1} {s : set \u03b1}\n\t[fintype \u21a5s] :\n\tset.maps_to \u21d1f\u207b\u00b9 s s \u2194 set.maps_to \u21d1f s s", "decl_tp": "\u2200 {\u03b1 : Type u} {f : equiv.perm \u03b1} {s : set \u03b1} [_inst_1 : fintype \u21a5s], set.maps_to \u21d1f\u207b\u00b9 s s \u2194 set.maps_to \u21d1f s s", "decl_nm": "equiv.perm.perm_inv_maps_to_iff_maps_to", "nl_statement_of_codex": "Let $f$ be a permutation of a set $S$. Then $f$ maps $S$ to itself if and only if $f^{-1}$ maps $S$ to itself."}
{"formal_statement": "theorem measure_eq_zero_of_trim_eq_zero {\u03b1 : Type*} {m m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} (hm : m \u2264 m0) (h : \u21d1(\u03bc.trim hm) s = 0) :\n\t\u21d1\u03bc s = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} (hm : m \u2264 m0), \u21d1(\u03bc.trim hm) s = 0 \u2192 \u21d1\u03bc s = 0", "decl_nm": "measure_theory.measure_eq_zero_of_trim_eq_zero", "nl_statement_of_codex": "Let $m$ and $m_0$ be measurable spaces and let $\\mu$ be a measure on $m$. If $m\\leq m_0$ and $\\mu$ is zero on $m_0$, then $\\mu$ is zero on $m$."}
{"formal_statement": "theorem sup {f : ordinal \u2192 ordinal} (H : ordinal.is_normal f) (h : nonempty \u03b9) :\n\t\u2200 {\u03b9 : Type*} {g : \u03b9 \u2192 ordinal},  f (ordinal.sup g) = ordinal.sup (f \u2218 g)", "decl_tp": "\u2200 {f : ordinal \u2192 ordinal}, ordinal.is_normal f \u2192 \u2200 {\u03b9 : Type u_1} {g : \u03b9 \u2192 ordinal}, nonempty \u03b9 \u2192 f (ordinal.sup g) = ordinal.sup (f \u2218 g)", "decl_nm": "ordinal.is_normal.sup", "nl_statement_of_codex": "Let $f$ be a normal function. Then $f$ commutes with the supremum."}
{"formal_statement": "theorem finite_Union {\u03b1 : Type u} {\u03b9 : Sort w} [fintype (plift \u03b9)] {f : \u03b9 \u2192 set \u03b1} :\n\t(\u2200 (i : \u03b9), (f i).finite) \u2192 (\u22c3 (i : \u03b9), f i).finite", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b9 : Sort w} [_inst_1 : fintype (plift \u03b9)] {f : \u03b9 \u2192 set \u03b1}, (\u2200 (i : \u03b9), (f i).finite) \u2192 (\u22c3 (i : \u03b9), f i).finite", "decl_nm": "set.finite_Union", "nl_statement_of_codex": "Let $f$ be a function from a finite set $I$ to the set of subsets of $X$. If each $f(i)$ is finite, then $\\bigcup_{i\\in I}f(i)$ is finite."}
{"formal_statement": "theorem mul_supr {\u03b1 : Type u} {\u03b9 : Sort v} (l : \u03b9 \u2192 language \u03b1) (m : language \u03b1) :\n\t(m * \u2a06 (i : \u03b9), l i) = \u2a06 (i : \u03b9), m * l i", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b9 : Sort v} (l : \u03b9 \u2192 language \u03b1) (m : language \u03b1), (m * \u2a06 (i : \u03b9), l i) = \u2a06 (i : \u03b9), m * l i", "decl_nm": "language.mul_supr", "nl_statement_of_codex": "Let $L_i$ be languages over an alphabet $\\Sigma$ for $i\\in I$. Then $(\\Sigma^*\\cdot \\bigcup_{i\\in I}L_i)=(\\bigcup_{i\\in I}(\\Sigma^*\\cdot L_i))$."}
{"formal_statement": "theorem gcd_coe (n m : \u2115+) :\n\t\u2191(n.gcd m) = \u2191n.gcd \u2191m", "decl_tp": "\u2200 (n m : \u2115+), \u2191(n.gcd m) = \u2191n.gcd \u2191m", "decl_nm": "pnat.gcd_coe", "nl_statement_of_codex": "The greatest common divisor of two positive natural numbers is the greatest common divisor of their coeifications."}
{"formal_statement": "theorem mul {\u03b1 \u03b2 : Type*} [group \u03b1] [comm_group \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : is_group_hom f)\n\t(hg : is_group_hom g) :\n\tis_group_hom (\u03bb (a : \u03b1), f a * g a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_3 : group \u03b1] [_inst_4 : comm_group \u03b2] {f g : \u03b1 \u2192 \u03b2}, is_group_hom f \u2192 is_group_hom g \u2192 is_group_hom (\u03bb (a : \u03b1), f a * g a)", "decl_nm": "is_group_hom.mul", "nl_statement_of_codex": "Let $f,g:G\\to H$ be group homomorphisms. Then the function $h:G\\to H$ defined by $h(x)=f(x)g(x)$ is a group homomorphism."}
{"formal_statement": "theorem Icc_subset_Icc {\u03b1 : Type u} [preorder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} (h\u2081 : a\u2082 \u2264 a\u2081)\n\t(h\u2082 : b\u2081 \u2264 b\u2082) :\n\tset.Icc a\u2081 b\u2081 \u2286 set.Icc a\u2082 b\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}, a\u2082 \u2264 a\u2081 \u2192 b\u2081 \u2264 b\u2082 \u2192 set.Icc a\u2081 b\u2081 \u2286 set.Icc a\u2082 b\u2082", "decl_nm": "set.Icc_subset_Icc", "nl_statement_of_codex": "Let $a_1, a_2, b_1, b_2$ be elements of a preorder $X$. If $a_2\\leq a_1$ and $b_1\\leq b_2$, then $[a_1, b_1]\\subseteq [a_2, b_2]$."}
{"formal_statement": "theorem imp_right {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {P Q : \u03a0 (x : \u03b1), p x \u2192 Prop}\n\t(h\u2081 : \u2200 (x : \u03b1) (h : p x), P x h) :\n\t( Q x h) \u2192 (\u2200 (x : \u03b1) (h : p x), P x h) \u2192 \u2200 (x : \u03b1) (h : p x), Q x h", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {P Q : \u03a0 (x : \u03b1), p x \u2192 Prop}, (\u2200 (x : \u03b1) (h : p x), P x h \u2192 Q x h) \u2192 (\u2200 (x : \u03b1) (h : p x), P x h) \u2192 \u2200 (x : \u03b1) (h : p x), Q x h", "decl_nm": "ball.imp_right", "nl_statement_of_codex": "Let $p$ be a property of elements of $A$. Let $P$ and $Q$ be properties of elements of $A$ and elements of $p$.\nIf $P$ holds for all elements of $A$ and elements of $p$, then $Q$ holds for all elements of $A$ and elements of $p$."}
{"formal_statement": "theorem inf_of_mem {\u03b1 \u03b2 : Type*} [semilattice_inf \u03b1] {s : finset \u03b2} (f : \u03b2 \u2192 \u03b1)\n\t{b : \u03b2} (h : b \u2208 s) :\n\t(\u2203 (a : \u03b1), s.inf (coe \u2218 f) = \u2191a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semilattice_inf \u03b1] {s : finset \u03b2} (f : \u03b2 \u2192 \u03b1) {b : \u03b2}, b \u2208 s \u2192 (\u2203 (a : \u03b1), s.inf (coe \u2218 f) = \u2191a)", "decl_nm": "finset.inf_of_mem", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\alpha$ be a function. Then there exists an element $a\\in \\alpha$ such that $s.inf(f)=a$."}
{"formal_statement": "theorem countable_Inter {\u03b9 \u03b1 : Type*} {l : filter \u03b1} [countable_Inter_filter l]\n\t[encodable \u03b9] {s t : \u03b9 \u2192 set \u03b1} :\n\t(\u2200 (i : \u03b9), s i =\u1da0[l] t i) \u2192 ((\u22c2 (i : \u03b9), s i) =\u1da0[l] \u22c2 (i : \u03b9), t i)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {l : filter \u03b1} [_inst_1 : countable_Inter_filter l] [_inst_2 : encodable \u03b9] {s t : \u03b9 \u2192 set \u03b1}, (\u2200 (i : \u03b9), s i =\u1da0[l] t i) \u2192 ((\u22c2 (i : \u03b9), s i) =\u1da0[l] \u22c2 (i : \u03b9), t i)", "decl_nm": "eventually_eq.countable_Inter", "nl_statement_of_codex": "Let $l$ be a filter on a set $X$ such that the intersection of any countable family of sets in $l$ is in $l$. Let $s,t:\\mathbb{N}\\to\\mathcal{P}(X)$ be two sequences of sets. If $s_n=t_n$ for all $n\\in\\mathbb{N}$, then $\\bigcap_{n\\in\\mathbb{N}}s_n=\\bigcap_{n\\in\\mathbb{N}}t_n$."}
{"formal_statement": "theorem tendsto_at_top_of_geom_le {v : \u2115 \u2192 \u211d} {c : \u211d} (h\u2080 : 0 < v 0) (hc : 1 < c) :\n\t(\u2200 (n : \u2115), c * v n \u2264 v (n + 1)) \u2192 filter.tendsto v filter.at_top filter.at_top", "decl_tp": "\u2200 {v : \u2115 \u2192 \u211d} {c : \u211d}, 0 < v 0 \u2192 1 < c \u2192 (\u2200 (n : \u2115), c * v n \u2264 v (n + 1)) \u2192 filter.tendsto v filter.at_top filter.at_top", "decl_nm": "tendsto_at_top_of_geom_le", "nl_statement_of_codex": "Let $v:\\mathbb{N}\\to\\mathbb{R}$ be a sequence of real numbers. If $v_0>0$ and $c>1$ and if $c\\cdot v_n\\leq v_{n+1}$ for all $n\\in\\mathbb{N}$, then $v_n\\to\\infty$."}
{"formal_statement": "theorem smul_mem {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_scalar \ud835\udd5c E] (S : convex_cone \ud835\udd5c E) {c : \ud835\udd5c} {x : E} (hc : 0 < c) (hx : x \u2208 S) :\n\tc \u2022 x \u2208 S", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_3 : has_scalar \ud835\udd5c E] (S : convex_cone \ud835\udd5c E) {c : \ud835\udd5c} {x : E}, 0 < c \u2192 x \u2208 S \u2192 c \u2022 x \u2208 S", "decl_nm": "convex_cone.smul_mem", "nl_statement_of_codex": "Let $S$ be a convex cone in a vector space $E$ over an ordered field $K$. If $x\\in S$ and $c>0$, then $cx\\in S$."}
{"formal_statement": "theorem concave_on_iff_div {\ud835\udd5c E \u03b2 : Type*} [linear_ordered_field \ud835\udd5c] [add_comm_monoid E]\n\t[ordered_add_comm_monoid \u03b2] [has_scalar \ud835\udd5c E] [has_scalar \ud835\udd5c \u03b2] {s : set E}\n\t{f : E \u2192 \u03b2} :\n\tconcave_on \ud835\udd5c s f \u2194 convex \ud835\udd5c s \u2227 \u2200 \u2983x y : E\u2984, x \u2208 s \u2192 y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192 (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y \u2264 f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : linear_ordered_field \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_3 : ordered_add_comm_monoid \u03b2] [_inst_4 : has_scalar \ud835\udd5c E] [_inst_5 : has_scalar \ud835\udd5c \u03b2] {s : set E} {f : E \u2192 \u03b2}, concave_on \ud835\udd5c s f \u2194 convex \ud835\udd5c s \u2227 \u2200 \u2983x y : E\u2984, x \u2208 s \u2192 y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192 (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y \u2264 f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y)", "decl_nm": "concave_on_iff_div", "nl_statement_of_codex": "Let $E$ be a set, $f:E\\to\\mathbb{R}$ and $s\\subset E$. Then $f$ is concave on $s$ if and only if $s$ is convex and for all $x,y\\in s$ and $a,b\\in\\mathbb{R}$ with $a,b\\geq 0$ and $a+b>0$ we have\n$$\\frac{a}{a+b}f(x)+\\frac{b}{a+b}f(y)\\leq f\\left(\\frac{a}{a+b}x+\\frac{b}{a+b}y"}
{"formal_statement": "theorem deriv_within {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v}\n\t[normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {s : set \ud835\udd5c}\n\t(h : has_deriv_within_at f f' s x) (hxs : unique_diff_within_at \ud835\udd5c s x) :\n\tderiv_within f s x = f'", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {s : set \ud835\udd5c}, has_deriv_within_at f f' s x \u2192 unique_diff_within_at \ud835\udd5c s x \u2192 deriv_within f s x = f'", "decl_nm": "has_deriv_within_at.deriv_within", "nl_statement_of_codex": "Let $f:U\\to\\mathbb{R}^n$ be a function defined on an open set $U\\subset\\mathbb{R}^n$. Suppose that $f$ is differentiable at $x\\in U$ and that $U$ is a unique differentiability set at $x$. Then the derivative of $f$ at $x$ is equal to the differential of $f$ at $x$."}
{"formal_statement": "theorem mem_lower_bounds_image {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (Hf : monotone f) (Ha : a \u2208 lower_bounds s) :\n\t\u2200 {a : \u03b1} {s : set \u03b1},  f a \u2208 lower_bounds (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, monotone f \u2192 \u2200 {a : \u03b1} {s : set \u03b1}, a \u2208 lower_bounds s \u2192 f a \u2208 lower_bounds (f '' s)", "decl_nm": "monotone.mem_lower_bounds_image", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function. If $a\\in A$ is a lower bound for $A$, then $f(a)$ is a lower bound for $f(A)$."}
{"formal_statement": "theorem is_fg_degree_le {R : Type u} [comm_ring R] (I : ideal (polynomial R))\n\t[is_noetherian_ring R] (n : \u2115) :\n\t(I.degree_le \u2191n).fg", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] (I : ideal (polynomial R)) [_inst_5 : is_noetherian_ring R] (n : \u2115), (I.degree_le \u2191n).fg", "decl_nm": "ideal.is_fg_degree_le", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $I$ be an ideal of $R[x]$. If $R$ is Noetherian, then the set of polynomials of degree at most $n$ in $I$ is finitely generated."}
{"formal_statement": "theorem mclosure_subset {G : Type*} [group G] {s : set G} :\n\tmonoid.closure s \u2286 group.closure s", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {s : set G}, monoid.closure s \u2286 group.closure s", "decl_nm": "group.mclosure_subset", "nl_statement_of_codex": "The monoid closure of a set $s$ is contained in the group closure of $s$."}
{"formal_statement": "theorem is_open_iff_ultrafilter' {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1]\n\t[compact_space \u03b1] (U : set \u03b1) :\n\tis_open U \u2194 \u2200 (F : ultrafilter \u03b1), F.Lim \u2208 U \u2192 U \u2208 F.to_filter", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : t2_space \u03b1] [_inst_3 : compact_space \u03b1] (U : set \u03b1), is_open U \u2194 \u2200 (F : ultrafilter \u03b1), F.Lim \u2208 U \u2192 U \u2208 F.to_filter", "decl_nm": "is_open_iff_ultrafilter'", "nl_statement_of_codex": "Let $X$ be a compact Hausdorff space. Then a subset $U$ of $X$ is open if and only if for every ultrafilter $F$ on $X$, if $F$ converges to a point in $U$, then $U$ is in $F$."}
{"formal_statement": "theorem sum_monomial_eq {R : Type u} {\u03c3 : Type*} [comm_semiring R] {A : Type*}\n\t[add_comm_monoid A] {u : \u03c3 \u2192\u2080 \u2115} {r : R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A} (w : b u 0 = 0) :\n\tfinsupp.sum (\u21d1(mv_polynomial.monomial u) r) b = b u r", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] {A : Type u_2} [_inst_3 : add_comm_monoid A] {u : \u03c3 \u2192\u2080 \u2115} {r : R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A}, b u 0 = 0 \u2192 finsupp.sum (\u21d1(mv_polynomial.monomial u) r) b = b u r", "decl_nm": "mv_polynomial.sum_monomial_eq", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ an abelian monoid, $u$ a monomial, and $b$ a polynomial. Then the coefficient of $u$ in $b$ is equal to the coefficient of $u$ in $b$."}
{"formal_statement": "theorem congr_mono {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f f\u2081 : E \u2192 F} {s t : set E} (h : differentiable_on \ud835\udd5c f s) (h\u2081 : t \u2286 s)\n\t(hx : x \u2208 t) :\n\t(\u2200 (x : E),  f\u2081 x = f x) \u2192  differentiable_on \ud835\udd5c f\u2081 t", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f f\u2081 : E \u2192 F} {s t : set E}, differentiable_on \ud835\udd5c f s \u2192 (\u2200 (x : E), x \u2208 t \u2192 f\u2081 x = f x) \u2192 t \u2286 s \u2192 differentiable_on \ud835\udd5c f\u2081 t", "decl_nm": "differentiable_on.congr_mono", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f,f_1:E\\to F$ be differentiable on $S$. If $T\\subset S$ and $f_1=f$ on $T$, then $f_1$ is differentiable on $T$."}
{"formal_statement": "theorem coe_comp {M N P : Type*} [mul_one_class M] [mul_one_class N] [mul_one_class P]\n\t(g : N \u2192* P) (f : M \u2192* N) :\n\t\u21d1(g.comp f) = \u21d1g \u2218 \u21d1f", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] [_inst_3 : mul_one_class P] (g : N \u2192* P) (f : M \u2192* N), \u21d1(g.comp f) = \u21d1g \u2218 \u21d1f", "decl_nm": "monoid_hom.coe_comp", "nl_statement_of_codex": "Let $M, N, P$ be monoids with identity. Let $f:M\\to N$ and $g:N\\to P$ be monoid homomorphisms. Then the composition $g\\circ f$ is a monoid homomorphism from $M$ to $P$."}
{"formal_statement": "theorem dual {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : filter \u03b1}\n\t{a : \u03b1} :\n\tis_extr_filter f l a \u2192 is_extr_filter (\u21d1order_dual.to_dual \u2218 f) l a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : filter \u03b1} {a : \u03b1}, is_extr_filter f l a \u2192 is_extr_filter (\u21d1order_dual.to_dual \u2218 f) l a", "decl_nm": "is_extr_filter.dual", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between preordered sets. If $f$ has a left-hand limit at $a$, then $f$ has a right-hand limit at $a$."}
{"formal_statement": "theorem gcd_a_eq (a b : \u2115+) :\n\ta = a.gcd_a' b * a.gcd b", "decl_tp": "\u2200 (a b : \u2115+), a = a.gcd_a' b * a.gcd b", "decl_nm": "pnat.gcd_a_eq", "nl_statement_of_codex": "For any positive integers $a$ and $b$, $a=a\\gcd(a,b)$."}
{"formal_statement": "theorem is_rotated_nil_iff' {\u03b1 : Type u} {l : list \u03b1} :\n\tlist.nil ~r l \u2194 list.nil = l", "decl_tp": "\u2200 {\u03b1 : Type u} {l : list \u03b1}, list.nil ~r l \u2194 list.nil = l", "decl_nm": "list.is_rotated_nil_iff'", "nl_statement_of_codex": "A list $l$ is rotated nil if and only if $l$ is nil."}
{"formal_statement": "theorem iso_of_components_inv_f {\u03b9 : Type*} {V : Type u} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C\u2081 C\u2082 : homological_complex V c}\n\t(f : \u03a0 (i : \u03b9), C\u2081.X i \u2245 C\u2082.X i) (hf : \u2200 (i j : \u03b9), c.rel i j \u2192 (f i).hom \u226b C\u2082.d i j = C\u2081.d i j \u226b (f j).hom)\n\t(i : \u03b9) :\n\t(homological_complex.hom.iso_of_components f hf).inv.f i = (f i).inv", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C\u2081 C\u2082 : homological_complex V c} (f : \u03a0 (i : \u03b9), C\u2081.X i \u2245 C\u2082.X i) (hf : \u2200 (i j : \u03b9), c.rel i j \u2192 (f i).hom \u226b C\u2082.d i j = C\u2081.d i j \u226b (f j).hom) (i : \u03b9), (homological_complex.hom.iso_of_components f hf).inv.f i = (f i).inv", "decl_nm": "homological_complex.hom.iso_of_components_inv_f", "nl_statement_of_codex": "Let $C_1$ and $C_2$ be homological complexes over a category $V$ with zero morphisms. Let $f$ be a collection of isomorphisms $f_i:C_1^i\\to C_2^i$ such that $f_i\\circ d_i^j=d_i^j\\circ f_j$ for all $i,j$. Then the inverse of the isomorphism $f:C_1\\to C_2$ is given by the collection of inverses $f_i^{-1}$."}
{"formal_statement": "theorem clear_denom_div {\u03b1 : Type*} [division_ring \u03b1] (a b b' c d : \u03b1)\n\t(h\u2080 : b \u2260 0) (h\u2081 : b * b' = d) (h\u2082 : a * b' = c) :\n\ta / b * d = c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : division_ring \u03b1] (a b b' c d : \u03b1), b \u2260 0 \u2192 b * b' = d \u2192 a * b' = c \u2192 a / b * d = c", "decl_nm": "norm_num.clear_denom_div", "nl_statement_of_codex": "Let $a,b,b',c,d$ be elements of a division ring $R$ such that $b\\neq 0$, $b\\cdot b'=d$, and $a\\cdot b'=c$. Then $a/b\\cdot d=c$."}
{"formal_statement": "theorem ediam_le_of_forall_dist_le {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{s : set \u03b1} {C : \u211d} :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b1), y \u2208 s \u2192 has_dist.dist x y \u2264 C) \u2192 emetric.diam s \u2264 ennreal.of_real C", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {s : set \u03b1} {C : \u211d}, (\u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b1), y \u2208 s \u2192 has_dist.dist x y \u2264 C) \u2192 emetric.diam s \u2264 ennreal.of_real C", "decl_nm": "metric.ediam_le_of_forall_dist_le", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $s\\subset X$. If $d(x,y)\\leq C$ for all $x,y\\in s$, then $\\diam(s)\\leq C$."}
{"formal_statement": "theorem presheaf_equiv_of_iso_inverse_obj_obj (C : Type u) [category_theory.category C]\n\t{X Y : Top} (H : X \u2245 Y) (G : (topological_space.opens \u21a5Y)\u1d52\u1d56 \u2964 C) (X_1 : (topological_space.opens \u21a5X)\u1d52\u1d56) :\n\t((Top.presheaf.presheaf_equiv_of_iso C H).inverse.obj G).obj X_1 = G.obj (opposite.op ((topological_space.opens.map H.inv).obj (opposite.unop X_1)))", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] {X Y : Top} (H : X \u2245 Y) (G : (topological_space.opens \u21a5Y)\u1d52\u1d56 \u2964 C) (X_1 : (topological_space.opens \u21a5X)\u1d52\u1d56), ((Top.presheaf.presheaf_equiv_of_iso C H).inverse.obj G).obj X_1 = G.obj (opposite.op ((topological_space.opens.map H.inv).obj (opposite.unop X_1)))", "decl_nm": "Top.presheaf.presheaf_equiv_of_iso_inverse_obj_obj", "nl_statement_of_codex": "Let $C$ be a category, $X$ and $Y$ be topological spaces, $H:X\\to Y$ be a homeomorphism, $G$ be a presheaf on $Y$, and $X_1$ be a presheaf on $X$. Then the presheaf on $X$ obtained by pulling back $G$ along $H$ is the presheaf on $X$ obtained by pulling back $G$ along $H^{-1}$."}
{"formal_statement": "theorem add_left_inj {M : Type*} [add_monoid M] {a b c : M} (ha : is_add_unit a) :\n\t(b + a = c + a \u2194 b = c)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_monoid M] {a b c : M}, is_add_unit a \u2192 (b + a = c + a \u2194 b = c)", "decl_nm": "is_add_unit.add_left_inj", "nl_statement_of_codex": "Let $M$ be an additive monoid and let $a, b, c\\in M$. If $a$ is an additive unit, then $b+a=c+a$ if and only if $b=c$."}
{"formal_statement": "theorem comp_apply_eq\u2082 {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3' : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3 \u03c3'] {x : R\u2082} :\n\t\u21d1\u03c3 (\u21d1\u03c3' x) = x", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3 : R\u2081 \u2192+* R\u2082} {\u03c3' : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3 \u03c3'] {x : R\u2082}, \u21d1\u03c3 (\u21d1\u03c3' x) = x", "decl_nm": "ring_hom_inv_pair.comp_apply_eq\u2082", "nl_statement_of_codex": "Let $R_1$ and $R_2$ be semirings and let $\\sigma:R_1\\to R_2$ and $\\sigma':R_2\\to R_1$ be a ring homomorphism and its inverse. Then $\\sigma'(\\sigma(x))=x$ for all $x\\in R_2$."}
{"formal_statement": "theorem div_left_inj' {G\u2080 : Type*} [group_with_zero G\u2080] {a b c : G\u2080} (hc : c \u2260 0) :\n\t(a / c = b / c \u2194 a = b)", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] {a b c : G\u2080}, c \u2260 0 \u2192 (a / c = b / c \u2194 a = b)", "decl_nm": "div_left_inj'", "nl_statement_of_codex": "Let $G$ be a group with zero. Then for all $a,b,c\\in G$ with $c\\neq 0$, we have $a/c=b/c$ if and only if $a=b$."}
{"formal_statement": "theorem comp_apply {k V1 P1 V2 P2 V3 P3 : Type*} [ring k] [add_comm_group V1]\n\t[module k V1] [add_torsor V1 P1] [add_comm_group V2] [module k V2] [add_torsor V2 P2]\n\t[add_comm_group V3] [module k V3] [add_torsor V3 P3] (f : P2 \u2192\u1d43[k] P3)\n\t(g : P1 \u2192\u1d43[k] P2) (p : P1) :\n\t\u21d1(f.comp g) p = \u21d1f (\u21d1g p)", "decl_tp": "\u2200 {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} {V3 : Type u_6} {P3 : Type u_7} [_inst_1 : ring k] [_inst_2 : add_comm_group V1] [_inst_3 : module k V1] [_inst_4 : add_torsor V1 P1] [_inst_5 : add_comm_group V2] [_inst_6 : module k V2] [_inst_7 : add_torsor V2 P2] [_inst_8 : add_comm_group V3] [_inst_9 : module k V3] [_inst_10 : add_torsor V3 P3] (f : P2 \u2192\u1d43[k] P3) (g : P1 \u2192\u1d43[k] P2) (p : P1), \u21d1(f.comp g) p = \u21d1f (\u21d1g p)", "decl_nm": "affine_map.comp_apply", "nl_statement_of_codex": "Let $k$ be a ring, $V_1, V_2, V_3$ be $k$-modules, and $P_1, P_2, P_3$ be $k$-torsors over $V_1, V_2, V_3$, respectively. Let $f:P_2\\to P_3$ and $g:P_1\\to P_2$ be $k$-linear maps. Then $(f\\circ g)(p)=f(g(p))$ for all $p\\in P_1$."}
{"formal_statement": "theorem smul_of_tower_mem {S : Type u'} {R : Type u} {M : Type v} [monoid R]\n\t[mul_action R M] [has_scalar S R] [has_scalar S M] [is_scalar_tower S R M]\n\t(p : sub_mul_action R M) (s : S) {x : M} (h : x \u2208 p) :\n\ts \u2022 x \u2208 p", "decl_tp": "\u2200 {S : Type u'} {R : Type u} {M : Type v} [_inst_1 : monoid R] [_inst_2 : mul_action R M] [_inst_3 : has_scalar S R] [_inst_4 : has_scalar S M] [_inst_5 : is_scalar_tower S R M] (p : sub_mul_action R M) (s : S) {x : M}, x \u2208 p \u2192 s \u2022 x \u2208 p", "decl_nm": "sub_mul_action.smul_of_tower_mem", "nl_statement_of_codex": "Let $R$ be a monoid, $M$ be an $R$-module, and $S$ be a monoid. Suppose that $S$ acts on $R$ and $M$ by scalar multiplication. If $p$ is a sub-$R$-module of $M$, then $s\\cdot x\\in p$ for all $s\\in S$ and $x\\in p$."}
{"formal_statement": "theorem prod_sum_index {\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} [dec : decidable_eq \u03b9]\n\t{\u03b9\u2081 : Type u\u2081} [decidable_eq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [\u03a0 (i\u2081 : \u03b9\u2081), has_zero (\u03b2\u2081 i\u2081)]\n\t[\u03a0 (i : \u03b9\u2081) (x : \u03b2\u2081 i), decidable (x \u2260 0)] [\u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)]\n\t[\u03a0 (i : \u03b9) (x : \u03b2 i), decidable (x \u2260 0)] [comm_monoid \u03b3] {f : \u03a0\u2080 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081}\n\t{g : \u03a0 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081 \u2192 (\u03a0\u2080 (i : \u03b9), \u03b2 i)} {h : \u03a0 (i : \u03b9), \u03b2 i \u2192 \u03b3} :\n\t(\u2200 (i : \u03b9), h i 0 = 1) \u2192 (\u2200 (i : \u03b9) (b\u2081 b\u2082 : \u03b2 i), h i (b\u2081 + b\u2082) = h i b\u2081 * h i b\u2082) \u2192 (f.sum g).prod h = f.prod (\u03bb (i : \u03b9\u2081)\n\t(b : \u03b2\u2081 i), (g i b).prod h)", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b3 : Type w} {\u03b2 : \u03b9 \u2192 Type v} [dec : decidable_eq \u03b9] {\u03b9\u2081 : Type u\u2081} [_inst_1 : decidable_eq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [_inst_2 : \u03a0 (i\u2081 : \u03b9\u2081), has_zero (\u03b2\u2081 i\u2081)] [_inst_3 : \u03a0 (i : \u03b9\u2081) (x : \u03b2\u2081 i), decidable (x \u2260 0)] [_inst_4 : \u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)] [_inst_5 : \u03a0 (i : \u03b9) (x : \u03b2 i), decidable (x \u2260 0)] [_inst_6 : comm_monoid \u03b3] {f : \u03a0\u2080 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081} {g : \u03a0 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081 \u2192 (\u03a0\u2080 (i : \u03b9), \u03b2 i)} {h : \u03a0 (i : \u03b9), \u03b2 i \u2192 \u03b3}, (\u2200 (i : \u03b9), h i 0 = 1) \u2192 (\u2200 (i : \u03b9) (b\u2081 b\u2082 : \u03b2 i), h i (b\u2081 + b\u2082) = h i b\u2081 * h i b\u2082) \u2192 (f.sum g).prod h = f.prod (\u03bb (i : \u03b9\u2081) (b : \u03b2\u2081 i), (g i b).prod h)", "decl_nm": "dfinsupp.prod_sum_index", "nl_statement_of_codex": "Let $f:I_1\\to \\mathbb{N}$ and $g:I_1\\times I\\to \\mathbb{N}$ be functions. Let $h:I\\to \\mathbb{N}$ be a function such that $h(0)=1$ and $h(x+y)=h(x)h(y)$ for all $x,y\\in I$. Then $\\prod_{i\\in I_1} \\prod_{j\\in I} g(i,j)^{f(i)}=\\prod_{i\\in I_1} \\prod_{j\\in I} g(i,j"}
{"formal_statement": "theorem swap_binary_fan_lift {C : Type u} [category_theory.category C]\n\t{P Q : C} {t : category_theory.limits.binary_fan P Q} (I : category_theory.limits.is_limit t)\n\t(s : category_theory.limits.cone (category_theory.limits.pair Q P)) :\n\tI.swap_binary_fan.lift s = I.lift (category_theory.limits.binary_fan.swap s)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {P Q : C} {t : category_theory.limits.binary_fan P Q} (I : category_theory.limits.is_limit t) (s : category_theory.limits.cone (category_theory.limits.pair Q P)), I.swap_binary_fan.lift s = I.lift (category_theory.limits.binary_fan.swap s)", "decl_nm": "category_theory.limits.is_limit.swap_binary_fan_lift", "nl_statement_of_codex": "Let $C$ be a category, let $P$ and $Q$ be objects of $C$, let $t$ be a binary fan from $P$ to $Q$, and let $I$ be a limit of $t$. Let $s$ be a cone from $Q$ to $P$. Then the lift of $s$ along the binary fan $t$ is equal to the lift of the cone $s$ along the binary fan $t$."}
{"formal_statement": "theorem coe_one {\u03b1 : Type*} {l : filter \u03b1} {M : Type*} [has_one M] :\n\t\u21911 = 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : filter \u03b1} {M : Type u_5} [_inst_1 : has_one M], \u21911 = 1", "decl_nm": "filter.germ.coe_one", "nl_statement_of_codex": "The constant function $1:\\mathbb{N}\\to M$ is equal to the constant function $1:\\mathbb{N}\\to M$."}
{"formal_statement": "theorem pow {n a b : \u2124} (m : \u2115) (h : a \u2261 b [ZMOD n]) :\n\ta ^ m \u2261 b ^ m [ZMOD n]", "decl_tp": "\u2200 {n a b : \u2124} (m : \u2115), a \u2261 b [ZMOD n] \u2192 a ^ m \u2261 b ^ m [ZMOD n]", "decl_nm": "int.modeq.pow", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{Z}$ and $n\\in\\mathbb{N}$. If $a\\equiv b\\pmod{n}$, then $a^m\\equiv b^m\\pmod{n}$."}
{"formal_statement": "theorem lift_index_left {p : \u2115} [fact (nat.prime p)] {f : padic_seq p}\n\t(hf : \u00acf \u2248 0) (v1 v3 : \u2115) :\n\tpadic_norm p (\u21d1f (padic_seq.stationary_point hf)) = padic_norm p (\u21d1f (linear_order.max v1 (linear_order.max (padic_seq.stationary_point hf) v3)))", "decl_tp": "\u2200 {p : \u2115} [_inst_1 : fact (nat.prime p)] {f : padic_seq p} (hf : \u00acf \u2248 0) (v1 v3 : \u2115), padic_norm p (\u21d1f (padic_seq.stationary_point hf)) = padic_norm p (\u21d1f (linear_order.max v1 (linear_order.max (padic_seq.stationary_point hf) v3)))", "decl_nm": "padic_seq.lift_index_left", "nl_statement_of_codex": "Let $p$ be a prime number and let $f$ be a $p$-adic sequence. Then the $p$-adic norm of $f$ at the stationary point of $f$ is equal to the $p$-adic norm of $f$ at the maximum of the stationary point of $f$ and two other integers."}
{"formal_statement": "theorem mem_coe_subgroup {G : Type*} [group G] [topological_space G] {U : open_subgroup G}\n\t{g : G} :\n\tg \u2208 \u2191U \u2194 g \u2208 U", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] [_inst_2 : topological_space G] {U : open_subgroup G} {g : G}, g \u2208 \u2191U \u2194 g \u2208 U", "decl_nm": "open_subgroup.mem_coe_subgroup", "nl_statement_of_codex": "Let $G$ be a topological group and let $U$ be an open subgroup of $G$. Then $g\\in U$ if and only if $g\\in\\overline{U}$."}
{"formal_statement": "theorem eq_prime_pow_of_dvd_least_prime_pow {a p k : \u2115} (pp : nat.prime p)\n\t(h\u2081 : \u00aca \u2223 p ^ k) (h\u2082 : a \u2223 p ^ (k + 1)) :\n\ta = p ^ (k + 1)", "decl_tp": "\u2200 {a p k : \u2115}, nat.prime p \u2192 \u00aca \u2223 p ^ k \u2192 a \u2223 p ^ (k + 1) \u2192 a = p ^ (k + 1)", "decl_nm": "nat.eq_prime_pow_of_dvd_least_prime_pow", "nl_statement_of_codex": "Let $p$ be a prime and let $a, k$ be natural numbers. If $a$ does not divide $p^k$ but $a$ divides $p^{k+1}$, then $a=p^{k+1}$."}
{"formal_statement": "theorem comap_map_eq_of_injective {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t{f : M \u2192* N} (hf : function.injective \u21d1f) :\n\t\u2200 (S : submonoid M), submonoid.comap f (submonoid.map f S) = S", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] {f : M \u2192* N}, function.injective \u21d1f \u2192 \u2200 (S : submonoid M), submonoid.comap f (submonoid.map f S) = S", "decl_nm": "submonoid.comap_map_eq_of_injective", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity. Let $f:M\\to N$ be a monoid homomorphism. If $f$ is injective, then $f$ is a bijection between the submonoids of $M$ and $N$."}
{"formal_statement": "theorem xz_sub {a : \u2115} (a1 : 1 < a) {m n : \u2115} (h : n \u2264 m) :\n\tpell.xz a1 (m - n) = pell.xz a1 m * pell.xz a1 n - \u2191(d a1) * pell.yz a1 m * pell.yz a1 n", "decl_tp": "\u2200 {a : \u2115} (a1 : 1 < a) {m n : \u2115}, n \u2264 m \u2192 pell.xz a1 (m - n) = pell.xz a1 m * pell.xz a1 n - \u2191(d a1) * pell.yz a1 m * pell.yz a1 n", "decl_nm": "pell.xz_sub", "nl_statement_of_codex": "Let $a$ be a positive integer greater than $1$. Then for all non-negative integers $m$ and $n$ with $n\\leq m$, we have\n$$x_a(m-n)=x_a(m)x_a(n)-d_a y_a(m)y_a(n).$$"}
{"formal_statement": "theorem lift_on\u2082_mk {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} [setoid \u03b1] (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2)\n\t(h : \u2200 (a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1), a\u2081 \u2248 b\u2081 \u2192 a\u2082 \u2248 b\u2082 \u2192 f a\u2081 a\u2082 = f b\u2081 b\u2082) (x y : \u03b1) :\n\t\u27e6x\u27e7.lift_on\u2082 \u27e6y\u27e7 f h = f x y", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} [_inst_1 : setoid \u03b1] (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (h : \u2200 (a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1), a\u2081 \u2248 b\u2081 \u2192 a\u2082 \u2248 b\u2082 \u2192 f a\u2081 a\u2082 = f b\u2081 b\u2082) (x y : \u03b1), \u27e6x\u27e7.lift_on\u2082 \u27e6y\u27e7 f h = f x y", "decl_nm": "quotient.lift_on\u2082_mk", "nl_statement_of_codex": "Let $f:A\\times A\\to B$ be a function. Then $f$ is well-defined on the quotient $A/\\sim$ if and only if $f$ is well-defined on $A$."}
{"formal_statement": "theorem coe_empty {\u03b1 : Type*} [measurable_space \u03b1] :\n\t\u2191\u2205 = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1], \u2191\u2205 = \u2205", "decl_nm": "measurable_set.coe_empty", "nl_statement_of_codex": "The measurable space associated to the empty set is the empty set."}
{"formal_statement": "theorem forall_is_conj {\u03b1 : Type u} [monoid \u03b1] {p : conj_classes \u03b1 \u2192 Prop} :\n\t(\u2200 (a : conj_classes \u03b1), p a) \u2194 \u2200 (a : \u03b1), p (conj_classes.mk a)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] {p : conj_classes \u03b1 \u2192 Prop}, (\u2200 (a : conj_classes \u03b1), p a) \u2194 \u2200 (a : \u03b1), p (conj_classes.mk a)", "decl_nm": "conj_classes.forall_is_conj", "nl_statement_of_codex": "Let $\u03b1$ be a monoid. Then the following are equivalent:\n(1) For all $a\\in \u03b1$, $p(a)$ is true.\n(2) For all $a\\in \u03b1$, $p(a)$ is true."}
{"formal_statement": "theorem sub_mem_Icc_iff_right {\u03b1 : Type*} [ordered_add_comm_group \u03b1] {a b c d : \u03b1} :\n\ta - b \u2208 set.Icc c d \u2194 b \u2208 set.Icc (a - d) (a - c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_add_comm_group \u03b1] {a b c d : \u03b1}, a - b \u2208 set.Icc c d \u2194 b \u2208 set.Icc (a - d) (a - c)", "decl_nm": "set.sub_mem_Icc_iff_right", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of an ordered abelian group. Then $a-b\\in[c,d]$ if and only if $b\\in[a-d,a-c]$."}
{"formal_statement": "theorem to_equiv_fun {X Y : Type u} (i : X \u2245 Y) :\n\t\u21d1(i.to_equiv) = i.hom", "decl_tp": "\u2200 {X Y : Type u} (i : X \u2245 Y), \u21d1(i.to_equiv) = i.hom", "decl_nm": "category_theory.iso.to_equiv_fun", "nl_statement_of_codex": "The function associated to an isomorphism is the isomorphism."}
{"formal_statement": "theorem add_lt_add_left {\u03b1 : Type*} [has_add \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_lt.lt]\n\t{b c : \u03b1} (bc : b < c) :\n\t\u2200 (a : \u03b1), a + b < a + c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_add \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_lt.lt] {b c : \u03b1}, b < c \u2192 \u2200 (a : \u03b1), a + b < a + c", "decl_nm": "add_lt_add_left", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linearly ordered set. If $b<c$, then $a+b<a+c$."}
{"formal_statement": "theorem repeat_zero {\u03b1 : Type*} (a : \u03b1) :\n\tmultiset.repeat a 0 = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} (a : \u03b1), multiset.repeat a 0 = 0", "decl_nm": "multiset.repeat_zero", "nl_statement_of_codex": "The multiset $\\{a\\}^0$ is the empty multiset."}
{"formal_statement": "theorem continuous_on {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} {s : set E} (h : differentiable_on \ud835\udd5c f s) :\n\tcontinuous_on f s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {s : set E}, differentiable_on \ud835\udd5c f s \u2192 continuous_on f s", "decl_nm": "differentiable_on.continuous_on", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be differentiable on $s\\subset E$. Then $f$ is continuous on $s$."}
{"formal_statement": "theorem prod_eq_bot {R : Type*} [comm_ring R] [is_domain R] {s : multiset (ideal R)} :\n\ts.prod = \u22a5 \u2194 \u2203 (I : ideal R) (H : I \u2208 s), I = \u22a5", "decl_tp": "\u2200 {R : Type u_1} [_inst_2 : comm_ring R] [_inst_3 : is_domain R] {s : multiset (ideal R)}, s.prod = \u22a5 \u2194 \u2203 (I : ideal R) (H : I \u2208 s), I = \u22a5", "decl_nm": "ideal.prod_eq_bot", "nl_statement_of_codex": "Let $R$ be a domain. Then the product of a multiset of ideals of $R$ is zero if and only if one of the ideals is zero."}
{"formal_statement": "theorem nearest_pt_zero {\u03b1 : Type*} [measurable_space \u03b1] [emetric_space \u03b1]\n\t[opens_measurable_space \u03b1] (e : \u2115 \u2192 \u03b1) :\n\tmeasure_theory.simple_func.nearest_pt e 0 = measure_theory.simple_func.const \u03b1 (e 0)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] [_inst_2 : emetric_space \u03b1] [_inst_3 : opens_measurable_space \u03b1] (e : \u2115 \u2192 \u03b1), measure_theory.simple_func.nearest_pt e 0 = measure_theory.simple_func.const \u03b1 (e 0)", "decl_nm": "measure_theory.simple_func.nearest_pt_zero", "nl_statement_of_codex": "The nearest point to $0$ of a sequence of measurable sets $e$ is the constant function with value $e(0)$."}
{"formal_statement": "theorem dist_lt_coe {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x y : \u03b1} {c : nnreal} :\n\thas_dist.dist x y < \u2191c \u2194 has_nndist.nndist x y < c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x y : \u03b1} {c : nnreal}, has_dist.dist x y < \u2191c \u2194 has_nndist.nndist x y < c", "decl_nm": "dist_lt_coe", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $x,y\\in X$. Then $d(x,y)<c$ if and only if $\\hat{d}(x,y)<c$."}
{"formal_statement": "theorem inv {G \u03b1 : Type*} [has_inv G] [measurable_space G] [has_measurable_inv G]\n\t[measurable_space \u03b1] {f : \u03b1 \u2192 G} {\u03bc : measure_theory.measure \u03b1} (hf : ae_measurable f \u03bc) :\n\tae_measurable (\u03bb (x : \u03b1), (f x)\u207b\u00b9) \u03bc", "decl_tp": "\u2200 {G : Type u_1} {\u03b1 : Type u_2} [_inst_1 : has_inv G] [_inst_2 : measurable_space G] [_inst_3 : has_measurable_inv G] [_inst_4 : measurable_space \u03b1] {f : \u03b1 \u2192 G} {\u03bc : measure_theory.measure \u03b1}, ae_measurable f \u03bc \u2192 ae_measurable (\u03bb (x : \u03b1), (f x)\u207b\u00b9) \u03bc", "decl_nm": "ae_measurable.inv", "nl_statement_of_codex": "Let $G$ be a group and let $f:X\\to G$ be a measurable function. Then the function $g:X\\to G$ defined by $g(x)=f(x)^{-1}$ is measurable."}
{"formal_statement": "theorem comap_top {G : Type*} [add_group G] {N : Type*} [add_group N] (f : G \u2192+ N) :\n\tadd_subgroup.comap f \u22a4 = \u22a4", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {N : Type u_3} [_inst_3 : add_group N] (f : G \u2192+ N), add_subgroup.comap f \u22a4 = \u22a4", "decl_nm": "add_subgroup.comap_top", "nl_statement_of_codex": "Let $G$ and $N$ be abelian groups and let $f:G\\to N$ be a homomorphism. Then the image of the trivial subgroup of $G$ under $f$ is the trivial subgroup of $N$."}
{"formal_statement": "theorem face_points' {k V P : Type*} [ring k] [add_comm_group V] [module k V]\n\t[add_torsor V P] {n : \u2115} (s : affine.simplex k P n) {fs : finset (fin (n + 1))}\n\t{m : \u2115} (h : fs.card = m + 1) :\n\t(s.face h).points = s.points \u2218 \u21d1(fs.order_emb_of_fin h)", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [_inst_4 : add_torsor V P] {n : \u2115} (s : affine.simplex k P n) {fs : finset (fin (n + 1))} {m : \u2115} (h : fs.card = m + 1), (s.face h).points = s.points \u2218 \u21d1(fs.order_emb_of_fin h)", "decl_nm": "affine.simplex.face_points'", "nl_statement_of_codex": "Let $s$ be an affine simplex in $P$ and let $fs$ be a finite set of $n+1$ elements. Let $m$ be the cardinality of $fs$. Then the points of the face of $s$ corresponding to $fs$ are the points of $s$ in the order given by $fs$."}
{"formal_statement": "theorem add_tprod_coeff {\u03b9 : Type*} [decidable_eq \u03b9] {R : Type*} [comm_semiring R]\n\t{s : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), add_comm_monoid (s i)] [\u03a0 (i : \u03b9), module R (s i)]\n\t(z : R) (f : \u03a0 (i : \u03b9), s i) (i : \u03b9) (m\u2081 m\u2082 : s i) :\n\tpi_tensor_product.tprod_coeff R z (function.update f i m\u2081) + pi_tensor_product.tprod_coeff R z (function.update f i m\u2082) = pi_tensor_product.tprod_coeff R z (function.update f i (m\u2081 + m\u2082))", "decl_tp": "\u2200 {\u03b9 : Type u_1} [_inst_1 : decidable_eq \u03b9] {R : Type u_4} [_inst_4 : comm_semiring R] {s : \u03b9 \u2192 Type u_7} [_inst_5 : \u03a0 (i : \u03b9), add_comm_monoid (s i)] [_inst_6 : \u03a0 (i : \u03b9), module R (s i)] (z : R) (f : \u03a0 (i : \u03b9), s i) (i : \u03b9) (m\u2081 m\u2082 : s i), pi_tensor_product.tprod_coeff R z (function.update f i m\u2081) + pi_tensor_product.tprod_coeff R z (function.update f i m\u2082) = pi_tensor_product.tprod_coeff R z (function.update f i (m\u2081 + m\u2082))", "decl_nm": "pi_tensor_product.add_tprod_coeff", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $s$ be a family of add_comm_monoid, and let $f$ be a family of $R$-modules. Then the coefficient of $f(i)$ in the tensor product of $f$ is a module over $R$."}
{"formal_statement": "theorem fin_strongly_measurable_of_measurable {\u03b1 G : Type*} {p : ennreal}\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_group G]\n\t[measurable_space G] [borel_space G] [topological_space.second_countable_topology G]\n\t{f : \u03b1 \u2192 G} (hf : measure_theory.mem_\u2112p f p \u03bc) (hf_meas : measurable f)\n\t(hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u22a4) :\n\tmeasure_theory.fin_strongly_measurable f \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_2} {p : ennreal} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group G] [_inst_2 : measurable_space G] [_inst_3 : borel_space G] [_inst_4 : topological_space.second_countable_topology G] {f : \u03b1 \u2192 G}, measure_theory.mem_\u2112p f p \u03bc \u2192 measurable f \u2192 p \u2260 0 \u2192 p \u2260 \u22a4 \u2192 measure_theory.fin_strongly_measurable f \u03bc", "decl_nm": "measure_theory.mem_\u2112p.fin_strongly_measurable_of_measurable", "nl_statement_of_codex": "Let $f:X\\to G$ be a measurable function. If $f\\in L^p(X,\\mu)$ for some $p\\in (0,\\infty)$, then $f$ is finitely strongly measurable."}
{"formal_statement": "theorem powerset_card_bUnion {\u03b1 : Type*} [decidable_eq (finset \u03b1)] (s : finset \u03b1) :\n\ts.powerset = (finset.range (s.card + 1)).bUnion (\u03bb (i : \u2115), finset.powerset_len i s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq (finset \u03b1)] (s : finset \u03b1), s.powerset = (finset.range (s.card + 1)).bUnion (\u03bb (i : \u2115), finset.powerset_len i s)", "decl_nm": "finset.powerset_card_bUnion", "nl_statement_of_codex": "The power set of a finite set $S$ is the disjoint union of the sets $\\mathcal{P}_i(S)$ of subsets of $S$ of size $i$."}
{"formal_statement": "theorem mk_mul_mk {\u03b1 : Type*} [comm_monoid \u03b1] {x y : \u03b1} :\n\tassociates.mk x * associates.mk y = associates.mk (x * y)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {x y : \u03b1}, associates.mk x * associates.mk y = associates.mk (x * y)", "decl_nm": "associates.mk_mul_mk", "nl_statement_of_codex": "Let $R$ be a commutative monoid. Then the map $x\\mapsto [x]$ is a homomorphism from $R$ to the quotient $R/\\sim$."}
{"formal_statement": "theorem symm_to_ring_hom_comp_to_ring_hom {R S : Type*} [non_assoc_semiring R]\n\t[non_assoc_semiring S] (e : R \u2243+* S) :\n\te.symm.to_ring_hom.comp e.to_ring_hom = ring_hom.id R", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (e : R \u2243+* S), e.symm.to_ring_hom.comp e.to_ring_hom = ring_hom.id R", "decl_nm": "ring_equiv.symm_to_ring_hom_comp_to_ring_hom", "nl_statement_of_codex": "Let $R$ and $S$ be non-associative semirings and let $e:R\\to S$ be an isomorphism of non-associative semirings. Then $e^{-1}\\circ e=\\mathrm{id}_R$."}
{"formal_statement": "theorem tan_zero :\n\treal.tan 0 = 0", "decl_tp": "real.tan 0 = 0", "decl_nm": "real.tan_zero", "nl_statement_of_codex": "$\\tan(0)=0$."}
{"formal_statement": "theorem is_right_regular_of_mul_eq_one {R : Type*} {a b : R} [monoid R]\n\t(h : a * b = 1) :\n\tis_right_regular a", "decl_tp": "\u2200 {R : Type u_1} {a b : R} [_inst_1 : monoid R], a * b = 1 \u2192 is_right_regular a", "decl_nm": "is_right_regular_of_mul_eq_one", "nl_statement_of_codex": "Let $R$ be a monoid and let $a, b\\in R$. If $ab=1$, then $a$ is right regular."}
{"formal_statement": "theorem is_minimal_iff_closed_vadd_invariant (M : Type*) {\u03b1 : Type*} [add_monoid M]\n\t[topological_space \u03b1] [add_action M \u03b1] [topological_space M] [has_continuous_vadd M \u03b1] :\n\tadd_action.is_minimal M \u03b1 \u2194 \u2200 (s : set \u03b1), is_closed s \u2192 (\u2200 (c : M), c +\u1d65 s \u2286 s) \u2192 s = \u2205 \u2228 s = set.univ", "decl_tp": "\u2200 (M : Type u_1) {\u03b1 : Type u_3} [_inst_1 : add_monoid M] [_inst_3 : topological_space \u03b1] [_inst_4 : add_action M \u03b1] [_inst_6 : topological_space M] [_inst_7 : has_continuous_vadd M \u03b1], add_action.is_minimal M \u03b1 \u2194 \u2200 (s : set \u03b1), is_closed s \u2192 (\u2200 (c : M), c +\u1d65 s \u2286 s) \u2192 s = \u2205 \u2228 s = set.univ", "decl_nm": "is_minimal_iff_closed_vadd_invariant", "nl_statement_of_codex": "Let $M$ be a topological monoid acting continuously on a topological space $X$. Then $M$ is minimal if and only if for every closed subset $S$ of $X$, if $S$ is invariant under the action of $M$, then $S$ is either empty or the whole space."}
{"formal_statement": "theorem of_inverse {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1} (h : continuous f') (l_inv : function.left_inverse f f')\n\t(r_inv : function.right_inverse f f') :\n\tis_closed_map f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1}, continuous f' \u2192 function.left_inverse f f' \u2192 function.right_inverse f f' \u2192 is_closed_map f", "decl_nm": "is_closed_map.of_inverse", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f$ has a continuous inverse, then $f$ is a closed map."}
{"formal_statement": "theorem ext {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t{f g : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082} (h : \u21d1f = \u21d1g) :\n\tf = g", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] {f g : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082}, \u21d1f = \u21d1g \u2192 f = g", "decl_nm": "continuous_linear_equiv.ext", "nl_statement_of_codex": "Let $R_1, R_2$ be semirings, let $\\sigma_{12}:R_1\\to R_2$ and $\\sigma_{21}:R_2\\to R_1$ be ring homomorphisms such that $\\sigma_{12}\\circ\\sigma_{21}=\\sigma_{21}\\circ\\sigma_{12}=\\mathrm{id}$. Let $M_1, M_2$ be topological abelian monoids, let $f,g:M_1\\to M_2$ be continuous $R_1$-module homomorphisms. If $f=g$ as $R_2$-"}
{"formal_statement": "theorem obj_obj_obj {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t{F : C \u00d7 D \u2964 E} {X : C} {Y : D} :\n\t((category_theory.curry.obj F).obj X).obj Y = F.obj (X, Y)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] {F : C \u00d7 D \u2964 E} {X : C} {Y : D}, ((category_theory.curry.obj F).obj X).obj Y = F.obj (X, Y)", "decl_nm": "category_theory.curry.obj_obj_obj", "nl_statement_of_codex": "Let $C, D, E$ be categories and let $F:C\\times D\\to E$ be a functor. Then $F(X,Y)$ is the same as $(F_X)_Y$."}
{"formal_statement": "theorem Ici {\u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : antitone f) :\n\tmonotone (\u03bb (x : \u03b1), set.Ici (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, antitone f \u2192 monotone (\u03bb (x : \u03b1), set.Ici (f x))", "decl_nm": "antitone.Ici", "nl_statement_of_codex": "Let $f:X\\to Y$ be an antitone function. Then the function $g:X\\to \\mathcal{P}(Y)$ defined by $g(x)=\\{y\\in Y: y\\geq f(x)\\}$ is monotone."}
{"formal_statement": "theorem smul_left_cancel {\u03b1 : Type u} {\u03b2 : Type v} [monoid \u03b1] [mul_action \u03b1 \u03b2]\n\t{a : \u03b1} (ha : is_unit a) :\n\t\u2200 {x y : \u03b2}, a \u2022 x = a \u2022 y \u2194 x = y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : monoid \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] {a : \u03b1}, is_unit a \u2192 \u2200 {x y : \u03b2}, a \u2022 x = a \u2022 y \u2194 x = y", "decl_nm": "is_unit.smul_left_cancel", "nl_statement_of_codex": "Let $G$ be a monoid acting on a set $X$. Let $g\\in G$ be a unit. Then $g\\cdot x=g\\cdot y$ if and only if $x=y$."}
{"formal_statement": "theorem fiber_clopen {X : Type*} [topological_space X] (S : discrete_quotient X)\n\t(A : set \u21a5S) :\n\tis_clopen (S.proj \u207b\u00b9' A)", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] (S : discrete_quotient X) (A : set \u21a5S), is_clopen (S.proj \u207b\u00b9' A)", "decl_nm": "discrete_quotient.fiber_clopen", "nl_statement_of_codex": "Let $X$ be a topological space and let $S$ be a discrete quotient of $X$. Then the preimage of any clopen set in $S$ is clopen in $X$."}
{"formal_statement": "theorem convex_lt {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [linear_ordered_add_comm_monoid E]\n\t[ordered_add_comm_monoid \u03b2] [module \ud835\udd5c E] [ordered_smul \ud835\udd5c E] {s : set E}\n\t{f : E \u2192 \u03b2} (hf : monotone_on f s) (hs : convex \ud835\udd5c s) :\n\t\u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | f x < r}", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : linear_ordered_add_comm_monoid E] [_inst_3 : ordered_add_comm_monoid \u03b2] [_inst_4 : module \ud835\udd5c E] [_inst_5 : ordered_smul \ud835\udd5c E] {s : set E} {f : E \u2192 \u03b2}, monotone_on f s \u2192 convex \ud835\udd5c s \u2192 \u2200 (r : \u03b2), convex \ud835\udd5c {x \u2208 s | f x < r}", "decl_nm": "monotone_on.convex_lt", "nl_statement_of_codex": "Let $E$ be a real vector space, let $s$ be a convex subset of $E$, and let $f:E\\to\\mathbb{R}$ be a monotone function. Then for each $r\\in\\mathbb{R}$, the set $\\{x\\in s:f(x)<r\\}$ is convex."}
{"formal_statement": "theorem coe_to_nnreal {a : ennreal} (\u1fb0 : a \u2260 \u22a4) :\n\t\u2191(a.to_nnreal) = a", "decl_tp": "\u2200 {a : ennreal}, a \u2260 \u22a4 \u2192 \u2191(a.to_nnreal) = a", "decl_nm": "ennreal.coe_to_nnreal", "nl_statement_of_codex": "The natural number $n$ is equal to the extended natural number $n$ if $n$ is not $\\infty$."}
{"formal_statement": "theorem coe_coe_add_hom {\u03b1 : Type u} [add_monoid \u03b1] :\n\t\u21d1with_top.coe_add_hom = coe", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_monoid \u03b1], \u21d1with_top.coe_add_hom = coe", "decl_nm": "with_top.coe_coe_add_hom", "nl_statement_of_codex": "The map $f:\\mathbb{N}\\to\\mathbb{N}\\cup\\{\\infty\\}$ defined by $f(n)=n$ is a homomorphism of additive monoids."}
{"formal_statement": "theorem total_variation_zero {\u03b1 : Type*} [measurable_space \u03b1] :\n\t0.total_variation = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1], 0.total_variation = 0", "decl_nm": "measure_theory.signed_measure.total_variation_zero", "nl_statement_of_codex": "The total variation of the zero measure is zero."}
{"formal_statement": "theorem sum_eq_multiset_sum {\u03b2 : Type u} {\u03b1 : Type v} [add_comm_monoid \u03b2]\n\t(s : finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n\ts.sum (\u03bb (x : \u03b1), f x) = (multiset.map f s.val).sum", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : add_comm_monoid \u03b2] (s : finset \u03b1) (f : \u03b1 \u2192 \u03b2), s.sum (\u03bb (x : \u03b1), f x) = (multiset.map f s.val).sum", "decl_nm": "finset.sum_eq_multiset_sum", "nl_statement_of_codex": "Let $s$ be a finite set and let $f:s\\to \\beta$ be a function. Then $\\sum_{x\\in s}f(x)=\\sum_{x\\in s}f(x)$."}
{"formal_statement": "theorem map_neighbor_set_apply_coe {V : Type u} {W : Type v} {G : simple_graph V}\n\t{G' : simple_graph W} (f : G \u2243g G') (v : V) (w : \u21a5(G.neighbor_set v)) :\n\t\u2191(\u21d1(f.map_neighbor_set v) w) = \u21d1f \u2191w", "decl_tp": "\u2200 {V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G \u2243g G') (v : V) (w : \u21a5(G.neighbor_set v)), \u2191(\u21d1(f.map_neighbor_set v) w) = \u21d1f \u2191w", "decl_nm": "simple_graph.iso.map_neighbor_set_apply_coe", "nl_statement_of_codex": "Let $G$ and $G'$ be simple graphs and let $f:G\\to G'$ be a graph isomorphism. Let $v$ be a vertex of $G$ and let $w$ be a neighbor of $v$. Then $f(w)$ is a neighbor of $f(v)$."}
{"formal_statement": "theorem dgo_equiv_homological_complex_unit_iso_2 {\u03b2 : Type*} [add_comm_group \u03b2]\n\t(b : \u03b2) (V : Type*) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] :\n\t(homological_complex.dgo_equiv_homological_complex b V).unit_iso = homological_complex.dgo_equiv_homological_complex_unit_iso b V", "decl_tp": "\u2200 {\u03b2 : Type u_1} [_inst_1 : add_comm_group \u03b2] (b : \u03b2) (V : Type u_2) [_inst_2 : category_theory.category V] [_inst_3 : category_theory.limits.has_zero_morphisms V], (homological_complex.dgo_equiv_homological_complex b V).unit_iso = homological_complex.dgo_equiv_homological_complex_unit_iso b V", "decl_nm": "homological_complex.dgo_equiv_homological_complex_unit_iso_2", "nl_statement_of_codex": "Let $V$ be a category with zero morphisms and let $b$ be an element of an abelian group. Then the unit isomorphism of the derived functor of the global sections functor is the same as the unit isomorphism of the derived functor of the global sections functor."}
{"formal_statement": "theorem preimage_singleton_eq_empty {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}\n\t{y : \u03b2} :\n\tf \u207b\u00b9' {y} = \u2205 \u2194 y \u2209 set.range f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {y : \u03b2}, f \u207b\u00b9' {y} = \u2205 \u2194 y \u2209 set.range f", "decl_nm": "set.preimage_singleton_eq_empty", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function. Then $f^{-1}(\\{y\\})=\\emptyset$ if and only if $y\\notin f(X)$."}
{"formal_statement": "theorem map_fun {L : first_order.language} {M N : Type*} [L.Structure M]\n\t[L.Structure N] (\u03c6 : L.hom M N) {n : \u2115} (f : L.functions n) (x : fin n \u2192 M) :\n\t\u21d1\u03c6 (first_order.language.Structure.fun_map f x) = first_order.language.Structure.fun_map f (\u21d1\u03c6 \u2218 x)", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} {N : Type u_4} [_inst_1 : L.Structure M] [_inst_2 : L.Structure N] (\u03c6 : L.hom M N) {n : \u2115} (f : L.functions n) (x : fin n \u2192 M), \u21d1\u03c6 (first_order.language.Structure.fun_map f x) = first_order.language.Structure.fun_map f (\u21d1\u03c6 \u2218 x)", "decl_nm": "first_order.language.hom.map_fun", "nl_statement_of_codex": "Let $L$ be a first-order language, let $M$ and $N$ be $L$-structures, and let $\\phi:M\\to N$ be an $L$-homomorphism. Then for any $n$-ary function symbol $f$ of $L$ and any $n$-tuple $(x_1,\\ldots,x_n)$ of elements of $M$, we have $\\phi(f(x_1,\\ldots,x_n))=f(\\phi(x_1),\\ldots,\\phi(x_n))$."}
{"formal_statement": "theorem is_diag_diagonal {\u03b1 n : Type*} [has_zero \u03b1] [decidable_eq n] (d : n \u2192 \u03b1) :\n\t(matrix.diagonal d).is_diag", "decl_tp": "\u2200 {\u03b1 : Type u_1} {n : Type u_4} [_inst_1 : has_zero \u03b1] [_inst_2 : decidable_eq n] (d : n \u2192 \u03b1), (matrix.diagonal d).is_diag", "decl_nm": "matrix.is_diag_diagonal", "nl_statement_of_codex": "The diagonal matrix with diagonal entries $d_i$ is diagonal."}
{"formal_statement": "theorem prev_eq_some {\u03b9 : Type*} (c : complex_shape \u03b9) {i j : \u03b9} (h : c.rel i j) :\n\tc.prev j = option.some \u27e8i, h\u27e9", "decl_tp": "\u2200 {\u03b9 : Type u_1} (c : complex_shape \u03b9) {i j : \u03b9} (h : c.rel i j), c.prev j = option.some \u27e8i, h\u27e9", "decl_nm": "complex_shape.prev_eq_some", "nl_statement_of_codex": "Let $c$ be a complex shape. Then $c.prev(j)$ is defined and equal to $i$ if and only if $c.rel(i,j)$ holds."}
{"formal_statement": "theorem mul_inverse_cancel_right {M\u2080 : Type*} [monoid_with_zero M\u2080] (x y : M\u2080)\n\t(h : is_unit x) :\n\ty * x * ring.inverse x = y", "decl_tp": "\u2200 {M\u2080 : Type u_1} [_inst_1 : monoid_with_zero M\u2080] (x y : M\u2080), is_unit x \u2192 y * x * ring.inverse x = y", "decl_nm": "ring.mul_inverse_cancel_right", "nl_statement_of_codex": "Let $M$ be a monoid with zero. Let $x, y\\in M$. If $x$ is a unit, then $yx^{-1}=y$."}
{"formal_statement": "theorem restrict_of_comp_subtype {\u03b9 R A : Type*} {x : \u03b9 \u2192 A} [comm_ring R]\n\t[comm_ring A] [algebra R A] {s : set \u03b9} (hs : algebraic_independent R (x \u2218 coe)) :\n\talgebraic_independent R (set.restrict x s)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {R : Type u_3} {A : Type u_5} {x : \u03b9 \u2192 A} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_5 : algebra R A] {s : set \u03b9}, algebraic_independent R (x \u2218 coe) \u2192 algebraic_independent R (set.restrict x s)", "decl_nm": "algebraic_independent.restrict_of_comp_subtype", "nl_statement_of_codex": "Let $R$ be a commutative ring, $A$ be a commutative $R$-algebra, and $x:\\mathbb{N}\\to A$ be a sequence of elements of $A$. If $x$ is algebraically independent over $R$, then the restriction of $x$ to any subset of $\\mathbb{N}$ is algebraically independent over $R$."}
{"formal_statement": "theorem interval_swap {\u03b1 : Type u} [linear_order \u03b1] (a b : \u03b1) :\n\tset.interval a b = set.interval b a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] (a b : \u03b1), set.interval a b = set.interval b a", "decl_nm": "set.interval_swap", "nl_statement_of_codex": "The interval $[a,b]$ is equal to the interval $[b,a]$."}
{"formal_statement": "theorem symm_comp_self {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t[semi_normed_group E] [semi_normed_group E\u2082] [module R E] [module R\u2082 E\u2082]\n\t(e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\t\u21d1(e.symm) \u2218 \u21d1e = id", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_5 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_6 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082), \u21d1(e.symm) \u2218 \u21d1e = id", "decl_nm": "linear_isometry_equiv.symm_comp_self", "nl_statement_of_codex": "Let $R$ and $R_2$ be semirings, let $\\sigma_{12}:R\\to R_2$ and $\\sigma_{21}:R_2\\to R$ be ring homomorphisms such that $\\sigma_{12}\\circ\\sigma_{21}=\\sigma_{21}\\circ\\sigma_{12}=\\mathrm{id}$. Let $E$ and $E_2$ be semi-normed groups over $R$ and $R_2$, respectively, and let $e:E\\to E_2$ be an isomorphism of $R$-modules. Then $e^{-1}\\circ e=\\math"}
{"formal_statement": "theorem map_map_permutations_aux2 {\u03b1 \u03b1' : Type*} (g : \u03b1 \u2192 \u03b1') (t : \u03b1) (ts ys : list \u03b1) :\n\tlist.map (list.map g) (list.permutations_aux2 t ts list.nil ys id).snd = (list.permutations_aux2 (g t)\n\t(list.map g ts) list.nil (list.map g ys) id).snd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b1' : Type u_2} (g : \u03b1 \u2192 \u03b1') (t : \u03b1) (ts ys : list \u03b1), list.map (list.map g) (list.permutations_aux2 t ts list.nil ys id).snd = (list.permutations_aux2 (g t) (list.map g ts) list.nil (list.map g ys) id).snd", "decl_nm": "list.map_map_permutations_aux2", "nl_statement_of_codex": "Let $g: \\alpha\\to \\alpha'$ be a function. Let $t\\in \\alpha$ and let $ts, ys$ be lists of elements of $\\alpha$. Then the second component of the pair $(\\sigma, \\tau)$ obtained by applying the function $list.permutations_aux2$ to $t, ts, list.nil, ys, id$ is equal to the second component of the pair $(\\sigma', \\tau')$ obtained by applying the function $list.permutations_aux2$ to $g(t), list.map g(ts), list.nil, list.map g(ys), id$."}
{"formal_statement": "theorem div_mul_cancel_of_mod_eq_zero {a b : \u2124} (H : a % b = 0) :\n\ta / b * b = a", "decl_tp": "\u2200 {a b : \u2124}, a % b = 0 \u2192 a / b * b = a", "decl_nm": "int.div_mul_cancel_of_mod_eq_zero", "nl_statement_of_codex": "If $a$ is divisible by $b$, then $a/b\\cdot b=a$."}
{"formal_statement": "theorem eq_lim_at_left_extend_from_Ioo {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[linear_order \u03b1] [densely_ordered \u03b1] [order_topology \u03b1] [topological_space \u03b2]\n\t[t2_space \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1} {la : \u03b2} (hab : a < b) (ha : filter.tendsto f (nhds_within a (set.Ioi a))\n\t(nhds la)) :\n\textend_from (set.Ioo a b) f a = la", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : densely_ordered \u03b1] [_inst_4 : order_topology \u03b1] [_inst_5 : topological_space \u03b2] [_inst_6 : t2_space \u03b2] {f : \u03b1 \u2192 \u03b2} {a b : \u03b1} {la : \u03b2}, a < b \u2192 filter.tendsto f (nhds_within a (set.Ioi a)) (nhds la) \u2192 extend_from (set.Ioo a b) f a = la", "decl_nm": "eq_lim_at_left_extend_from_Ioo", "nl_statement_of_codex": "Let $f:A\\to B$ be a function from a dense subset $A$ of a linear order to a Hausdorff space $B$. Let $a,b\\in A$ with $a<b$. If $f$ converges to $l$ at $a$ from the right, then $f$ converges to $l$ at $a$ from the left."}
{"formal_statement": "theorem eq_of_perm_factors {a b : \u2115} (ha : 0 < a) (hb : 0 < b) (h : a.factors ~ b.factors) :\n\ta = b", "decl_tp": "\u2200 {a b : \u2115}, 0 < a \u2192 0 < b \u2192 a.factors ~ b.factors \u2192 a = b", "decl_nm": "nat.eq_of_perm_factors", "nl_statement_of_codex": "If $a$ and $b$ are positive integers and the multisets of prime factors of $a$ and $b$ are permutations of each other, then $a=b$."}
{"formal_statement": "theorem tsum_mul_left {\u03b1 : Type*} (a : nnreal) (f : \u03b1 \u2192 nnreal) :\n\t\u2211' (x : \u03b1), a * f x = a * \u2211' (x : \u03b1), f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} (a : nnreal) (f : \u03b1 \u2192 nnreal), \u2211' (x : \u03b1), a * f x = a * \u2211' (x : \u03b1), f x", "decl_nm": "nnreal.tsum_mul_left", "nl_statement_of_codex": "Let $a$ be a nonnegative real number and let $f$ be a function from a set $A$ to the nonnegative reals. Then\n$\\sum_{x\\in A} a\\cdot f(x)=a\\cdot\\sum_{x\\in A} f(x)$."}
{"formal_statement": "theorem right_inv_on_inv_fun_on {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} [nonempty \u03b1] (h : set.surj_on f s t) :\n\tset.right_inv_on (function.inv_fun_on f s) f t", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2} [_inst_1 : nonempty \u03b1], set.surj_on f s t \u2192 set.right_inv_on (function.inv_fun_on f s) f t", "decl_nm": "set.surj_on.right_inv_on_inv_fun_on", "nl_statement_of_codex": "Let $f:A\\to B$ be a surjective function. Then $f^{-1}:B\\to A$ is a right inverse of $f$."}
{"formal_statement": "theorem ext_of_Ioc {\u03b1 : Type*} [topological_space \u03b1] {m : measurable_space \u03b1}\n\t[topological_space.second_countable_topology \u03b1] [conditionally_complete_linear_order \u03b1]\n\t[order_topology \u03b1] [borel_space \u03b1] [no_bot_order \u03b1] (\u03bc \u03bd : measure_theory.measure \u03b1)\n\t[measure_theory.is_locally_finite_measure \u03bc] :\n\t(\u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u21d1\u03bc (set.Ioc a b) = \u21d1\u03bd (set.Ioc a b)) \u2192 \u03bc = \u03bd", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_18 : topological_space \u03b1] {m : measurable_space \u03b1} [_inst_19 : topological_space.second_countable_topology \u03b1] [_inst_20 : conditionally_complete_linear_order \u03b1] [_inst_21 : order_topology \u03b1] [_inst_22 : borel_space \u03b1] [_inst_23 : no_bot_order \u03b1] (\u03bc \u03bd : measure_theory.measure \u03b1) [_inst_24 : measure_theory.is_locally_finite_measure \u03bc], (\u2200 \u2983a b : \u03b1\u2984, a < b \u2192 \u21d1\u03bc (set.Ioc a b) = \u21d1\u03bd (set.Ioc a b)) \u2192 \u03bc = \u03bd", "decl_nm": "measure_theory.measure.ext_of_Ioc", "nl_statement_of_codex": "Let $X$ be a second countable topological space with a conditional complete linear order. Let $\\mu$ and $\\nu$ be locally finite measures on $X$. Then $\\mu=\\nu$ if and only if $\\mu(a,b)=\\nu(a,b)$ for all $a<b$."}
{"formal_statement": "theorem whiskering_left_map_app_app (C : Type u\u2081) [category_theory.category C]\n\t(D : Type u\u2082) [category_theory.category D] (E : Type u\u2083) [category_theory.category E]\n\t(F G : C \u2964 D) (\u03c4 : F \u27f6 G) (H : D \u2964 E) (c : C) :\n\t(((category_theory.whiskering_left C D E).map \u03c4).app H).app c = H.map (\u03c4.app c)", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] (D : Type u\u2082) [_inst_2 : category_theory.category D] (E : Type u\u2083) [_inst_3 : category_theory.category E] (F G : C \u2964 D) (\u03c4 : F \u27f6 G) (H : D \u2964 E) (c : C), (((category_theory.whiskering_left C D E).map \u03c4).app H).app c = H.map (\u03c4.app c)", "decl_nm": "category_theory.whiskering_left_map_app_app", "nl_statement_of_codex": "Let $C, D, E$ be categories and let $F, G:C\\to D$ and $H:D\\to E$ be functors. Let $\\tau:F\\to G$ be a natural transformation. Then for any object $c$ of $C$, the functor $(H\\circ \\tau)$ applied to $c$ is equal to the functor $H$ applied to the functor $\\tau$ applied to $c$."}
{"formal_statement": "theorem ext {R : Type u\u2081} [comm_semiring R] {p : \u2115} [hp : fact (nat.prime p)]\n\t[char_p R p] {f g : ring.perfection R p} :\n\t(\u2200 (n : \u2115), \u21d1(perfection.coeff R p n) f = \u21d1(perfection.coeff R p n) g) \u2192 f = g", "decl_tp": "\u2200 {R : Type u\u2081} [_inst_1 : comm_semiring R] {p : \u2115} [hp : fact (nat.prime p)] [_inst_2 : char_p R p] {f g : ring.perfection R p}, (\u2200 (n : \u2115), \u21d1(perfection.coeff R p n) f = \u21d1(perfection.coeff R p n) g) \u2192 f = g", "decl_nm": "perfection.ext", "nl_statement_of_codex": "Let $R$ be a commutative ring of characteristic $p$. Let $f,g:R\\to R$ be two $p$-th power series. Then $f=g$ if and only if $f(x)=g(x)$ for all $x\\in R$."}
{"formal_statement": "theorem eq_pow_of_mul_eq_pow_bit1_right {a b c : \u2124} (hab : is_coprime a b)\n\t(h : a * b = c ^ bit1 k) :\n\t\u2200 {k : \u2115},  (\u2203 (d : \u2124), b = d ^ bit1 k)", "decl_tp": "\u2200 {a b c : \u2124}, is_coprime a b \u2192 \u2200 {k : \u2115}, a * b = c ^ bit1 k \u2192 (\u2203 (d : \u2124), b = d ^ bit1 k)", "decl_nm": "int.eq_pow_of_mul_eq_pow_bit1_right", "nl_statement_of_codex": "Let $a,b,c\\in\\mathbb{Z}$ be coprime. If $ab=c^{2^k}$, then $b=d^{2^k}$ for some $d\\in\\mathbb{Z}$."}
{"formal_statement": "theorem eq_div_of_mul_eq' {G : Type u} [group G] {a b c : G} (h : a * c = b) :\n\ta = b / c", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] {a b c : G}, a * c = b \u2192 a = b / c", "decl_nm": "eq_div_of_mul_eq'", "nl_statement_of_codex": "Let $G$ be a group and let $a, b, c\\in G$. If $a\\cdot c=b$, then $a=b/c$."}
{"formal_statement": "theorem map_matrix_symm {m R : Type*} {\u03b1 : Type v} {\u03b2 : Type w} [fintype m]\n\t[decidable_eq m] [comm_semiring R] [semiring \u03b1] [semiring \u03b2] [algebra R \u03b1]\n\t[algebra R \u03b2] (f : \u03b1 \u2243\u2090[R] \u03b2) :\n\tf.map_matrix.symm = f.symm.map_matrix", "decl_tp": "\u2200 {m : Type u_2} {R : Type u_7} {\u03b1 : Type v} {\u03b2 : Type w} [_inst_1 : fintype m] [_inst_2 : decidable_eq m] [_inst_3 : comm_semiring R] [_inst_4 : semiring \u03b1] [_inst_5 : semiring \u03b2] [_inst_7 : algebra R \u03b1] [_inst_8 : algebra R \u03b2] (f : \u03b1 \u2243\u2090[R] \u03b2), f.map_matrix.symm = f.symm.map_matrix", "decl_nm": "alg_equiv.map_matrix_symm", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $\u03b1$ and $\u03b2$ be $R$-algebras, and let $f:\u03b1\\to \u03b2$ be an $R$-algebra isomorphism. Then the matrix of $f^{-1}$ is the transpose of the matrix of $f$."}
{"formal_statement": "theorem supr_inf_le_Sup_inf {\u03b1 : Type*} [complete_lattice \u03b1] {a : \u03b1} {s : set \u03b1} :\n\t(\u2a06 (b : \u03b1) (H : b \u2208 s), b \u2293 a) \u2264 has_Sup.Sup s \u2293 a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : complete_lattice \u03b1] {a : \u03b1} {s : set \u03b1}, (\u2a06 (b : \u03b1) (H : b \u2208 s), b \u2293 a) \u2264 has_Sup.Sup s \u2293 a", "decl_nm": "supr_inf_le_Sup_inf", "nl_statement_of_codex": "Let $s$ be a set of elements of a complete lattice $L$. Then $\\sup_{b\\in s}(b\\wedge a)\\leq \\sup s\\wedge a$."}
{"formal_statement": "theorem has_mul_mul_re {R : Type*} [comm_ring R] {c\u2081 c\u2082 : R} (a b : quaternion_algebra R c\u2081 c\u2082) :\n\t(a * b).re = a.re * b.re + c\u2081 * a.im_i * b.im_i + c\u2082 * a.im_j * b.im_j - c\u2081 * c\u2082 * a.im_k * b.im_k", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a b : quaternion_algebra R c\u2081 c\u2082), (a * b).re = a.re * b.re + c\u2081 * a.im_i * b.im_i + c\u2082 * a.im_j * b.im_j - c\u2081 * c\u2082 * a.im_k * b.im_k", "decl_nm": "quaternion_algebra.has_mul_mul_re", "nl_statement_of_codex": "The real part of the product of two quaternions is the sum of the product of the real parts, the product of the imaginary parts in the $i$-direction, the product of the imaginary parts in the $j$-direction, and the product of the imaginary parts in the $k$-direction."}
{"formal_statement": "theorem congr_apply {R\u2082 M\u2082 : Type*} [comm_semiring R\u2082] [add_comm_monoid M\u2082]\n\t[module R\u2082 M\u2082] {M\u2082' : Type*1} [add_comm_monoid M\u2082'] [module R\u2082 M\u2082'] (e : M\u2082 \u2243\u2097[R\u2082] M\u2082')\n\t(B : bilin_form R\u2082 M\u2082) (x y : M\u2082') :\n\t\u21d1(\u21d1(bilin_form.congr e) B) x y = \u21d1B (\u21d1(e.symm) x) (\u21d1(e.symm) y)", "decl_tp": "\u2200 {R\u2082 : Type u_5} {M\u2082 : Type u_6} [_inst_7 : comm_semiring R\u2082] [_inst_8 : add_comm_monoid M\u2082] [_inst_9 : module R\u2082 M\u2082] {M\u2082' : Type u_11} [_inst_16 : add_comm_monoid M\u2082'] [_inst_18 : module R\u2082 M\u2082'] (e : M\u2082 \u2243\u2097[R\u2082] M\u2082') (B : bilin_form R\u2082 M\u2082) (x y : M\u2082'), \u21d1(\u21d1(bilin_form.congr e) B) x y = \u21d1B (\u21d1(e.symm) x) (\u21d1(e.symm) y)", "decl_nm": "bilin_form.congr_apply", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M$ and $M'$ be $R$-modules. Let $e:M\\to M'$ be an isomorphism of $R$-modules.\nLet $B:M\\times M\\to R$ be a bilinear form. Then $B'(x,y)=B(e^{-1}(x),e^{-1}(y))$ is a bilinear form on $M'$."}
{"formal_statement": "theorem eq_of_prod_extend_right_ne {\u03b1\u2081 \u03b2\u2081 : Type*} [decidable_eq \u03b1\u2081] {e : equiv.perm \u03b2\u2081}\n\t{a a' : \u03b1\u2081} {b : \u03b2\u2081} (h : \u21d1(equiv.perm.prod_extend_right a e) (a', b) \u2260 (a', b)) :\n\ta' = a", "decl_tp": "\u2200 {\u03b1\u2081 : Type u_1} {\u03b2\u2081 : Type u_2} [_inst_1 : decidable_eq \u03b1\u2081] {e : equiv.perm \u03b2\u2081} {a a' : \u03b1\u2081} {b : \u03b2\u2081}, \u21d1(equiv.perm.prod_extend_right a e) (a', b) \u2260 (a', b) \u2192 a' = a", "decl_nm": "equiv.perm.eq_of_prod_extend_right_ne", "nl_statement_of_codex": "Let $e$ be a permutation of $\\beta_1$ and let $a, a'$ be elements of $\\alpha_1$. If $(a', b)$ is not in the image of the permutation $e$ extended by $a$, then $a'=a$."}
{"formal_statement": "theorem sigma_congr_right_trans {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} (F G : \u03a0 (a : \u03b1), equiv.perm (\u03b2 a)) :\n\tequiv.trans (equiv.perm.sigma_congr_right F) (equiv.perm.sigma_congr_right G) = equiv.perm.sigma_congr_right (\u03bb (a : \u03b1), equiv.trans (F a)\n\t(G a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : \u03b1 \u2192 Type u_2} (F G : \u03a0 (a : \u03b1), equiv.perm (\u03b2 a)), equiv.trans (equiv.perm.sigma_congr_right F) (equiv.perm.sigma_congr_right G) = equiv.perm.sigma_congr_right (\u03bb (a : \u03b1), equiv.trans (F a) (G a))", "decl_nm": "equiv.perm.sigma_congr_right_trans", "nl_statement_of_codex": "Let $F,G:\\alpha\\to\\mathrm{Perm}(\\beta)$ be two functions. Then the permutation of $\\beta$ induced by $F$ followed by the permutation of $\\beta$ induced by $G$ is the permutation of $\\beta$ induced by the function $a\\mapsto F(a)\\circ G(a)$."}
{"formal_statement": "theorem comp_map (V : Type v) [category_theory.category V] [category_theory.monoidal_category V]\n\t{C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083} [category_theory.enriched_category V C]\n\t[category_theory.enriched_category V D] [category_theory.enriched_category V E]\n\t(F : category_theory.enriched_functor V C D) (G : category_theory.enriched_functor V D E)\n\t(X Y : C) :\n\t(category_theory.enriched_functor.comp V F G).map X Y = F.map X Y \u226b G.map (F.obj X)\n\t(F.obj Y)", "decl_tp": "\u2200 (V : Type v) [_inst_1 : category_theory.category V] [_inst_2 : category_theory.monoidal_category V] {C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083} [_inst_4 : category_theory.enriched_category V C] [_inst_5 : category_theory.enriched_category V D] [_inst_6 : category_theory.enriched_category V E] (F : category_theory.enriched_functor V C D) (G : category_theory.enriched_functor V D E) (X Y : C), (category_theory.enriched_functor.comp V F G).map X Y = F.map X Y \u226b G.map (F.obj X) (F.obj Y)", "decl_nm": "category_theory.enriched_functor.comp_map", "nl_statement_of_codex": "Let $V$ be a monoidal category. Let $C, D, E$ be $V$-enriched categories. Let $F:C\\to D$ and $G:D\\to E$ be $V$-enriched functors. Then the composition $G\\circ F$ is given by $G\\circ F(X,Y)=F(X,Y)\\otimes G(FX,FY)$."}
{"formal_statement": "theorem top_\u03c3 {\u03b1 : Type*} :\n\tfilter.realizer.top.\u03c3 = unit", "decl_tp": "\u2200 {\u03b1 : Type u_1}, filter.realizer.top.\u03c3 = unit", "decl_nm": "filter.realizer.top_\u03c3", "nl_statement_of_codex": "The top filter on a type $\u03b1$ is the filter of all subsets of $\u03b1$."}
{"formal_statement": "theorem pi_div_two_pos :\n\t0 < real.pi / 2", "decl_tp": "0 < real.pi / 2", "decl_nm": "real.pi_div_two_pos", "nl_statement_of_codex": "$\\pi/2$ is positive."}
{"formal_statement": "theorem up_eq_up {\u03b1 : Type*} [encodable \u03b1] {a b : ulower \u03b1} :\n\ta.up = b.up \u2194 a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : encodable \u03b1] {a b : ulower \u03b1}, a.up = b.up \u2194 a = b", "decl_nm": "ulower.up_eq_up", "nl_statement_of_codex": "Let $a, b$ be lower ultrafilters on $\u03b1$. Then $a.up = b.up$ if and only if $a = b$."}
{"formal_statement": "theorem emb_domain_linear_map_apply {\u0393 R : Type*} [partial_order \u0393] [semiring R]\n\t{\u0393' : Type*} [partial_order \u0393'] (f : \u0393 \u21aao \u0393') (\u1fb0 : hahn_series \u0393 R) :\n\t\u21d1(hahn_series.emb_domain_linear_map f) \u1fb0 = hahn_series.emb_domain f \u1fb0", "decl_tp": "\u2200 {\u0393 : Type u_1} {R : Type u_2} [_inst_1 : partial_order \u0393] [_inst_2 : semiring R] {\u0393' : Type u_4} [_inst_5 : partial_order \u0393'] (f : \u0393 \u21aao \u0393') (\u1fb0 : hahn_series \u0393 R), \u21d1(hahn_series.emb_domain_linear_map f) \u1fb0 = hahn_series.emb_domain f \u1fb0", "decl_nm": "hahn_series.emb_domain_linear_map_apply", "nl_statement_of_codex": "Let $f: \\Gamma\\to \\Gamma'$ be an order-embedding. Then $f$ induces a linear map $f^*: \\mathbb{R}[\\Gamma]\\to \\mathbb{R}[\\Gamma']$ by $f^*(a)=a\\circ f$. If $\\alpha$ is a Hahn series over $\\Gamma$, then $f^*(\\alpha)=\\alpha\\circ f$."}
{"formal_statement": "theorem lt_succ {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : well_founded r) {x : \u03b1} :\n\t(\u2203 (y : \u03b1), r x y) \u2192 r x (wf.succ x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : well_founded r) {x : \u03b1}, (\u2203 (y : \u03b1), r x y) \u2192 r x (wf.succ x)", "decl_nm": "well_founded.lt_succ", "nl_statement_of_codex": "Let $r$ be a well-founded relation on a set $X$. Then for each $x\\in X$ there is a $y\\in X$ such that $x\\,r\\,y$."}
{"formal_statement": "theorem measurable_set_Ioo {\u03b1 : Type*} [topological_space \u03b1] [measurable_space \u03b1]\n\t[opens_measurable_space \u03b1] [linear_order \u03b1] [order_closed_topology \u03b1]\n\t{a b : \u03b1} :\n\tmeasurable_set (set.Ioo a b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : opens_measurable_space \u03b1] [_inst_16 : linear_order \u03b1] [_inst_17 : order_closed_topology \u03b1] {a b : \u03b1}, measurable_set (set.Ioo a b)", "decl_nm": "measurable_set_Ioo", "nl_statement_of_codex": "The set $(a,b)$ is measurable."}
{"formal_statement": "theorem abs_by_cases {\u03b1 : Type u} [has_neg \u03b1] [linear_order \u03b1] (P : \u03b1 \u2192 Prop)\n\t{a : \u03b1} (h1 : P a) (h2 : P (-a)) :\n\tP |a|", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_neg \u03b1] [_inst_2 : linear_order \u03b1] (P : \u03b1 \u2192 Prop) {a : \u03b1}, P a \u2192 P (-a) \u2192 P |a|", "decl_nm": "abs_by_cases", "nl_statement_of_codex": "Let $P$ be a property of elements of a linear order. If $P(a)$ and $P(-a)$ hold, then $P(|a|)$ holds."}
{"formal_statement": "theorem mul_left_surjective {G : Type u} [group G] (a : G) :\n\tfunction.surjective (has_mul.mul a)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] (a : G), function.surjective (has_mul.mul a)", "decl_nm": "mul_left_surjective", "nl_statement_of_codex": "The left multiplication by $a$ is surjective."}
{"formal_statement": "theorem inf_ae_iff {\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{f : filter \u03b1} :\n\t\u03bc.finite_at_filter (f \u2293 \u03bc.ae) \u2194 \u03bc.finite_at_filter f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : filter \u03b1}, \u03bc.finite_at_filter (f \u2293 \u03bc.ae) \u2194 \u03bc.finite_at_filter f", "decl_nm": "measure_theory.measure.finite_at_filter.inf_ae_iff", "nl_statement_of_codex": "Let $f$ be a filter on a measurable space $(X,\\mathcal{A})$ and let $\\mu$ be a measure on $\\mathcal{A}$. Then $\\mu$ is finite on $f$ if and only if $\\mu$ is finite on $f\\cap\\mathcal{N}$, where $\\mathcal{N}$ is the set of $\\mu$-null sets."}
{"formal_statement": "theorem tendsto_at_bot_at_bot_iff_of_monotone {\u03b1 \u03b2 : Type*} [nonempty \u03b1]\n\t[semilattice_inf \u03b1] [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : monotone f) :\n\t(filter.tendsto f filter.at_bot filter.at_bot \u2194 \u2200 (b : \u03b2), \u2203 (a : \u03b1), f a \u2264 b)", "decl_tp": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : nonempty \u03b1] [_inst_2 : semilattice_inf \u03b1] [_inst_3 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, monotone f \u2192 (filter.tendsto f filter.at_bot filter.at_bot \u2194 \u2200 (b : \u03b2), \u2203 (a : \u03b1), f a \u2264 b)", "decl_nm": "filter.tendsto_at_bot_at_bot_iff_of_monotone", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function between partially ordered sets. Then $f$ tends to $-\\infty$ if and only if for every $b\\in B$ there is an $a\\in A$ such that $f(a)\\leq b$."}
{"formal_statement": "theorem const_inv {\u03b1 \u03b2 : Type*} [has_inv \u03b2] (a : \u03b2) :\n\t(function.const \u03b1 a)\u207b\u00b9 = function.const \u03b1 a\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_inv \u03b2] (a : \u03b2), (function.const \u03b1 a)\u207b\u00b9 = function.const \u03b1 a\u207b\u00b9", "decl_nm": "pi.const_inv", "nl_statement_of_codex": "The inverse of a constant function is the constant function with the inverse of the constant."}
{"formal_statement": "theorem coe_def_rev {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n\te.to_continuous_linear_map = \u2191e", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082), e.to_continuous_linear_map = \u2191e", "decl_nm": "continuous_linear_equiv.coe_def_rev", "nl_statement_of_codex": "Let $R_1, R_2$ be semirings, let $\\sigma_{12}:R_1\\to R_2$ be a ring homomorphism, and let $\\sigma_{21}:R_2\\to R_1$ be its inverse. Let $M_1$ and $M_2$ be modules over $R_1$ and $R_2$, respectively. Then the map $e:M_1\\to M_2$ is a continuous linear map if and only if $e$ is a semilinear map."}
{"formal_statement": "theorem gcd_dvd_gcd_mul_right (m n k : \u2115) :\n\tm.gcd n \u2223 (m * k).gcd n", "decl_tp": "\u2200 (m n k : \u2115), m.gcd n \u2223 (m * k).gcd n", "decl_nm": "nat.gcd_dvd_gcd_mul_right", "nl_statement_of_codex": "$\\gcd(m,n)$ divides $\\gcd(mk,n)$."}
{"formal_statement": "theorem integral_comp_mul_deriv {a b : \u211d} {f f' g : \u211d \u2192 \u211d} (h' : continuous_on f' (set.interval a b))\n\t(hg : continuous g) :\n\t(\u2200 (x : \u211d), x \u2208 set.interval a b \u2192 has_deriv_at f (f' x) x) \u2192   \u222b (x : \u211d) in a..b, (g \u2218 f) x * f' x = \u222b (x : \u211d) in f a..f b, g x", "decl_tp": "\u2200 {a b : \u211d} {f f' g : \u211d \u2192 \u211d}, (\u2200 (x : \u211d), x \u2208 set.interval a b \u2192 has_deriv_at f (f' x) x) \u2192 continuous_on f' (set.interval a b) \u2192 continuous g \u2192 \u222b (x : \u211d) in a..b, (g \u2218 f) x * f' x = \u222b (x : \u211d) in f a..f b, g x", "decl_nm": "interval_integral.integral_comp_mul_deriv", "nl_statement_of_codex": "Let $f, f', g: \\mathbb{R}\\to \\mathbb{R}$ be continuous functions. If $f'$ is continuous on $[a,b]$ and $f$ is differentiable on $[a,b]$, then $\\int_a^b g(f(x))f'(x)dx = \\int_{f(a)}^{f(b)} g(x)dx$."}
{"formal_statement": "theorem continuous_sigma {\u03b2 : Type v} {\u03b9 : Type*} {\u03c3 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), topological_space (\u03c3 i)]\n\t[topological_space \u03b2] {f : sigma \u03c3 \u2192 \u03b2} :\n\t(\u2200 (i : \u03b9), continuous (\u03bb (a : \u03c3 i), f \u27e8i, a\u27e9)) \u2192 continuous f", "decl_tp": "\u2200 {\u03b2 : Type v} {\u03b9 : Type u_1} {\u03c3 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), topological_space (\u03c3 i)] [_inst_2 : topological_space \u03b2] {f : sigma \u03c3 \u2192 \u03b2}, (\u2200 (i : \u03b9), continuous (\u03bb (a : \u03c3 i), f \u27e8i, a\u27e9)) \u2192 continuous f", "decl_nm": "continuous_sigma", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a topological space. Let $f:X\\to Y$ be a function. If $f$ is continuous, then $f$ is continuous."}
{"formal_statement": "theorem eq_inv_of_inv_hom_id {C : Type u} [category_theory.category C]\n\t{X Y : C} {f : X \u27f6 Y} [category_theory.is_iso f] {g : Y \u27f6 X} (inv_hom_id : g \u226b f = \ud835\udfd9 Y) :\n\tg = category_theory.inv f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f : X \u27f6 Y} [_inst_2 : category_theory.is_iso f] {g : Y \u27f6 X}, g \u226b f = \ud835\udfd9 Y \u2192 g = category_theory.inv f", "decl_nm": "category_theory.is_iso.eq_inv_of_inv_hom_id", "nl_statement_of_codex": "Let $C$ be a category and let $f:X\\to Y$ be an isomorphism. If $g:Y\\to X$ is a morphism such that $g\\circ f=\\mathrm{id}_Y$, then $g=f^{-1}$."}
{"formal_statement": "theorem nth_stream_fr_nonneg {K : Type*} {v : K} {n : \u2115} [linear_ordered_field K]\n\t[floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K}\n\t(nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) :\n\t0 \u2264 ifp_n.fr", "decl_tp": "\u2200 {K : Type u_1} {v : K} {n : \u2115} [_inst_1 : linear_ordered_field K] [_inst_2 : floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K}, generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n \u2192 0 \u2264 ifp_n.fr", "decl_nm": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg", "nl_statement_of_codex": "Let $K$ be a linear ordered field with floor function. Let $v\\in K$ and $n\\in\\mathbb{N}$. Let $ifp_n$ be the $n$-th convergent of $v$. Then $ifp_n.fr\\geq 0$."}
{"formal_statement": "theorem iterate_add {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) (m n : \u2115) :\n\tf^[m + n] = f^[m] \u2218 (f^[n])", "decl_tp": "\u2200 {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) (m n : \u2115), f^[m + n] = f^[m] \u2218 (f^[n])", "decl_nm": "function.iterate_add", "nl_statement_of_codex": "Let $f:A\\to A$ be a function. Then $f^{m+n}=f^m\\circ f^n$."}
{"formal_statement": "theorem mul_left_eq_zero_iff {R : Type u} [semiring R] {p : polynomial R}\n\t(h : p.monic) :\n\t\u2200 {q : polynomial R}, q * p = 0 \u2194 q = 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {p : polynomial R}, p.monic \u2192 \u2200 {q : polynomial R}, q * p = 0 \u2194 q = 0", "decl_nm": "polynomial.monic.mul_left_eq_zero_iff", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a monic polynomial. Then $qp=0$ if and only if $q=0$."}
{"formal_statement": "theorem duplicate_iff_two_le_count {\u03b1 : Type*} {l : list \u03b1} {x : \u03b1} [decidable_eq \u03b1] :\n\tlist.duplicate x l \u2194 2 \u2264 list.count x l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l : list \u03b1} {x : \u03b1} [_inst_1 : decidable_eq \u03b1], list.duplicate x l \u2194 2 \u2264 list.count x l", "decl_nm": "list.duplicate_iff_two_le_count", "nl_statement_of_codex": "Let $l$ be a list of elements of $A$ and let $x\\in A$. Then $x$ occurs at least twice in $l$ if and only if $x$ occurs at least twice in $l$."}
{"formal_statement": "theorem self_inv_act_eq_iff_eq {R : Type*} [rack R] {x y : R} :\n\track.inv_act x x = rack.inv_act y y \u2194 x = y", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : rack R] {x y : R}, rack.inv_act x x = rack.inv_act y y \u2194 x = y", "decl_nm": "rack.self_inv_act_eq_iff_eq", "nl_statement_of_codex": "Let $R$ be a rack. Then $x$ and $y$ are equal if and only if $x\\triangleright x=y\\triangleright y$."}
{"formal_statement": "theorem irrational_rat_mul_iff {q : \u211a} {x : \u211d} :\n\tirrational (\u2191q * x) \u2194 q \u2260 0 \u2227 irrational x", "decl_tp": "\u2200 {q : \u211a} {x : \u211d}, irrational (\u2191q * x) \u2194 q \u2260 0 \u2227 irrational x", "decl_nm": "irrational_rat_mul_iff", "nl_statement_of_codex": "Let $q$ be a rational number and $x$ be a real number. Then $qx$ is irrational if and only if $q\\neq 0$ and $x$ is irrational."}
{"formal_statement": "theorem equiv_fn_of_discrete_symm_apply_to_fun (\u03b1 \u03b2 : Type*) [topological_space \u03b1]\n\t[topological_space \u03b2] [discrete_topology \u03b1] (f : \u03b1 \u2192 \u03b2) (\u1fb0 : \u03b1) :\n\t\u21d1(\u21d1((continuous_map.equiv_fn_of_discrete \u03b1 \u03b2).symm) f) \u1fb0 = f \u1fb0", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u03b2 : Type u_2) [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_4 : discrete_topology \u03b1] (f : \u03b1 \u2192 \u03b2) (\u1fb0 : \u03b1), \u21d1(\u21d1((continuous_map.equiv_fn_of_discrete \u03b1 \u03b2).symm) f) \u1fb0 = f \u1fb0", "decl_nm": "continuous_map.equiv_fn_of_discrete_symm_apply_to_fun", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces $X$ and $Y$. If $X$ is discrete, then $f$ is continuous."}
{"formal_statement": "theorem induced_order_topology {\u03b1 : Type u} {\u03b2 : Type v} [partial_order \u03b1]\n\t[ta : topological_space \u03b2] [partial_order \u03b2] [order_topology \u03b2] (f : \u03b1 \u2192 \u03b2) :\n\t(\u2200 {x y : \u03b1}, f x < f y \u2194 x < y) \u2192 (\u2200 {x y : \u03b2}, x < y \u2192 (\u2203 (a : \u03b1), x < f a \u2227 f a < y)) \u2192 order_topology \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : partial_order \u03b1] [ta : topological_space \u03b2] [_inst_2 : partial_order \u03b2] [_inst_3 : order_topology \u03b2] (f : \u03b1 \u2192 \u03b2), (\u2200 {x y : \u03b1}, f x < f y \u2194 x < y) \u2192 (\u2200 {x y : \u03b2}, x < y \u2192 (\u2203 (a : \u03b1), x < f a \u2227 f a < y)) \u2192 order_topology \u03b1", "decl_nm": "induced_order_topology", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between partially ordered sets. If $f$ is order-preserving and for each $x<y$ in $Y$ there is $a\\in X$ such that $x<f(a)<y$, then the order topology on $X$ is the same as the topology induced by $f$."}
{"formal_statement": "theorem injective {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1] [pseudo_emetric_space \u03b2]\n\t(h : \u03b1 \u2243\u1d62 \u03b2) :\n\tfunction.injective \u21d1h", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2), function.injective \u21d1h", "decl_nm": "isometric.injective", "nl_statement_of_codex": "Let $h:X\\to Y$ be an isometry between pseudo-metric spaces $X$ and $Y$. Then $h$ is injective."}
{"formal_statement": "theorem of_nat_add_neg_succ_of_nat_of_lt {m n : \u2115} (h : m < n.succ) :\n\tint.of_nat m + -[1+ n] = -[1+ n - m]", "decl_tp": "\u2200 {m n : \u2115}, m < n.succ \u2192 int.of_nat m + -[1+ n] = -[1+ n - m]", "decl_nm": "int.of_nat_add_neg_succ_of_nat_of_lt", "nl_statement_of_codex": "Let $m,n$ be natural numbers. If $m<n+1$, then $m+-n=1-n+m$."}
{"formal_statement": "theorem le_add_congr {\u03b1 : Type u} {l\u2081 l\u2082 m\u2081 m\u2082 : language \u03b1} :\n\tl\u2081 \u2264 m\u2081 \u2192 l\u2082 \u2264 m\u2082 \u2192 l\u2081 + l\u2082 \u2264 m\u2081 + m\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {l\u2081 l\u2082 m\u2081 m\u2082 : language \u03b1}, l\u2081 \u2264 m\u2081 \u2192 l\u2082 \u2264 m\u2082 \u2192 l\u2081 + l\u2082 \u2264 m\u2081 + m\u2082", "decl_nm": "language.le_add_congr", "nl_statement_of_codex": "Let $l_1, l_2, m_1, m_2$ be languages. If $l_1\\leq m_1$ and $l_2\\leq m_2$, then $l_1+l_2\\leq m_1+m_2$."}
{"formal_statement": "theorem singleton_iff {\u03b1 : Type u} {L\u2081 : list (\u03b1 \u00d7 bool)} {x : \u03b1 \u00d7 bool} :\n\tfree_group.red [x] L\u2081 \u2194 L\u2081 = [x]", "decl_tp": "\u2200 {\u03b1 : Type u} {L\u2081 : list (\u03b1 \u00d7 bool)} {x : \u03b1 \u00d7 bool}, free_group.red [x] L\u2081 \u2194 L\u2081 = [x]", "decl_nm": "free_group.red.singleton_iff", "nl_statement_of_codex": "A list $L$ is reduced if and only if $L$ is a singleton."}
{"formal_statement": "theorem continuous_on_primitive_Icc {\u03b1 E : Type*} [linear_order \u03b1] [measurable_space \u03b1]\n\t[measurable_space E] [normed_group E] [topological_space.second_countable_topology E]\n\t[complete_space E] [normed_space \u211d E] [borel_space E] [topological_space \u03b1]\n\t[order_topology \u03b1] [opens_measurable_space \u03b1] [topological_space.first_countable_topology \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 E} {a b : \u03b1} [measure_theory.has_no_atoms \u03bc]\n\t(h_int : measure_theory.integrable_on f (set.Icc a b) \u03bc) :\n\tcontinuous_on (\u03bb (x : \u03b1), \u222b (t : \u03b1) in set.Icc a x, f t \u2202\u03bc) (set.Icc a b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_4} [_inst_1 : linear_order \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : topological_space.second_countable_topology E] [_inst_6 : complete_space E] [_inst_7 : normed_space \u211d E] [_inst_8 : borel_space E] [_inst_9 : topological_space \u03b1] [_inst_10 : order_topology \u03b1] [_inst_11 : opens_measurable_space \u03b1] [_inst_12 : topological_space.first_countable_topology \u03b1] {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 E} {a b : \u03b1} [_inst_13 : measure_theory.has_no_atoms \u03bc], measure_theory.integrable_on f (set.Icc a b) \u03bc \u2192 continuous_on (\u03bb (x : \u03b1), \u222b (t : \u03b1) in set.Icc a x, f t \u2202\u03bc) (set.Icc a b)", "decl_nm": "interval_integral.continuous_on_primitive_Icc", "nl_statement_of_codex": "Let $E$ be a complete normed space and let $f:I\\to E$ be a measurable function on an interval $I$. Then the function $F:I\\to E$ defined by $F(x)=\\int_a^x f(t)dt$ is continuous on $I$."}
{"formal_statement": "theorem inv_mul_self {G : Type u} [group G] (a : G) :\n\ta\u207b\u00b9 * a = 1", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] (a : G), a\u207b\u00b9 * a = 1", "decl_nm": "inv_mul_self", "nl_statement_of_codex": "For any group $G$ and any $a\\in G$, $a^{-1}a=1$."}
{"formal_statement": "theorem coe_prod_congr {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] [topological_space \u03b4] (h\u2081 : \u03b1 \u2243\u209c \u03b2) (h\u2082 : \u03b3 \u2243\u209c \u03b4) :\n\t\u21d1(h\u2081.prod_congr h\u2082) = prod.map \u21d1h\u2081 \u21d1h\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] [_inst_4 : topological_space \u03b4] (h\u2081 : \u03b1 \u2243\u209c \u03b2) (h\u2082 : \u03b3 \u2243\u209c \u03b4), \u21d1(h\u2081.prod_congr h\u2082) = prod.map \u21d1h\u2081 \u21d1h\u2082", "decl_nm": "homeomorph.coe_prod_congr", "nl_statement_of_codex": "The continuous map $f:X\\times Y\\to X'\\times Y'$ induced by the product of two homeomorphisms $f:X\\to X'$ and $g:Y\\to Y'$ is the product of the continuous maps induced by $f$ and $g$."}
{"formal_statement": "theorem le_refl (x : pgame) :\n\tx \u2264 x", "decl_tp": "\u2200 (x : pgame), x \u2264 x", "decl_nm": "pgame.le_refl", "nl_statement_of_codex": "For any positional game $x$, $x\\leq x$."}
{"formal_statement": "theorem ext {\u03b1 : Type u} {\u03b2 : Type v} [add_comm_group \u03b2] (g h : free_abelian_group \u03b1 \u2192+ \u03b2) :\n\t(\u2200 (x : \u03b1), \u21d1g (free_abelian_group.of x) = \u21d1h (free_abelian_group.of x)) \u2192 g = h", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : add_comm_group \u03b2] (g h : free_abelian_group \u03b1 \u2192+ \u03b2), (\u2200 (x : \u03b1), \u21d1g (free_abelian_group.of x) = \u21d1h (free_abelian_group.of x)) \u2192 g = h", "decl_nm": "free_abelian_group.lift.ext", "nl_statement_of_codex": "Let $g, h: \\mathbb{Z}^n\\to \\mathbb{Z}$ be additive group homomorphisms. Then $g=h$ if and only if $g(e_i)=h(e_i)$ for all $i=1,\\ldots,n$."}
{"formal_statement": "theorem range_inl_inter_range_inr {\u03b1 : Type u} {\u03b2 : Type v} :\n\tset.range sum.inl \u2229 set.range sum.inr = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v}, set.range sum.inl \u2229 set.range sum.inr = \u2205", "decl_nm": "set.range_inl_inter_range_inr", "nl_statement_of_codex": "The range of the left injection and the range of the right injection are disjoint."}
{"formal_statement": "theorem right_op_map {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] (F : C\u1d52\u1d56 \u2964 D) (X Y : C) (f : X \u27f6 Y) :\n\tF.right_op.map f = (F.map f.op).op", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C\u1d52\u1d56 \u2964 D) (X Y : C) (f : X \u27f6 Y), F.right_op.map f = (F.map f.op).op", "decl_nm": "category_theory.functor.right_op_map", "nl_statement_of_codex": "Let $F:C^{op}\\to D$ be a functor. Then $F$ is a functor from $C$ to $D^{op}$."}
{"formal_statement": "theorem cycle_factors_finset_eq_singleton {\u03b1 : Type*} [decidable_eq \u03b1]\n\t[fintype \u03b1] {f : equiv.perm \u03b1} (hf : f.is_cycle) :\n\tf.cycle_factors_finset = {f}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] {f : equiv.perm \u03b1}, f.is_cycle \u2192 f.cycle_factors_finset = {f}", "decl_nm": "equiv.perm.is_cycle.cycle_factors_finset_eq_singleton", "nl_statement_of_codex": "Let $f$ be a cycle on a finite set $X$. Then the set of cycle factors of $f$ is $\\{f\\}$."}
{"formal_statement": "theorem zeta_apply {x : \u2115} :\n\t\u21d1nat.arithmetic_function.zeta x = ite (x = 0) 0 1", "decl_tp": "\u2200 {x : \u2115}, \u21d1nat.arithmetic_function.zeta x = ite (x = 0) 0 1", "decl_nm": "nat.arithmetic_function.zeta_apply", "nl_statement_of_codex": "The Riemann zeta function is $1$ for all positive integers and $0$ for $0$."}
{"formal_statement": "theorem continuous_on_mul_of_subset {\u03b1 : Type*} [measurable_space \u03b1] [topological_space \u03b1]\n\t[opens_measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s t : set \u03b1}\n\t{f g : \u03b1 \u2192 \u211d} (hf : measure_theory.integrable_on f s \u03bc) (hg : continuous_on g t)\n\t(hs : measurable_set s) (ht : is_compact t) (hst : s \u2286 t) :\n\tmeasure_theory.integrable_on (\u03bb (x : \u03b1), g x * f x) s \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] [_inst_4 : topological_space \u03b1] [_inst_5 : opens_measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s t : set \u03b1} {f g : \u03b1 \u2192 \u211d}, measure_theory.integrable_on f s \u03bc \u2192 continuous_on g t \u2192 measurable_set s \u2192 is_compact t \u2192 s \u2286 t \u2192 measure_theory.integrable_on (\u03bb (x : \u03b1), g x * f x) s \u03bc", "decl_nm": "measure_theory.integrable_on.continuous_on_mul_of_subset", "nl_statement_of_codex": "Let $f,g:X\\to\\mathbb{R}$ be measurable functions on a measurable space $X$ and let $s,t\\subset X$ be measurable sets. Suppose that $f$ is integrable on $s$ and $g$ is continuous on $t$. If $s\\subset t$ and $t$ is compact, then $gf$ is integrable on $s$."}
{"formal_statement": "theorem subtype_domain_neg {\u03b1 G : Type*} [add_group G] {p : \u03b1 \u2192 Prop} {v : \u03b1 \u2192\u2080 G} :\n\tfinsupp.subtype_domain p (-v) = -finsupp.subtype_domain p v", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_9} [_inst_1 : add_group G] {p : \u03b1 \u2192 Prop} {v : \u03b1 \u2192\u2080 G}, finsupp.subtype_domain p (-v) = -finsupp.subtype_domain p v", "decl_nm": "finsupp.subtype_domain_neg", "nl_statement_of_codex": "Let $G$ be an additive group and let $v:\\alpha\\to G$ be a finitely supported function. Then the finitely supported function $-v$ is equal to the finitely supported function $-v$ restricted to the domain $p$."}
{"formal_statement": "theorem size_up_to_succ' {n : \u2115} (c : composition n) (i : fin c.length) :\n\tc.size_up_to (\u2191i + 1) = c.size_up_to \u2191i + c.blocks_fun i", "decl_tp": "\u2200 {n : \u2115} (c : composition n) (i : fin c.length), c.size_up_to (\u2191i + 1) = c.size_up_to \u2191i + c.blocks_fun i", "decl_nm": "composition.size_up_to_succ'", "nl_statement_of_codex": "Let $c$ be a composition of $n$. Then for any $i\\in\\{0,\\ldots,n-1\\}$, we have $c.size_up_to(i+1)=c.size_up_to(i)+c.blocks_fun(i)$."}
{"formal_statement": "theorem inv_mul' {G\u2080 : Type*} [group_with_zero G\u2080] (u : units G\u2080) :\n\t(\u2191u)\u207b\u00b9 * \u2191u = 1", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] (u : units G\u2080), (\u2191u)\u207b\u00b9 * \u2191u = 1", "decl_nm": "units.inv_mul'", "nl_statement_of_codex": "Let $G$ be a group with zero. Then the inverse of a unit $u$ is the unit $u^{-1}$."}
{"formal_statement": "theorem to_compl_apply {\u03b1 : Type*} [uniform_space \u03b1] [add_group \u03b1] [uniform_add_group \u03b1]\n\t(\u1fb0 : \u03b1) :\n\t\u21d1uniform_space.completion.to_compl \u1fb0 = \u2191\u1fb0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] [_inst_2 : add_group \u03b1] [_inst_3 : uniform_add_group \u03b1] (\u1fb0 : \u03b1), \u21d1uniform_space.completion.to_compl \u1fb0 = \u2191\u1fb0", "decl_nm": "uniform_space.completion.to_compl_apply", "nl_statement_of_codex": "The map $f:\\alpha\\to\\widehat{\\alpha}$ is the identity map."}
{"formal_statement": "theorem closure_eq_of_le {R : Type u} [ring R] {s : set R} {t : subring R}\n\t(h\u2081 : s \u2286 \u2191t) (h\u2082 : t \u2264 subring.closure s) :\n\tsubring.closure s = t", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {s : set R} {t : subring R}, s \u2286 \u2191t \u2192 t \u2264 subring.closure s \u2192 subring.closure s = t", "decl_nm": "subring.closure_eq_of_le", "nl_statement_of_codex": "Let $R$ be a ring and let $s$ be a subset of $R$. Let $t$ be a subring of $R$ such that $s\\subset t$ and $t$ is the smallest subring of $R$ containing $s$. Then $t$ is the closure of $s$."}
{"formal_statement": "theorem map_sublists'_aux {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (g : list \u03b2 \u2192 list \u03b3)\n\t(l : list \u03b1) (f : list \u03b1 \u2192 list \u03b2) (r : list (list \u03b2)) :\n\tlist.map g (l.sublists'_aux f r) = l.sublists'_aux (g \u2218 f) (list.map g r)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (g : list \u03b2 \u2192 list \u03b3) (l : list \u03b1) (f : list \u03b1 \u2192 list \u03b2) (r : list (list \u03b2)), list.map g (l.sublists'_aux f r) = l.sublists'_aux (g \u2218 f) (list.map g r)", "decl_nm": "list.map_sublists'_aux", "nl_statement_of_codex": "Let $l$ be a list of elements of type $\\alpha$, let $f$ be a function from lists of elements of type $\\alpha$ to lists of elements of type $\\beta$, and let $g$ be a function from lists of elements of type $\\beta$ to lists of elements of type $\\gamma$. Then the list of all lists of elements of type $\\gamma$ obtained by applying $g$ to the lists of elements of type $\\beta$ obtained by applying $f$ to the sublists of $l$ is equal to the list of all lists of elements of type $\\gamma$ obtained by applying $g$ to the lists of elements of type $\\beta$ obtained by applying $f$ to"}
{"formal_statement": "theorem image_image {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (g : \u03b2 \u2192 \u03b3)\n\t(f : \u03b1 \u2192 \u03b2) (s : set \u03b1) :\n\tg '' (f '' s) = (\u03bb (x : \u03b1), g (f x)) '' s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (s : set \u03b1), g '' (f '' s) = (\u03bb (x : \u03b1), g (f x)) '' s", "decl_nm": "set.image_image", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be functions. Then $g\\circ f:A\\to C$ is the function $g\\circ f(x)=g(f(x))$."}
{"formal_statement": "theorem upper_semicontinuous_on_univ_iff {\u03b1 : Type*} [topological_space \u03b1]\n\t{\u03b2 : Type*} [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n\tupper_semicontinuous_on f set.univ \u2194 upper_semicontinuous f", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, upper_semicontinuous_on f set.univ \u2194 upper_semicontinuous f", "decl_nm": "upper_semicontinuous_on_univ_iff", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Then $f$ is upper semicontinuous if and only if $f$ is upper semicontinuous on $X$."}
{"formal_statement": "theorem coe_center (G : Type*) [add_group G] :\n\t\u2191(add_subgroup.center G) = set.add_center G", "decl_tp": "\u2200 (G : Type u_1) [_inst_1 : add_group G], \u2191(add_subgroup.center G) = set.add_center G", "decl_nm": "add_subgroup.coe_center", "nl_statement_of_codex": "The center of a group $G$ is a subgroup of $G$."}
{"formal_statement": "theorem mod_two_ne_one {n : \u2115} :\n\t\u00acn % 2 = 1 \u2194 n % 2 = 0", "decl_tp": "\u2200 {n : \u2115}, \u00acn % 2 = 1 \u2194 n % 2 = 0", "decl_nm": "nat.mod_two_ne_one", "nl_statement_of_codex": "For any natural number $n$, $n$ is even if and only if $n$ is not odd."}
{"formal_statement": "theorem characteristic_iff_comap_le {G : Type*} [group G] {H : subgroup G} :\n\tH.characteristic \u2194 \u2200 (\u03d5 : G \u2243* G), subgroup.comap \u03d5.to_monoid_hom H \u2264 H", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H : subgroup G}, H.characteristic \u2194 \u2200 (\u03d5 : G \u2243* G), subgroup.comap \u03d5.to_monoid_hom H \u2264 H", "decl_nm": "subgroup.characteristic_iff_comap_le", "nl_statement_of_codex": "A subgroup $H$ of $G$ is characteristic if and only if for every isomorphism $\\phi:G\\to G$, $\\phi(H)\\leq H$."}
{"formal_statement": "theorem Ico_union_right {\u03b1 : Type u} [partial_order \u03b1] {a b : \u03b1} (hab : a \u2264 b) :\n\tset.Ico a b \u222a {b} = set.Icc a b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] {a b : \u03b1}, a \u2264 b \u2192 set.Ico a b \u222a {b} = set.Icc a b", "decl_nm": "set.Ico_union_right", "nl_statement_of_codex": "Let $a,b\\in\\alpha$ with $a\\leq b$. Then $[a,b)=\\{x\\in\\alpha\\mid a\\leq x<b\\}$ is equal to $[a,b]=\\{x\\in\\alpha\\mid a\\leq x\\leq b\\}$."}
{"formal_statement": "theorem univ_sigma_univ {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [fintype \u03b1] [\u03a0 (a : \u03b1), fintype (\u03b2 a)] :\n\tfinset.univ.sigma (\u03bb (a : \u03b1), finset.univ) = finset.univ", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : \u03b1 \u2192 Type u_2} [_inst_1 : fintype \u03b1] [_inst_2 : \u03a0 (a : \u03b1), fintype (\u03b2 a)], finset.univ.sigma (\u03bb (a : \u03b1), finset.univ) = finset.univ", "decl_nm": "finset.univ_sigma_univ", "nl_statement_of_codex": "Let $A$ be a finite set and let $B_a$ be a finite set for each $a\\in A$. Then $\\bigcup_{a\\in A}B_a$ is a finite set."}
{"formal_statement": "theorem dist_eq {X : Type u} {Y : Type v} [metric_space X] [metric_space Y]\n\t[inhabited X] [inhabited Y] {x y : X \u2295 Y} :\n\thas_dist.dist x y = metric.sum.dist x y", "decl_tp": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : metric_space X] [_inst_2 : metric_space Y] [_inst_3 : inhabited X] [_inst_4 : inhabited Y] {x y : X \u2295 Y}, has_dist.dist x y = metric.sum.dist x y", "decl_nm": "metric.sum.dist_eq", "nl_statement_of_codex": "The distance between two points in the sum of two metric spaces is the sum of the distances between the points in the two metric spaces."}
{"formal_statement": "theorem continuous_within_at {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082]\n\t{\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {s : set M\u2081} {x : M\u2081} :\n\tcontinuous_within_at \u21d1e s x", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {s : set M\u2081} {x : M\u2081}, continuous_within_at \u21d1e s x", "decl_nm": "continuous_linear_equiv.continuous_within_at", "nl_statement_of_codex": "Let $R_1, R_2$ be semirings, $M_1, M_2$ be topological spaces, and $e:M_1\\to M_2$ be a semilinear map. Then $e$ is continuous at $x$."}
{"formal_statement": "theorem lift_obj {C : Type u} [category_theory.category C] {D : Type*}\n\t[category_theory.category D] {Z : D} (F : C \u2964 D) (M : \u03a0 (x : C), F.obj x \u27f6 Z)\n\t(hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x) (X : category_theory.with_terminal C) :\n\t(category_theory.with_terminal.lift F M hM).obj X = category_theory.with_terminal.lift._match_1 F X", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {D : Type u_1} [_inst_2 : category_theory.category D] {Z : D} (F : C \u2964 D) (M : \u03a0 (x : C), F.obj x \u27f6 Z) (hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x) (X : category_theory.with_terminal C), (category_theory.with_terminal.lift F M hM).obj X = category_theory.with_terminal.lift._match_1 F X", "decl_nm": "category_theory.with_terminal.lift_obj", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ be a functor. Let $Z$ be an object of $D$ and let $M:C\\to D$ be a functor such that $M(f)=F(f)\\circ M(x)$ for all morphisms $f:x\\to y$ in $C$. Let $X$ be a terminal object of $C$. Then the object of $D$ corresponding to $X$ under the functor $M$ is the object of $D$ corresponding to $X$ under the functor $F$."}
{"formal_statement": "theorem trans {R : Type*} [ring R] {M\u2081 M\u2082 M\u2083 : Type*} [add_comm_group M\u2081]\n\t[add_comm_group M\u2082] [add_comm_group M\u2083] [module R M\u2081] [module R M\u2082] [module R M\u2083]\n\t{Q\u2081 : quadratic_form R M\u2081} {Q\u2082 : quadratic_form R M\u2082} {Q\u2083 : quadratic_form R M\u2083}\n\t(h : Q\u2081.equivalent Q\u2082) (h' : Q\u2082.equivalent Q\u2083) :\n\tQ\u2081.equivalent Q\u2083", "decl_tp": "\u2200 {R : Type u_2} [_inst_2 : ring R] {M\u2081 : Type u_5} {M\u2082 : Type u_6} {M\u2083 : Type u_7} [_inst_6 : add_comm_group M\u2081] [_inst_7 : add_comm_group M\u2082] [_inst_8 : add_comm_group M\u2083] [_inst_9 : module R M\u2081] [_inst_10 : module R M\u2082] [_inst_11 : module R M\u2083] {Q\u2081 : quadratic_form R M\u2081} {Q\u2082 : quadratic_form R M\u2082} {Q\u2083 : quadratic_form R M\u2083}, Q\u2081.equivalent Q\u2082 \u2192 Q\u2082.equivalent Q\u2083 \u2192 Q\u2081.equivalent Q\u2083", "decl_nm": "quadratic_form.equivalent.trans", "nl_statement_of_codex": "Let $R$ be a ring and let $M_1, M_2, M_3$ be $R$-modules. Let $Q_1, Q_2, Q_3$ be quadratic forms on $M_1, M_2, M_3$ respectively. If $Q_1$ is equivalent to $Q_2$ and $Q_2$ is equivalent to $Q_3$, then $Q_1$ is equivalent to $Q_3$."}
{"formal_statement": "theorem dual_iff {\u03b1 : Type*} {t : ordnode \u03b1} :\n\tt.dual.sized \u2194 t.sized", "decl_tp": "\u2200 {\u03b1 : Type u_1} {t : ordnode \u03b1}, t.dual.sized \u2194 t.sized", "decl_nm": "ordnode.sized.dual_iff", "nl_statement_of_codex": "The dual of an ordinal is the same size as the original ordinal."}
{"formal_statement": "theorem hom_ext {C : Type u} [category_theory.category C] {X Y : C} {f g : X \u27f6 Y}\n\t[category_theory.limits.has_equalizer f g] {W : C} {k l : W \u27f6 category_theory.limits.equalizer f g}\n\t(h : k \u226b category_theory.limits.equalizer.\u03b9 f g = l \u226b category_theory.limits.equalizer.\u03b9 f g) :\n\tk = l", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f g : X \u27f6 Y} [_inst_2 : category_theory.limits.has_equalizer f g] {W : C} {k l : W \u27f6 category_theory.limits.equalizer f g}, k \u226b category_theory.limits.equalizer.\u03b9 f g = l \u226b category_theory.limits.equalizer.\u03b9 f g \u2192 k = l", "decl_nm": "category_theory.limits.equalizer.hom_ext", "nl_statement_of_codex": "Let $C$ be a category, $X, Y$ objects of $C$, and $f, g:X\\to Y$ morphisms. If $f$ and $g$ have an equalizer, then the equalizer is unique up to isomorphism."}
{"formal_statement": "theorem pos_iff {R S : Type*} [semiring R] [ordered_semiring S] (abv : absolute_value R S)\n\t{x : R} :\n\t0 < \u21d1abv x \u2194 x \u2260 0", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : semiring R] [_inst_2 : ordered_semiring S] (abv : absolute_value R S) {x : R}, 0 < \u21d1abv x \u2194 x \u2260 0", "decl_nm": "absolute_value.pos_iff", "nl_statement_of_codex": "Let $R$ be a semiring and $S$ an ordered semiring. Let $abv$ be an absolute value on $R$ with values in $S$. Then $0<abv(x)$ if and only if $x\\neq 0$."}
{"formal_statement": "theorem iff_false_right {a b : Prop} (ha : \u00aca) :\n\t(b \u2194 a \u2194 \u00acb)", "decl_tp": "\u2200 {a b : Prop}, \u00aca \u2192 (b \u2194 a \u2194 \u00acb)", "decl_nm": "iff_false_right", "nl_statement_of_codex": "If $a$ is false, then $b$ is equivalent to $a$ being equivalent to $b$ being false."}
{"formal_statement": "theorem surj {M : Type*} [comm_monoid M] {S : submonoid M} {N : Type*}\n\t[comm_monoid N] (f : S.localization_map N) (z : N) :\n\t\u2203 (x : M \u00d7 \u21a5S), z * \u21d1(f.to_map) \u2191(x.snd) = \u21d1(f.to_map) x.fst", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {S : submonoid M} {N : Type u_2} [_inst_2 : comm_monoid N] (f : S.localization_map N) (z : N), \u2203 (x : M \u00d7 \u21a5S), z * \u21d1(f.to_map) \u2191(x.snd) = \u21d1(f.to_map) x.fst", "decl_nm": "submonoid.localization_map.surj", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, and let $N$ be a commutative monoid. Let $f:S^{-1}M\\to N$ be a ring homomorphism. Then for each $z\\in N$ there exist $x\\in M$ and $s\\in S$ such that $zf(s^{-1}x)=f(x)$."}
{"formal_statement": "theorem zero_nmem_multiset_map_X_add_C {R : Type u} [nontrivial R] [semiring R]\n\t{\u03b1 : Type*} (m : multiset \u03b1) (f : \u03b1 \u2192 R) :\n\t0 \u2209 multiset.map (\u03bb (a : \u03b1), polynomial.X + \u21d1polynomial.C (f a)) m", "decl_tp": "\u2200 {R : Type u} [_inst_1 : nontrivial R] [_inst_2 : semiring R] {\u03b1 : Type u_1} (m : multiset \u03b1) (f : \u03b1 \u2192 R), 0 \u2209 multiset.map (\u03bb (a : \u03b1), polynomial.X + \u21d1polynomial.C (f a)) m", "decl_nm": "polynomial.zero_nmem_multiset_map_X_add_C", "nl_statement_of_codex": "Let $R$ be a nontrivial semiring, let $m$ be a multiset of elements of a type $\u03b1$, and let $f:\u03b1\\to R$. Then $0$ is not an element of the multiset $\\{X+f(a):a\\in m\\}$."}
{"formal_statement": "theorem to_topological_space_top {\u03b1 : Type u} [add_group \u03b1] :\n\t\u22a4.to_topological_space = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1], \u22a4.to_topological_space = \u22a4", "decl_nm": "add_group_topology.to_topological_space_top", "nl_statement_of_codex": "The topology on the additive group $\\mathbb{R}$ is the trivial topology."}
{"formal_statement": "theorem Ico_self {\u03b1 : Type*} [preorder \u03b1] [locally_finite_order \u03b1] (a : \u03b1) :\n\tfinset.Ico a a = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] (a : \u03b1), finset.Ico a a = \u2205", "decl_nm": "finset.Ico_self", "nl_statement_of_codex": "Let $a$ be a locally finite preorder. Then $\\{x\\in\\mathbb{R}\\mid a\\leq x\\leq a\\}=\\emptyset$."}
{"formal_statement": "theorem monotone_uncurry_coe (\u03b1 : Type*) (\u03b2 : \u03b1 \u2192 Type*) (\u03b3 : \u03a0 (a : \u03b1), \u03b2 a \u2192 Type*)\n\t[\u03a0 (x : \u03b1) (y : \u03b2 x), preorder (\u03b3 x y)] (f : \u03a0 (x : \u03b1) (y : (\u03bb (a : \u03b1), \u03b2 a) x), (\u03bb (a : \u03b1)\n\t(b : \u03b2 a), \u03b3 a b) x y) (x : \u03a3 (a : \u03b1), \u03b2 a) :\n\t\u21d1(pi.monotone_uncurry \u03b1 \u03b2 \u03b3) f x = sigma.uncurry f x", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u03b2 : \u03b1 \u2192 Type u_2) (\u03b3 : \u03a0 (a : \u03b1), \u03b2 a \u2192 Type u_3) [_inst_1 : \u03a0 (x : \u03b1) (y : \u03b2 x), preorder (\u03b3 x y)] (f : \u03a0 (x : \u03b1) (y : (\u03bb (a : \u03b1), \u03b2 a) x), (\u03bb (a : \u03b1) (b : \u03b2 a), \u03b3 a b) x y) (x : \u03a3 (a : \u03b1), \u03b2 a), \u21d1(pi.monotone_uncurry \u03b1 \u03b2 \u03b3) f x = sigma.uncurry f x", "decl_nm": "pi.monotone_uncurry_coe", "nl_statement_of_codex": "Let $f:X\\times Y\\to Z$ be a function. Then the function $g:X\\to Z^Y$ defined by $g(x)(y)=f(x,y)$ is monotone if and only if $f$ is monotone."}
{"formal_statement": "theorem coe_algebra_map {k : Type u\u2081} {G : Type u\u2082} {A : Type*} [comm_semiring k]\n\t[semiring A] [algebra k A] [monoid G] :\n\t\u21d1(algebra_map k (monoid_algebra A G)) = finsupp.single 1 \u2218 \u21d1(algebra_map k A)", "decl_tp": "\u2200 {k : Type u\u2081} {G : Type u\u2082} {A : Type u_1} [_inst_1 : comm_semiring k] [_inst_2 : semiring A] [_inst_3 : algebra k A] [_inst_4 : monoid G], \u21d1(algebra_map k (monoid_algebra A G)) = finsupp.single 1 \u2218 \u21d1(algebra_map k A)", "decl_nm": "monoid_algebra.coe_algebra_map", "nl_statement_of_codex": "The map $f:A\\to A[G]$ defined by $f(a)=a\\cdot 1_G$ is an algebra homomorphism."}
{"formal_statement": "theorem abs_div_tendsto_at_top_of_degree_gt {\ud835\udd5c : Type*} [normed_linear_ordered_field \ud835\udd5c]\n\t(P Q : polynomial \ud835\udd5c) [order_topology \ud835\udd5c] (hdeg : Q.degree < P.degree) (hQ : Q \u2260 0) :\n\tfilter.tendsto (\u03bb (x : \ud835\udd5c), |polynomial.eval x P / polynomial.eval x Q|) filter.at_top filter.at_top", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : normed_linear_ordered_field \ud835\udd5c] (P Q : polynomial \ud835\udd5c) [_inst_2 : order_topology \ud835\udd5c], Q.degree < P.degree \u2192 Q \u2260 0 \u2192 filter.tendsto (\u03bb (x : \ud835\udd5c), |polynomial.eval x P / polynomial.eval x Q|) filter.at_top filter.at_top", "decl_nm": "polynomial.abs_div_tendsto_at_top_of_degree_gt", "nl_statement_of_codex": "Let $P$ and $Q$ be polynomials with coefficients in a normed linear ordered field $K$. If $Q$ is not the zero polynomial and $Q$ has degree less than $P$, then $\\lim_{x\\to\\infty}|P(x)/Q(x)|=\\infty$."}
{"formal_statement": "theorem indicator_congr {\u03b1 M : Type*} [has_zero M] {s : set \u03b1} {f g : \u03b1 \u2192 M}\n\t(h : set.eq_on f g s) :\n\ts.indicator f = s.indicator g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : has_zero M] {s : set \u03b1} {f g : \u03b1 \u2192 M}, set.eq_on f g s \u2192 s.indicator f = s.indicator g", "decl_nm": "set.indicator_congr", "nl_statement_of_codex": "Let $M$ be a set with zero element. Let $f,g:\\alpha\\to M$ and let $s\\subset\\alpha$. Then $f$ and $g$ are equal on $s$ if and only if the indicator functions of $f$ and $g$ on $s$ are equal."}
{"formal_statement": "theorem interior_eq_nhds {\u03b1 : Type u} [topological_space \u03b1] {s : set \u03b1} :\n\tinterior s = {a : \u03b1 | nhds a \u2264 filter.principal s}", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, interior s = {a : \u03b1 | nhds a \u2264 filter.principal s}", "decl_nm": "interior_eq_nhds", "nl_statement_of_codex": "The interior of a set $S$ is the set of all points $x$ such that every neighborhood of $x$ intersects $S$."}
{"formal_statement": "theorem to_module_aut_apply (R : Type*) {S : Type*} (M : Type*) [semiring R]\n\t[add_comm_monoid M] [module R M] [group S] [distrib_mul_action S M] [smul_comm_class S R M]\n\t(s : S) :\n\t\u21d1(distrib_mul_action.to_module_aut R M) s = distrib_mul_action.to_linear_equiv R M s", "decl_tp": "\u2200 (R : Type u_1) {S : Type u_6} (M : Type u_7) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] [_inst_4 : group S] [_inst_5 : distrib_mul_action S M] [_inst_6 : smul_comm_class S R M] (s : S), \u21d1(distrib_mul_action.to_module_aut R M) s = distrib_mul_action.to_linear_equiv R M s", "decl_nm": "distrib_mul_action.to_module_aut_apply", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $S$ a group acting on $M$ by $R$-linear maps. Then the map $S\\to\\mathrm{Aut}_R(M)$ sending $s\\in S$ to the $R$-linear map $m\\mapsto s\\cdot m$ is a group homomorphism."}
{"formal_statement": "theorem conj_lie_apply {K : Type*} [is_R_or_C K] :\n\t\u21d1is_R_or_C.conj_lie = \u21d1star_ring_aut", "decl_tp": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K], \u21d1is_R_or_C.conj_lie = \u21d1star_ring_aut", "decl_nm": "is_R_or_C.conj_lie_apply", "nl_statement_of_codex": "The conjugation map is a Lie algebra automorphism of the Lie algebra of a star ring."}
{"formal_statement": "theorem to_lipschitz_with {\u03b1 : Type*} [emetric_space \u03b1] {K : nnreal} {f : \u03b1 \u2192 \u03b1}\n\t(hf : contracting_with K f) :\n\tlipschitz_with K f", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : emetric_space \u03b1] {K : nnreal} {f : \u03b1 \u2192 \u03b1}, contracting_with K f \u2192 lipschitz_with K f", "decl_nm": "contracting_with.to_lipschitz_with", "nl_statement_of_codex": "Let $f:X\\to X$ be a function on a metric space $X$. If $f$ is contracting with constant $K$, then $f$ is Lipschitz with constant $K$."}
{"formal_statement": "theorem mem_id_rel {\u03b1 : Type*} {a b : \u03b1} :\n\t(a, b) \u2208 id_rel \u2194 a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b : \u03b1}, (a, b) \u2208 id_rel \u2194 a = b", "decl_nm": "mem_id_rel", "nl_statement_of_codex": "$(a,b)\\in\\{(x,x)\\mid x\\in\\alpha\\}$ if and only if $a=b$."}
{"formal_statement": "theorem extension\u2082_coe_coe {\u03b1 : Type*} [uniform_space \u03b1] {\u03b2 : Type*} [uniform_space \u03b2]\n\t{\u03b3 : Type*} [uniform_space \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} [separated_space \u03b3] (hf : uniform_continuous\u2082 f) :\n\t\u2200 (a : \u03b1) (b : \u03b2), uniform_space.completion.extension\u2082 f \u2191a \u2191b = f a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : uniform_space \u03b2] {\u03b3 : Type u_3} [_inst_3 : uniform_space \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} [_inst_4 : separated_space \u03b3], uniform_continuous\u2082 f \u2192 \u2200 (a : \u03b1) (b : \u03b2), uniform_space.completion.extension\u2082 f \u2191a \u2191b = f a b", "decl_nm": "uniform_space.completion.extension\u2082_coe_coe", "nl_statement_of_codex": "Let $f:X\\times Y\\to Z$ be a uniformly continuous function. Then the extension of $f$ to the completion of $X\\times Y$ is given by $f$."}
{"formal_statement": "theorem cos {\u03b1 : Type*} [measurable_space \u03b1] {f : \u03b1 \u2192 \u211d} (hf : measurable f) :\n\tmeasurable (\u03bb (x : \u03b1), real.cos (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {f : \u03b1 \u2192 \u211d}, measurable f \u2192 measurable (\u03bb (x : \u03b1), real.cos (f x))", "decl_nm": "measurable.cos", "nl_statement_of_codex": "Let $f$ be a measurable function from a measurable space $X$ to $\\mathbb{R}$. Then the function $x\\mapsto \\cos(f(x))$ is measurable."}
{"formal_statement": "theorem nodup_map_on {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {s : multiset \u03b1} :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b1), y \u2208 s \u2192 f x = f y \u2192 x = y) \u2192 s.nodup \u2192 (multiset.map f s).nodup", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {s : multiset \u03b1}, (\u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b1), y \u2208 s \u2192 f x = f y \u2192 x = y) \u2192 s.nodup \u2192 (multiset.map f s).nodup", "decl_nm": "multiset.nodup_map_on", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $s$ be a multiset of elements of $A$. If $f$ is injective on $s$, then $f(s)$ is a multiset without duplicates."}
{"formal_statement": "theorem bijective {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [mul_action \u03b1 \u03b2]\n\t(g : \u03b1) :\n\tfunction.bijective (\u03bb (b : \u03b2), g \u2022 b)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] (g : \u03b1), function.bijective (\u03bb (b : \u03b2), g \u2022 b)", "decl_nm": "mul_action.bijective", "nl_statement_of_codex": "Let $G$ be a group acting on a set $X$. Then the map $g\\mapsto g\\cdot x$ is a bijection for each $x\\in X$."}
{"formal_statement": "theorem subset {\u03b1 : Type*} {s t : set \u03b1} (\u1fb0 : s = t) :\n\ts \u2286 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1}, s = t \u2192 s \u2286 t", "decl_nm": "eq.subset", "nl_statement_of_codex": "If $s=t$, then $s\\subset t$."}
{"formal_statement": "theorem map_vadd {G \u03b1 : Type*} {m : measurable_space \u03b1} [add_group G] [add_action G \u03b1]\n\t[measurable_space G] [has_measurable_vadd G \u03b1] (c : G) (\u03bc : measure_theory.measure \u03b1)\n\t[measure_theory.vadd_invariant_measure G \u03b1 \u03bc] :\n\t\u21d1(measure_theory.measure.map (has_vadd.vadd c)) \u03bc = \u03bc", "decl_tp": "\u2200 {G : Type u_1} {\u03b1 : Type u_3} {m : measurable_space \u03b1} [_inst_1 : add_group G] [_inst_2 : add_action G \u03b1] [_inst_3 : measurable_space G] [_inst_4 : has_measurable_vadd G \u03b1] (c : G) (\u03bc : measure_theory.measure \u03b1) [_inst_5 : measure_theory.vadd_invariant_measure G \u03b1 \u03bc], \u21d1(measure_theory.measure.map (has_vadd.vadd c)) \u03bc = \u03bc", "decl_nm": "measure_theory.map_vadd", "nl_statement_of_codex": "Let $G$ be an abelian group acting on a measurable space $(X,\\mathcal{A})$. Let $\\mu$ be a $G$-invariant measure on $(X,\\mathcal{A})$. Then the measure $\\mu$ is invariant under the action of $G$ by translation."}
{"formal_statement": "theorem to_add_equiv_symm_apply {\u03b1 : Type u} (\u03b2 : Type v) [group \u03b1] [add_monoid \u03b2]\n\t[distrib_mul_action \u03b1 \u03b2] (x : \u03b1) (\u1fb0 : \u03b2) :\n\t\u21d1((distrib_mul_action.to_add_equiv \u03b2 x).symm) \u1fb0 = x\u207b\u00b9 \u2022 \u1fb0", "decl_tp": "\u2200 {\u03b1 : Type u} (\u03b2 : Type v) [_inst_1 : group \u03b1] [_inst_2 : add_monoid \u03b2] [_inst_3 : distrib_mul_action \u03b1 \u03b2] (x : \u03b1) (\u1fb0 : \u03b2), \u21d1((distrib_mul_action.to_add_equiv \u03b2 x).symm) \u1fb0 = x\u207b\u00b9 \u2022 \u1fb0", "decl_nm": "distrib_mul_action.to_add_equiv_symm_apply", "nl_statement_of_codex": "Let $G$ be a group acting on a monoid $M$. Then the inverse of the isomorphism $M\\to M$ given by $m\\mapsto g\\cdot m$ is given by $m\\mapsto g^{-1}\\cdot m$."}
{"formal_statement": "theorem forall_exists_index {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {q : (\u2203 (x : \u03b1), p x) \u2192 Prop} :\n\t(\u2200 (h : \u2203 (x : \u03b1), p x), q h) \u2194 \u2200 (x : \u03b1) (h : p x), q _", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {q : (\u2203 (x : \u03b1), p x) \u2192 Prop}, (\u2200 (h : \u2203 (x : \u03b1), p x), q h) \u2194 \u2200 (x : \u03b1) (h : p x), q _", "decl_nm": "forall_exists_index", "nl_statement_of_codex": "For all $x$ such that $p(x)$ holds, $q(x)$ holds if and only if for all $x$ such that $p(x)$ holds, $q(x)$ holds."}
{"formal_statement": "theorem ext {\u03b1 : Type*} {s\u2081 s\u2082 : finset \u03b1} :\n\t(\u2200 (a : \u03b1), a \u2208 s\u2081 \u2194 a \u2208 s\u2082) \u2192 s\u2081 = s\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s\u2081 s\u2082 : finset \u03b1}, (\u2200 (a : \u03b1), a \u2208 s\u2081 \u2194 a \u2208 s\u2082) \u2192 s\u2081 = s\u2082", "decl_nm": "finset.ext", "nl_statement_of_codex": "Let $s_1$ and $s_2$ be finite sets. Then $s_1=s_2$ if and only if $s_1$ and $s_2$ have the same elements."}
{"formal_statement": "theorem card_mul (a b : ordinal) :\n\t(a * b).card = a.card * b.card", "decl_tp": "\u2200 (a b : ordinal), (a * b).card = a.card * b.card", "decl_nm": "ordinal.card_mul", "nl_statement_of_codex": "The cardinality of the product of two ordinals is the product of their cardinalities."}
{"formal_statement": "theorem prod_inv {\u03b1 M G : Type*} [has_zero M] [comm_group G] {f : \u03b1 \u2192\u2080 M}\n\t{h : \u03b1 \u2192 M \u2192 G} :\n\tf.prod (\u03bb (a : \u03b1) (b : M), (h a b)\u207b\u00b9) = (f.prod h)\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {G : Type u_9} [_inst_1 : has_zero M] [_inst_2 : comm_group G] {f : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 G}, f.prod (\u03bb (a : \u03b1) (b : M), (h a b)\u207b\u00b9) = (f.prod h)\u207b\u00b9", "decl_nm": "finsupp.prod_inv", "nl_statement_of_codex": "Let $f:\\alpha\\to M$ be a function with finite support. Then $\\prod_{a\\in\\alpha}h(a,f(a))^{-1}=\\left(\\prod_{a\\in\\alpha}h(a,f(a))\\right)^{-1}$."}
{"formal_statement": "theorem trop_inf {R S : Type*} [linear_order R] [order_top R] (s : finset S)\n\t(f : S \u2192 R) :\n\ttropical.trop (s.inf f) = s.sum (\u03bb (i : S), tropical.trop (f i))", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : linear_order R] [_inst_2 : order_top R] (s : finset S) (f : S \u2192 R), tropical.trop (s.inf f) = s.sum (\u03bb (i : S), tropical.trop (f i))", "decl_nm": "finset.trop_inf", "nl_statement_of_codex": "Let $R$ be a linear order with a top element. Let $S$ be a finite set and let $f:S\\to R$. Then the tropical infimum of $f$ is the tropical sum of the values of $f$."}
{"formal_statement": "theorem fix_core {\u03b1 : Type} {F : parser \u03b1 \u2192 parser \u03b1} :\n\t(\u2200 (p : parser \u03b1), p.mono \u2192 (F p).mono) \u2192 \u2200 (max_depth : \u2115), (parser.fix_core F max_depth).mono", "decl_tp": "\u2200 {\u03b1 : Type} {F : parser \u03b1 \u2192 parser \u03b1}, (\u2200 (p : parser \u03b1), p.mono \u2192 (F p).mono) \u2192 \u2200 (max_depth : \u2115), (parser.fix_core F max_depth).mono", "decl_nm": "parser.mono.fix_core", "nl_statement_of_codex": "Let $F$ be a function from the set of parsers to itself. If $F$ preserves monotonicity, then the fixed point of $F$ is monotone."}
{"formal_statement": "theorem eq_order_of {M : Type*} [comm_monoid M] {k : \u2115} {\u03b6 : M} (h : is_primitive_root \u03b6 k) :\n\tk = order_of \u03b6", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {k : \u2115} {\u03b6 : M}, is_primitive_root \u03b6 k \u2192 k = order_of \u03b6", "decl_nm": "is_primitive_root.eq_order_of", "nl_statement_of_codex": "Let $M$ be a commutative monoid and let $k$ be a natural number. Let $\\zeta$ be an element of $M$. If $\\zeta$ is a primitive root of $k$, then $k$ is the order of $\\zeta$."}
{"formal_statement": "theorem exists_le_sum_fiber_of_nsmul_le_sum {\u03b1 : Type u} {\u03b2 : Type v} {M : Type w}\n\t[linear_ordered_cancel_add_comm_monoid M] [decidable_eq \u03b2] [fintype \u03b1]\n\t[fintype \u03b2] (f : \u03b1 \u2192 \u03b2) {w : \u03b1 \u2192 M} {b : M} [nonempty \u03b2] (hb : fintype.card \u03b2 \u2022 b \u2264 finset.univ.sum (\u03bb (x : \u03b1), w x)) :\n\t(\u2203 (y : \u03b2), b \u2264 (finset.filter (\u03bb (x : \u03b1), f x = y) finset.univ).sum (\u03bb (x : \u03b1), w x))", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {M : Type w} [_inst_1 : linear_ordered_cancel_add_comm_monoid M] [_inst_2 : decidable_eq \u03b2] [_inst_3 : fintype \u03b1] [_inst_4 : fintype \u03b2] (f : \u03b1 \u2192 \u03b2) {w : \u03b1 \u2192 M} {b : M} [_inst_5 : nonempty \u03b2], fintype.card \u03b2 \u2022 b \u2264 finset.univ.sum (\u03bb (x : \u03b1), w x) \u2192 (\u2203 (y : \u03b2), b \u2264 (finset.filter (\u03bb (x : \u03b1), f x = y) finset.univ).sum (\u03bb (x : \u03b1), w x))", "decl_nm": "fintype.exists_le_sum_fiber_of_nsmul_le_sum", "nl_statement_of_codex": "Let $M$ be a linear ordered cancelative commutative monoid with identity. Let $f:A\\to B$ be a function. Let $w:A\\to M$ and $b\\in M$. If $|B|\\cdot b\\leq \\sum_{x\\in A}w(x)$, then there is $y\\in B$ such that $b\\leq \\sum_{x\\in f^{-1}(y)}w(x)$."}
{"formal_statement": "theorem extreme_points_eq {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_scalar \ud835\udd5c E] {A B : set E} (hAB : is_extreme \ud835\udd5c A B) :\n\tset.extreme_points \ud835\udd5c B = B \u2229 set.extreme_points \ud835\udd5c A", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_3 : has_scalar \ud835\udd5c E] {A B : set E}, is_extreme \ud835\udd5c A B \u2192 set.extreme_points \ud835\udd5c B = B \u2229 set.extreme_points \ud835\udd5c A", "decl_nm": "is_extreme.extreme_points_eq", "nl_statement_of_codex": "Let $A$ and $B$ be subsets of a vector space $E$ over an ordered field $\\mathbb{K}$. If $A$ is extreme in $B$, then the extreme points of $B$ are exactly the points of $B$ that are extreme in $A$."}
{"formal_statement": "theorem outer_measure_eq_infi {G : Type w} [topological_space G] (\u03bc : measure_theory.content G)\n\t[t2_space G] (A : set G) :\n\t\u21d1(\u03bc.outer_measure) A = \u2a05 (U : set G) (hU : is_open U) (h : A \u2286 U), \u03bc.inner_content \u27e8U, hU\u27e9", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] (\u03bc : measure_theory.content G) [_inst_2 : t2_space G] (A : set G), \u21d1(\u03bc.outer_measure) A = \u2a05 (U : set G) (hU : is_open U) (h : A \u2286 U), \u03bc.inner_content \u27e8U, hU\u27e9", "decl_nm": "measure_theory.content.outer_measure_eq_infi", "nl_statement_of_codex": "Let $G$ be a topological space and let $\\mu$ be a content on $G$. Then the outer measure of a set $A$ is the infimum of the inner contents of all open sets containing $A$."}
{"formal_statement": "theorem ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type*}\n\t[comm_ring R] [is_domain R] [is_principal_ideal_ring R] [semiring S] (f : R \u2192+* S)\n\t(s : submonoid S) (a : R) (ha : a \u2260 0) :\n\t(\u2200 (b : R), b \u2208 principal_ideal_ring.factors a \u2192 \u21d1f b \u2208 s) \u2192 (\u2200 (c : units R), \u21d1f \u2191c \u2208 s) \u2192 \u21d1f a \u2208 s", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_4 : comm_ring R] [_inst_5 : is_domain R] [_inst_6 : is_principal_ideal_ring R] [_inst_7 : semiring S] (f : R \u2192+* S) (s : submonoid S) (a : R), a \u2260 0 \u2192 (\u2200 (b : R), b \u2208 principal_ideal_ring.factors a \u2192 \u21d1f b \u2208 s) \u2192 (\u2200 (c : units R), \u21d1f \u2191c \u2208 s) \u2192 \u21d1f a \u2208 s", "decl_nm": "principal_ideal_ring.ring_hom_mem_submonoid_of_factors_subset_of_units_subset", "nl_statement_of_codex": "Let $R$ be a commutative domain and let $S$ be a semiring. Let $f:R\\to S$ be a ring homomorphism. Let $s$ be a submonoid of $S$. Let $a\\in R$ be nonzero. Suppose that $f(b)\\in s$ for all $b\\in R$ such that $b$ divides $a$ in $R$. Suppose that $f(c)\\in s$ for all units $c\\in R$. Then $f(a)\\in s$."}
{"formal_statement": "theorem infi_bUnion {\u03b1 \u03b2 \u03b3 : Type*} [complete_lattice \u03b2] [decidable_eq \u03b1]\n\t(s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n\t(\u2a05 (y : \u03b1) (H : y \u2208 s.bUnion t), f y) = \u2a05 (x : \u03b3) (H : x \u2208 s) (y : \u03b1)\n\t(H : y \u2208 t x), f y", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : complete_lattice \u03b2] [_inst_2 : decidable_eq \u03b1] (s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b1) (f : \u03b1 \u2192 \u03b2), (\u2a05 (y : \u03b1) (H : y \u2208 s.bUnion t), f y) = \u2a05 (x : \u03b3) (H : x \u2208 s) (y : \u03b1) (H : y \u2208 t x), f y", "decl_nm": "finset.infi_bUnion", "nl_statement_of_codex": "Let $s$ be a finite set, $t$ a function from $s$ to finite sets, and $f$ a function from the union of the sets $t(x)$ to a complete lattice. Then the infimum of $f$ over the union of the sets $t(x)$ is equal to the infimum of $f$ over the set of pairs $(x,y)$ where $x\\in s$ and $y\\in t(x)$."}
{"formal_statement": "theorem map_get {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (o : part \u03b1) (\u1fb0 : o.dom) :\n\t(part.map f o).get \u1fb0 = (f \u2218 o.get) \u1fb0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2) (o : part \u03b1) (\u1fb0 : o.dom), (part.map f o).get \u1fb0 = (f \u2218 o.get) \u1fb0", "decl_nm": "part.map_get", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $o$ be a partial function from $A$ to $B$. Then the partial function $f\\circ o$ is the same as the partial function $o$ with the codomain replaced by $B$."}
{"formal_statement": "theorem ext {x y : punit} :\n\tx = y", "decl_tp": "\u2200 {x y : punit}, x = y", "decl_nm": "punit.ext", "nl_statement_of_codex": "There is only one point in the one-point space."}
{"formal_statement": "theorem lower_semicontinuous_within_at_const {\u03b1 : Type*} [topological_space \u03b1]\n\t{\u03b2 : Type*} [preorder \u03b2] {x : \u03b1} {s : set \u03b1} {z : \u03b2} :\n\tlower_semicontinuous_within_at (\u03bb (x : \u03b1), z) s x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {x : \u03b1} {s : set \u03b1} {z : \u03b2}, lower_semicontinuous_within_at (\u03bb (x : \u03b1), z) s x", "decl_nm": "lower_semicontinuous_within_at_const", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a preordered set. Let $x\\in X$ and let $s\\subset X$. Then the constant function $f:X\\to Y$ defined by $f(x)=z$ is lower semicontinuous at $x$ on $s$."}
{"formal_statement": "theorem of_real_cos (x : \u211d) :\n\t\u2191(real.cos x) = complex.cos \u2191x", "decl_tp": "\u2200 (x : \u211d), \u2191(real.cos x) = complex.cos \u2191x", "decl_nm": "complex.of_real_cos", "nl_statement_of_codex": "The real cosine function is the real part of the complex cosine function."}
{"formal_statement": "theorem bot_lt_zero :\n\t\u22a5 < 0", "decl_tp": "\u22a5 < 0", "decl_nm": "ereal.bot_lt_zero", "nl_statement_of_codex": "The bottom element of the natural numbers is less than zero."}
{"formal_statement": "theorem le_mul_inv_of_mul_le {\u03b1 : Type*} {a b c : \u03b1} [linear_ordered_comm_group_with_zero \u03b1]\n\t(h : c \u2260 0) (hab : a * c \u2264 b) :\n\ta \u2264 b * c\u207b\u00b9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b c : \u03b1} [_inst_1 : linear_ordered_comm_group_with_zero \u03b1], c \u2260 0 \u2192 a * c \u2264 b \u2192 a \u2264 b * c\u207b\u00b9", "decl_nm": "le_mul_inv_of_mul_le", "nl_statement_of_codex": "Let $R$ be a linearly ordered commutative group with zero. Let $a,b,c\\in R$ with $c\\neq 0$. If $ac\\leq b$, then $a\\leq bc^{-1}$."}
{"formal_statement": "theorem aeval_tower_X {R : Type u} {\u03c3 : Type*} [comm_semiring R] {S A : Type*}\n\t[comm_semiring S] [comm_semiring A] [algebra S R] [algebra S A] (g : R \u2192\u2090[S] A)\n\t(y : \u03c3 \u2192 A) (i : \u03c3) :\n\t\u21d1(mv_polynomial.aeval_tower g y) (mv_polynomial.X i) = y i", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] {S : Type u_2} {A : Type u_3} [_inst_3 : comm_semiring S] [_inst_4 : comm_semiring A] [_inst_6 : algebra S R] [_inst_7 : algebra S A] (g : R \u2192\u2090[S] A) (y : \u03c3 \u2192 A) (i : \u03c3), \u21d1(mv_polynomial.aeval_tower g y) (mv_polynomial.X i) = y i", "decl_nm": "mv_polynomial.aeval_tower_X", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $S$ be a commutative semiring, let $A$ be a commutative semiring, let $g:R\\to A$ be an $S$-algebra homomorphism, let $y:\\sigma\\to A$ be a function, and let $i\\in\\sigma$. Then the $i$th component of the function $mv_polynomial.aeval_tower g y$ is $y(i)$."}
{"formal_statement": "theorem neg_def (x : \u211d) :\n\t\u2191-x = -\u2191x", "decl_tp": "\u2200 (x : \u211d), \u2191-x = -\u2191x", "decl_nm": "ereal.neg_def", "nl_statement_of_codex": "The negation of a real number is the negation of the corresponding natural number."}
{"formal_statement": "theorem bUnion_union {\u03b1 \u03b2 : Type*} (s t : set \u03b1) (u : \u03b1 \u2192 set \u03b2) :\n\t(\u22c3 (x : \u03b1) (H : x \u2208 s \u222a t), u x) = (\u22c3 (x : \u03b1) (H : x \u2208 s), u x) \u222a \u22c3 (x : \u03b1)\n\t(H : x \u2208 t), u x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (s t : set \u03b1) (u : \u03b1 \u2192 set \u03b2), (\u22c3 (x : \u03b1) (H : x \u2208 s \u222a t), u x) = (\u22c3 (x : \u03b1) (H : x \u2208 s), u x) \u222a \u22c3 (x : \u03b1) (H : x \u2208 t), u x", "decl_nm": "set.bUnion_union", "nl_statement_of_codex": "Let $s$ and $t$ be sets and let $u$ be a function from $s\\cup t$ to a set $V$. Then $\\bigcup_{x\\in s\\cup t}u(x)=\\bigcup_{x\\in s}u(x)\\cup\\bigcup_{x\\in t}u(x)$."}
{"formal_statement": "theorem sub {\u03b1 F E' : Type*} [has_norm F] [normed_group E'] {g : \u03b1 \u2192 F}\n\t{l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'} (h\u2081 : asymptotics.is_o f\u2081 g l) (h\u2082 : asymptotics.is_o f\u2082 g l) :\n\tasymptotics.is_o (\u03bb (x : \u03b1), f\u2081 x - f\u2082 x) g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {g : \u03b1 \u2192 F} {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'}, asymptotics.is_o f\u2081 g l \u2192 asymptotics.is_o f\u2082 g l \u2192 asymptotics.is_o (\u03bb (x : \u03b1), f\u2081 x - f\u2082 x) g l", "decl_nm": "asymptotics.is_o.sub", "nl_statement_of_codex": "Let $F$ be a normed space, let $E'$ be a normed group, let $g:\\alpha\\to F$ be a function, let $l$ be a filter on $\\alpha$, and let $f_1, f_2:\\alpha\\to E'$ be functions. If $f_1$ and $f_2$ are $o(g)$ with respect to $l$, then $f_1-f_2$ is $o(g)$ with respect to $l$."}
{"formal_statement": "theorem mem_support {V : Type u} (G : simple_graph V) {v : V} :\n\tv \u2208 G.support \u2194 \u2203 (w : V), G.adj v w", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) {v : V}, v \u2208 G.support \u2194 \u2203 (w : V), G.adj v w", "decl_nm": "simple_graph.mem_support", "nl_statement_of_codex": "Let $G$ be a simple graph. Then $v\\in G.support$ if and only if there is a vertex $w$ such that $v$ and $w$ are adjacent."}
{"formal_statement": "theorem right {\u03b1 : Type u} {s t : set \u03b1} (h : (s \u2229 t).nonempty) :\n\tt.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, (s \u2229 t).nonempty \u2192 t.nonempty", "decl_nm": "set.nonempty.right", "nl_statement_of_codex": "If $s\\cap t$ is nonempty, then $t$ is nonempty."}
{"formal_statement": "theorem of_eq {\u03b1 : Type u} (x : free_group \u03b1) :\n\t\u21d1(\u21d1free_group.lift free_group.of) x = x", "decl_tp": "\u2200 {\u03b1 : Type u} (x : free_group \u03b1), \u21d1(\u21d1free_group.lift free_group.of) x = x", "decl_nm": "free_group.lift.of_eq", "nl_statement_of_codex": "The map $x\\mapsto \\overline{x}$ is the identity map on the free group on $X$."}
{"formal_statement": "theorem union {\u03b3 : Type w} [semilattice_inf \u03b3] {a\u2081 a\u2082 : \u03b3} {s t : set \u03b3}\n\t(hs : is_glb s a\u2081) (ht : is_glb t a\u2082) :\n\tis_glb (s \u222a t) (a\u2081 \u2293 a\u2082)", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : semilattice_inf \u03b3] {a\u2081 a\u2082 : \u03b3} {s t : set \u03b3}, is_glb s a\u2081 \u2192 is_glb t a\u2082 \u2192 is_glb (s \u222a t) (a\u2081 \u2293 a\u2082)", "decl_nm": "is_glb.union", "nl_statement_of_codex": "Let $S$ and $T$ be subsets of a semilattice $(\\gamma,\\wedge)$. Then $\\bigwedge S\\wedge\\bigwedge T=\\bigwedge(S\\cup T)$."}
{"formal_statement": "theorem comp_assoc {M N P Q : Type*} [has_one M] [has_one N] [has_one P]\n\t[has_one Q] (f : one_hom M N) (g : one_hom N P) (h : one_hom P Q) :\n\t(h.comp g).comp f = h.comp (g.comp f)", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} {Q : Type u_4} [_inst_1 : has_one M] [_inst_2 : has_one N] [_inst_3 : has_one P] [_inst_4 : has_one Q] (f : one_hom M N) (g : one_hom N P) (h : one_hom P Q), (h.comp g).comp f = h.comp (g.comp f)", "decl_nm": "one_hom.comp_assoc", "nl_statement_of_codex": "Let $M, N, P, Q$ be monoids. Let $f:M\\to N$, $g:N\\to P$, and $h:P\\to Q$ be monoid homomorphisms. Then $(h\\circ g)\\circ f = h\\circ (g\\circ f)$."}
{"formal_statement": "theorem coe_pi {R : Type u} {\u03b9 : Type v} {M\u2081 : \u03b9 \u2192 Type w\u2081} [decidable_eq \u03b9]\n\t[semiring R] [\u03a0 (i : \u03b9), add_comm_monoid (M\u2081 i)] [\u03a0 (i : \u03b9), module R (M\u2081 i)]\n\t[\u03a0 (i : \u03b9), topological_space (M\u2081 i)] {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u03a0 (i : \u03b9'), add_comm_monoid (M' i)]\n\t[\u03a0 (i : \u03b9'), topological_space (M' i)] [\u03a0 (i : \u03b9'), module R (M' i)] (f : \u03a0 (i : \u03b9'), continuous_multilinear_map R M\u2081 (M' i)) :\n\t\u21d1(continuous_multilinear_map.pi f) = \u03bb (m : \u03a0 (i : \u03b9), M\u2081 i) (j : \u03b9'), \u21d1(f j) m", "decl_tp": "\u2200 {R : Type u} {\u03b9 : Type v} {M\u2081 : \u03b9 \u2192 Type w\u2081} [_inst_1 : decidable_eq \u03b9] [_inst_2 : semiring R] [_inst_4 : \u03a0 (i : \u03b9), add_comm_monoid (M\u2081 i)] [_inst_10 : \u03a0 (i : \u03b9), module R (M\u2081 i)] [_inst_16 : \u03a0 (i : \u03b9), topological_space (M\u2081 i)] {\u03b9' : Type u_1} {M' : \u03b9' \u2192 Type u_2} [_inst_21 : \u03a0 (i : \u03b9'), add_comm_monoid (M' i)] [_inst_22 : \u03a0 (i : \u03b9'), topological_space (M' i)] [_inst_23 : \u03a0 (i : \u03b9'), module R (M' i)] (f : \u03a0 (i : \u03b9'), continuous_multilinear_map R M\u2081 (M' i)), \u21d1(continuous_multilinear_map.pi f) = \u03bb (m : \u03a0 (i : \u03b9), M\u2081 i) (j : \u03b9'), \u21d1(f j) m", "decl_nm": "continuous_multilinear_map.coe_pi", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $\\mathcal{I}$ be a set, and let $M_i$ be an $R$-module for each $i\\in\\mathcal{I}$.\nLet $\\mathcal{I}'$ be a set, and let $N_i$ be an $R$-module for each $i\\in\\mathcal{I}'$.\nLet $f_i:M_i\\to N_i$ be a continuous $R$-multilinear map for each $i\\in\\mathcal{I}'$.\nThen the map $\\prod_{i\\in\\mathcal{"}
{"formal_statement": "theorem subset_zero_locus_vanishing_ideal {R : Type u} [comm_ring R] (t : set (prime_spectrum R)) :\n\tt \u2286 prime_spectrum.zero_locus \u2191(prime_spectrum.vanishing_ideal t)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] (t : set (prime_spectrum R)), t \u2286 prime_spectrum.zero_locus \u2191(prime_spectrum.vanishing_ideal t)", "decl_nm": "prime_spectrum.subset_zero_locus_vanishing_ideal", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $t$ be a subset of the prime spectrum of $R$. Then $t$ is contained in the zero locus of the vanishing ideal of $t$."}
{"formal_statement": "theorem coe_to_fractional_ideal_bot {R : Type*} [comm_ring R] {S : submonoid R}\n\t{P : Type*} [comm_ring P] [algebra R P] :\n\t\u2191\u22a5 = 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {S : submonoid R} {P : Type u_2} [_inst_2 : comm_ring P] [_inst_3 : algebra R P], \u2191\u22a5 = 0", "decl_nm": "fractional_ideal.coe_to_fractional_ideal_bot", "nl_statement_of_codex": "The fractional ideal generated by the zero ideal is the zero ideal."}
{"formal_statement": "theorem congr_hom {\u03b9 : Type*} {V : Type u} [category_theory.category V]\n\t[category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C D : homological_complex V c}\n\t{f g : C \u27f6 D} (w : f = g) :\n\t\u2200 (i : \u03b9), f.f i = g.f i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} {C D : homological_complex V c} {f g : C \u27f6 D}, f = g \u2192 \u2200 (i : \u03b9), f.f i = g.f i", "decl_nm": "homological_complex.congr_hom", "nl_statement_of_codex": "Let $C$ and $D$ be homological complexes of shape $c$ and let $f,g:C\\to D$ be morphisms of complexes. If $f=g$, then $f_i=g_i$ for all $i\\in\\mathrm{Ob}(c)$."}
{"formal_statement": "theorem map_nhds_eq {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : open_embedding f) :\n\t\u2200 (a : \u03b1), filter.map f (nhds a) = nhds (f a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, open_embedding f \u2192 \u2200 (a : \u03b1), filter.map f (nhds a) = nhds (f a)", "decl_nm": "open_embedding.map_nhds_eq", "nl_statement_of_codex": "Let $f:X\\to Y$ be an open embedding. Then $f$ maps the neighborhood filter of $x$ to the neighborhood filter of $f(x)$."}
{"formal_statement": "theorem extend_extends {X : Type*} [topological_space X] {a b : X} (\u03b3 : path a b)\n\t{t : \u211d} (ht : t \u2208 set.Icc 0 1) :\n\t\u03b3.extend t = \u21d1\u03b3 \u27e8t, ht\u27e9", "decl_tp": "\u2200 {X : Type u_1} [_inst_3 : topological_space X] {a b : X} (\u03b3 : path a b) {t : \u211d} (ht : t \u2208 set.Icc 0 1), \u03b3.extend t = \u21d1\u03b3 \u27e8t, ht\u27e9", "decl_nm": "path.extend_extends", "nl_statement_of_codex": "Let $X$ be a topological space and let $a,b\\in X$. Let $\\gamma:[0,1]\\to X$ be a path from $a$ to $b$. Then $\\gamma$ extends to a path from $a$ to $\\gamma(t)$ for any $t\\in [0,1]$."}
{"formal_statement": "theorem associator_inv_apply {X Y Z : Type u} {x : X} {y : Y} {z : Z} :\n\t(\u03b1_ X Y Z).inv (x, y, z) = ((x, y), z)", "decl_tp": "\u2200 {X Y Z : Type u} {x : X} {y : Y} {z : Z}, (\u03b1_ X Y Z).inv (x, y, z) = ((x, y), z)", "decl_nm": "category_theory.associator_inv_apply", "nl_statement_of_codex": "The inverse of the associator is the associator."}
{"formal_statement": "theorem mk_set_le {\u03b1 : Type u} (s : set \u03b1) :\n\tcardinal.mk \u21a5s \u2264 cardinal.mk \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} (s : set \u03b1), cardinal.mk \u21a5s \u2264 cardinal.mk \u03b1", "decl_nm": "cardinal.mk_set_le", "nl_statement_of_codex": "The cardinality of a set $s$ is less than or equal to the cardinality of the universe."}
{"formal_statement": "theorem obj_map_app {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {E : Type u\u2083} [category_theory.category E]\n\t{F : C \u00d7 D \u2964 E} {X X' : C} {f : X \u27f6 X'} {Y : D} :\n\t((category_theory.curry.obj F).map f).app Y = F.map (f, \ud835\udfd9 Y)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {E : Type u\u2083} [_inst_3 : category_theory.category E] {F : C \u00d7 D \u2964 E} {X X' : C} {f : X \u27f6 X'} {Y : D}, ((category_theory.curry.obj F).map f).app Y = F.map (f, \ud835\udfd9 Y)", "decl_nm": "category_theory.curry.obj_map_app", "nl_statement_of_codex": "Let $C, D, E$ be categories and let $F:C\\times D\\to E$ be a functor. Then for any $X, X'\\in C$ and $f:X\\to X'$ and $Y\\in D$, we have $(F(f,\\mathrm{id}_Y))(Y)=(F(f))(Y)$."}
{"formal_statement": "theorem is_glb_Ioc {\u03b3 : Type w} [semilattice_sup \u03b3] [densely_ordered \u03b3]\n\t{a b : \u03b3} (hab : a < b) :\n\tis_glb (set.Ioc a b) a", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : semilattice_sup \u03b3] [_inst_4 : densely_ordered \u03b3] {a b : \u03b3}, a < b \u2192 is_glb (set.Ioc a b) a", "decl_nm": "is_glb_Ioc", "nl_statement_of_codex": "Let $\\gamma$ be a densely ordered semilattice. Let $a,b\\in\\gamma$ with $a<b$. Then $a$ is the greatest lower bound of the interval $[a,b)$."}
{"formal_statement": "theorem div_nonpos {a b : \u2124} (Ha : 0 \u2264 a) (Hb : b \u2264 0) :\n\ta / b \u2264 0", "decl_tp": "\u2200 {a b : \u2124}, 0 \u2264 a \u2192 b \u2264 0 \u2192 a / b \u2264 0", "decl_nm": "int.div_nonpos", "nl_statement_of_codex": "If $a\\geq 0$ and $b\\leq 0$, then $a/b\\leq 0$."}
{"formal_statement": "theorem snd_obj {A : Type u\u2081} [category_theory.category A] {B : Type u\u2082}\n\t[category_theory.category B] {T : Type u\u2083} [category_theory.category T]\n\t(L : A \u2964 T) (R : B \u2964 T) (X : category_theory.comma L R) :\n\t(category_theory.comma.snd L R).obj X = X.right", "decl_tp": "\u2200 {A : Type u\u2081} [_inst_1 : category_theory.category A] {B : Type u\u2082} [_inst_2 : category_theory.category B] {T : Type u\u2083} [_inst_3 : category_theory.category T] (L : A \u2964 T) (R : B \u2964 T) (X : category_theory.comma L R), (category_theory.comma.snd L R).obj X = X.right", "decl_nm": "category_theory.comma.snd_obj", "nl_statement_of_codex": "Let $A, B, T$ be categories and let $L:A\\to T$ and $R:B\\to T$ be functors. Let $X$ be an object of the comma category $(L\\downarrow R)$. Then the second projection of $X$ is $X.right$."}
{"formal_statement": "theorem disjoint_one_right {\u03b1 : Type*} (f : equiv.perm \u03b1) :\n\tf.disjoint 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} (f : equiv.perm \u03b1), f.disjoint 1", "decl_nm": "equiv.perm.disjoint_one_right", "nl_statement_of_codex": "The identity permutation is disjoint from any permutation."}
{"formal_statement": "theorem ae_measurable_const {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} [measurable_space \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} {b : \u03b2} :\n\tae_measurable (\u03bb (a : \u03b1), b) \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} [_inst_1 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} {b : \u03b2}, ae_measurable (\u03bb (a : \u03b1), b) \u03bc", "decl_nm": "ae_measurable_const", "nl_statement_of_codex": "The constant function $f(x)=b$ is almost everywhere measurable."}
{"formal_statement": "theorem mem_conjugates_of_set_iff {G : Type*} [group G] {s : set G} {x : G} :\n\tx \u2208 group.conjugates_of_set s \u2194 \u2203 (a : G) (H : a \u2208 s), is_conj a x", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {s : set G} {x : G}, x \u2208 group.conjugates_of_set s \u2194 \u2203 (a : G) (H : a \u2208 s), is_conj a x", "decl_nm": "group.mem_conjugates_of_set_iff", "nl_statement_of_codex": "Let $G$ be a group and let $s$ be a subset of $G$. Then $x\\in G$ is in the conjugacy class of $s$ if and only if there is an element $a\\in s$ such that $x$ is conjugate to $a$."}
{"formal_statement": "theorem convex_hull_image {\ud835\udd5c E F : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[add_comm_monoid F] [module \ud835\udd5c E] [module \ud835\udd5c F] (f : E \u2192\u2097[\ud835\udd5c] F) (s : set E) :\n\t\u21d1(convex_hull \ud835\udd5c) (\u21d1f '' s) = \u21d1f '' \u21d1(convex_hull \ud835\udd5c) s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {F : Type u_3} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_3 : add_comm_monoid F] [_inst_4 : module \ud835\udd5c E] [_inst_5 : module \ud835\udd5c F] (f : E \u2192\u2097[\ud835\udd5c] F) (s : set E), \u21d1(convex_hull \ud835\udd5c) (\u21d1f '' s) = \u21d1f '' \u21d1(convex_hull \ud835\udd5c) s", "decl_nm": "linear_map.convex_hull_image", "nl_statement_of_codex": "Let $f:E\\to F$ be a linear map between two vector spaces over a field $K$. Then the convex hull of the image of $f$ is equal to the image of the convex hull of $f$."}
{"formal_statement": "theorem add_eq_self {c : cardinal} (h : cardinal.omega \u2264 c) :\n\tc + c = c", "decl_tp": "\u2200 {c : cardinal}, cardinal.omega \u2264 c \u2192 c + c = c", "decl_nm": "cardinal.add_eq_self", "nl_statement_of_codex": "If $c$ is a cardinal such that $\\aleph_0\\leq c$, then $c+c=c$."}
{"formal_statement": "theorem prod {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [topological_space \u03b2]\n\t{s : set \u03b1} {t : set \u03b2} (hs : is_connected s) (ht : is_connected t) :\n\tis_connected (s.prod t)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {s : set \u03b1} {t : set \u03b2}, is_connected s \u2192 is_connected t \u2192 is_connected (s.prod t)", "decl_nm": "is_connected.prod", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces. If $X$ and $Y$ are connected, then $X\\times Y$ is connected."}
{"formal_statement": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {\u03b1 G : Type*} [group G] [group_with_zero \u03b1]\n\t[mul_distrib_mul_action \u03b1 G] {a : \u03b1} (ha : a \u2260 0) :\n\t\u2200 (S : subgroup G) (x : G), x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_2} [_inst_1 : group G] [_inst_3 : group_with_zero \u03b1] [_inst_4 : mul_distrib_mul_action \u03b1 G] {a : \u03b1}, a \u2260 0 \u2192 \u2200 (S : subgroup G) (x : G), x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "decl_nm": "subgroup.mem_pointwise_smul_iff_inv_smul_mem\u2080", "nl_statement_of_codex": "Let $G$ be a group and let $a\\in\\mathbb{Z}$. Then $a\\cdot S$ is the set of all elements of the form $a\\cdot s$ for $s\\in S$.\nMoreover, $a\\cdot S=a^{-1}\\cdot S$."}
{"formal_statement": "theorem to_add_hom_injective {M N : Type*} [add_zero_class M] [add_zero_class N] :\n\tfunction.injective add_monoid_hom.to_add_hom", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N], function.injective add_monoid_hom.to_add_hom", "decl_nm": "add_monoid_hom.to_add_hom_injective", "nl_statement_of_codex": "The map from the set of additive monoid homomorphisms from $M$ to $N$ to the set of functions from $M$ to $N$ is injective."}
{"formal_statement": "theorem div_le_iff_of_neg {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b c : \u03b1}\n\t(hc : c < 0) :\n\t(b / c \u2264 a \u2194 a * c \u2264 b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b c : \u03b1}, c < 0 \u2192 (b / c \u2264 a \u2194 a * c \u2264 b)", "decl_nm": "div_le_iff_of_neg", "nl_statement_of_codex": "Let $a,b,c$ be real numbers such that $c<0$. Then $b/c\\leq a$ if and only if $ac\\leq b$."}
{"formal_statement": "theorem is_empty_ring_equiv_symm_apply_support (R : Type u) (\u03c3 : Type*)\n\t[comm_semiring R] [he : is_empty \u03c3] (\u1fb0 : R) :\n\t(\u21d1((mv_polynomial.is_empty_ring_equiv R \u03c3).symm) \u1fb0).support = ite (\u1fb0 = 0) \u2205 {0}", "decl_tp": "\u2200 (R : Type u) (\u03c3 : Type u_1) [_inst_1 : comm_semiring R] [he : is_empty \u03c3] (\u1fb0 : R), (\u21d1((mv_polynomial.is_empty_ring_equiv R \u03c3).symm) \u1fb0).support = ite (\u1fb0 = 0) \u2205 {0}", "decl_nm": "mv_polynomial.is_empty_ring_equiv_symm_apply_support", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $\\sigma$ be an empty type. Then the support of the polynomial $a$ is $\\{0\\}$ if $a\\neq 0$ and is empty if $a=0$."}
{"formal_statement": "theorem unique_has_one {\u03b1 : Type*} [unique \u03b1] [has_one \u03b1] :\n\tinhabited.default \u03b1 = 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : unique \u03b1] [_inst_2 : has_one \u03b1], inhabited.default \u03b1 = 1", "decl_nm": "unique_has_one", "nl_statement_of_codex": "If $\u03b1$ is a type with a unique element and a multiplicative identity, then the unique element of $\u03b1$ is the multiplicative identity."}
{"formal_statement": "theorem map {\u03b1 \u03b2 n : Type*} {A : matrix n n \u03b1} (h : A.is_symm) :\n\t\u2200 (f : \u03b1 \u2192 \u03b2), (A.map f).is_symm", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {n : Type u_3} {A : matrix n n \u03b1}, A.is_symm \u2192 \u2200 (f : \u03b1 \u2192 \u03b2), (A.map f).is_symm", "decl_nm": "matrix.is_symm.map", "nl_statement_of_codex": "Let $A$ be a symmetric matrix. Then $f(A)$ is symmetric for any function $f$."}
{"formal_statement": "theorem bounded_range_of_tendsto_cofinite {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_metric_space \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : filter.tendsto f filter.cofinite (nhds a)) :\n\tmetric.bounded (set.range f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] {f : \u03b2 \u2192 \u03b1} {a : \u03b1}, filter.tendsto f filter.cofinite (nhds a) \u2192 metric.bounded (set.range f)", "decl_nm": "metric.bounded_range_of_tendsto_cofinite", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function from a pseudo-metric space $X$ to a metric space $Y$. If $f$ tends to $a\\in Y$ along the cofinite filter, then the range of $f$ is bounded."}
{"formal_statement": "theorem inclusion_injective {\u03b1 : Type*} {s t : set \u03b1} (h : s \u2286 t) :\n\tfunction.injective (set.inclusion h)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s t : set \u03b1} (h : s \u2286 t), function.injective (set.inclusion h)", "decl_nm": "set.inclusion_injective", "nl_statement_of_codex": "The inclusion map $s\\to t$ is injective if $s\\subset t$."}
{"formal_statement": "theorem nil_sublist {\u03b1 : Type u} (l : list \u03b1) :\n\tlist.nil <+ l", "decl_tp": "\u2200 {\u03b1 : Type u} (l : list \u03b1), list.nil <+ l", "decl_nm": "list.nil_sublist", "nl_statement_of_codex": "The empty list is a sublist of any list."}
{"formal_statement": "theorem to_linear_equiv_symm_apply (R : Type*) {S : Type*} (M : Type*)\n\t[semiring R] [add_comm_monoid M] [module R M] [group S] [distrib_mul_action S M]\n\t[smul_comm_class S R M] (s : S) (\u1fb0 : M) :\n\t\u21d1((distrib_mul_action.to_linear_equiv R M s).symm) \u1fb0 = (distrib_mul_action.to_add_equiv M s).inv_fun \u1fb0", "decl_tp": "\u2200 (R : Type u_1) {S : Type u_6} (M : Type u_7) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] [_inst_4 : group S] [_inst_5 : distrib_mul_action S M] [_inst_6 : smul_comm_class S R M] (s : S) (\u1fb0 : M), \u21d1((distrib_mul_action.to_linear_equiv R M s).symm) \u1fb0 = (distrib_mul_action.to_add_equiv M s).inv_fun \u1fb0", "decl_nm": "distrib_mul_action.to_linear_equiv_symm_apply", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $S$ a group acting on $M$ by $R$-linear maps. Then the inverse of the linear equivalence between $M$ and $M$ given by the action of $s\\in S$ is the additive equivalence between $M$ and $M$ given by the action of $s\\in S$."}
{"formal_statement": "theorem finprod_false {M : Type*} [comm_monoid M] (f : false \u2192 M) :\n\tfinprod (\u03bb (i : false), f i) = 1", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] (f : false \u2192 M), finprod (\u03bb (i : false), f i) = 1", "decl_nm": "finprod_false", "nl_statement_of_codex": "The product of the empty family of elements of a commutative monoid is the identity element."}
{"formal_statement": "theorem to_span_singleton_apply (R M : Type*) [semiring R] [add_comm_monoid M]\n\t[module R M] (x : M) (b : R) :\n\t\u21d1(linear_map.to_span_singleton R M x) b = b \u2022 x", "decl_tp": "\u2200 (R : Type u_1) (M : Type u_9) [_inst_1 : semiring R] [_inst_4 : add_comm_monoid M] [_inst_8 : module R M] (x : M) (b : R), \u21d1(linear_map.to_span_singleton R M x) b = b \u2022 x", "decl_nm": "linear_map.to_span_singleton_apply", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $x\\in M$. Then the linear map $\\mathbb{R}\\to M$ given by $b\\mapsto bx$ is the unique linear map $\\mathbb{R}\\to M$ that sends $1$ to $x$."}
{"formal_statement": "theorem length_to_list_pos_of_mem_support {\u03b1 : Type*} [fintype \u03b1] [decidable_eq \u03b1]\n\t(p : equiv.perm \u03b1) (x : \u03b1) (h : x \u2208 p.support) :\n\t0 < (p.to_list x).length", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b1] (p : equiv.perm \u03b1) (x : \u03b1), x \u2208 p.support \u2192 0 < (p.to_list x).length", "decl_nm": "equiv.perm.length_to_list_pos_of_mem_support", "nl_statement_of_codex": "Let $p$ be a permutation of a finite set $X$. If $x\\in X$ is in the support of $p$, then the length of the list $p.to_list x$ is positive."}
{"formal_statement": "theorem lift_eq {R : Type*} [comm_ring R] {S : Type*} [comm_ring S] [algebra R S]\n\t{P : Type*} [comm_ring P] (x : R) [is_localization.away x S] {g : R \u2192+* P}\n\t(hg : is_unit (\u21d1g x)) (a : R) :\n\t\u21d1(is_localization.away.lift x hg) (\u21d1(algebra_map R S) a) = \u21d1g a", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {S : Type u_2} [_inst_2 : comm_ring S] [_inst_3 : algebra R S] {P : Type u_3} [_inst_4 : comm_ring P] (x : R) [_inst_5 : is_localization.away x S] {g : R \u2192+* P} (hg : is_unit (\u21d1g x)) (a : R), \u21d1(is_localization.away.lift x hg) (\u21d1(algebra_map R S) a) = \u21d1g a", "decl_nm": "is_localization.away.away_map.lift_eq", "nl_statement_of_codex": "Let $R$ be a commutative ring, $S$ be an $R$-algebra, $P$ be a commutative ring, $x\\in R$, $g:R\\to P$ be a ring homomorphism, and $a\\in R$. If $g(x)$ is a unit in $P$, then the map $g$ induces a ring homomorphism $g:S\\to P$."}
{"formal_statement": "theorem map_sub {R M : Type*} [add_comm_group M] [ring R] [module R M]\n\t{Q : quadratic_form R M} (x y : M) :\n\t\u21d1Q (x - y) = \u21d1Q (y - x)", "decl_tp": "\u2200 {R : Type u_2} {M : Type u_3} [_inst_1 : add_comm_group M] [_inst_2 : ring R] [_inst_4 : module R M] {Q : quadratic_form R M} (x y : M), \u21d1Q (x - y) = \u21d1Q (y - x)", "decl_nm": "quadratic_form.map_sub", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, and $Q$ a quadratic form on $M$. Then $Q(x-y)=Q(y-x)$."}
{"formal_statement": "theorem measure_eq_extend {\u03b1 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}\n\t{s : set \u03b1} (hs : measurable_set s) :\n\t\u21d1\u03bc s = measure_theory.extend (\u03bb (t : set \u03b1) (ht : measurable_set t), \u21d1\u03bc t) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1}, measurable_set s \u2192 \u21d1\u03bc s = measure_theory.extend (\u03bb (t : set \u03b1) (ht : measurable_set t), \u21d1\u03bc t) s", "decl_nm": "measure_theory.measure_eq_extend", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $s\\subset X$ be a measurable set. Then $\\mu(s)$ is equal to the measure of $s$ with respect to the measure $\\mu$ extended to the measurable sets."}
{"formal_statement": "theorem mul_mem {M : Type*} [monoid M] {x y z : M} (_x : y \u2208 powers x) :\n\tz \u2208 powers x \u2192 y * z \u2208 powers x", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid M] {x y z : M}, y \u2208 powers x \u2192 z \u2208 powers x \u2192 y * z \u2208 powers x", "decl_nm": "powers.mul_mem", "nl_statement_of_codex": "Let $M$ be a monoid and let $x, y, z\\in M$. If $y$ is a power of $x$ and $z$ is a power of $x$, then $yz$ is a power of $x$."}
{"formal_statement": "theorem young_inequality (a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) :\n\ta * b \u2264 a ^ \u2191p / p + b ^ \u2191q / q", "decl_tp": "\u2200 (a b : nnreal) {p q : nnreal}, 1 < p \u2192 1 / p + 1 / q = 1 \u2192 a * b \u2264 a ^ \u2191p / p + b ^ \u2191q / q", "decl_nm": "nnreal.young_inequality", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{R}^+$ and $p,q\\in\\mathbb{R}^+$ such that $1<p$ and $1/p+1/q=1$. Then $ab\\leq a^p/p+b^q/q$."}
{"formal_statement": "theorem disjoint_prod_perm {\u03b1 : Type*} {l\u2081 l\u2082 : list (equiv.perm \u03b1)} (hl : list.pairwise equiv.perm.disjoint l\u2081)\n\t(hp : l\u2081 ~ l\u2082) :\n\tl\u2081.prod = l\u2082.prod", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l\u2081 l\u2082 : list (equiv.perm \u03b1)}, list.pairwise equiv.perm.disjoint l\u2081 \u2192 l\u2081 ~ l\u2082 \u2192 l\u2081.prod = l\u2082.prod", "decl_nm": "equiv.perm.disjoint_prod_perm", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of permutations of a set $A$. If $l_1$ and $l_2$ are disjoint and $l_1$ is a permutation of $l_2$, then the product of the permutations in $l_1$ is equal to the product of the permutations in $l_2$."}
{"formal_statement": "theorem ext {G : Type u} (x y : semigroup G) :\n\tsemigroup.mul = semigroup.mul \u2192 x = y", "decl_tp": "\u2200 {G : Type u} (x y : semigroup G), semigroup.mul = semigroup.mul \u2192 x = y", "decl_nm": "semigroup.ext", "nl_statement_of_codex": "Let $G$ be a semigroup. If two semigroups $x$ and $y$ have the same multiplication, then $x=y$."}
{"formal_statement": "theorem op_act_op_eq {R : Type*} [rack R] {x y : R} :\n\tshelf.act (mul_opposite.op x) (mul_opposite.op y) = mul_opposite.op (rack.inv_act x y)", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : rack R] {x y : R}, shelf.act (mul_opposite.op x) (mul_opposite.op y) = mul_opposite.op (rack.inv_act x y)", "decl_nm": "rack.op_act_op_eq", "nl_statement_of_codex": "The action of the opposite of $x$ on the opposite of $y$ is the opposite of the inverse action of $x$ on $y$."}
{"formal_statement": "theorem ball_image_iff {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}\n\t{p : \u03b2 \u2192 Prop} :\n\t(\u2200 (y : \u03b2), y \u2208 f '' s \u2192 p y) \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 p (f x)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} {p : \u03b2 \u2192 Prop}, (\u2200 (y : \u03b2), y \u2208 f '' s \u2192 p y) \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 p (f x)", "decl_nm": "set.ball_image_iff", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function and let $A\\subset X$. Then $f(A)\\subset Y$ if and only if $f^{-1}(f(A))=A$."}
{"formal_statement": "theorem map_comp {C : Type u\u2081} [category_theory.category C] {X Y Z : C}\n\t(f : X \u27f6 Y) (g : Y \u27f6 Z) [category_theory.mono f] [category_theory.mono g]\n\t(x : category_theory.subobject X) :\n\t(category_theory.subobject.map (f \u226b g)).obj x = (category_theory.subobject.map g).obj ((category_theory.subobject.map f).obj x)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [_inst_3 : category_theory.mono f] [_inst_4 : category_theory.mono g] (x : category_theory.subobject X), (category_theory.subobject.map (f \u226b g)).obj x = (category_theory.subobject.map g).obj ((category_theory.subobject.map f).obj x)", "decl_nm": "category_theory.subobject.map_comp", "nl_statement_of_codex": "Let $C$ be a category and let $X, Y, Z$ be objects of $C$. Let $f:X\\to Y$ and $g:Y\\to Z$ be morphisms in $C$.\nIf $f$ and $g$ are monomorphisms, then the following diagram commutes:\n$$\\begin{array}{ccc}\nX & \\xrightarrow{f} & Y \\\\\n\\downarrow & & \\downarrow \\\\\n\\operatorname{im}(f) & \\xrightarrow{g} & \\operatorname{im}(g\\circ f)\n\\end{array}$$"}
{"formal_statement": "theorem algebra_map_def (k : Type u) [field k] {R : Type*} [comm_semiring R]\n\t[alg : algebra R k] :\n\talgebra_map R (algebraic_closure k) = (algebraic_closure.of_step k 0).comp (algebra_map R k)", "decl_tp": "\u2200 (k : Type u) [_inst_1 : field k] {R : Type u_1} [_inst_2 : comm_semiring R] [alg : algebra R k], algebra_map R (algebraic_closure k) = (algebraic_closure.of_step k 0).comp (algebra_map R k)", "decl_nm": "algebraic_closure.algebra_map_def", "nl_statement_of_codex": "The algebra map from $R$ to the algebraic closure of $k$ is the composition of the algebra map from $R$ to $k$ with the algebra map from $k$ to the algebraic closure of $k$."}
{"formal_statement": "theorem Icc_diff_Ioc_same {\u03b1 : Type u} [partial_order \u03b1] {a b : \u03b1} (h : a \u2264 b) :\n\tset.Icc a b \\ set.Ioc a b = {a}", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] {a b : \u03b1}, a \u2264 b \u2192 set.Icc a b \\ set.Ioc a b = {a}", "decl_nm": "set.Icc_diff_Ioc_same", "nl_statement_of_codex": "Let $a,b\\in\\mathbb{R}$ with $a\\leq b$. Then $[a,b]\\setminus(a,b)=[a]$."}
{"formal_statement": "theorem sum_congr_trans {\u03b1 \u03b2 : Type*} (e : equiv.perm \u03b1) (f : equiv.perm \u03b2)\n\t(g : equiv.perm \u03b1) (h : equiv.perm \u03b2) :\n\tequiv.trans (e.sum_congr f) (g.sum_congr h) = equiv.perm.sum_congr (equiv.trans e g)\n\t(equiv.trans f h)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : equiv.perm \u03b1) (f : equiv.perm \u03b2) (g : equiv.perm \u03b1) (h : equiv.perm \u03b2), equiv.trans (e.sum_congr f) (g.sum_congr h) = equiv.perm.sum_congr (equiv.trans e g) (equiv.trans f h)", "decl_nm": "equiv.perm.sum_congr_trans", "nl_statement_of_codex": "Let $e,f,g,h$ be permutations of sets $A,B,A,B$ respectively. Then $(e+f)\\circ(g+h)=(eg+fh)$."}
{"formal_statement": "theorem lift_to_terminal_map {C : Type u} [category_theory.category C]\n\t{D : Type*} [category_theory.category D] {Z : D} (F : C \u2964 D) (hZ : category_theory.limits.is_terminal Z)\n\t(X Y : category_theory.with_terminal C) (f : X \u27f6 Y) :\n\t(category_theory.with_terminal.lift_to_terminal F hZ).map f = category_theory.with_terminal.lift._match_2 F (\u03bb (x : C), hZ.from (F.obj x)) X Y f", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {D : Type u_1} [_inst_2 : category_theory.category D] {Z : D} (F : C \u2964 D) (hZ : category_theory.limits.is_terminal Z) (X Y : category_theory.with_terminal C) (f : X \u27f6 Y), (category_theory.with_terminal.lift_to_terminal F hZ).map f = category_theory.with_terminal.lift._match_2 F (\u03bb (x : C), hZ.from (F.obj x)) X Y f", "decl_nm": "category_theory.with_terminal.lift_to_terminal_map", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ be a functor. Let $Z$ be a terminal object in $D$ and let $X$ and $Y$ be objects in $C$ with terminal maps $f:X\\to Y$. Then the map $F(f):F(X)\\to F(Y)$ is terminal in $D$."}
{"formal_statement": "theorem add_im_j {R : Type*} [comm_ring R] (a b : quaternion R) :\n\t(a + b).im_j = a.im_j + b.im_j", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (a b : quaternion R), (a + b).im_j = a.im_j + b.im_j", "decl_nm": "quaternion.add_im_j", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then the imaginary part of the sum of two quaternions $a$ and $b$ is the sum of the imaginary parts of $a$ and $b$."}
{"formal_statement": "theorem to_submonoid_mono {G : Type*} [group G] :\n\tmonotone subgroup.to_submonoid", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G], monotone subgroup.to_submonoid", "decl_nm": "subgroup.to_submonoid_mono", "nl_statement_of_codex": "The map from subgroups of $G$ to submonoids of $G$ is monotone."}
{"formal_statement": "theorem uniform_continuous_iff {\u03b1 \u03b2 : Type*} [u\u03b1 : uniform_space \u03b1] [u\u03b2 : uniform_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} :\n\tuniform_continuous f \u2194 u\u03b1 \u2264 uniform_space.comap f u\u03b2", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [u\u03b1 : uniform_space \u03b1] [u\u03b2 : uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2}, uniform_continuous f \u2194 u\u03b1 \u2264 uniform_space.comap f u\u03b2", "decl_nm": "uniform_continuous_iff", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between uniform spaces. Then $f$ is uniformly continuous if and only if the uniformity on $X$ is coarser than the uniformity on $Y$."}
{"formal_statement": "theorem bind_le {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {g : \u03b1 \u2192 filter \u03b2}\n\t{l : filter \u03b2} :\n\t(\u2200\u1da0 (x : \u03b1) in f, g x \u2264 l) \u2192 f.bind g \u2264 l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b1} {g : \u03b1 \u2192 filter \u03b2} {l : filter \u03b2}, (\u2200\u1da0 (x : \u03b1) in f, g x \u2264 l) \u2192 f.bind g \u2264 l", "decl_nm": "filter.bind_le", "nl_statement_of_codex": "Let $f$ be a filter on $\u03b1$ and let $g$ be a function from $\u03b1$ to filters on $\u03b2$. If $g(x)$ is a subset of $l$ for all $x\\in f$, then $f\\circ g$ is a subset of $l$."}
{"formal_statement": "theorem sum_option_index_smul {\u03b1 M R : Type*1} [semiring R] [add_comm_monoid M]\n\t[module R M] (f : option \u03b1 \u2192\u2080 R) (b : option \u03b1 \u2192 M) :\n\tf.sum (\u03bb (o : option \u03b1) (r : R), r \u2022 b o) = \u21d1f option.none \u2022 b option.none + f.some.sum (\u03bb (a : \u03b1)\n\t(r : R), r \u2022 b (option.some a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {R : Type u_11} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] (f : option \u03b1 \u2192\u2080 R) (b : option \u03b1 \u2192 M), f.sum (\u03bb (o : option \u03b1) (r : R), r \u2022 b o) = \u21d1f option.none \u2022 b option.none + f.some.sum (\u03bb (a : \u03b1) (r : R), r \u2022 b (option.some a))", "decl_nm": "finsupp.sum_option_index_smul", "nl_statement_of_codex": "Let $f$ be a function from the option type to a semiring $R$. Let $b$ be a function from the option type to a module $M$ over $R$. Then\n$$\\sum_{o\\in\\text{option}} f(o)b(o)=f(\\text{none})b(\\text{none})+\\sum_{a\\in\\text{some}} f(a)b(a).$$"}
{"formal_statement": "theorem exists_ne {\u03b1 : Type*} [nontrivial \u03b1] [decidable_eq \u03b1] (x : \u03b1) :\n\t\u2203 (y : \u03b1), y \u2260 x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : nontrivial \u03b1] [_inst_2 : decidable_eq \u03b1] (x : \u03b1), \u2203 (y : \u03b1), y \u2260 x", "decl_nm": "decidable.exists_ne", "nl_statement_of_codex": "Let $X$ be a nontrivial set. Then there exists an element $y\\in X$ such that $y\\neq x$."}
{"formal_statement": "theorem to_fun_eq_coe {R : Type*} [ring R] {E : Type*} [add_comm_group E]\n\t[module R E] {F : Type*} [add_comm_group F] [module R F] (f : linear_pmap R E F)\n\t(x : \u21a5(f.domain)) :\n\t\u21d1(f.to_fun) x = \u21d1f x", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R] {E : Type u_2} [_inst_2 : add_comm_group E] [_inst_3 : module R E] {F : Type u_3} [_inst_4 : add_comm_group F] [_inst_5 : module R F] (f : linear_pmap R E F) (x : \u21a5(f.domain)), \u21d1(f.to_fun) x = \u21d1f x", "decl_nm": "linear_pmap.to_fun_eq_coe", "nl_statement_of_codex": "Let $R$ be a ring, $E$ and $F$ be $R$-modules. Let $f:E\\to F$ be a linear map. Then $f$ is equal to the function $f:E\\to F$ defined by $f(x)=f(x)$."}
{"formal_statement": "theorem map_radical_le {R : Type u} {S : Type v} [comm_ring R] [comm_ring S]\n\t(f : R \u2192+* S) {I : ideal R} :\n\tideal.map f I.radical \u2264 (ideal.map f I).radical", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : comm_ring R] [_inst_2 : comm_ring S] (f : R \u2192+* S) {I : ideal R}, ideal.map f I.radical \u2264 (ideal.map f I).radical", "decl_nm": "ideal.map_radical_le", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings and let $f:R\\to S$ be a ring homomorphism. Then the radical of the ideal $f(I)$ is contained in the radical of the ideal $I$."}
{"formal_statement": "theorem unique_up_to_iso_inv {C : Type u\u2081} [category_theory.category C]\n\t{I I' : C} (hI : category_theory.limits.is_initial I) (hI' : category_theory.limits.is_initial I') :\n\t(hI.unique_up_to_iso hI').inv = hI'.to I", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {I I' : C} (hI : category_theory.limits.is_initial I) (hI' : category_theory.limits.is_initial I'), (hI.unique_up_to_iso hI').inv = hI'.to I", "decl_nm": "category_theory.limits.is_initial.unique_up_to_iso_inv", "nl_statement_of_codex": "Let $C$ be a category and let $I$ and $I'$ be initial objects in $C$. Then the inverse of the unique isomorphism from $I$ to $I'$ is the unique morphism from $I'$ to $I$."}
{"formal_statement": "theorem comap_coe_at_top {R : Type*} [ordered_ring R] [nontrivial R] [archimedean R] :\n\tfilter.comap coe filter.at_top = filter.at_top", "decl_tp": "\u2200 {R : Type u_2} [_inst_1 : ordered_ring R] [_inst_2 : nontrivial R] [_inst_3 : archimedean R], filter.comap coe filter.at_top = filter.at_top", "decl_nm": "int.comap_coe_at_top", "nl_statement_of_codex": "The filter of cofinite sets is the same as the filter of sets containing $+\\infty$."}
{"formal_statement": "theorem inl_desc_assoc {C : Type u} [category_theory.category C] {W X Y Z : C}\n\t{f : X \u27f6 Y} {g : X \u27f6 Z} [category_theory.limits.has_pushout f g] (h : Y \u27f6 W)\n\t(k : Z \u27f6 W) (w : f \u226b h = g \u226b k) {X' : C} (f' : W \u27f6 X') :\n\tcategory_theory.limits.pushout.inl \u226b category_theory.limits.pushout.desc h k w \u226b f' = h \u226b f'", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [_inst_2 : category_theory.limits.has_pushout f g] (h : Y \u27f6 W) (k : Z \u27f6 W) (w : f \u226b h = g \u226b k) {X' : C} (f' : W \u27f6 X'), category_theory.limits.pushout.inl \u226b category_theory.limits.pushout.desc h k w \u226b f' = h \u226b f'", "decl_nm": "category_theory.limits.pushout.inl_desc_assoc", "nl_statement_of_codex": "Let $C$ be a category. Let $f:X\\to Y$ and $g:X\\to Z$ be morphisms in $C$ and let $h:Y\\to W$ and $k:Z\\to W$ be morphisms in $C$. Suppose that $f$ and $g$ have a pushout $p:W\\to X'$. Then the following diagram commutes:\n$$\\begin{array}{ccc}\nX & \\xrightarrow{(f,g)} & Y\\times Z \\\\\n\\downarrow{p} & & \\downarrow{(h,k)} \\\\\nX' & \\xrightarrow{(h\\circ"}
{"formal_statement": "theorem has_limits_of_shape_of_equivalence {J : Type u\u2081} [category_theory.category J]\n\t{C : Type u} [category_theory.category C] {J' : Type u\u2082} [category_theory.category J'] :\n\t(J \u224c J') \u2192 \u2200 [category_theory.limits.has_limits_of_shape J C], category_theory.limits.has_limits_of_shape J' C", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u} [_inst_3 : category_theory.category C] {J' : Type u\u2082} [_inst_4 : category_theory.category J'], (J \u224c J') \u2192 \u2200 [_inst_5 : category_theory.limits.has_limits_of_shape J C], category_theory.limits.has_limits_of_shape J' C", "decl_nm": "category_theory.limits.has_limits_of_shape_of_equivalence", "nl_statement_of_codex": "If $J$ and $J'$ are equivalent categories, then $C$ has limits of shape $J$ if and only if $C$ has limits of shape $J'$."}
{"formal_statement": "theorem coe_prod_comm_symm {R S : Type*} [non_assoc_semiring R] [non_assoc_semiring S] :\n\t\u21d1(ring_equiv.prod_comm.symm) = prod.swap", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_3} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S], \u21d1(ring_equiv.prod_comm.symm) = prod.swap", "decl_nm": "ring_equiv.coe_prod_comm_symm", "nl_statement_of_codex": "The inverse of the commutativity isomorphism between $R\\times S$ and $S\\times R$ is the swap map."}
{"formal_statement": "theorem smul_eq_iff_eq_inv_smul {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [mul_action \u03b1 \u03b2]\n\t(g : \u03b1) {x y : \u03b2} :\n\tg \u2022 x = y \u2194 x = g\u207b\u00b9 \u2022 y", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] (g : \u03b1) {x y : \u03b2}, g \u2022 x = y \u2194 x = g\u207b\u00b9 \u2022 y", "decl_nm": "smul_eq_iff_eq_inv_smul", "nl_statement_of_codex": "Let $G$ be a group acting on a set $X$. Then $g\\cdot x=y$ if and only if $x=g^{-1}\\cdot y$."}
{"formal_statement": "theorem self_cast_nat_mul {R : Type u\u2081} [semiring R] {a : R} (n : \u2115) :\n\tcommute a (\u2191n * a)", "decl_tp": "\u2200 {R : Type u\u2081} [_inst_1 : semiring R] {a : R} (n : \u2115), commute a (\u2191n * a)", "decl_nm": "commute.self_cast_nat_mul", "nl_statement_of_codex": "Let $R$ be a semiring and let $a\\in R$. Then $a(na)=na$."}
{"formal_statement": "theorem mk_zero_smul {\u03b9 : Type*} {A : \u03b9 \u2192 Type*} [add_monoid \u03b9] [graded_monoid.ghas_mul A]\n\t{i : \u03b9} (a : A 0) (b : A i) :\n\tgraded_monoid.mk i (a \u2022 b) = graded_monoid.mk 0 a * graded_monoid.mk i b", "decl_tp": "\u2200 {\u03b9 : Type u_1} {A : \u03b9 \u2192 Type u_2} [_inst_1 : add_monoid \u03b9] [_inst_2 : graded_monoid.ghas_mul A] {i : \u03b9} (a : A 0) (b : A i), graded_monoid.mk i (a \u2022 b) = graded_monoid.mk 0 a * graded_monoid.mk i b", "decl_nm": "graded_monoid.mk_zero_smul", "nl_statement_of_codex": "Let $A$ be a graded monoid. Then $A_0\\cdot A_i=A_0\\otimes A_i$."}
{"formal_statement": "theorem initial_mono_class_of_disjoint_coproducts {C : Type u} [category_theory.category C]\n\t[category_theory.limits.coproducts_disjoint C] :\n\tcategory_theory.limits.initial_mono_class C", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.coproducts_disjoint C], category_theory.limits.initial_mono_class C", "decl_nm": "category_theory.limits.initial_mono_class_of_disjoint_coproducts", "nl_statement_of_codex": "If $C$ has disjoint coproducts, then the class of initial monomorphisms in $C$ is a factorization system."}
{"formal_statement": "theorem summable_of_nonneg_of_le {\u03b2 : Type*} {f g : \u03b2 \u2192 \u211d} (hf : summable f) :\n\t(\u2200 (b : \u03b2), 0 \u2264 g b) \u2192 (\u2200 (b : \u03b2), g b \u2264 f b) \u2192  summable g", "decl_tp": "\u2200 {\u03b2 : Type u_2} {f g : \u03b2 \u2192 \u211d}, (\u2200 (b : \u03b2), 0 \u2264 g b) \u2192 (\u2200 (b : \u03b2), g b \u2264 f b) \u2192 summable f \u2192 summable g", "decl_nm": "summable_of_nonneg_of_le", "nl_statement_of_codex": "Let $f,g:\\beta\\to\\mathbb{R}$. If $f$ is summable and $g$ is nonnegative and less than or equal to $f$, then $g$ is summable."}
{"formal_statement": "theorem some_orelse {\u03b1 : Type*} (a : \u03b1) (x : option \u03b1) :\n\t(option.some a <|> x) = option.some a", "decl_tp": "\u2200 {\u03b1 : Type u_1} (a : \u03b1) (x : option \u03b1), (option.some a <|> x) = option.some a", "decl_nm": "option.some_orelse", "nl_statement_of_codex": "The expression $(\\mathrm{some}\\ a\\ \\mathrm{orelse}\\ x)$ is equal to $\\mathrm{some}\\ a$."}
{"formal_statement": "theorem associated_one_of_mul_eq_one {\u03b1 : Type*} [comm_monoid \u03b1] {a : \u03b1}\n\t(b : \u03b1) (hab : a * b = 1) :\n\tassociated a 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {a : \u03b1} (b : \u03b1), a * b = 1 \u2192 associated a 1", "decl_nm": "associated_one_of_mul_eq_one", "nl_statement_of_codex": "Let $a$ and $b$ be elements of a commutative monoid $M$. If $ab=1$, then $a$ is associated to $1$."}
{"formal_statement": "theorem vsub {\u03b1 V P : Type*} [semi_normed_group V] [pseudo_metric_space P]\n\t[semi_normed_add_torsor V P] [topological_space \u03b1] {f g : \u03b1 \u2192 P} {x : \u03b1}\n\t(hf : continuous_at f x) (hg : continuous_at g x) :\n\tcontinuous_at (f -\u1d65 g) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : semi_normed_group V] [_inst_2 : pseudo_metric_space P] [_inst_3 : semi_normed_add_torsor V P] [_inst_7 : topological_space \u03b1] {f g : \u03b1 \u2192 P} {x : \u03b1}, continuous_at f x \u2192 continuous_at g x \u2192 continuous_at (f -\u1d65 g) x", "decl_nm": "continuous_at.vsub", "nl_statement_of_codex": "Let $V$ be a semi-normed group, $P$ a pseudo-metric space, and $f,g:X\\to P$ continuous at $x$. Then $f-g$ is continuous at $x$."}
{"formal_statement": "theorem card_option {\u03b1 : Type*} [fintype \u03b1] :\n\tfintype.card (option \u03b1) = fintype.card \u03b1 + 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1], fintype.card (option \u03b1) = fintype.card \u03b1 + 1", "decl_nm": "fintype.card_option", "nl_statement_of_codex": "The cardinality of the set of options of a finite set is one more than the cardinality of the set."}
{"formal_statement": "theorem ext {R : Type u} {A : Type v} {B : Type w} [comm_semiring R] [semiring A]\n\t[semiring B] [algebra R A] [algebra R B] {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} :\n\t(\u2200 (x : A), \u21d1\u03c6\u2081 x = \u21d1\u03c6\u2082 x) \u2192 \u03c6\u2081 = \u03c6\u2082", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : semiring B] [_inst_6 : algebra R A] [_inst_7 : algebra R B] {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B}, (\u2200 (x : A), \u21d1\u03c6\u2081 x = \u21d1\u03c6\u2082 x) \u2192 \u03c6\u2081 = \u03c6\u2082", "decl_nm": "alg_hom.ext", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be semirings, and $\u03c6_1, \u03c6_2:A\u2192B$ be $R$-algebra homomorphisms. Then $\u03c6_1=\u03c6_2$ if and only if $\u03c6_1(x)=\u03c6_2(x)$ for all $x\\in A$."}
{"formal_statement": "theorem measure_trim_to_measurable_eq_zero {\u03b1 : Type*} {m m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} {hm : m \u2264 m0} (hs : \u21d1(\u03bc.trim hm) s = 0) :\n\t\u21d1\u03bc (measure_theory.to_measurable (\u03bc.trim hm) s) = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {s : set \u03b1} {hm : m \u2264 m0}, \u21d1(\u03bc.trim hm) s = 0 \u2192 \u21d1\u03bc (measure_theory.to_measurable (\u03bc.trim hm) s) = 0", "decl_nm": "measure_theory.measure_trim_to_measurable_eq_zero", "nl_statement_of_codex": "Let $m$ and $m'$ be measurable spaces and let $\\mu$ be a measure on $m$. Let $s$ be a set in $m'$. If $m\\leq m'$ and $\\mu(s)=0$, then $\\mu(s)=0$."}
{"formal_statement": "theorem nth_map {\u0393 \u0393' : Type*} [inhabited \u0393] [inhabited \u0393'] (f : turing.pointed_map \u0393 \u0393')\n\t(l : turing.list_blank \u0393) (n : \u2115) :\n\t(turing.list_blank.map f l).nth n = \u21d1f (l.nth n)", "decl_tp": "\u2200 {\u0393 : Type u_1} {\u0393' : Type u_2} [_inst_1 : inhabited \u0393] [_inst_2 : inhabited \u0393'] (f : turing.pointed_map \u0393 \u0393') (l : turing.list_blank \u0393) (n : \u2115), (turing.list_blank.map f l).nth n = \u21d1f (l.nth n)", "decl_nm": "turing.list_blank.nth_map", "nl_statement_of_codex": "Let $f:\\Gamma\\to\\Gamma'$ be a pointed map. Let $l$ be a list of blanks in $\\Gamma$. Then the $n$th element of the list $f(l)$ is $f(l_n)$."}
{"formal_statement": "theorem comp_antitone {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [topological_space \u03b1]\n\t[preorder \u03b2] [preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (hf : is_local_max f a)\n\t(hg : antitone g) :\n\t\u2200 {g : \u03b2 \u2192 \u03b3},  is_local_min (g \u2218 f) a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {a : \u03b1}, is_local_max f a \u2192 \u2200 {g : \u03b2 \u2192 \u03b3}, antitone g \u2192 is_local_min (g \u2218 f) a", "decl_nm": "is_local_max.comp_antitone", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. If $f$ has a local maximum at $a\\in X$, then $g\\circ f$ has a local minimum at $a$ for any function $g:Y\\to Z$ that is antitone."}
{"formal_statement": "theorem lift_max {a : cardinal} {b : cardinal} :\n\ta.lift = b.lift \u2194 a.lift = b.lift", "decl_tp": "\u2200 {a : cardinal} {b : cardinal}, a.lift = b.lift \u2194 a.lift = b.lift", "decl_nm": "cardinal.lift_max", "nl_statement_of_codex": "The lift of a cardinal is equal to the lift of another cardinal if and only if the lift of the first cardinal is equal to the lift of the second cardinal."}
{"formal_statement": "theorem inv_on_inv_fun_on {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} [nonempty \u03b1] (h : set.surj_on f s t) :\n\tset.inv_on (function.inv_fun_on f s) f (function.inv_fun_on f s '' t) t", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2} [_inst_1 : nonempty \u03b1], set.surj_on f s t \u2192 set.inv_on (function.inv_fun_on f s) f (function.inv_fun_on f s '' t) t", "decl_nm": "set.surj_on.inv_on_inv_fun_on", "nl_statement_of_codex": "Let $f:A\\to B$ be a surjective function. Then $f^{-1}:B\\to A$ is a bijection from $B$ to $f^{-1}(B)$."}
{"formal_statement": "theorem take_zero {\u03b1 : Type u} (s : stream \u03b1) :\n\tstream.take 0 s = list.nil", "decl_tp": "\u2200 {\u03b1 : Type u} (s : stream \u03b1), stream.take 0 s = list.nil", "decl_nm": "stream.take_zero", "nl_statement_of_codex": "The first $0$ elements of a stream $s$ is the empty list."}
{"formal_statement": "theorem upper_semicontinuous_within_at {\u03b1 : Type*} [topological_space \u03b1]\n\t{\u03b2 : Type*} [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {x : \u03b1} (s : set \u03b1) (h : upper_semicontinuous_at f x) :\n\tupper_semicontinuous_within_at f s x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {x : \u03b1} (s : set \u03b1), upper_semicontinuous_at f x \u2192 upper_semicontinuous_within_at f s x", "decl_nm": "upper_semicontinuous_at.upper_semicontinuous_within_at", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a preordered set. Let $f:X\\to Y$ and let $x\\in X$. If $f$ is upper semicontinuous at $x$, then $f$ is upper semicontinuous within $x$."}
{"formal_statement": "theorem inv_mul_cancel_comm_assoc {G : Type*} [comm_group G] (a b : G) :\n\ta\u207b\u00b9 * (b * a) = b", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : comm_group G] (a b : G), a\u207b\u00b9 * (b * a) = b", "decl_nm": "inv_mul_cancel_comm_assoc", "nl_statement_of_codex": "Let $G$ be a commutative group. Then $a^{-1}(ba)=b$ for all $a,b\\in G$."}
{"formal_statement": "theorem and_or_imp {a b c : Prop} [decidable a] :\n\ta \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c", "decl_tp": "\u2200 {a b c : Prop} [_inst_1 : decidable a], a \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c", "decl_nm": "decidable.and_or_imp", "nl_statement_of_codex": "$a\\land b\\lor (a\\to c)$ is equivalent to $a\\to (b\\lor c)$."}
{"formal_statement": "theorem sum_comp_inl (C : Type u\u2081) [category_theory.category C] (D : Type u\u2081)\n\t[category_theory.category D] {P Q R : C} (f : sum.inl P \u27f6 sum.inl Q) (g : sum.inl Q \u27f6 sum.inl R) :\n\tf \u226b g = f \u226b g", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] (D : Type u\u2081) [_inst_2 : category_theory.category D] {P Q R : C} (f : sum.inl P \u27f6 sum.inl Q) (g : sum.inl Q \u27f6 sum.inl R), f \u226b g = f \u226b g", "decl_nm": "category_theory.sum_comp_inl", "nl_statement_of_codex": "Let $C$ and $D$ be categories. Let $P, Q, R$ be objects of $C$ and let $f:P\\to Q$ and $g:Q\\to R$ be morphisms in $C$. Then $f\\circ g=f\\circ g$."}
{"formal_statement": "theorem congr {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {s : set E}\n\t{f f\u2081 : E \u2192 F} {n : with_top \u2115} (h : times_cont_diff_on \ud835\udd5c n f s) (hx : x \u2208 s) :\n\t(\u2200 (x : E),  f\u2081 x = f x) \u2192 times_cont_diff_on \ud835\udd5c n f\u2081 s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {s : set E} {f f\u2081 : E \u2192 F} {n : with_top \u2115}, times_cont_diff_on \ud835\udd5c n f s \u2192 (\u2200 (x : E), x \u2208 s \u2192 f\u2081 x = f x) \u2192 times_cont_diff_on \ud835\udd5c n f\u2081 s", "decl_nm": "times_cont_diff_on.congr", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f, f_1:E\\to F$ and let $s\\subset E$. If $f$ is $n$-times continuously differentiable on $s$, then $f_1$ is $n$-times continuously differentiable on $s$ if $f_1(x)=f(x)$ for all $x\\in s$."}
{"formal_statement": "theorem of_det_ne_zero {n : Type*} [fintype n] {A : Type*} [decidable_eq n]\n\t[comm_ring A] [is_domain A] {M : matrix n n A} :\n\tM.det \u2260 0 \u2192 M.nondegenerate", "decl_tp": "\u2200 {n : Type u_3} [_inst_4 : fintype n] {A : Type u_1} [_inst_5 : decidable_eq n] [_inst_6 : comm_ring A] [_inst_7 : is_domain A] {M : matrix n n A}, M.det \u2260 0 \u2192 M.nondegenerate", "decl_nm": "matrix.nondegenerate.of_det_ne_zero", "nl_statement_of_codex": "Let $A$ be a domain and let $M$ be an $n\\times n$ matrix over $A$. If the determinant of $M$ is nonzero, then $M$ is nondegenerate."}
{"formal_statement": "theorem face_upper {n : \u2115} (I : box_integral.box (fin (n + 1))) (i : fin (n + 1))\n\t(\u1fb0 : fin n) :\n\t(I.face i).upper \u1fb0 = (I.upper \u2218 \u21d1(i.succ_above)) \u1fb0", "decl_tp": "\u2200 {n : \u2115} (I : box_integral.box (fin (n + 1))) (i : fin (n + 1)) (\u1fb0 : fin n), (I.face i).upper \u1fb0 = (I.upper \u2218 \u21d1(i.succ_above)) \u1fb0", "decl_nm": "box_integral.box.face_upper", "nl_statement_of_codex": "Let $I$ be a box integral in $\\mathbb{R}^{n+1}$. Let $i\\in\\{0,\\ldots,n\\}$ and let $\\alpha\\in\\{0,\\ldots,n-1\\}$. Then the upper bound of the $i$-face of $I$ at $\\alpha$ is the upper bound of $I$ at $\\alpha$ if $i\\neq\\alpha$ and the upper bound of $I$ at $\\alpha+1$ if $i=\\alpha$."}
{"formal_statement": "theorem one_le_mul {\u03b1 : Type*} [mul_one_class \u03b1] [preorder \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_le.le]\n\t{a b : \u03b1} (ha : 1 \u2264 a) (hb : 1 \u2264 b) :\n\t1 \u2264 a * b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : mul_one_class \u03b1] [_inst_2 : preorder \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] {a b : \u03b1}, 1 \u2264 a \u2192 1 \u2264 b \u2192 1 \u2264 a * b", "decl_nm": "one_le_mul", "nl_statement_of_codex": "Let $R$ be a preordered ring with $1$. If $1\\le a$ and $1\\le b$, then $1\\le ab$."}
{"formal_statement": "theorem modify_nth_tail_modify_nth_tail {\u03b1 : Type u} {f g : list \u03b1 \u2192 list \u03b1}\n\t(m n : \u2115) (l : list \u03b1) :\n\tlist.modify_nth_tail g (m + n) (list.modify_nth_tail f n l) = list.modify_nth_tail (\u03bb (l : list \u03b1), list.modify_nth_tail g m (f l)) n l", "decl_tp": "\u2200 {\u03b1 : Type u} {f g : list \u03b1 \u2192 list \u03b1} (m n : \u2115) (l : list \u03b1), list.modify_nth_tail g (m + n) (list.modify_nth_tail f n l) = list.modify_nth_tail (\u03bb (l : list \u03b1), list.modify_nth_tail g m (f l)) n l", "decl_nm": "list.modify_nth_tail_modify_nth_tail", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to\\mathbb{N}$ be two functions. Then $f(g(n))=g(f(n))$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem map_symm {R : Type*} [ordered_comm_semiring R] {M : Type*} [add_comm_monoid M]\n\t[module R M] {N : Type*} [add_comm_monoid N] [module R N] (\u03b9 : Type*)\n\t[decidable_eq \u03b9] [nontrivial R] (e : M \u2243\u2097[R] N) :\n\t(orientation.map \u03b9 e).symm = orientation.map \u03b9 e.symm", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ordered_comm_semiring R] {M : Type u_2} [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {N : Type u_3} [_inst_4 : add_comm_monoid N] [_inst_5 : module R N] (\u03b9 : Type u_4) [_inst_6 : decidable_eq \u03b9] [_inst_7 : nontrivial R] (e : M \u2243\u2097[R] N), (orientation.map \u03b9 e).symm = orientation.map \u03b9 e.symm", "decl_nm": "orientation.map_symm", "nl_statement_of_codex": "Let $R$ be an ordered commutative semiring, $M$ and $N$ be $R$-modules, and $e:M\\to N$ be an isomorphism of $R$-modules. Then the orientation of $e$ is the inverse of the orientation of $e^{-1}$."}
{"formal_statement": "theorem mul_self_le_mul_self_of_le_of_neg_le {\u03b1 : Type u} [linear_ordered_ring \u03b1]\n\t{x y : \u03b1} (h\u2081 : x \u2264 y) :\n\t- x * x \u2264 y * y", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_ring \u03b1] {x y : \u03b1}, x \u2264 y \u2192 -x \u2264 y \u2192 x * x \u2264 y * y", "decl_nm": "mul_self_le_mul_self_of_le_of_neg_le", "nl_statement_of_codex": "Let $x,y\\in\\alpha$ be elements of a linear ordered ring. If $x\\leq y$, then $-x^2\\leq y^2$."}
{"formal_statement": "theorem vadd_const_symm_apply (k : Type*) {P\u2081 V\u2081 : Type*} [ring k] [add_comm_group V\u2081]\n\t[module k V\u2081] [add_torsor V\u2081 P\u2081] (b p' : P\u2081) :\n\t\u21d1((affine_equiv.vadd_const k b).symm) p' = p' -\u1d65 b", "decl_tp": "\u2200 (k : Type u_1) {P\u2081 : Type u_2} {V\u2081 : Type u_6} [_inst_1 : ring k] [_inst_2 : add_comm_group V\u2081] [_inst_3 : module k V\u2081] [_inst_4 : add_torsor V\u2081 P\u2081] (b p' : P\u2081), \u21d1((affine_equiv.vadd_const k b).symm) p' = p' -\u1d65 b", "decl_nm": "affine_equiv.vadd_const_symm_apply", "nl_statement_of_codex": "Let $k$ be a ring, $V_1$ an $k$-module, and $P_1$ an $V_1$-torsor. Let $b$ be an element of $P_1$. Then the inverse of the map $p\\mapsto p+b$ is the map $p\\mapsto p-b$."}
{"formal_statement": "theorem of_injective_apply {\u03b1 : Sort u_1} {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (hf : function.injective f)\n\t(a : \u03b1) :\n\t\u21d1(equiv.of_injective f hf) a = \u27e8f a, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2) (hf : function.injective f) (a : \u03b1), \u21d1(equiv.of_injective f hf) a = \u27e8f a, _\u27e9", "decl_nm": "equiv.of_injective_apply", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then the inverse of the bijection $f:A\\to f(A)$ is given by $f^{-1}(b)=a$ if $f(a)=b$."}
{"formal_statement": "theorem union_subset_iff {\u03b1 : Type u} {s t u : set \u03b1} :\n\ts \u222a t \u2286 u \u2194 s \u2286 u \u2227 t \u2286 u", "decl_tp": "\u2200 {\u03b1 : Type u} {s t u : set \u03b1}, s \u222a t \u2286 u \u2194 s \u2286 u \u2227 t \u2286 u", "decl_nm": "set.union_subset_iff", "nl_statement_of_codex": "$s\\cup t\\subset u$ if and only if $s\\subset u$ and $t\\subset u$."}
{"formal_statement": "theorem smul_add {M A : Type*} [monoid M] [add_monoid A] [distrib_mul_action M A]\n\t(a : M) (b\u2081 b\u2082 : A) :\n\ta \u2022 (b\u2081 + b\u2082) = a \u2022 b\u2081 + a \u2022 b\u2082", "decl_tp": "\u2200 {M : Type u_1} {A : Type u_4} [_inst_1 : monoid M] [_inst_2 : add_monoid A] [_inst_3 : distrib_mul_action M A] (a : M) (b\u2081 b\u2082 : A), a \u2022 (b\u2081 + b\u2082) = a \u2022 b\u2081 + a \u2022 b\u2082", "decl_nm": "smul_add", "nl_statement_of_codex": "Let $M$ be a monoid, $A$ an abelian monoid, and let $M$ act on $A$ by monoid homomorphisms. Then the action is distributive over addition."}
{"formal_statement": "theorem const {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1] [pseudo_emetric_space \u03b2]\n\t(b : \u03b2) :\n\tlipschitz_with 0 (\u03bb (a : \u03b1), b)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] (b : \u03b2), lipschitz_with 0 (\u03bb (a : \u03b1), b)", "decl_nm": "lipschitz_with.const", "nl_statement_of_codex": "The constant function $f(x)=b$ is Lipschitz with constant $0$."}
{"formal_statement": "theorem comap {\u03b1 \u03b2 : Type*} {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (h : transitive r) (a : \u03b1) :\n\t\u2200 (f :  \u03b2), transitive (r on f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b2 \u2192 \u03b2 \u2192 Prop}, transitive r \u2192 \u2200 (f : \u03b1 \u2192 \u03b2), transitive (r on f)", "decl_nm": "transitive.comap", "nl_statement_of_codex": "Let $r$ be a transitive relation on $B$. Then for any function $f:A\\to B$, the relation $r$ on $f$ is transitive."}
{"formal_statement": "theorem one_le_inv {a : ennreal} :\n\t1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "decl_tp": "\u2200 {a : ennreal}, 1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "decl_nm": "ennreal.one_le_inv", "nl_statement_of_codex": "For $a\\in\\mathbb{R}_{\\geq 0}$, $1\\leq a^{-1}$ if and only if $a\\leq 1$."}
{"formal_statement": "theorem is_glb_Ioo {\u03b3 : Type w} [semilattice_sup \u03b3] [densely_ordered \u03b3]\n\t{a b : \u03b3} (h : a < b) :\n\tis_glb (set.Ioo a b) a", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : semilattice_sup \u03b3] [_inst_4 : densely_ordered \u03b3] {a b : \u03b3}, a < b \u2192 is_glb (set.Ioo a b) a", "decl_nm": "is_glb_Ioo", "nl_statement_of_codex": "Let $a,b$ be elements of a dense linear order. Then $a$ is the greatest lower bound of the interval $(a,b)$."}
{"formal_statement": "theorem parallel_promises {\u03b1 : Type u} {S : wseq (computation \u03b1)} {a : \u03b1} :\n\t(\u2200 (s : computation \u03b1), s \u2208 S \u2192 s ~> a) \u2192 computation.parallel S ~> a", "decl_tp": "\u2200 {\u03b1 : Type u} {S : wseq (computation \u03b1)} {a : \u03b1}, (\u2200 (s : computation \u03b1), s \u2208 S \u2192 s ~> a) \u2192 computation.parallel S ~> a", "decl_nm": "computation.parallel_promises", "nl_statement_of_codex": "If each computation in a sequence of computations $S$ promises $a$, then the parallel computation of $S$ promises $a$."}
{"formal_statement": "theorem measurable_to_nnreal :\n\tmeasurable ennreal.to_nnreal", "decl_tp": "measurable ennreal.to_nnreal", "decl_nm": "ennreal.measurable_to_nnreal", "nl_statement_of_codex": "The function $f:\\mathbb{R}_{\\geq 0}\\to\\mathbb{R}_{\\geq 0}$ defined by $f(x)=x$ is measurable."}
{"formal_statement": "theorem frequently_nhds_mem {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] {a : \u03b1} {s : set \u03b1} (ha : is_lub s a) (hs : s.nonempty) :\n\t(\u2203\u1da0 (x : \u03b1) in nhds a, x \u2208 s)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_3 : linear_order \u03b1] [_inst_5 : order_topology \u03b1] {a : \u03b1} {s : set \u03b1}, is_lub s a \u2192 s.nonempty \u2192 (\u2203\u1da0 (x : \u03b1) in nhds a, x \u2208 s)", "decl_nm": "is_lub.frequently_nhds_mem", "nl_statement_of_codex": "Let $X$ be a topological space with a linear order and the order topology. Let $a$ be a supremum of a nonempty set $S$. Then there is a sequence in $S$ converging to $a$."}
{"formal_statement": "theorem filter_inter {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p] [decidable_eq \u03b1]\n\t(s t : finset \u03b1) :\n\tfinset.filter p s \u2229 t = finset.filter p (s \u2229 t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_3 : decidable_eq \u03b1] (s t : finset \u03b1), finset.filter p s \u2229 t = finset.filter p (s \u2229 t)", "decl_nm": "finset.filter_inter", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a set $A$. Let $s,t$ be finite subsets of $A$. Then $p(s)\\cap t=p(s\\cap t)$."}
{"formal_statement": "theorem to_add_monoid_hom_injective {M : Type*} [monoid M] {A : Type*}\n\t[add_monoid A] [distrib_mul_action M A] {B : Type*} [add_monoid B] [distrib_mul_action M B]\n\t{f g : A \u2192+[M] B} (h : \u2191f = \u2191g) :\n\tf = g", "decl_tp": "\u2200 {M : Type u_5} [_inst_4 : monoid M] {A : Type u_6} [_inst_5 : add_monoid A] [_inst_6 : distrib_mul_action M A] {B : Type u_8} [_inst_9 : add_monoid B] [_inst_10 : distrib_mul_action M B] {f g : A \u2192+[M] B}, \u2191f = \u2191g \u2192 f = g", "decl_nm": "distrib_mul_action_hom.to_add_monoid_hom_injective", "nl_statement_of_codex": "Let $M$ be a monoid, let $A$ and $B$ be $M$-modules, and let $f,g:A\\to B$ be $M$-module homomorphisms. If $f$ and $g$ are equal as additive functions, then $f=g$."}
{"formal_statement": "theorem choose_le_succ (a c : \u2115) :\n\ta.choose c \u2264 a.succ.choose c", "decl_tp": "\u2200 (a c : \u2115), a.choose c \u2264 a.succ.choose c", "decl_nm": "nat.choose_le_succ", "nl_statement_of_codex": "$\\binom{a}{c}\\leq \\binom{a+1}{c}$."}
{"formal_statement": "theorem of_injective_apply {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] {module_M : module R M} {module_M\u2082 : module R\u2082 M\u2082}\n\t{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n\t[ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {h : function.injective \u21d1f} (x : M) :\n\t\u2191(\u21d1(linear_equiv.of_injective f h) x) = \u21d1f x", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_5 : add_comm_monoid M] [_inst_6 : add_comm_monoid M\u2082] {module_M : module R M} {module_M\u2082 : module R\u2082 M\u2082} {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) [_inst_10 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_11 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {h : function.injective \u21d1f} (x : M), \u2191(\u21d1(linear_equiv.of_injective f h) x) = \u21d1f x", "decl_nm": "linear_equiv.of_injective_apply", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $M$ and $M'$ be $R$-modules and $R'$-modules, respectively, and let $f:M\\to M'$ be a linear map. If $f$ is injective, then $f$ is an isomorphism."}
{"formal_statement": "theorem list_sum_mem {K : Type u} [field K] (s : subfield K) {l : list K} :\n\t(\u2200 (x : K), x \u2208 l \u2192 x \u2208 s) \u2192 l.sum \u2208 s", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K) {l : list K}, (\u2200 (x : K), x \u2208 l \u2192 x \u2208 s) \u2192 l.sum \u2208 s", "decl_nm": "subfield.list_sum_mem", "nl_statement_of_codex": "Let $K$ be a field and let $s$ be a subfield of $K$. Let $l$ be a list of elements of $K$. If each element of $l$ is in $s$, then the sum of the elements of $l$ is in $s$."}
{"formal_statement": "theorem const_mul_left {\u03b1 F R : Type*} [has_norm F] [normed_ring R] {c : \u211d}\n\t{g : \u03b1 \u2192 F} {l : filter \u03b1} {f : \u03b1 \u2192 R} (h : asymptotics.is_O_with c f g l) :\n\t\u2200 (c' : R), asymptotics.is_O_with (\u2225c'\u2225 * c) (\u03bb (x : \u03b1), c' * f x) g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {R : Type u_9} [_inst_2 : has_norm F] [_inst_7 : normed_ring R] {c : \u211d} {g : \u03b1 \u2192 F} {l : filter \u03b1} {f : \u03b1 \u2192 R}, asymptotics.is_O_with c f g l \u2192 \u2200 (c' : R), asymptotics.is_O_with (\u2225c'\u2225 * c) (\u03bb (x : \u03b1), c' * f x) g l", "decl_nm": "asymptotics.is_O_with.const_mul_left", "nl_statement_of_codex": "Let $f,g:\\alpha\\to R$ be functions and let $c\\in\\mathbb{R}$. If $f$ is $O(g)$, then $cf$ is $O(g)$."}
{"formal_statement": "theorem le_mul_ediam_image {\u03b1 \u03b2 : Type*} [pseudo_emetric_space \u03b1] [pseudo_emetric_space \u03b2]\n\t{K : nnreal} {f : \u03b1 \u2192 \u03b2} (hf : antilipschitz_with K f) :\n\t\u2200 (s : set \u03b1), emetric.diam s \u2264 \u2191K * emetric.diam (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2}, antilipschitz_with K f \u2192 \u2200 (s : set \u03b1), emetric.diam s \u2264 \u2191K * emetric.diam (f '' s)", "decl_nm": "antilipschitz_with.le_mul_ediam_image", "nl_statement_of_codex": "Let $f:X\\to Y$ be an antilipschitz map with constant $K$. Then for any set $A\\subset X$, we have $\\diam(A)\\leq K\\diam(f(A))$."}
{"formal_statement": "theorem mk_sub_mk {A B : Type*} [add_group A] [add_group B] (x\u2081 x\u2082 : A)\n\t(y\u2081 y\u2082 : B) :\n\t(x\u2081, y\u2081) - (x\u2082, y\u2082) = (x\u2081 - x\u2082, y\u2081 - y\u2082)", "decl_tp": "\u2200 {A : Type u_1} {B : Type u_2} [_inst_1 : add_group A] [_inst_2 : add_group B] (x\u2081 x\u2082 : A) (y\u2081 y\u2082 : B), (x\u2081, y\u2081) - (x\u2082, y\u2082) = (x\u2081 - x\u2082, y\u2081 - y\u2082)", "decl_nm": "prod.mk_sub_mk", "nl_statement_of_codex": "Let $A$ and $B$ be additive groups. Then $(x_1,y_1)-(x_2,y_2)=(x_1-x_2,y_1-y_2)$."}
{"formal_statement": "theorem finite_def {R M : Type*} [semiring R] [add_comm_monoid M] [module R M] :\n\tmodule.finite R M \u2194 \u22a4.fg", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_6 : semiring R] [_inst_7 : add_comm_monoid M] [_inst_8 : module R M], module.finite R M \u2194 \u22a4.fg", "decl_nm": "module.finite_def", "nl_statement_of_codex": "A module $M$ over a semiring $R$ is finite if and only if $M$ is finitely generated."}
{"formal_statement": "theorem to_linear_map_of_linear_map {R : Type u} {A : Type v} {B : Type w}\n\t[comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B]\n\t(f : A \u2192\u2097[R] B) (map_one : \u21d1f 1 = 1) (map_mul : \u2200 (x y : A), \u21d1f (x * y) = \u21d1f x * \u21d1f y) :\n\t(alg_hom.of_linear_map f map_one map_mul).to_linear_map = f", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : semiring B] [_inst_6 : algebra R A] [_inst_7 : algebra R B] (f : A \u2192\u2097[R] B) (map_one : \u21d1f 1 = 1) (map_mul : \u2200 (x y : A), \u21d1f (x * y) = \u21d1f x * \u21d1f y), (alg_hom.of_linear_map f map_one map_mul).to_linear_map = f", "decl_nm": "alg_hom.to_linear_map_of_linear_map", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be $R$-algebras. Let $f:A\\to B$ be a linear map. Then $f$ is an algebra homomorphism if and only if $f(1)=1$ and $f(xy)=f(x)f(y)$ for all $x,y\\in A$."}
{"formal_statement": "theorem le_radius_of_summable_norm {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {r : nnreal} (p : formal_multilinear_series \ud835\udd5c E F)\n\t(hs : summable (\u03bb (n : \u2115), \u2225p n\u2225 * \u2191r ^ n)) :\n\t\u2191r \u2264 p.radius", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {r : nnreal} (p : formal_multilinear_series \ud835\udd5c E F), summable (\u03bb (n : \u2115), \u2225p n\u2225 * \u2191r ^ n) \u2192 \u2191r \u2264 p.radius", "decl_nm": "formal_multilinear_series.le_radius_of_summable_norm", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $p$ be a formal multilinear series from $E$ to $F$. If the series $\\sum_{n=0}^\\infty \\|p_n\\|r^n$ is summable, then $r\\leq r_p$."}
{"formal_statement": "theorem closure_eq_self_union_frontier {\u03b1 : Type u} [topological_space \u03b1]\n\t(s : set \u03b1) :\n\tclosure s = s \u222a frontier s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] (s : set \u03b1), closure s = s \u222a frontier s", "decl_nm": "closure_eq_self_union_frontier", "nl_statement_of_codex": "The closure of a set $S$ is equal to the union of $S$ and the frontier of $S$."}
{"formal_statement": "theorem sum_finsum_comm {\u03b1 \u03b2 M : Type*} [add_comm_monoid M] (s : finset \u03b1)\n\t(f : \u03b1 \u2192 \u03b2 \u2192 M) :\n\t(\u2200 (a : \u03b1), a \u2208 s \u2192 (function.support (f a)).finite) \u2192 s.sum (\u03bb (a : \u03b1), finsum (\u03bb (b : \u03b2), f a b)) = finsum (\u03bb (b : \u03b2), s.sum (\u03bb (a : \u03b1), f a b))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {M : Type u_4} [_inst_1 : add_comm_monoid M] (s : finset \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 M), (\u2200 (a : \u03b1), a \u2208 s \u2192 (function.support (f a)).finite) \u2192 s.sum (\u03bb (a : \u03b1), finsum (\u03bb (b : \u03b2), f a b)) = finsum (\u03bb (b : \u03b2), s.sum (\u03bb (a : \u03b1), f a b))", "decl_nm": "sum_finsum_comm", "nl_statement_of_codex": "Let $M$ be an abelian monoid. Let $s$ be a finite set and let $f:s\\times\\beta\\to M$. Suppose that for each $a\\in s$ the set $\\{b\\in\\beta:f(a,b)\\neq 0\\}$ is finite. Then $\\sum_{a\\in s}\\sum_{b\\in\\beta}f(a,b)=\\sum_{b\\in\\beta}\\sum_{a\\in s}f(a,b)$."}
{"formal_statement": "theorem comp\u2081 (f : \u2115 \u2192 \u2115) (hf : nat.primrec' (\u03bb (v : vector \u2115 1), f v.head))\n\t(hg : nat.primrec' g) :\n\t\u2200 {n : \u2115} {g : vector \u2115 n \u2192 \u2115},  nat.primrec' (\u03bb (v : vector \u2115 n), f (g v))", "decl_tp": "\u2200 (f : \u2115 \u2192 \u2115), nat.primrec' (\u03bb (v : vector \u2115 1), f v.head) \u2192 \u2200 {n : \u2115} {g : vector \u2115 n \u2192 \u2115}, nat.primrec' g \u2192 nat.primrec' (\u03bb (v : vector \u2115 n), f (g v))", "decl_nm": "nat.primrec'.comp\u2081", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}^n\\to\\mathbb{N}$ be primitive recursive functions. Then the function $h:\\mathbb{N}^{n+1}\\to\\mathbb{N}$ defined by $h(x_1,\\ldots,x_{n+1})=f(g(x_1,\\ldots,x_n),x_{n+1})$ is primitive recursive."}
{"formal_statement": "theorem coe_mul_right {R : Type*} [non_unital_non_assoc_semiring R] (r : R) :\n\t\u21d1(add_monoid_hom.mul_right r) = \u03bb (_x : R), _x * r", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : non_unital_non_assoc_semiring R] (r : R), \u21d1(add_monoid_hom.mul_right r) = \u03bb (_x : R), _x * r", "decl_nm": "add_monoid_hom.coe_mul_right", "nl_statement_of_codex": "The function $f:R\\to R$ defined by $f(x)=xr$ is a monoid homomorphism."}
{"formal_statement": "theorem deriv_div_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c}\n\t{\ud835\udd5c' : Type*} [nondiscrete_normed_field \ud835\udd5c'] [normed_algebra \ud835\udd5c \ud835\udd5c'] {c : \ud835\udd5c \u2192 \ud835\udd5c'}\n\t(d : \ud835\udd5c') :\n\tderiv (\u03bb (x : \ud835\udd5c), c x / d) x = deriv c x / d", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {\ud835\udd5c' : Type u_1} [_inst_6 : nondiscrete_normed_field \ud835\udd5c'] [_inst_7 : normed_algebra \ud835\udd5c \ud835\udd5c'] {c : \ud835\udd5c \u2192 \ud835\udd5c'} (d : \ud835\udd5c'), deriv (\u03bb (x : \ud835\udd5c), c x / d) x = deriv c x / d", "decl_nm": "deriv_div_const", "nl_statement_of_codex": "Let $c$ be a function from a nondiscrete normed field $K$ to a nondiscrete normed field $K'$ and let $d$ be an element of $K'$. Then the derivative of the function $x\\mapsto c(x)/d$ is equal to the derivative of $c$ divided by $d$."}
{"formal_statement": "theorem is_empty_of_colorable_zero {V : Type u} (G : simple_graph V) (h : G.colorable 0) :\n\tis_empty V", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V), G.colorable 0 \u2192 is_empty V", "decl_nm": "simple_graph.is_empty_of_colorable_zero", "nl_statement_of_codex": "If a simple graph $G$ is colorable with $0$ colors, then $G$ has no vertices."}
{"formal_statement": "theorem alg_equiv_iso_Algebra_iso_hom {R : Type u} [comm_ring R] {X Y : Type u}\n\t[ring X] [ring Y] [algebra R X] [algebra R Y] (e : X \u2243\u2090[R] Y) :\n\talg_equiv_iso_Algebra_iso.hom e = e.to_Algebra_iso", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] {X Y : Type u} [_inst_2 : ring X] [_inst_3 : ring Y] [_inst_4 : algebra R X] [_inst_5 : algebra R Y] (e : X \u2243\u2090[R] Y), alg_equiv_iso_Algebra_iso.hom e = e.to_Algebra_iso", "decl_nm": "alg_equiv_iso_Algebra_iso_hom", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $X$ and $Y$ be $R$-algebras. Then the map $e:X\\to Y$ is an isomorphism of $R$-algebras if and only if it is an isomorphism of $R$-modules."}
{"formal_statement": "theorem map_right_id_hom_app_right {A : Type u\u2081} [category_theory.category A]\n\t{B : Type u\u2082} [category_theory.category B] {T : Type u\u2083} [category_theory.category T]\n\t(L : A \u2964 T) (R : B \u2964 T) (X : category_theory.comma L R) :\n\t((category_theory.comma.map_right_id L R).hom.app X).right = \ud835\udfd9 ((category_theory.comma.map_right L (\ud835\udfd9 R)).obj X).right", "decl_tp": "\u2200 {A : Type u\u2081} [_inst_1 : category_theory.category A] {B : Type u\u2082} [_inst_2 : category_theory.category B] {T : Type u\u2083} [_inst_3 : category_theory.category T] (L : A \u2964 T) (R : B \u2964 T) (X : category_theory.comma L R), ((category_theory.comma.map_right_id L R).hom.app X).right = \ud835\udfd9 ((category_theory.comma.map_right L (\ud835\udfd9 R)).obj X).right", "decl_nm": "category_theory.comma.map_right_id_hom_app_right", "nl_statement_of_codex": "Let $A, B, T$ be categories and let $L:A\\to T$ and $R:B\\to T$ be functors. Let $X$ be an object of the comma category $(L\\downarrow R)$. Then the right component of the morphism $(\\mathrm{id}_L\\downarrow \\mathrm{id}_R)_X$ is the identity morphism of the right component of the object $(L\\downarrow \\mathrm{id}_R)_X$."}
{"formal_statement": "theorem iso_mk_inv_right {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {T : D} {S : C \u2964 D} {f f' : category_theory.costructured_arrow S T}\n\t(g : f.left \u2245 f'.left) (w : S.map g.hom \u226b f'.hom = f.hom) :\n\t(category_theory.costructured_arrow.iso_mk g w).inv.right = category_theory.eq_to_hom _", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {T : D} {S : C \u2964 D} {f f' : category_theory.costructured_arrow S T} (g : f.left \u2245 f'.left) (w : S.map g.hom \u226b f'.hom = f.hom), (category_theory.costructured_arrow.iso_mk g w).inv.right = category_theory.eq_to_hom _", "decl_nm": "category_theory.costructured_arrow.iso_mk_inv_right", "nl_statement_of_codex": "Let $C$ and $D$ be categories, let $S:C\\to D$ be a functor, let $T$ be an object of $D$, and let $f,f':S\\to T$ be morphisms.\nSuppose that $g:f\\to f'$ is an isomorphism. Then the inverse of the isomorphism $g$ is given by $g^{-1}=\\text{eq_to_hom}(w)$."}
{"formal_statement": "theorem types_comp {X Y Z : Type u} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n\tf \u226b g = g \u2218 f", "decl_tp": "\u2200 {X Y Z : Type u} (f : X \u27f6 Y) (g : Y \u27f6 Z), f \u226b g = g \u2218 f", "decl_nm": "category_theory.types_comp", "nl_statement_of_codex": "The composition of two types is the composition of the functions."}
{"formal_statement": "theorem continuous_on_mul {\u03b1 : Type*} [conditionally_complete_linear_order \u03b1]\n\t[measurable_space \u03b1] [topological_space \u03b1] [order_topology \u03b1] [opens_measurable_space \u03b1]\n\t{\u03bc : measure_theory.measure \u03b1} {a b : \u03b1} {f g : \u03b1 \u2192 \u211d} (hf : interval_integrable f \u03bc a b)\n\t(hg : continuous_on g (set.interval a b)) :\n\tinterval_integrable (\u03bb (x : \u03b1), g x * f x) \u03bc a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_6 : conditionally_complete_linear_order \u03b1] [_inst_7 : measurable_space \u03b1] [_inst_8 : topological_space \u03b1] [_inst_9 : order_topology \u03b1] [_inst_10 : opens_measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {a b : \u03b1} {f g : \u03b1 \u2192 \u211d}, interval_integrable f \u03bc a b \u2192 continuous_on g (set.interval a b) \u2192 interval_integrable (\u03bb (x : \u03b1), g x * f x) \u03bc a b", "decl_nm": "interval_integrable.continuous_on_mul", "nl_statement_of_codex": "Let $f,g:[a,b]\\to\\mathbb{R}$ be measurable functions. If $f$ is integrable and $g$ is continuous, then $gf$ is integrable."}
{"formal_statement": "theorem get_or_else_bot_le_iff {\u03b1 : Type u} [has_le \u03b1] [order_bot \u03b1] {a : with_bot \u03b1}\n\t{b : \u03b1} :\n\toption.get_or_else a \u22a5 \u2264 b \u2194 a \u2264 \u2191b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_le \u03b1] [_inst_2 : order_bot \u03b1] {a : with_bot \u03b1} {b : \u03b1}, option.get_or_else a \u22a5 \u2264 b \u2194 a \u2264 \u2191b", "decl_nm": "with_bot.get_or_else_bot_le_iff", "nl_statement_of_codex": "Let $a$ be an element of the type $with\\_bot\\ \\alpha$ and let $b$ be an element of $\\alpha$. Then $a\\leq b$ if and only if $a\\leq b$."}
{"formal_statement": "theorem comap_bot {G : Type*} [group G] {N : Type*} [group N] (f : G \u2192* N) :\n\tsubgroup.comap f \u22a5 = f.ker", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] (f : G \u2192* N), subgroup.comap f \u22a5 = f.ker", "decl_nm": "monoid_hom.comap_bot", "nl_statement_of_codex": "Let $f:G\\to N$ be a group homomorphism. Then the kernel of $f$ is the preimage of the trivial subgroup of $N$."}
{"formal_statement": "theorem map_id {\u03b1 : Type*} [uniform_space \u03b1] :\n\tuniform_space.completion.map id = id", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1], uniform_space.completion.map id = id", "decl_nm": "uniform_space.completion.map_id", "nl_statement_of_codex": "The identity map on the completion of a uniform space is the identity map."}
{"formal_statement": "theorem is_O_congr {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{E : Type*} [has_norm E] {F : Type*} [has_norm F] (e : local_homeomorph \u03b1 \u03b2)\n\t{b : \u03b2} (b : \u03b2) (hb : b \u2208 e.to_local_equiv.target) :\n\t\u2200 {f :  E} {g :  F}, asymptotics.is_O f g (nhds b) \u2194 asymptotics.is_O (f \u2218 \u21d1e)\n\t(g \u2218 \u21d1e) (nhds (\u21d1(e.symm) b))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {E : Type u_3} [_inst_3 : has_norm E] {F : Type u_4} [_inst_4 : has_norm F] (e : local_homeomorph \u03b1 \u03b2) {b : \u03b2}, b \u2208 e.to_local_equiv.target \u2192 \u2200 {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F}, asymptotics.is_O f g (nhds b) \u2194 asymptotics.is_O (f \u2218 \u21d1e) (g \u2218 \u21d1e) (nhds (\u21d1(e.symm) b))", "decl_nm": "local_homeomorph.is_O_congr", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Then for any $b\\in Y$ and any functions $f,g:X\\to\\mathbb{R}$,\n$f(x)=O(g(x))$ as $x\\to b$ if and only if $f(e^{-1}(y))=O(g(e^{-1}(y)))$ as $y\\to e(b)$."}
{"formal_statement": "theorem log_neg {x : \u211d} (h0 : 0 < x) (h1 : x < 1) :\n\treal.log x < 0", "decl_tp": "\u2200 {x : \u211d}, 0 < x \u2192 x < 1 \u2192 real.log x < 0", "decl_nm": "real.log_neg", "nl_statement_of_codex": "If $0<x<1$, then $\\log x<0$."}
{"formal_statement": "theorem monotone_comap {\u03b1 \u03b2 : Type*} {g : \u03b2 \u2192 \u03b1} :\n\tmonotone (measurable_space.comap g)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {g : \u03b2 \u2192 \u03b1}, monotone (measurable_space.comap g)", "decl_nm": "measurable_space.monotone_comap", "nl_statement_of_codex": "Let $X$ and $Y$ be measurable spaces and let $f:X\\to Y$ be a measurable function. Then the inverse image of a measurable set is measurable."}
{"formal_statement": "theorem fun_unique_apply (\u03b9 R M : Type*) [unique \u03b9] [semiring R] [add_comm_monoid M]\n\t[module R M] :\n\t\u21d1(linear_equiv.fun_unique \u03b9 R M) = function.eval (inhabited.default \u03b9)", "decl_tp": "\u2200 (\u03b9 : Type u_1) (R : Type u_2) (M : Type u_3) [_inst_15 : unique \u03b9] [_inst_16 : semiring R] [_inst_17 : add_comm_monoid M] [_inst_18 : module R M], \u21d1(linear_equiv.fun_unique \u03b9 R M) = function.eval (inhabited.default \u03b9)", "decl_nm": "linear_equiv.fun_unique_apply", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ be an $R$-module, and $\\iota$ be a type with a unique element. Then the function\n$\\mathrm{fun\\_unique}:\\mathrm{Lin}(\\iota,M)\\to M$ is the evaluation map at the unique element of $\\iota$."}
{"formal_statement": "theorem left {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf : function.injective2 f)\n\t(h : f a\u2081 b\u2081 = f a\u2082 b\u2082) :\n\t\u2200 \u2983a\u2081 a\u2082 : \u03b1\u2984 \u2983b\u2081 b\u2082 : \u03b2\u2984,  a\u2081 = a\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3), function.injective2 f \u2192 \u2200 \u2983a\u2081 a\u2082 : \u03b1\u2984 \u2983b\u2081 b\u2082 : \u03b2\u2984, f a\u2081 b\u2081 = f a\u2082 b\u2082 \u2192 a\u2081 = a\u2082", "decl_nm": "function.injective2.left", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be an injective function. Then $f$ is injective in the first variable."}
{"formal_statement": "theorem mfderiv_within_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {M : Type*} [topological_space M] [charted_space H M]\n\t[smooth_manifold_with_corners I M] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{H' : Type*} [topological_space H'] (I' : model_with_corners \ud835\udd5c E' H')\n\t{M' : Type*} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I' M']\n\t{s : set M} {x : M} {c : M'} (hxs : unique_mdiff_within_at I s x) :\n\tmfderiv_within I I' (\u03bb (y : M), c) s x = 0", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {E' : Type u_5} [_inst_8 : normed_group E'] [_inst_9 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_10 : topological_space H'] (I' : model_with_corners \ud835\udd5c E' H') {M' : Type u_7} [_inst_11 : topological_space M'] [_inst_12 : charted_space H' M'] [_inst_13 : smooth_manifold_with_corners I' M'] {s : set M} {x : M} {c : M'}, unique_mdiff_within_at I s x \u2192 mfderiv_within I I' (\u03bb (y : M), c) s x = 0", "decl_nm": "mfderiv_within_const", "nl_statement_of_codex": "Let $M$ and $M'$ be smooth manifolds with corners, let $I$ and $I'$ be models with corners, and let $s$ be a subset of $M$. Let $c$ be a point in $M'$. Then the derivative of the constant function $f:M\\to M'$ defined by $f(x)=c$ is zero at $x$."}
{"formal_statement": "theorem upper_bounds_Ioo {\u03b3 : Type w} [semilattice_inf \u03b3] [densely_ordered \u03b3]\n\t{a b : \u03b3} (hab : a < b) :\n\tupper_bounds (set.Ioo a b) = set.Ici b", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : semilattice_inf \u03b3] [_inst_4 : densely_ordered \u03b3] {a b : \u03b3}, a < b \u2192 upper_bounds (set.Ioo a b) = set.Ici b", "decl_nm": "upper_bounds_Ioo", "nl_statement_of_codex": "Let $a,b\\in\\gamma$ with $a<b$. Then the set of upper bounds of the interval $(a,b)$ is the interval $[b,\\infty)$."}
{"formal_statement": "theorem cosh {E : Type*} [normed_group E] [normed_space \u211d E] {f : E \u2192 \u211d}\n\t{s : set E} (hc : differentiable_on \u211d f s) :\n\tdifferentiable_on \u211d (\u03bb (x : E), real.cosh (f x)) s", "decl_tp": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {s : set E}, differentiable_on \u211d f s \u2192 differentiable_on \u211d (\u03bb (x : E), real.cosh (f x)) s", "decl_nm": "differentiable_on.cosh", "nl_statement_of_codex": "Let $E$ be a normed space over $\\mathbb{R}$ and let $f:E\\to\\mathbb{R}$. If $f$ is differentiable on $E$, then $x\\mapsto\\cosh(f(x))$ is differentiable on $E$."}
{"formal_statement": "theorem left_neg_equiv_symm_from_left_neg {M : Type*} [add_comm_monoid M]\n\t(S : add_submonoid M) (hS : S \u2264 is_add_unit.add_submonoid M) (x : \u21a5(S.left_neg)) :\n\t\u21d1((S.left_neg_equiv hS).symm) (S.from_left_neg x) = x", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_comm_monoid M] (S : add_submonoid M) (hS : S \u2264 is_add_unit.add_submonoid M) (x : \u21a5(S.left_neg)), \u21d1((S.left_neg_equiv hS).symm) (S.from_left_neg x) = x", "decl_nm": "add_submonoid.left_neg_equiv_symm_from_left_neg", "nl_statement_of_codex": "Let $M$ be an additive commutative monoid and let $S$ be an additive submonoid of $M$. Suppose that $S$ contains the additive identity of $M$. Then the inverse of the map $S\\to S$ given by $x\\mapsto -x$ is given by $x\\mapsto -x$."}
{"formal_statement": "theorem const_add {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v}\n\t[normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} (c : F)\n\t(hf : has_deriv_at f f' x) :\n\thas_deriv_at (\u03bb (x : \ud835\udd5c), c + f x) f' x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} (c : F), has_deriv_at f f' x \u2192 has_deriv_at (\u03bb (x : \ud835\udd5c), c + f x) f' x", "decl_nm": "has_deriv_at.const_add", "nl_statement_of_codex": "Let $f: \\mathbb{K}\\to F$ be differentiable at $x\\in \\mathbb{K}$. Then $f+c$ is differentiable at $x$."}
{"formal_statement": "theorem measurable_liminf' {\u03b1 \u03b4 : Type*} [topological_space \u03b1] [measurable_space \u03b1]\n\t[borel_space \u03b1] [measurable_space \u03b4] [complete_linear_order \u03b1] [order_topology \u03b1]\n\t[topological_space.second_countable_topology \u03b1] {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n\t{u : filter \u03b9} (hu : u.has_countable_basis p s) :\n\t(\u2200 (i : \u03b9), measurable (f i)) \u2192 \u2200 {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 set \u03b9},  (\u2200 (i : \u03b9'), (s i).countable) \u2192 measurable (\u03bb (x : \u03b4), u.liminf (\u03bb (i : \u03b9), f i x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b4 : Type u_5} [_inst_1 : topological_space \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : borel_space \u03b1] [_inst_10 : measurable_space \u03b4] [_inst_11 : complete_linear_order \u03b1] [_inst_12 : order_topology \u03b1] [_inst_13 : topological_space.second_countable_topology \u03b1] {\u03b9 : Type u_2} {\u03b9' : Type u_3} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {u : filter \u03b9}, (\u2200 (i : \u03b9), measurable (f i)) \u2192 \u2200 {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 set \u03b9}, u.has_countable_basis p s \u2192 (\u2200 (i : \u03b9'), (s i).countable) \u2192 measurable (\u03bb (x : \u03b4), u.liminf (\u03bb (i : \u03b9), f i x))", "decl_nm": "measurable_liminf'", "nl_statement_of_codex": "Let $X$ be a second countable topological space and let $Y$ be a measurable space. Let $f:X\\times Y\\to \\mathbb{R}$ be a function such that $f(x,\\cdot)$ is measurable for each $x\\in X$. Then the function $g:Y\\to \\mathbb{R}$ defined by $g(y)=\\liminf_{x\\to\\infty} f(x,y)$ is measurable."}
{"formal_statement": "theorem Ioo_subset_Ioo {\u03b1 : Type u} [preorder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} (h\u2081 : a\u2082 \u2264 a\u2081)\n\t(h\u2082 : b\u2081 \u2264 b\u2082) :\n\tset.Ioo a\u2081 b\u2081 \u2286 set.Ioo a\u2082 b\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}, a\u2082 \u2264 a\u2081 \u2192 b\u2081 \u2264 b\u2082 \u2192 set.Ioo a\u2081 b\u2081 \u2286 set.Ioo a\u2082 b\u2082", "decl_nm": "set.Ioo_subset_Ioo", "nl_statement_of_codex": "Let $a_1, a_2, b_1, b_2$ be real numbers such that $a_2\\leq a_1$ and $b_1\\leq b_2$. Then $[a_1, b_1]\\subset [a_2, b_2]$."}
{"formal_statement": "theorem sin_sub (x y : \u2102) :\n\tcomplex.sin (x - y) = complex.sin x * complex.cos y - complex.cos x * complex.sin y", "decl_tp": "\u2200 (x y : \u2102), complex.sin (x - y) = complex.sin x * complex.cos y - complex.cos x * complex.sin y", "decl_nm": "complex.sin_sub", "nl_statement_of_codex": "$\\sin(x-y)=\\sin x\\cos y-\\cos x\\sin y$."}
{"formal_statement": "theorem sum_apply_ite_of_false {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} {s : finset \u03b1}\n\t[add_comm_monoid \u03b2] {p : \u03b1 \u2192 Prop} {hp : decidable_pred p} (f g : \u03b1 \u2192 \u03b3)\n\t(k : \u03b3 \u2192 \u03b2) :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 \u00acp x) \u2192 s.sum (\u03bb (x : \u03b1), k (ite (p x) (f x) (g x))) = s.sum (\u03bb (x : \u03b1), k (g x))", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} {s : finset \u03b1} [_inst_1 : add_comm_monoid \u03b2] {p : \u03b1 \u2192 Prop} {hp : decidable_pred p} (f g : \u03b1 \u2192 \u03b3) (k : \u03b3 \u2192 \u03b2), (\u2200 (x : \u03b1), x \u2208 s \u2192 \u00acp x) \u2192 s.sum (\u03bb (x : \u03b1), k (ite (p x) (f x) (g x))) = s.sum (\u03bb (x : \u03b1), k (g x))", "decl_nm": "finset.sum_apply_ite_of_false", "nl_statement_of_codex": "Let $s$ be a finite set, $p$ a predicate on $s$, $f,g:s\\to \\gamma$, and $k:\\gamma\\to \\beta$. If $p$ is false on $s$, then\n$\\sum_{x\\in s} k(f(x))=\\sum_{x\\in s} k(g(x))$."}
{"formal_statement": "theorem join_apply {\u03b1 : Type*} [measurable_space \u03b1] {m : measure_theory.measure (measure_theory.measure \u03b1)}\n\t{s : set \u03b1} :\n\tmeasurable_set s \u2192 \u21d1(m.join) s = \u222b\u207b (\u03bc : measure_theory.measure \u03b1), \u21d1\u03bc s \u2202m", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {m : measure_theory.measure (measure_theory.measure \u03b1)} {s : set \u03b1}, measurable_set s \u2192 \u21d1(m.join) s = \u222b\u207b (\u03bc : measure_theory.measure \u03b1), \u21d1\u03bc s \u2202m", "decl_nm": "measure_theory.measure.join_apply", "nl_statement_of_codex": "Let $m$ be a measure on the measurable space $(X,\\mathcal{A})$. Then for any measurable set $A\\in\\mathcal{A}$,\n$m(A)=\\int_X\\mu(A)dm$."}
{"formal_statement": "theorem to_real_le_coe_of_le_coe {a : ennreal} {b : nnreal} (h : a \u2264 \u2191b) :\n\ta.to_real \u2264 \u2191b", "decl_tp": "\u2200 {a : ennreal} {b : nnreal}, a \u2264 \u2191b \u2192 a.to_real \u2264 \u2191b", "decl_nm": "ennreal.to_real_le_coe_of_le_coe", "nl_statement_of_codex": "Let $a$ be an extended nonnegative real number and let $b$ be a nonnegative real number. If $a\\leq b$, then $a$ is less than or equal to $b$."}
{"formal_statement": "theorem dvd_iff_dvd_of_digits (b b' : \u2115) (c : \u2124) (h : \u2191b \u2223 \u2191b' - c) :\n\t\u2200 (n : \u2115), b \u2223 n \u2194 \u2191b \u2223 nat.of_digits c (b'.digits n)", "decl_tp": "\u2200 (b b' : \u2115) (c : \u2124), \u2191b \u2223 \u2191b' - c \u2192 \u2200 (n : \u2115), b \u2223 n \u2194 \u2191b \u2223 nat.of_digits c (b'.digits n)", "decl_nm": "nat.dvd_iff_dvd_of_digits", "nl_statement_of_codex": "Let $b,b'$ be natural numbers and $c$ be an integer. If $b$ divides $b'-c$, then for each natural number $n$, $b$ divides $n$ if and only if $b$ divides the number obtained by writing $n$ in base $b'$ and adding $c$ to each digit."}
{"formal_statement": "theorem count_le_count_cons {\u03b1 : Type*} [decidable_eq \u03b1] (a b : \u03b1) (l : list \u03b1) :\n\tlist.count a l \u2264 list.count a (b :: l)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a b : \u03b1) (l : list \u03b1), list.count a l \u2264 list.count a (b :: l)", "decl_nm": "list.count_le_count_cons", "nl_statement_of_codex": "Let $a$ and $b$ be elements of a type $\u03b1$ and let $l$ be a list of elements of $\u03b1$. Then the number of occurrences of $a$ in $l$ is less than or equal to the number of occurrences of $a$ in the list $b::l$."}
{"formal_statement": "theorem mem_path_component {X : Type*} [topological_space X] {x y : X}\n\t{F : set X} (h : is_path_connected F) (x_in : x \u2208 F) (y_in : y \u2208 F) :\n\ty \u2208 path_component x", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {x y : X} {F : set X}, is_path_connected F \u2192 x \u2208 F \u2192 y \u2208 F \u2192 y \u2208 path_component x", "decl_nm": "is_path_connected.mem_path_component", "nl_statement_of_codex": "Let $X$ be a topological space and let $F$ be a path-connected subset of $X$. Then for any $x,y\\in F$, $y$ is in the path-component of $x$."}
{"formal_statement": "theorem idempotent {\u03b1 : Type*} [partial_order \u03b1] (c : closure_operator \u03b1)\n\t(x : \u03b1) :\n\t\u21d1c (\u21d1c x) = \u21d1c x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] (c : closure_operator \u03b1) (x : \u03b1), \u21d1c (\u21d1c x) = \u21d1c x", "decl_nm": "closure_operator.idempotent", "nl_statement_of_codex": "Let $c$ be a closure operator on a partially ordered set $X$. Then $c$ is idempotent."}
{"formal_statement": "theorem sep_univ {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} :\n\t{a \u2208 set.univ | p a} = {a : \u03b1 | p a}", "decl_tp": "\u2200 {\u03b1 : Type u_1} {p : \u03b1 \u2192 Prop}, {a \u2208 set.univ | p a} = {a : \u03b1 | p a}", "decl_nm": "set.sep_univ", "nl_statement_of_codex": "The set $\\{a\\in\\mathbb{R}|p(a)\\}$ is equal to the set $\\{a\\in\\mathbb{R}|p(a)\\}$."}
{"formal_statement": "theorem incidence_other_neighbor_edge {V : Type u} (G : simple_graph V)\n\t[decidable_eq V] {v w : V} (h : w \u2208 G.neighbor_set v) :\n\tG.other_vertex_of_incident _ = w", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) [_inst_1 : decidable_eq V] {v w : V} (h : w \u2208 G.neighbor_set v), G.other_vertex_of_incident _ = w", "decl_nm": "simple_graph.incidence_other_neighbor_edge", "nl_statement_of_codex": "Let $G$ be a simple graph. Let $v,w$ be vertices of $G$. If $w$ is a neighbor of $v$, then $w$ is the other vertex of an edge incident to $v$."}
{"formal_statement": "theorem is_open_of_open_subgroup {G : Type*} [group G] [topological_space G]\n\t[has_continuous_mul G] (H : subgroup G) {U : open_subgroup G} (h : U.to_subgroup \u2264 H) :\n\tis_open \u2191H", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] [_inst_2 : topological_space G] [_inst_3 : has_continuous_mul G] (H : subgroup G) {U : open_subgroup G}, U.to_subgroup \u2264 H \u2192 is_open \u2191H", "decl_nm": "subgroup.is_open_of_open_subgroup", "nl_statement_of_codex": "Let $G$ be a topological group and let $H$ be a subgroup of $G$. If $H$ is contained in an open subgroup of $G$, then $H$ is open in $G$."}
{"formal_statement": "theorem bit1_im {d : \u2124} (z : \u2124\u221ad) :\n\t(bit1 z).im = bit0 z.im", "decl_tp": "\u2200 {d : \u2124} (z : \u2124\u221ad), (bit1 z).im = bit0 z.im", "decl_nm": "zsqrtd.bit1_im", "nl_statement_of_codex": "The imaginary part of $2z$ is twice the imaginary part of $z$."}
{"formal_statement": "theorem pairwise_disjoint_union {\u03b1 \u03b9 : Type*} [semilattice_inf \u03b1] [order_bot \u03b1]\n\t{s t : set \u03b9} {f : \u03b9 \u2192 \u03b1} :\n\t(s \u222a t).pairwise_disjoint f \u2194 s.pairwise_disjoint f \u2227 t.pairwise_disjoint f \u2227 \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 \u2200 \u2983j : \u03b9\u2984, j \u2208 t \u2192 i \u2260 j \u2192 disjoint (f i)\n\t(f j)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {s t : set \u03b9} {f : \u03b9 \u2192 \u03b1}, (s \u222a t).pairwise_disjoint f \u2194 s.pairwise_disjoint f \u2227 t.pairwise_disjoint f \u2227 \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 \u2200 \u2983j : \u03b9\u2984, j \u2208 t \u2192 i \u2260 j \u2192 disjoint (f i) (f j)", "decl_nm": "set.pairwise_disjoint_union", "nl_statement_of_codex": "Let $f:I\\to \\mathcal{A}$ be a function from a set $I$ to a semilattice $\\mathcal{A}$. Then the union of two pairwise disjoint subsets $S,T$ of $I$ is pairwise disjoint if and only if $S$ and $T$ are pairwise disjoint and the images of $S$ and $T$ are disjoint."}
{"formal_statement": "theorem pos_smul_left {R : Type*} [ordered_comm_semiring R] {M : Type*}\n\t[add_comm_monoid M] [module R M] {v\u2081 v\u2082 : M} {r : R} (h : same_ray R v\u2081 v\u2082)\n\t(hr : 0 < r) :\n\tsame_ray R (r \u2022 v\u2081) v\u2082", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ordered_comm_semiring R] {M : Type u_2} [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {v\u2081 v\u2082 : M} {r : R}, same_ray R v\u2081 v\u2082 \u2192 0 < r \u2192 same_ray R (r \u2022 v\u2081) v\u2082", "decl_nm": "same_ray.pos_smul_left", "nl_statement_of_codex": "Let $R$ be an ordered commutative semiring, $M$ a module over $R$, and $v_1, v_2\\in M$. If $v_1$ and $v_2$ are on the same ray, then $rv_1$ and $v_2$ are on the same ray for any $r>0$."}
{"formal_statement": "theorem of_image_eq {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{e : local_homeomorph \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2} (h : \u21d1e '' (e.to_local_equiv.source \u2229 s) = e.to_local_equiv.target \u2229 t) :\n\te.is_image s t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {e : local_homeomorph \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2}, \u21d1e '' (e.to_local_equiv.source \u2229 s) = e.to_local_equiv.target \u2229 t \u2192 e.is_image s t", "decl_nm": "local_homeomorph.is_image.of_image_eq", "nl_statement_of_codex": "Let $e:U\\to V$ be a local homeomorphism between topological spaces $U$ and $V$. Let $s\\subset U$ and $t\\subset V$. Then $e$ is the image of $s$ under $e$ if and only if $e(U\\cap s)=V\\cap t$."}
{"formal_statement": "theorem mul_indicator_compl_mul_self_apply {\u03b1 M : Type*} [mul_one_class M]\n\t(s : set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n\ts\u1d9c.mul_indicator f a * s.mul_indicator f a = f a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : mul_one_class M] (s : set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1), s\u1d9c.mul_indicator f a * s.mul_indicator f a = f a", "decl_nm": "set.mul_indicator_compl_mul_self_apply", "nl_statement_of_codex": "Let $s$ be a set and let $f:s\\to M$ be a function. Then $(s\\setminus\\{a\\})\\cdot f(a) + s\\cdot f(a) = f(a)$."}
{"formal_statement": "theorem measurable_of_empty_codomain {\u03b1 \u03b2 : Type*} [measurable_space \u03b1]\n\t[measurable_space \u03b2] [is_empty \u03b2] (f : \u03b1 \u2192 \u03b2) :\n\tmeasurable f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] [_inst_4 : is_empty \u03b2] (f : \u03b1 \u2192 \u03b2), measurable f", "decl_nm": "measurable_of_empty_codomain", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function where $Y$ is the empty set. Then $f$ is measurable."}
{"formal_statement": "theorem coe_of (V : Type u) [semi_normed_group V] :\n\t\u21a5(SemiNormedGroup.of V) = V", "decl_tp": "\u2200 (V : Type u) [_inst_1 : semi_normed_group V], \u21a5(SemiNormedGroup.of V) = V", "decl_nm": "SemiNormedGroup.coe_of", "nl_statement_of_codex": "The underlying type of a semi-normed group is the same as the semi-normed group itself."}
{"formal_statement": "theorem map_adj {V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W}\n\t(f : G \u2192g G') {v w : V} (h : G.adj v w) :\n\tG'.adj (\u21d1f v) (\u21d1f w)", "decl_tp": "\u2200 {V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G \u2192g G') {v w : V}, G.adj v w \u2192 G'.adj (\u21d1f v) (\u21d1f w)", "decl_nm": "simple_graph.hom.map_adj", "nl_statement_of_codex": "Let $G$ and $G'$ be simple graphs and let $f:G\\to G'$ be a graph homomorphism. If $v$ and $w$ are adjacent in $G$, then $f(v)$ and $f(w)$ are adjacent in $G'$."}
{"formal_statement": "theorem image_eq_preimage {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) (s : set \u03b1) :\n\t\u21d1e '' s = \u21d1(e.symm) \u207b\u00b9' s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : \u03b1 \u2243 \u03b2) (s : set \u03b1), \u21d1e '' s = \u21d1(e.symm) \u207b\u00b9' s", "decl_nm": "equiv.image_eq_preimage", "nl_statement_of_codex": "Let $e:A\\to B$ be a bijection. Then $e(A)=e^{-1}(B)$."}
{"formal_statement": "theorem neg_neg_part {\u03b1 : Type*} [measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1) :\n\t(-j).neg_part = j.pos_part", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1), (-j).neg_part = j.pos_part", "decl_nm": "measure_theory.jordan_decomposition.neg_neg_part", "nl_statement_of_codex": "Let $j$ be a Jordan decomposition of a measure space $(X,\\mathcal{A},\\mu)$. Then the positive part of $j$ is equal to the negative part of $-j$."}
{"formal_statement": "theorem isometry_on_inr {X : Type u} {Y : Type v} [metric_space X] [metric_space Y]\n\t[inhabited X] [inhabited Y] :\n\tisometry sum.inr", "decl_tp": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : metric_space X] [_inst_2 : metric_space Y] [_inst_3 : inhabited X] [_inst_4 : inhabited Y], isometry sum.inr", "decl_nm": "metric.isometry_on_inr", "nl_statement_of_codex": "The map $Y\\to X\\times Y$ given by $y\\mapsto (0,y)$ is an isometry."}
{"formal_statement": "theorem map_comap_eq_self {R R\u2082 M M\u2082 : Type*2} [semiring R] [semiring R\u2082]\n\t[add_comm_monoid M] [add_comm_monoid M\u2082] [module R M] [module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082}\n\t[ring_hom_surjective \u03c4\u2081\u2082] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {q : submodule R\u2082 M\u2082} (h : q \u2264 f.range) :\n\tsubmodule.map f (submodule.comap f q) = q", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] [_inst_8 : module R M] [_inst_9 : module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082} [_inst_12 : ring_hom_surjective \u03c4\u2081\u2082] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {q : submodule R\u2082 M\u2082}, q \u2264 f.range \u2192 submodule.map f (submodule.comap f q) = q", "decl_nm": "submodule.map_comap_eq_self", "nl_statement_of_codex": "Let $R, R_2$ be semirings, $M, M_2$ be $R$-modules, and $f:M\\to M_2$ be a linear map. Let $q$ be a submodule of $M_2$. Then $f^{-1}(q)$ is a submodule of $M$ and $f(f^{-1}(q))=q$."}
{"formal_statement": "theorem to_localization_map_to_monoid_hom_apply {R : Type*} [comm_ring R]\n\t(M : submonoid R) (S : Type*) [comm_ring S] [algebra R S] [is_localization M S]\n\t(\u1fb0 : R) :\n\t\u21d1((is_localization.to_localization_map M S).to_monoid_hom) \u1fb0 = \u21d1(algebra_map R S) \u1fb0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (M : submonoid R) (S : Type u_2) [_inst_2 : comm_ring S] [_inst_3 : algebra R S] [_inst_5 : is_localization M S] (\u1fb0 : R), \u21d1((is_localization.to_localization_map M S).to_monoid_hom) \u1fb0 = \u21d1(algebra_map R S) \u1fb0", "decl_nm": "is_localization.to_localization_map_to_monoid_hom_apply", "nl_statement_of_codex": "Let $R$ be a commutative ring, let $M$ be a submonoid of $R$, let $S$ be a commutative ring, and let $R\\to S$ be a ring homomorphism. Suppose that $S$ is a localization of $M$. Then the map $R\\to S$ is the same as the map $R\\to S$ induced by the universal property of localization."}
{"formal_statement": "theorem integral_eq_zero_of_ae {\u03b1 E : Type*} [normed_group E] [topological_space.second_countable_topology E]\n\t[normed_space \u211d E] [complete_space E] [measurable_space E] [borel_space E]\n\t{m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 E} (hf : f =\u1d50[\u03bc] 0) :\n\t\u222b (a : \u03b1), f a \u2202\u03bc = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} [_inst_1 : normed_group E] [_inst_2 : topological_space.second_countable_topology E] [_inst_3 : normed_space \u211d E] [_inst_4 : complete_space E] [_inst_5 : measurable_space E] [_inst_6 : borel_space E] {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 E}, f =\u1d50[\u03bc] 0 \u2192 \u222b (a : \u03b1), f a \u2202\u03bc = 0", "decl_nm": "measure_theory.integral_eq_zero_of_ae", "nl_statement_of_codex": "Let $E$ be a complete normed space and let $f:X\\to E$ be a measurable function. If $f$ is almost everywhere equal to $0$, then $\\int_X f\\,d\\mu=0$."}
{"formal_statement": "theorem lt_mem_sets_of_Limsup_lt {\u03b1 : Type u} [conditionally_complete_linear_order \u03b1]\n\t{f : filter \u03b1} {b : \u03b1} (h : filter.is_bounded has_le.le f) (l : f.Limsup < b) :\n\t(\u2200\u1da0 (a : \u03b1) in f, a < b)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : conditionally_complete_linear_order \u03b1] {f : filter \u03b1} {b : \u03b1}, filter.is_bounded has_le.le f \u2192 f.Limsup < b \u2192 (\u2200\u1da0 (a : \u03b1) in f, a < b)", "decl_nm": "lt_mem_sets_of_Limsup_lt", "nl_statement_of_codex": "Let $f$ be a filter on a conditionally complete linear order $\u03b1$. If $f$ is bounded above and $\\limsup f<b$, then $f$ is eventually less than $b$."}
{"formal_statement": "theorem const_mul {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {m : \u2115} (hm : function.is_periodic_pt f m x) :\n\t\u2200 (n : \u2115), function.is_periodic_pt f (n * m) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {m : \u2115}, function.is_periodic_pt f m x \u2192 \u2200 (n : \u2115), function.is_periodic_pt f (n * m) x", "decl_nm": "function.is_periodic_pt.const_mul", "nl_statement_of_codex": "Let $f:X\\to X$ be a function and let $x\\in X$. If $f$ is periodic at $x$ with period $m$, then $f$ is periodic at $x$ with period $nm$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem tendsto_const_smul_iff {M \u03b1 \u03b2 : Type*} [topological_space M] [topological_space \u03b1]\n\t[monoid M] [mul_action M \u03b1] [has_continuous_smul M \u03b1] {f : \u03b2 \u2192 \u03b1} {l : filter \u03b2}\n\t{a : \u03b1} {c : M} (hc : is_unit c) :\n\t(filter.tendsto (\u03bb (x : \u03b2), c \u2022 f x) l (nhds (c \u2022 a)) \u2194 filter.tendsto f l (nhds a))", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_2} {\u03b2 : Type u_3} [_inst_1 : topological_space M] [_inst_2 : topological_space \u03b1] [_inst_3 : monoid M] [_inst_4 : mul_action M \u03b1] [_inst_5 : has_continuous_smul M \u03b1] {f : \u03b2 \u2192 \u03b1} {l : filter \u03b2} {a : \u03b1} {c : M}, is_unit c \u2192 (filter.tendsto (\u03bb (x : \u03b2), c \u2022 f x) l (nhds (c \u2022 a)) \u2194 filter.tendsto f l (nhds a))", "decl_nm": "is_unit.tendsto_const_smul_iff", "nl_statement_of_codex": "Let $M$ be a monoid, let $\u03b1$ be a topological space, and let $f:\u03b2\\to \u03b1$. Then $f$ converges to $a$ if and only if $cf$ converges to $ca$."}
{"formal_statement": "theorem measurable_set_of_continuous_at {\u03b1 : Type*} [topological_space \u03b1]\n\t[measurable_space \u03b1] [opens_measurable_space \u03b1] {\u03b2 : Type*} [emetric_space \u03b2]\n\t(f : \u03b1 \u2192 \u03b2) :\n\tmeasurable_set {x : \u03b1 | continuous_at f x}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : opens_measurable_space \u03b1] {\u03b2 : Type u_2} [_inst_14 : emetric_space \u03b2] (f : \u03b1 \u2192 \u03b2), measurable_set {x : \u03b1 | continuous_at f x}", "decl_nm": "measurable_set_of_continuous_at", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Then the set of points $x\\in X$ at which $f$ is continuous is measurable."}
{"formal_statement": "theorem map_sub {R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081} [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] [add_comm_group M] [add_comm_group N] [module R M]\n\t[module R N] [lie_ring_module L M] [lie_ring_module L N] [lie_module R L M]\n\t[lie_module R L N] (f : M \u2192\u2097\u2045R,L\u2046 N) (x y : M) :\n\t\u21d1f (x - y) = \u21d1f x - \u21d1f y", "decl_tp": "\u2200 {R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : add_comm_group M] [_inst_5 : add_comm_group N] [_inst_7 : module R M] [_inst_8 : module R N] [_inst_10 : lie_ring_module L M] [_inst_11 : lie_ring_module L N] [_inst_13 : lie_module R L M] [_inst_14 : lie_module R L N] (f : M \u2192\u2097\u2045R,L\u2046 N) (x y : M), \u21d1f (x - y) = \u21d1f x - \u21d1f y", "decl_nm": "lie_module_hom.map_sub", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring, $M$ and $N$ $R$-modules and $L$-modules. Let $f:M\\to N$ be a linear map of $R$-modules and $L$-modules. Then $f(x-y)=f(x)-f(y)$."}
{"formal_statement": "theorem arg_eq_nhds_of_re_pos {x : \u2102} (hx : 0 < x.re) :\n\t(complex.arg =\u1da0[nhds x] \u03bb (x : \u2102), real.arcsin (x.im / complex.abs x))", "decl_tp": "\u2200 {x : \u2102}, 0 < x.re \u2192 (complex.arg =\u1da0[nhds x] \u03bb (x : \u2102), real.arcsin (x.im / complex.abs x))", "decl_nm": "complex.arg_eq_nhds_of_re_pos", "nl_statement_of_codex": "Let $x$ be a complex number with positive real part. Then the argument of $x$ is equal to the arcsine of the imaginary part of $x$ divided by the absolute value of $x$."}
{"formal_statement": "theorem mod_mem_iff {R : Type u} [euclidean_domain R] {S : ideal R} {x y : R}\n\t(hy : y \u2208 S) :\n\t(x % y \u2208 S \u2194 x \u2208 S)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : euclidean_domain R] {S : ideal R} {x y : R}, y \u2208 S \u2192 (x % y \u2208 S \u2194 x \u2208 S)", "decl_nm": "mod_mem_iff", "nl_statement_of_codex": "Let $R$ be a Euclidean domain and let $S$ be an ideal of $R$. Then $x\\in S$ if and only if $x\\bmod y\\in S$."}
{"formal_statement": "theorem map_eq_zero_iff {R\u2081 R\u2082 : Type*} [semiring R\u2081] [semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t{M\u2081 : Type*} [topological_space M\u2081] [add_comm_monoid M\u2081] {M\u2082 : Type*}\n\t[topological_space M\u2082] [add_comm_monoid M\u2082] [module R\u2081 M\u2081] [module R\u2082 M\u2082]\n\t(e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {x : M\u2081} :\n\t\u21d1e x = 0 \u2194 x = 0", "decl_tp": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [_inst_4 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_5 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {M\u2081 : Type u_4} [_inst_12 : topological_space M\u2081] [_inst_13 : add_comm_monoid M\u2081] {M\u2082 : Type u_6} [_inst_16 : topological_space M\u2082] [_inst_17 : add_comm_monoid M\u2082] [_inst_22 : module R\u2081 M\u2081] [_inst_24 : module R\u2082 M\u2082] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {x : M\u2081}, \u21d1e x = 0 \u2194 x = 0", "decl_nm": "continuous_linear_equiv.map_eq_zero_iff", "nl_statement_of_codex": "Let $R_1, R_2$ be semirings, $M_1, M_2$ be topological spaces, and $\u03c3_{12}:R_1\\to R_2$ be a ring homomorphism.\nLet $e:M_1\\to M_2$ be a $\u03c3_{12}$-linear map. Then $e(x)=0$ if and only if $x=0$."}
{"formal_statement": "theorem mul_left {\u03b1 : Type*} [comm_monoid \u03b1] {a b : \u03b1} :\n\ta \u2223 b \u2192 \u2200 (c : \u03b1), a \u2223 c * b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {a b : \u03b1}, a \u2223 b \u2192 \u2200 (c : \u03b1), a \u2223 c * b", "decl_nm": "has_dvd.dvd.mul_left", "nl_statement_of_codex": "Let $R$ be a commutative monoid. If $a$ divides $b$, then $a$ divides $cb$ for all $c\\in R$."}
{"formal_statement": "theorem le_trans {\u03b1 : Type*} [linear_order \u03b1] (a b c : finset.colex \u03b1)\n\t(AB : a \u2264 b) (BC : b \u2264 c) :\n\ta \u2264 c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] (a b c : finset.colex \u03b1), a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c", "decl_nm": "colex.le_trans", "nl_statement_of_codex": "Let $a,b,c$ be colexicographically ordered finite sets. If $a\\leq b$ and $b\\leq c$, then $a\\leq c$."}
{"formal_statement": "theorem identity {\u03b1 : Type u} (s : stream \u03b1) :\n\tstream.pure id\u229bs = s", "decl_tp": "\u2200 {\u03b1 : Type u} (s : stream \u03b1), stream.pure id\u229bs = s", "decl_nm": "stream.identity", "nl_statement_of_codex": "The identity function is the identity element of the monad of streams."}
{"formal_statement": "theorem comp_lower_semicontinuous {\u03b1 : Type*} [topological_space \u03b1] {\u03b3 : Type*}\n\t[linear_order \u03b3] [topological_space \u03b3] [order_topology \u03b3] {\u03b4 : Type*}\n\t[linear_order \u03b4] [topological_space \u03b4] [order_topology \u03b4] {g : \u03b3 \u2192 \u03b4}\n\t{f : \u03b1 \u2192 \u03b3} (hg : continuous g) (hf : lower_semicontinuous f) (gmon : monotone g) :\n\tlower_semicontinuous (g \u2218 f)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b3 : Type u_3} [_inst_3 : linear_order \u03b3] [_inst_4 : topological_space \u03b3] [_inst_5 : order_topology \u03b3] {\u03b4 : Type u_4} [_inst_6 : linear_order \u03b4] [_inst_7 : topological_space \u03b4] [_inst_8 : order_topology \u03b4] {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}, continuous g \u2192 lower_semicontinuous f \u2192 monotone g \u2192 lower_semicontinuous (g \u2218 f)", "decl_nm": "continuous.comp_lower_semicontinuous", "nl_statement_of_codex": "Let $f:X\\to Y$ and $g:Y\\to Z$ be functions between topological spaces. If $f$ is lower semicontinuous and $g$ is continuous and monotone, then $g\\circ f$ is lower semicontinuous."}
{"formal_statement": "theorem nth_count (p : \u2115 \u2192 Prop) [decidable_pred p] {n : \u2115} (hpn : p n) :\n\tnat.nth p (nat.count p n) = n", "decl_tp": "\u2200 (p : \u2115 \u2192 Prop) [_inst_1 : decidable_pred p] {n : \u2115}, p n \u2192 nat.nth p (nat.count p n) = n", "decl_nm": "nat.nth_count", "nl_statement_of_codex": "Let $p$ be a decidable predicate on $\\mathbb{N}$. Let $n$ be a natural number such that $p(n)$ holds. Then $n$ is the $k$-th number such that $p$ holds, where $k$ is the number of natural numbers less than or equal to $n$ such that $p$ holds."}
{"formal_statement": "theorem kernel_is_iso_comp_hom {C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_zero_morphisms C] {X Y Z : C} (f : X \u27f6 Y)\n\t(g : Y \u27f6 Z) [category_theory.is_iso f] [category_theory.limits.has_kernel g] :\n\t(category_theory.limits.kernel_is_iso_comp f g).hom = category_theory.limits.kernel.lift g (category_theory.limits.kernel.\u03b9 (f \u226b g) \u226b f) _", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [_inst_4 : category_theory.is_iso f] [_inst_5 : category_theory.limits.has_kernel g], (category_theory.limits.kernel_is_iso_comp f g).hom = category_theory.limits.kernel.lift g (category_theory.limits.kernel.\u03b9 (f \u226b g) \u226b f) _", "decl_nm": "category_theory.limits.kernel_is_iso_comp_hom", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$ and $g:Y\\to Z$ be morphisms. If $f$ is an isomorphism and $g$ has a kernel, then the kernel of $g\\circ f$ is isomorphic to the kernel of $g$."}
{"formal_statement": "theorem Sup_mem {\u03b1 : Type*} [conditionally_complete_linear_order \u03b1] [topological_space \u03b1]\n\t[order_topology \u03b1] {s : set \u03b1} (hs : is_compact s) (ne_s : s.nonempty) :\n\thas_Sup.Sup s \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] {s : set \u03b1}, is_compact s \u2192 s.nonempty \u2192 has_Sup.Sup s \u2208 s", "decl_nm": "is_compact.Sup_mem", "nl_statement_of_codex": "Let $s$ be a compact subset of a conditionally complete linear order $X$. Then $\\sup s\\in s$."}
{"formal_statement": "theorem psub_eq_none {m n : \u2115} :\n\tm.psub n = option.none \u2194 m < n", "decl_tp": "\u2200 {m n : \u2115}, m.psub n = option.none \u2194 m < n", "decl_nm": "nat.psub_eq_none", "nl_statement_of_codex": "$m.psub n$ is none if and only if $m<n$."}
{"formal_statement": "theorem sub_apply {R\u2081 R\u2082 M N\u2082 : Type*4} [semiring R\u2081] [semiring R\u2082] [add_comm_monoid M]\n\t[add_comm_group N\u2082] [module R\u2081 M] [module R\u2082 N\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082)\n\t(x : M) :\n\t\u21d1(f - g) x = \u21d1f x - \u21d1g x", "decl_tp": "\u2200 {R\u2081 : Type u_2} {R\u2082 : Type u_3} {M : Type u_9} {N\u2082 : Type u_14} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] [_inst_4 : add_comm_monoid M] [_inst_8 : add_comm_group N\u2082] [_inst_10 : module R\u2081 M] [_inst_14 : module R\u2082 N\u2082] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) (x : M), \u21d1(f - g) x = \u21d1f x - \u21d1g x", "decl_nm": "linear_map.sub_apply", "nl_statement_of_codex": "Let $R_1, R_2, M, N_2$ be semirings, $M$ an additive commutative monoid, $N_2$ an additive commutative group,\n$M$ a module over $R_1$, and $N_2$ a module over $R_2$. Let $\\sigma_{12}:R_1\\to R_2$ be a semiring homomorphism.\nLet $f, g:M\\to N_2$ be linear maps. Then $(f-g)(x)=f(x)-g(x)$."}
{"formal_statement": "theorem swap {\u03b1 : Type*} [has_lt \u03b1] {a b : \u03b1} {o : ordering} :\n\to.compares b a \u2192 o.swap.compares a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_lt \u03b1] {a b : \u03b1} {o : ordering}, o.compares b a \u2192 o.swap.compares a b", "decl_nm": "ordering.compares.swap", "nl_statement_of_codex": "Let $a,b$ be elements of a linearly ordered set $X$. Then $a<b$ if and only if $b>a$."}
{"formal_statement": "theorem init' {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : initial_seg r s)\n\t{a : \u03b1} {b : \u03b2} :\n\ts b (\u21d1f a) \u2192 (\u2203 (a' : \u03b1), \u21d1f a' = b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : initial_seg r s) {a : \u03b1} {b : \u03b2}, s b (\u21d1f a) \u2192 (\u2203 (a' : \u03b1), \u21d1f a' = b)", "decl_nm": "initial_seg.init'", "nl_statement_of_codex": "Let $f:A\\to B$ be an initial segment. If $b\\in B$ and $b\\leq f(a)$ for some $a\\in A$, then there is an $a'\\in A$ such that $f(a')=b$."}
{"formal_statement": "theorem prod_subset_preimage_fst {\u03b1 \u03b2 : Type*} (s : set \u03b1) (t : set \u03b2) :\n\ts.prod t \u2286 prod.fst \u207b\u00b9' s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (s : set \u03b1) (t : set \u03b2), s.prod t \u2286 prod.fst \u207b\u00b9' s", "decl_nm": "set.prod_subset_preimage_fst", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then $s\\times t\\subseteq s\\times\\mathbb{R}$."}
{"formal_statement": "theorem smul_sum {\u03b1 \u03b2 R M : Type*} [has_zero \u03b2] [monoid R] [add_comm_monoid M]\n\t[distrib_mul_action R M] {v : \u03b1 \u2192\u2080 \u03b2} {c : R} {h : \u03b1 \u2192 \u03b2 \u2192 M} :\n\tc \u2022 v.sum h = v.sum (\u03bb (a : \u03b1) (b : \u03b2), c \u2022 h a b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {R : Type u_3} {M : Type u_4} [_inst_1 : has_zero \u03b2] [_inst_2 : monoid R] [_inst_3 : add_comm_monoid M] [_inst_4 : distrib_mul_action R M] {v : \u03b1 \u2192\u2080 \u03b2} {c : R} {h : \u03b1 \u2192 \u03b2 \u2192 M}, c \u2022 v.sum h = v.sum (\u03bb (a : \u03b1) (b : \u03b2), c \u2022 h a b)", "decl_nm": "finsupp.smul_sum", "nl_statement_of_codex": "Let $R$ be a monoid, $M$ be an abelian monoid, and $R$ act on $M$ by multiplication. Let $v$ be a finitely supported function from $A$ to $B$, and let $h:A\\times B\\to M$. Then $c\\cdot v\\sum h=v\\sum (c\\cdot h)$."}
{"formal_statement": "theorem volume_Ioi {a : \u211d} :\n\t\u21d1measure_theory.measure_space.volume (set.Ioi a) = \u22a4", "decl_tp": "\u2200 {a : \u211d}, \u21d1measure_theory.measure_space.volume (set.Ioi a) = \u22a4", "decl_nm": "real.volume_Ioi", "nl_statement_of_codex": "The volume of the set $(a,\\infty)$ is $\\infty$."}
{"formal_statement": "theorem support_nonempty_iff {\u03b1 M : Type*} [has_zero M] {f : \u03b1 \u2192\u2080 M} :\n\tf.support.nonempty \u2194 f \u2260 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] {f : \u03b1 \u2192\u2080 M}, f.support.nonempty \u2194 f \u2260 0", "decl_nm": "finsupp.support_nonempty_iff", "nl_statement_of_codex": "The support of a function $f:\\alpha\\to M$ is nonempty if and only if $f$ is not the zero function."}
{"formal_statement": "theorem vadd_pi_subset {K \u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), has_vadd K (R i)]\n\t(r : K) (s : set \u03b9) (t : \u03a0 (i : \u03b9), set (R i)) :\n\tr +\u1d65 s.pi t \u2286 s.pi (r +\u1d65 t)", "decl_tp": "\u2200 {K : Type u_1} {\u03b9 : Type u_2} {R : \u03b9 \u2192 Type u_3} [_inst_1 : \u03a0 (i : \u03b9), has_vadd K (R i)] (r : K) (s : set \u03b9) (t : \u03a0 (i : \u03b9), set (R i)), r +\u1d65 s.pi t \u2286 s.pi (r +\u1d65 t)", "decl_nm": "vadd_pi_subset", "nl_statement_of_codex": "Let $K$ be a field, let $R$ be a family of $K$-vector spaces, and let $r\\in K$, $s\\subseteq I$, and $t:I\\to R$ be given. Then $r+\\sum_{i\\in s}t(i)\\subseteq \\sum_{i\\in s}(r+t(i))$."}
{"formal_statement": "theorem condexp_ae_eq {\u03b1 E \u03b9 : Type*} [preorder \u03b9] [measurable_space E]\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_group E]\n\t[normed_space \u211d E] [complete_space E] [borel_space E] [topological_space.second_countable_topology E]\n\t{f : \u03b9 \u2192 \u03b1 \u2192 E} {\u2131 : measure_theory.filtration \u03b9 m0} [measure_theory.sigma_finite_filtration \u03bc \u2131]\n\t(hf : measure_theory.martingale f \u2131 \u03bc) (hij : i \u2264 j) :\n\t\u2200 {i j : \u03b9},  measure_theory.condexp (\u21d1\u2131 i) _ \u03bc (f j) =\u1d50[\u03bc] f i", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} {\u03b9 : Type u_3} [_inst_1 : preorder \u03b9] [_inst_2 : measurable_space E] {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : normed_group E] [_inst_4 : normed_space \u211d E] [_inst_5 : complete_space E] [_inst_6 : borel_space E] [_inst_7 : topological_space.second_countable_topology E] {f : \u03b9 \u2192 \u03b1 \u2192 E} {\u2131 : measure_theory.filtration \u03b9 m0} [_inst_8 : measure_theory.sigma_finite_filtration \u03bc \u2131], measure_theory.martingale f \u2131 \u03bc \u2192 \u2200 {i j : \u03b9}, i \u2264 j \u2192 measure_theory.condexp (\u21d1\u2131 i) _ \u03bc (f j) =\u1d50[\u03bc] f i", "decl_nm": "measure_theory.martingale.condexp_ae_eq", "nl_statement_of_codex": "Let $E$ be a complete normed group. Let $f:\\mathbb{N}\\times\\Omega\\to E$ be a martingale. Then the conditional expectation of $f_j$ given $\\mathcal{F}_i$ is equal to $f_i$ almost surely."}
{"formal_statement": "theorem tendsto_pure {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {a : filter \u03b1}\n\t{b : \u03b2} :\n\tfilter.tendsto f a (has_pure.pure b) \u2194 \u2200\u1da0 (x : \u03b1) in a, f x = b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {a : filter \u03b1} {b : \u03b2}, filter.tendsto f a (has_pure.pure b) \u2194 \u2200\u1da0 (x : \u03b1) in a, f x = b", "decl_nm": "filter.tendsto_pure", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $a\\in B$. Then $f$ converges to $a$ if and only if $f(x)=a$ for all $x$ in $A$."}
{"formal_statement": "theorem map_domain_congr {\u03b1 \u03b2 M : Type*} [add_comm_monoid M] {v : \u03b1 \u2192\u2080 M}\n\t{f g : \u03b1 \u2192 \u03b2} :\n\t(\u2200 (x : \u03b1), x \u2208 v.support \u2192 f x = g x) \u2192 finsupp.map_domain f v = finsupp.map_domain g v", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {M : Type u_5} [_inst_1 : add_comm_monoid M] {v : \u03b1 \u2192\u2080 M} {f g : \u03b1 \u2192 \u03b2}, (\u2200 (x : \u03b1), x \u2208 v.support \u2192 f x = g x) \u2192 finsupp.map_domain f v = finsupp.map_domain g v", "decl_nm": "finsupp.map_domain_congr", "nl_statement_of_codex": "Let $M$ be an abelian monoid, let $v:\\alpha\\to M$ be a finitely supported function, and let $f,g:\\alpha\\to\\beta$. If $f(x)=g(x)$ for all $x\\in\\alpha$ such that $v(x)\\neq 0$, then $f\\circ v=g\\circ v$."}
{"formal_statement": "theorem pairwise_lt_range (n : \u2115) :\n\tlist.pairwise has_lt.lt (list.range n)", "decl_tp": "\u2200 (n : \u2115), list.pairwise has_lt.lt (list.range n)", "decl_nm": "list.pairwise_lt_range", "nl_statement_of_codex": "The list $[0,1,\\ldots,n-1]$ is pairwise less than."}
{"formal_statement": "theorem image_upper_bounds_subset_lower_bounds_image {\u03b1 : Type u} {\u03b2 : Type v}\n\t[preorder \u03b1] [preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1} (hf : antitone f) :\n\tf '' upper_bounds s \u2286 lower_bounds (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}, antitone f \u2192 f '' upper_bounds s \u2286 lower_bounds (f '' s)", "decl_nm": "antitone.image_upper_bounds_subset_lower_bounds_image", "nl_statement_of_codex": "Let $f:A\\to B$ be an antitone function. Then $f(U)\\subset L$ where $U$ is the set of upper bounds of $A$ and $L$ is the set of lower bounds of $f(A)$."}
{"formal_statement": "theorem generator_mem {R : Type u} {M : Type v} [add_comm_group M] [ring R]\n\t[module R M] (S : submodule R M) [S.is_principal] :\n\tsubmodule.is_principal.generator S \u2208 S", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : add_comm_group M] [_inst_2 : ring R] [_inst_3 : module R M] (S : submodule R M) [_inst_4 : S.is_principal], submodule.is_principal.generator S \u2208 S", "decl_nm": "submodule.is_principal.generator_mem", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, and $S$ a principal submodule of $M$. Then the generator of $S$ is in $S$."}
{"formal_statement": "theorem nil_comp {V : Type u} [quiver V] {a b : V} (p : quiver.path a b) :\n\tquiver.path.nil.comp p = p", "decl_tp": "\u2200 {V : Type u} [_inst_1 : quiver V] {a b : V} (p : quiver.path a b), quiver.path.nil.comp p = p", "decl_nm": "quiver.path.nil_comp", "nl_statement_of_codex": "The composition of the zero path with any path is the path itself."}
{"formal_statement": "theorem dprod_cons {\u03b9 \u03b1 : Type*} {A : \u03b9 \u2192 Type*} [add_monoid \u03b9] [graded_monoid.gmonoid A]\n\t(f\u03b9 : \u03b1 \u2192 \u03b9) (fA : \u03a0 (a : \u03b1), A (f\u03b9 a)) (a : \u03b1) (l : list \u03b1) :\n\t(a :: l).dprod f\u03b9 fA = graded_monoid.ghas_mul.mul (fA a) (l.dprod f\u03b9 fA)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {A : \u03b9 \u2192 Type u_3} [_inst_1 : add_monoid \u03b9] [_inst_2 : graded_monoid.gmonoid A] (f\u03b9 : \u03b1 \u2192 \u03b9) (fA : \u03a0 (a : \u03b1), A (f\u03b9 a)) (a : \u03b1) (l : list \u03b1), (a :: l).dprod f\u03b9 fA = graded_monoid.ghas_mul.mul (fA a) (l.dprod f\u03b9 fA)", "decl_nm": "list.dprod_cons", "nl_statement_of_codex": "Let $A$ be a graded monoid. Let $f_A: \\alpha\\to A$ be a function. Then $(a::l).dprod f_A = f_A(a)\\cdot l.dprod f_A$."}
{"formal_statement": "theorem \u03c0_of_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t(X Y : C) :\n\tcategory_theory.is_iso (category_theory.limits.cokernel.\u03c0 0)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] (X Y : C), category_theory.is_iso (category_theory.limits.cokernel.\u03c0 0)", "decl_nm": "category_theory.limits.cokernel.\u03c0_of_zero", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Then the morphism $\\pi_0:X\\to Y$ is an isomorphism."}
{"formal_statement": "theorem emetric_ball_nnreal {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x : \u03b1}\n\t{\u03b5 : nnreal} :\n\temetric.ball x \u2191\u03b5 = metric.ball x \u2191\u03b5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : nnreal}, emetric.ball x \u2191\u03b5 = metric.ball x \u2191\u03b5", "decl_nm": "metric.emetric_ball_nnreal", "nl_statement_of_codex": "The emetric ball of radius $\\epsilon$ around $x$ is the same as the metric ball of radius $\\epsilon$ around $x$."}
{"formal_statement": "theorem inv_mul_eq_div {G : Type u} [comm_group G] (a b : G) :\n\ta\u207b\u00b9 * b = b / a", "decl_tp": "\u2200 {G : Type u} [_inst_1 : comm_group G] (a b : G), a\u207b\u00b9 * b = b / a", "decl_nm": "inv_mul_eq_div", "nl_statement_of_codex": "In a commutative group, $a^{-1}b=b/a$."}
{"formal_statement": "theorem cInf_Icc {\u03b1 : Type*} [conditionally_complete_lattice \u03b1] {a b : \u03b1}\n\t(h : a \u2264 b) :\n\thas_Inf.Inf (set.Icc a b) = a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : conditionally_complete_lattice \u03b1] {a b : \u03b1}, a \u2264 b \u2192 has_Inf.Inf (set.Icc a b) = a", "decl_nm": "cInf_Icc", "nl_statement_of_codex": "Let $a,b\\in\\alpha$ with $a\\leq b$. Then $\\inf\\{x\\in\\alpha\\mid a\\leq x\\leq b\\}=a$."}
{"formal_statement": "theorem bot_general_commutator {G : Type*} [group G] (H : subgroup G) :\n\t\u2045\u22a5,H\u2046 = \u22a5", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (H : subgroup G), \u2045\u22a5,H\u2046 = \u22a5", "decl_nm": "bot_general_commutator", "nl_statement_of_codex": "The general commutator of the trivial subgroup and a subgroup $H$ of a group $G$ is trivial."}
{"formal_statement": "theorem prod_symm {R : Type u} {M : Type v} {M\u2082 : Type w} {M\u2083 : Type y}\n\t{M\u2084 : Type z} [semiring R] [add_comm_monoid M] [add_comm_monoid M\u2082] [add_comm_monoid M\u2083]\n\t[add_comm_monoid M\u2084] {module_M : module R M} {module_M\u2082 : module R M\u2082}\n\t{module_M\u2083 : module R M\u2083} {module_M\u2084 : module R M\u2084} (e\u2081 : M \u2243\u2097[R] M\u2082)\n\t(e\u2082 : M\u2083 \u2243\u2097[R] M\u2084) :\n\t(e\u2081.prod e\u2082).symm = e\u2081.symm.prod e\u2082.symm", "decl_tp": "\u2200 {R : Type u} {M : Type v} {M\u2082 : Type w} {M\u2083 : Type y} {M\u2084 : Type z} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : add_comm_monoid M\u2082] [_inst_4 : add_comm_monoid M\u2083] [_inst_5 : add_comm_monoid M\u2084] {module_M : module R M} {module_M\u2082 : module R M\u2082} {module_M\u2083 : module R M\u2083} {module_M\u2084 : module R M\u2084} (e\u2081 : M \u2243\u2097[R] M\u2082) (e\u2082 : M\u2083 \u2243\u2097[R] M\u2084), (e\u2081.prod e\u2082).symm = e\u2081.symm.prod e\u2082.symm", "decl_nm": "linear_equiv.prod_symm", "nl_statement_of_codex": "Let $R$ be a semiring, $M, M_2, M_3, M_4$ be $R$-modules. Let $e_1:M\\to M_2$ and $e_2:M_3\\to M_4$ be $R$-linear maps. Then $(e_1\\times e_2)^{-1}=(e_1^{-1}\\times e_2^{-1})$."}
{"formal_statement": "theorem eq_univ_of_forall {\u03b1 : Type u} {s : set \u03b1} :\n\t(\u2200 (x : \u03b1), x \u2208 s) \u2192 s = set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1}, (\u2200 (x : \u03b1), x \u2208 s) \u2192 s = set.univ", "decl_nm": "set.eq_univ_of_forall", "nl_statement_of_codex": "Let $s$ be a set. If $s$ contains all elements of $\u03b1$, then $s=\u03b1$."}
{"formal_statement": "theorem is_amalgamation_restrict {C : Type u\u2081} [category_theory.category C]\n\t{P : C\u1d52\u1d56 \u2964 Type w} {X : C} {R\u2081 R\u2082 : category_theory.presieve X} (h : R\u2081 \u2264 R\u2082)\n\t(x : category_theory.presieve.family_of_elements P R\u2082) (t : P.obj (opposite.op X))\n\t(ht : x.is_amalgamation t) :\n\t(category_theory.presieve.family_of_elements.restrict h x).is_amalgamation t", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {P : C\u1d52\u1d56 \u2964 Type w} {X : C} {R\u2081 R\u2082 : category_theory.presieve X} (h : R\u2081 \u2264 R\u2082) (x : category_theory.presieve.family_of_elements P R\u2082) (t : P.obj (opposite.op X)), x.is_amalgamation t \u2192 (category_theory.presieve.family_of_elements.restrict h x).is_amalgamation t", "decl_nm": "category_theory.presieve.is_amalgamation_restrict", "nl_statement_of_codex": "Let $C$ be a category, $P$ a presheaf on $C$, $X$ an object of $C$, $R_1$ and $R_2$ presieves on $X$, and $h:R_1\\leq R_2$. Let $x$ be an element of $P(X)$ and $t$ an element of $P(X)$. If $x$ is an amalgamation of $t$, then the restriction of $x$ to $R_1$ is an amalgamation of $t$."}
{"formal_statement": "theorem mod_def (a b : \u2124) :\n\ta % b = a - b * (a / b)", "decl_tp": "\u2200 (a b : \u2124), a % b = a - b * (a / b)", "decl_nm": "int.mod_def", "nl_statement_of_codex": "For all integers $a$ and $b$, $a\\equiv a\\pmod{b}$ if and only if $a=bq+r$ for some integers $q$ and $r$ with $0\\leq r<b$."}
{"formal_statement": "theorem is_add_cyclic_of_card_pow_eq_one_le {\u03b1 : Type*} [add_group \u03b1] [decidable_eq \u03b1]\n\t[fintype \u03b1] :\n\t(\u2200 (n : \u2115), 0 < n \u2192 (finset.filter (\u03bb (a : \u03b1), n \u2022 a = 0) finset.univ).card \u2264 n) \u2192 is_add_cyclic \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_4 : add_group \u03b1] [_inst_5 : decidable_eq \u03b1] [_inst_6 : fintype \u03b1], (\u2200 (n : \u2115), 0 < n \u2192 (finset.filter (\u03bb (a : \u03b1), n \u2022 a = 0) finset.univ).card \u2264 n) \u2192 is_add_cyclic \u03b1", "decl_nm": "is_add_cyclic_of_card_pow_eq_one_le", "nl_statement_of_codex": "Let $G$ be a finite abelian group. If for each $n\\in\\mathbb{N}$ the number of elements of order $n$ is at most $n$, then $G$ is cyclic."}
{"formal_statement": "theorem le_dirac_apply {\u03b1 : Type*} {s : set \u03b1} [measurable_space \u03b1] {a : \u03b1} :\n\ts.indicator 1 a \u2264 \u21d1(measure_theory.measure.dirac a) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : set \u03b1} [_inst_3 : measurable_space \u03b1] {a : \u03b1}, s.indicator 1 a \u2264 \u21d1(measure_theory.measure.dirac a) s", "decl_nm": "measure_theory.measure.le_dirac_apply", "nl_statement_of_codex": "Let $s$ be a measurable set and let $a$ be an element of $s$. Then the indicator function of $s$ at $a$ is less than or equal to the Dirac measure of $a$ at $s$."}
{"formal_statement": "theorem ceil_le {\u03b1 : Type*} [linear_ordered_semiring \u03b1] [floor_semiring \u03b1]\n\t{a : \u03b1} {n : \u2115} :\n\t\u2308a\u2309\u208a \u2264 n \u2194 a \u2264 \u2191n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_semiring \u03b1] [_inst_2 : floor_semiring \u03b1] {a : \u03b1} {n : \u2115}, \u2308a\u2309\u208a \u2264 n \u2194 a \u2264 \u2191n", "decl_nm": "nat.ceil_le", "nl_statement_of_codex": "Let $a$ be an element of a linear ordered semiring $R$ with floor function. Then $\\lceil a\\rceil\\leq n$ if and only if $a\\leq n$."}
{"formal_statement": "theorem lift_mk {\u03b1 \u03b2 : Type*} (f : {f // \u2200 (a\u2081 a\u2082 : \u03b1), f a\u2081 a\u2082 = f a\u2082 a\u2081})\n\t(a\u2081 a\u2082 : \u03b1) :\n\t\u21d1sym2.lift f \u27e6(a\u2081, a\u2082)\u27e7 = \u2191f a\u2081 a\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : {f // \u2200 (a\u2081 a\u2082 : \u03b1), f a\u2081 a\u2082 = f a\u2082 a\u2081}) (a\u2081 a\u2082 : \u03b1), \u21d1sym2.lift f \u27e6(a\u2081, a\u2082)\u27e7 = \u2191f a\u2081 a\u2082", "decl_nm": "sym2.lift_mk", "nl_statement_of_codex": "Let $f$ be a function from $\\alpha\\times\\alpha$ to $\\beta$ such that $f(a_1,a_2)=f(a_2,a_1)$ for all $a_1,a_2\\in\\alpha$. Then $\\overline{f}(a_1,a_2)=f(a_1,a_2)$."}
{"formal_statement": "theorem set_bInter_bUnion {\u03b1 \u03b2 \u03b3 : Type*} [decidable_eq \u03b1] (s : finset \u03b3)\n\t(t : \u03b3 \u2192 finset \u03b1) (f : \u03b1 \u2192 set \u03b2) :\n\t(\u22c2 (y : \u03b1) (H : y \u2208 s.bUnion t), f y) = \u22c2 (x : \u03b3) (H : x \u2208 s) (y : \u03b1)\n\t(H : y \u2208 t x), f y", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : decidable_eq \u03b1] (s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b1) (f : \u03b1 \u2192 set \u03b2), (\u22c2 (y : \u03b1) (H : y \u2208 s.bUnion t), f y) = \u22c2 (x : \u03b3) (H : x \u2208 s) (y : \u03b1) (H : y \u2208 t x), f y", "decl_nm": "finset.set_bInter_bUnion", "nl_statement_of_codex": "Let $s$ be a finite set, $t$ a function from $s$ to finite sets, and $f$ a function from finite sets to sets. Then\n$$\\bigcap_{y\\in\\bigcup_{x\\in s}t(x)}f(y)=\\bigcap_{x\\in s}\\bigcap_{y\\in t(x)}f(y).$$"}
{"formal_statement": "theorem symm {\u0393 : Type*} [inhabited \u0393] {l\u2081 l\u2082 : list \u0393} :\n\tturing.blank_rel l\u2081 l\u2082 \u2192 turing.blank_rel l\u2082 l\u2081", "decl_tp": "\u2200 {\u0393 : Type u_1} [_inst_1 : inhabited \u0393] {l\u2081 l\u2082 : list \u0393}, turing.blank_rel l\u2081 l\u2082 \u2192 turing.blank_rel l\u2082 l\u2081", "decl_nm": "turing.blank_rel.symm", "nl_statement_of_codex": "Let $l_1, l_2$ be lists of elements of a type $\\Gamma$. Then $l_1$ is related to $l_2$ by the blank relation if and only if $l_2$ is related to $l_1$ by the blank relation."}
{"formal_statement": "theorem monotone_int_of_le_succ {\u03b1 : Type u} [preorder \u03b1] {f : \u2124 \u2192 \u03b1} :\n\t(\u2200 (n : \u2124), f n \u2264 f (n + 1)) \u2192 monotone f", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {f : \u2124 \u2192 \u03b1}, (\u2200 (n : \u2124), f n \u2264 f (n + 1)) \u2192 monotone f", "decl_nm": "monotone_int_of_le_succ", "nl_statement_of_codex": "Let $f:\\mathbb{Z}\\to\\alpha$ be a function. If $f(n)\\leq f(n+1)$ for all $n\\in\\mathbb{Z}$, then $f$ is monotone."}
{"formal_statement": "theorem map_pure {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n\tfilter.map f (has_pure.pure a) = has_pure.pure (f a)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (a : \u03b1), filter.map f (has_pure.pure a) = has_pure.pure (f a)", "decl_nm": "filter.map_pure", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function and let $x\\in X$. Then $f(x)$ is a pure element of $Y$."}
{"formal_statement": "theorem evaluation_obj_map (C : Type u\u2081) [category_theory.category C] (D : Type u\u2082)\n\t[category_theory.category D] (X : C) (F G : C \u2964 D) (\u03b1 : F \u27f6 G) :\n\t((category_theory.evaluation C D).obj X).map \u03b1 = \u03b1.app X", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C] (D : Type u\u2082) [_inst_2 : category_theory.category D] (X : C) (F G : C \u2964 D) (\u03b1 : F \u27f6 G), ((category_theory.evaluation C D).obj X).map \u03b1 = \u03b1.app X", "decl_nm": "category_theory.evaluation_obj_map", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $X$ be an object of $C$. Let $F, G:C\\to D$ be functors and let $\\alpha:F\\to G$ be a natural transformation. Then the evaluation of $\\alpha$ at $X$ is the same as the application of $\\alpha$ to $X$."}
{"formal_statement": "theorem coe_comp {V\u2081 V\u2082 V\u2083 : Type*} [semi_normed_group V\u2081] [semi_normed_group V\u2082]\n\t[semi_normed_group V\u2083] (f : normed_group_hom V\u2081 V\u2082) (g : normed_group_hom V\u2082 V\u2083) :\n\t\u21d1(g.comp f) = \u21d1g \u2218 \u21d1f", "decl_tp": "\u2200 {V\u2081 : Type u_2} {V\u2082 : Type u_3} {V\u2083 : Type u_4} [_inst_2 : semi_normed_group V\u2081] [_inst_3 : semi_normed_group V\u2082] [_inst_4 : semi_normed_group V\u2083] (f : normed_group_hom V\u2081 V\u2082) (g : normed_group_hom V\u2082 V\u2083), \u21d1(g.comp f) = \u21d1g \u2218 \u21d1f", "decl_nm": "normed_group_hom.coe_comp", "nl_statement_of_codex": "Let $V_1, V_2, V_3$ be semi-normed groups and let $f:V_1\\to V_2$ and $g:V_2\\to V_3$ be normed group homomorphisms. Then $g\\circ f$ is a normed group homomorphism and $(g\\circ f)^*=g^*\\circ f^*$."}
{"formal_statement": "theorem dvd_gcd {m n k : \u2115} :\n\tk \u2223 m \u2192 k \u2223 n \u2192 k \u2223 m.gcd n", "decl_tp": "\u2200 {m n k : \u2115}, k \u2223 m \u2192 k \u2223 n \u2192 k \u2223 m.gcd n", "decl_nm": "nat.dvd_gcd", "nl_statement_of_codex": "If $k$ divides $m$ and $k$ divides $n$, then $k$ divides $\\gcd(m,n)$."}
{"formal_statement": "theorem mem_upper_bounds_image {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : antitone f) (ha : a \u2208 lower_bounds s) :\n\t\u2200 {a : \u03b1} {s : set \u03b1},  f a \u2208 upper_bounds (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, antitone f \u2192 \u2200 {a : \u03b1} {s : set \u03b1}, a \u2208 lower_bounds s \u2192 f a \u2208 upper_bounds (f '' s)", "decl_nm": "antitone.mem_upper_bounds_image", "nl_statement_of_codex": "Let $f:A\\to B$ be an antitone function. If $a\\in\\inf A$, then $f(a)\\in\\sup f(A)$."}
{"formal_statement": "theorem map_repeat {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (k : \u2115) :\n\tmultiset.map f (multiset.repeat a k) = multiset.repeat (f a) k", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (k : \u2115), multiset.map f (multiset.repeat a k) = multiset.repeat (f a) k", "decl_nm": "multiset.map_repeat", "nl_statement_of_codex": "The map $f$ applied to the multiset $\\{a,\\ldots,a\\}$ is the multiset $\\{f(a),\\ldots,f(a)\\}$."}
{"formal_statement": "theorem dropn_tail {\u03b1 : Type u} (s : wseq \u03b1) (n : \u2115) :\n\ts.tail.drop n = s.drop (n + 1)", "decl_tp": "\u2200 {\u03b1 : Type u} (s : wseq \u03b1) (n : \u2115), s.tail.drop n = s.drop (n + 1)", "decl_nm": "wseq.dropn_tail", "nl_statement_of_codex": "Let $s$ be a weak sequence of elements of a type $\u03b1$. Then $s.tail.drop(n)=s.drop(n+1)$."}
{"formal_statement": "theorem clm_apply {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {G : Type*} [normed_group G] [normed_space \ud835\udd5c G]\n\t{s : set E} {H : Type*} [normed_group H] [normed_space \ud835\udd5c H] {c : E \u2192 (G \u2192L[\ud835\udd5c] H)}\n\t{u : E \u2192 G} (hc : differentiable_on \ud835\udd5c c s) (hu : differentiable_on \ud835\udd5c u s) :\n\tdifferentiable_on \ud835\udd5c (\u03bb (y : E), \u21d1(c y) (u y)) s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {s : set E} {H : Type u_6} [_inst_10 : normed_group H] [_inst_11 : normed_space \ud835\udd5c H] {c : E \u2192 (G \u2192L[\ud835\udd5c] H)} {u : E \u2192 G}, differentiable_on \ud835\udd5c c s \u2192 differentiable_on \ud835\udd5c u s \u2192 differentiable_on \ud835\udd5c (\u03bb (y : E), \u21d1(c y) (u y)) s", "decl_nm": "differentiable_on.clm_apply", "nl_statement_of_codex": "Let $E, G, H$ be normed spaces over $\\mathbb{K}$ and let $s\\subset E$. Let $c:E\\to L(G,H)$ and $u:E\\to G$ be differentiable functions. Then the function $y\\mapsto c(y)(u(y))$ is differentiable."}
{"formal_statement": "theorem erase_dup {\u03b1 : Type u} [decidable_eq \u03b1] {l : list \u03b1} (h : l.nodup) :\n\tl.erase_dup = l", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : decidable_eq \u03b1] {l : list \u03b1}, l.nodup \u2192 l.erase_dup = l", "decl_nm": "list.nodup.erase_dup", "nl_statement_of_codex": "If $l$ is a list with no duplicates, then $l.erase\\_dup=l$."}
{"formal_statement": "theorem not_and_of_not_right (a : Prop) {b : Prop} :\n\t\u00acb \u2192 \u00ac(a \u2227 b)", "decl_tp": "\u2200 (a : Prop) {b : Prop}, \u00acb \u2192 \u00ac(a \u2227 b)", "decl_nm": "not_and_of_not_right", "nl_statement_of_codex": "If $b$ is false, then $a\\land b$ is false."}
{"formal_statement": "theorem mem_prod {G : Type*} [group G] {N : Type*} [group N] {H : subgroup G}\n\t{K : subgroup N} {p : G \u00d7 N} :\n\tp \u2208 H.prod K \u2194 p.fst \u2208 H \u2227 p.snd \u2208 K", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] {H : subgroup G} {K : subgroup N} {p : G \u00d7 N}, p \u2208 H.prod K \u2194 p.fst \u2208 H \u2227 p.snd \u2208 K", "decl_nm": "subgroup.mem_prod", "nl_statement_of_codex": "Let $G$ and $N$ be groups and let $H$ and $K$ be subgroups of $G$ and $N$, respectively. Then $(g,n)\\in H\\times K$ if and only if $g\\in H$ and $n\\in K$."}
{"formal_statement": "theorem factor_multiset_of_prime (p : nat.primes) :\n\t\u2191p.factor_multiset = prime_multiset.of_prime p", "decl_tp": "\u2200 (p : nat.primes), \u2191p.factor_multiset = prime_multiset.of_prime p", "decl_nm": "pnat.factor_multiset_of_prime", "nl_statement_of_codex": "The multiset of prime factors of a prime $p$ is the multiset containing $p$ with multiplicity $1$."}
{"formal_statement": "theorem infinite_neg_def {x : \u211d*} :\n\tx.infinite_neg \u2194 \u2200 (r : \u211d), x < \u2191r", "decl_tp": "\u2200 {x : \u211d*}, x.infinite_neg \u2194 \u2200 (r : \u211d), x < \u2191r", "decl_nm": "hyperreal.infinite_neg_def", "nl_statement_of_codex": "$x$ is infinite negative if and only if $x<r$ for all $r\\in\\mathbb{R}$."}
{"formal_statement": "theorem image_eq_target_inter_inv_preimage {\u03b1 \u03b2 : Type*} [topological_space \u03b1]\n\t[topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) {s : set \u03b1} (h : s \u2286 e.to_local_equiv.source) :\n\t\u21d1e '' s = e.to_local_equiv.target \u2229 \u21d1(e.symm) \u207b\u00b9' s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) {s : set \u03b1}, s \u2286 e.to_local_equiv.source \u2192 \u21d1e '' s = e.to_local_equiv.target \u2229 \u21d1(e.symm) \u207b\u00b9' s", "decl_nm": "local_homeomorph.image_eq_target_inter_inv_preimage", "nl_statement_of_codex": "Let $e:U\\to V$ be a local homeomorphism. Then $e(U\\cap e^{-1}(V))=V$."}
{"formal_statement": "theorem left_inverse {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n\t(h : function.right_inverse g f) :\n\tfunction.left_inverse f g", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}, function.right_inverse g f \u2192 function.left_inverse f g", "decl_nm": "function.right_inverse.left_inverse", "nl_statement_of_codex": "If $g$ is a right inverse of $f$, then $f$ is a left inverse of $g$."}
{"formal_statement": "theorem is_integral_trans {R S T : Type*} [comm_ring R] [comm_ring S] [comm_ring T]\n\t(f : R \u2192+* S) (g : S \u2192+* T) (hf : f.is_integral) (hg : g.is_integral) :\n\t(g.comp f).is_integral", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_4} {T : Type u_5} [_inst_1 : comm_ring R] [_inst_4 : comm_ring S] [_inst_5 : comm_ring T] (f : R \u2192+* S) (g : S \u2192+* T), f.is_integral \u2192 g.is_integral \u2192 (g.comp f).is_integral", "decl_nm": "ring_hom.is_integral_trans", "nl_statement_of_codex": "Let $R, S, T$ be commutative rings and let $f:R\\to S$ and $g:S\\to T$ be ring homomorphisms. If $f$ and $g$ are integral, then so is $g\\circ f$."}
{"formal_statement": "theorem eq_of_eq_on_set_top {R : Type u} {S : Type v} [ring R] [ring S]\n\t{f g : R \u2192+* S} (h : set.eq_on \u21d1f \u21d1g \u2191\u22a4) :\n\tf = g", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : ring R] [_inst_2 : ring S] {f g : R \u2192+* S}, set.eq_on \u21d1f \u21d1g \u2191\u22a4 \u2192 f = g", "decl_nm": "ring_hom.eq_of_eq_on_set_top", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f,g:R\\to S$ be ring homomorphisms. If $f$ and $g$ agree on all of $R$, then $f=g$."}
{"formal_statement": "theorem not_is_left_regular_zero_iff {R : Type*} [mul_zero_class R] :\n\t\u00acis_left_regular 0 \u2194 nontrivial R", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : mul_zero_class R], \u00acis_left_regular 0 \u2194 nontrivial R", "decl_nm": "not_is_left_regular_zero_iff", "nl_statement_of_codex": "$0$ is not left regular if and only if $R$ is nontrivial."}
{"formal_statement": "theorem triangle_rotation_functor {C : Type u} [category_theory.category C]\n\t[category_theory.preadditive C] [category_theory.has_shift C \u2124] [\u2200 (n : \u2124), (category_theory.shift_functor C n).additive] :\n\tcategory_theory.triangulated.triangle_rotation.functor = category_theory.triangulated.rotate", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.has_shift C \u2124] [_inst_4 : \u2200 (n : \u2124), (category_theory.shift_functor C n).additive], category_theory.triangulated.triangle_rotation.functor = category_theory.triangulated.rotate", "decl_nm": "category_theory.triangulated.triangle_rotation_functor", "nl_statement_of_codex": "The triangle rotation functor is equal to the rotation functor."}
{"formal_statement": "theorem sup {\u03b1 : Type u} {\u03b2 : Type v} [semilattice_sup \u03b2] {f g : \u03b1 \u2192 \u03b2}\n\t{a : \u03b1} {l : filter \u03b1} (hf : is_min_filter f l a) (hg : is_min_filter g l a) :\n\tis_min_filter (\u03bb (x : \u03b1), f x \u2294 g x) l a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : semilattice_sup \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : filter \u03b1}, is_min_filter f l a \u2192 is_min_filter g l a \u2192 is_min_filter (\u03bb (x : \u03b1), f x \u2294 g x) l a", "decl_nm": "is_min_filter.sup", "nl_statement_of_codex": "Let $f,g:X\\to Y$ be functions from a set $X$ to a semilattice $Y$. Let $a\\in X$ and let $l$ be a filter on $X$. If $f$ and $g$ are minimal filters on $l$ at $a$, then $f\\vee g$ is a minimal filter on $l$ at $a$."}
{"formal_statement": "theorem dvd_eq_int (a b c : \u2124) (p : Prop) (h\u2081 : b % a = c) (h\u2082 : c = 0 = p) :\n\ta \u2223 b = p", "decl_tp": "\u2200 (a b c : \u2124) (p : Prop), b % a = c \u2192 c = 0 = p \u2192 a \u2223 b = p", "decl_nm": "norm_num.dvd_eq_int", "nl_statement_of_codex": "Let $a,b,c\\in\\mathbb{Z}$. Then $a\\mid b$ if and only if $b\\equiv c\\pmod{a}$ and $c=0$."}
{"formal_statement": "theorem mod_mul_left_mod (a b c : \u2115) :\n\ta % (b * c) % c = a % c", "decl_tp": "\u2200 (a b c : \u2115), a % (b * c) % c = a % c", "decl_nm": "nat.mod_mul_left_mod", "nl_statement_of_codex": "For all $a,b,c\\in\\mathbb{N}$, we have $a\\bmod(b\\cdot c)\\bmod c=a\\bmod c$."}
{"formal_statement": "theorem to_equiv_injective {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} :\n\tfunction.injective rel_iso.to_equiv", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}, function.injective rel_iso.to_equiv", "decl_nm": "rel_iso.to_equiv_injective", "nl_statement_of_codex": "The function $f: \\mathrm{Rel}(\\alpha)\\to \\mathrm{Rel}(\\beta)$ is injective."}
{"formal_statement": "theorem by_contradiction_trick (p : Prop) :\n\t(\u2200 (f : Prop), (p \u2192 f) \u2192 f) \u2192 p", "decl_tp": "\u2200 (p : Prop), (\u2200 (f : Prop), (p \u2192 f) \u2192 f) \u2192 p", "decl_nm": "auto.by_contradiction_trick", "nl_statement_of_codex": "If for any proposition $f$ we have that $p\\to f$ implies $f$, then $p$ is true."}
{"formal_statement": "theorem degrees_C {R : Type u} {\u03c3 : Type*} [comm_semiring R] (a : R) :\n\t(\u21d1mv_polynomial.C a).degrees = 0", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] (a : R), (\u21d1mv_polynomial.C a).degrees = 0", "decl_nm": "mv_polynomial.degrees_C", "nl_statement_of_codex": "The degree of the constant polynomial $a$ is $0$."}
{"formal_statement": "theorem nonempty_coe_sort {\u03b1 : Type*} (s : finset \u03b1) :\n\tnonempty \u21a5s \u2194 s.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : finset \u03b1), nonempty \u21a5s \u2194 s.nonempty", "decl_nm": "finset.nonempty_coe_sort", "nl_statement_of_codex": "A finite set $s$ is nonempty if and only if the set of its elements is nonempty."}
{"formal_statement": "theorem continuous_on_ceil {\u03b1 : Type*} [linear_ordered_ring \u03b1] [floor_ring \u03b1]\n\t[topological_space \u03b1] (n : \u2124) :\n\tcontinuous_on (\u03bb (x : \u03b1), \u2191\u2308x\u2309) (set.Ioc (\u2191n - 1) \u2191n)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_ring \u03b1] [_inst_2 : floor_ring \u03b1] [_inst_3 : topological_space \u03b1] (n : \u2124), continuous_on (\u03bb (x : \u03b1), \u2191\u2308x\u2309) (set.Ioc (\u2191n - 1) \u2191n)", "decl_nm": "continuous_on_ceil", "nl_statement_of_codex": "The function $x\\mapsto \\lceil x\\rceil$ is continuous on the interval $[n-1,n)$."}
{"formal_statement": "theorem smul_left_symm_apply {k : Type*} (M : Type*) [linear_ordered_field k]\n\t[ordered_add_comm_group M] [mul_action_with_zero k M] [ordered_smul k M]\n\t{c : k} (hc : 0 < c) (b : M) :\n\t\u21d1(rel_iso.symm (order_iso.smul_left M hc)) b = c\u207b\u00b9 \u2022 b", "decl_tp": "\u2200 {k : Type u_1} (M : Type u_2) [_inst_1 : linear_ordered_field k] [_inst_2 : ordered_add_comm_group M] [_inst_3 : mul_action_with_zero k M] [_inst_4 : ordered_smul k M] {c : k} (hc : 0 < c) (b : M), \u21d1(rel_iso.symm (order_iso.smul_left M hc)) b = c\u207b\u00b9 \u2022 b", "decl_nm": "order_iso.smul_left_symm_apply", "nl_statement_of_codex": "Let $M$ be an ordered vector space over a field $k$ and let $c\\in k$ be positive. Then the inverse of the map $x\\mapsto cx$ is given by $x\\mapsto c^{-1}x$."}
{"formal_statement": "theorem linear_proj_of_is_compl_comp_subtype {R : Type*} [ring R] {E : Type*}\n\t[add_comm_group E] [module R E] {p q : submodule R E} (h : is_compl p q) :\n\t(p.linear_proj_of_is_compl q h).comp p.subtype = linear_map.id", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R] {E : Type u_2} [_inst_2 : add_comm_group E] [_inst_3 : module R E] {p q : submodule R E} (h : is_compl p q), (p.linear_proj_of_is_compl q h).comp p.subtype = linear_map.id", "decl_nm": "submodule.linear_proj_of_is_compl_comp_subtype", "nl_statement_of_codex": "Let $R$ be a ring, $E$ an $R$-module, and $p,q$ submodules of $E$. If $p$ is a complement of $q$, then the projection $p\\to p$ is the identity map."}
{"formal_statement": "theorem continuous_on {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {s : set E} {c : nnreal} (hf : approximates_linear_on f f' s c) :\n\tcontinuous_on f s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {s : set E} {c : nnreal}, approximates_linear_on f f' s c \u2192 continuous_on f s", "decl_nm": "approximates_linear_on.continuous_on", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ and $f':E\\to L(E,F)$ be linear maps. If $f$ is approximated by $f'$ on a set $S$ with accuracy $c$, then $f$ is continuous on $S$."}
{"formal_statement": "theorem eq_mk\u2083_closed {\u03b1 : Type*} [partial_order \u03b1] (c : closure_operator \u03b1) :\n\tc = closure_operator.mk\u2083 \u21d1c c.closed _ _ _", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] (c : closure_operator \u03b1), c = closure_operator.mk\u2083 \u21d1c c.closed _ _ _", "decl_nm": "closure_operator.eq_mk\u2083_closed", "nl_statement_of_codex": "Let $c$ be a closure operator on a partial order $P$. Then $c$ is equal to the closure operator $c'$ defined by $c'(A)=\\bigcup\\{B\\subseteq P:B\\text{ is closed and }B\\subseteq A\\}$."}
{"formal_statement": "theorem mem_sphere_zero_iff_norm {E : Type*} [semi_normed_group E] {w : E}\n\t{r : \u211d} :\n\tw \u2208 metric.sphere 0 r \u2194 \u2225w\u2225 = r", "decl_tp": "\u2200 {E : Type u_3} [_inst_1 : semi_normed_group E] {w : E} {r : \u211d}, w \u2208 metric.sphere 0 r \u2194 \u2225w\u2225 = r", "decl_nm": "mem_sphere_zero_iff_norm", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $w\\in E$. Then $w$ is in the sphere of radius $r$ centered at $0$ if and only if $\\|w\\|=r$."}
{"formal_statement": "theorem complete_space_coe {\u03b1 : Type*} [uniform_space \u03b1] {s : set \u03b1} (hs : is_complete s) :\n\tcomplete_space \u21a5s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] {s : set \u03b1}, is_complete s \u2192 complete_space \u21a5s", "decl_nm": "is_complete.complete_space_coe", "nl_statement_of_codex": "Let $s$ be a complete subset of a uniform space $X$. Then $s$ is a complete uniform space."}
{"formal_statement": "theorem neg_sqrt_lt_of_sq_lt {x y : \u211d} (h : x ^ 2 < y) :\n\t-real.sqrt y < x", "decl_tp": "\u2200 {x y : \u211d}, x ^ 2 < y \u2192 -real.sqrt y < x", "decl_nm": "real.neg_sqrt_lt_of_sq_lt", "nl_statement_of_codex": "If $x^2<y$, then $-\\sqrt{y}<x$."}
{"formal_statement": "theorem smooth_on {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {f : M \u2192 M'} {s : set M} (hf : smooth I I' f) :\n\tsmooth_on I I' f s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] {f : M \u2192 M'} {s : set M}, smooth I I' f \u2192 smooth_on I I' f s", "decl_nm": "smooth.smooth_on", "nl_statement_of_codex": "Let $f:M\\to M'$ be a smooth map between manifolds with corners. Then $f$ is smooth on any subset $s$ of $M$."}
{"formal_statement": "theorem symm_symm {X : Type u} {Y : Type v} [topological_space X] [topological_space Y]\n\t{P : C(X, Y) \u2192 Prop} {f\u2080 f\u2081 : C(X, Y)} (F : f\u2080.homotopy_with f\u2081 P) :\n\tF.symm.symm = F", "decl_tp": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] {P : C(X, Y) \u2192 Prop} {f\u2080 f\u2081 : C(X, Y)} (F : f\u2080.homotopy_with f\u2081 P), F.symm.symm = F", "decl_nm": "continuous_map.homotopy_with.symm_symm", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $P$ be a property of continuous functions from $X$ to $Y$. Let $f_0, f_1:X\\to Y$ be continuous functions. If $f_0$ is homotopic to $f_1$ with respect to $P$, then the homotopy from $f_0$ to $f_1$ is equal to the homotopy from $f_1$ to $f_0$."}
{"formal_statement": "theorem coe_zero {\u03b1 : Type u} [has_zero \u03b1] :\n\t\u21910 = 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_zero \u03b1], \u21910 = 0", "decl_nm": "with_bot.coe_zero", "nl_statement_of_codex": "The coercion from a type with a zero to the type of natural numbers is the zero function."}
{"formal_statement": "theorem nodup_range' (s n : \u2115) :\n\t(list.range' s n).nodup", "decl_tp": "\u2200 (s n : \u2115), (list.range' s n).nodup", "decl_nm": "list.nodup_range'", "nl_statement_of_codex": "The list $[s, s+1, \\ldots, s+n-1]$ has no duplicates."}
{"formal_statement": "theorem image_add_right' {\u03b1 : Type*} {t : set \u03b1} {b : \u03b1} [add_group \u03b1] :\n\t(\u03bb (a : \u03b1), a + -b) '' t = (\u03bb (a : \u03b1), a + b) \u207b\u00b9' t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {t : set \u03b1} {b : \u03b1} [_inst_1 : add_group \u03b1], (\u03bb (a : \u03b1), a + -b) '' t = (\u03bb (a : \u03b1), a + b) \u207b\u00b9' t", "decl_nm": "set.image_add_right'", "nl_statement_of_codex": "Let $t$ be a subset of an additive group $G$. Then the image of $t$ under the map $a\\mapsto a-b$ is the preimage of $t$ under the map $a\\mapsto a+b$."}
{"formal_statement": "theorem vadd_coe {\u03b1 : Type u} [add_group \u03b1] (H : add_subgroup \u03b1) (a x : \u03b1) :\n\ta +\u1d65 \u2191x = \u2191(a + x)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] (H : add_subgroup \u03b1) (a x : \u03b1), a +\u1d65 \u2191x = \u2191(a + x)", "decl_nm": "add_action.quotient.vadd_coe", "nl_statement_of_codex": "Let $H$ be an additive subgroup of an additive group $G$. Then for all $a\\in G$ and $x\\in H$, $a+x\\in H$."}
{"formal_statement": "theorem div_right {G\u2080 : Type*} [group_with_zero G\u2080] {a b c : G\u2080} (hab : commute a b)\n\t(hac : commute a c) :\n\tcommute a (b / c)", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] {a b c : G\u2080}, commute a b \u2192 commute a c \u2192 commute a (b / c)", "decl_nm": "commute.div_right", "nl_statement_of_codex": "Let $G$ be a group with zero. Let $a, b, c\\in G$. If $a$ commutes with $b$ and $a$ commutes with $c$, then $a$ commutes with $b/c$."}
{"formal_statement": "theorem inf_dist_le_inf_dist_of_subset {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{s t : set \u03b1} {x : \u03b1} (h : s \u2286 t) (hs : s.nonempty) :\n\tmetric.inf_dist x t \u2264 metric.inf_dist x s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {s t : set \u03b1} {x : \u03b1}, s \u2286 t \u2192 s.nonempty \u2192 metric.inf_dist x t \u2264 metric.inf_dist x s", "decl_nm": "metric.inf_dist_le_inf_dist_of_subset", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $s,t\\subset X$. If $s\\subset t$ and $s$ is nonempty, then $\\inf_{x\\in t}d(x,s)\\leq \\inf_{x\\in s}d(x,s)$."}
{"formal_statement": "theorem eq {\u03b1 n : Type*} {A : matrix n n \u03b1} (h : A.is_symm) :\n\tA.transpose = A", "decl_tp": "\u2200 {\u03b1 : Type u_1} {n : Type u_3} {A : matrix n n \u03b1}, A.is_symm \u2192 A.transpose = A", "decl_nm": "matrix.is_symm.eq", "nl_statement_of_codex": "If $A$ is a symmetric matrix, then $A^T=A$."}
{"formal_statement": "theorem is_refl {R\u2081 M\u2081 : Type*} [ring R\u2081] [add_comm_group M\u2081] [module R\u2081 M\u2081]\n\t{B\u2081 : bilin_form R\u2081 M\u2081} (H : B\u2081.is_alt) :\n\tB\u2081.is_refl", "decl_tp": "\u2200 {R\u2081 : Type u_3} {M\u2081 : Type u_4} [_inst_4 : ring R\u2081] [_inst_5 : add_comm_group M\u2081] [_inst_6 : module R\u2081 M\u2081] {B\u2081 : bilin_form R\u2081 M\u2081}, B\u2081.is_alt \u2192 B\u2081.is_refl", "decl_nm": "bilin_form.is_alt.is_refl", "nl_statement_of_codex": "A bilinear form $B$ is reflexive if and only if it is alternating."}
{"formal_statement": "theorem hausdorff_measure_preimage {X Y : Type*} [emetric_space X] [emetric_space Y]\n\t[measurable_space X] [borel_space X] [measurable_space Y] [borel_space Y]\n\t{f : X \u2192 Y} {d : \u211d} (hf : isometry f) (hd : 0 \u2264 d \u2228 function.surjective f) :\n\t\u2200 (s : set Y), \u21d1(measure_theory.measure.hausdorff_measure d) (f \u207b\u00b9' s) = \u21d1(measure_theory.measure.hausdorff_measure d)\n\t(s \u2229 set.range f)", "decl_tp": "\u2200 {X : Type u_2} {Y : Type u_3} [_inst_1 : emetric_space X] [_inst_2 : emetric_space Y] [_inst_3 : measurable_space X] [_inst_4 : borel_space X] [_inst_5 : measurable_space Y] [_inst_6 : borel_space Y] {f : X \u2192 Y} {d : \u211d}, isometry f \u2192 0 \u2264 d \u2228 function.surjective f \u2192 \u2200 (s : set Y), \u21d1(measure_theory.measure.hausdorff_measure d) (f \u207b\u00b9' s) = \u21d1(measure_theory.measure.hausdorff_measure d) (s \u2229 set.range f)", "decl_nm": "isometry.hausdorff_measure_preimage", "nl_statement_of_codex": "Let $X$ and $Y$ be metric spaces, let $f:X\\to Y$ be an isometry, and let $d\\geq 0$. Then for any set $S\\subset Y$, the Hausdorff measure of $f^{-1}(S)$ is equal to the Hausdorff measure of $S\\cap f(X)$."}
{"formal_statement": "theorem one_mul_equiv (x : pgame) :\n\t(1 * x).equiv x", "decl_tp": "\u2200 (x : pgame), (1 * x).equiv x", "decl_nm": "pgame.one_mul_equiv", "nl_statement_of_codex": "The game $1*x$ is equivalent to the game $x$."}
{"formal_statement": "theorem not_first_loses_of_first_wins {G : pgame} :\n\tG.first_wins \u2192 \u00acG.first_loses", "decl_tp": "\u2200 {G : pgame}, G.first_wins \u2192 \u00acG.first_loses", "decl_nm": "pgame.not_first_loses_of_first_wins", "nl_statement_of_codex": "If the first player has a winning strategy in a game $G$, then the second player does not have a winning strategy in $G$."}
{"formal_statement": "theorem congr_right {\u03b1 \u03b2 \u03b3 : Type*} [primcodable \u03b1] [primcodable \u03b2] [primcodable \u03b3]\n\t{p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : one_one_equiv q r) :\n\t(one_one_equiv p q \u2194 one_one_equiv p r)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_3 : primcodable \u03b3] {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop}, one_one_equiv q r \u2192 (one_one_equiv p q \u2194 one_one_equiv p r)", "decl_nm": "one_one_equiv.congr_right", "nl_statement_of_codex": "Let $p, q, r$ be properties of types $\u03b1, \u03b2, \u03b3$ respectively. If $q$ and $r$ are equivalent, then $p$ and $q$ are equivalent if and only if $p$ and $r$ are equivalent."}
{"formal_statement": "theorem eq_or_edist_eq_top_of_fixed_points {\u03b1 : Type*} [emetric_space \u03b1]\n\t{K : nnreal} {f : \u03b1 \u2192 \u03b1} (hf : contracting_with K f) (hx : function.is_fixed_pt f x)\n\t(hy : function.is_fixed_pt f y) :\n\t\u2200 {x y : \u03b1},   x = y \u2228 has_edist.edist x y = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : emetric_space \u03b1] {K : nnreal} {f : \u03b1 \u2192 \u03b1}, contracting_with K f \u2192 \u2200 {x y : \u03b1}, function.is_fixed_pt f x \u2192 function.is_fixed_pt f y \u2192 x = y \u2228 has_edist.edist x y = \u22a4", "decl_nm": "contracting_with.eq_or_edist_eq_top_of_fixed_points", "nl_statement_of_codex": "Let $f:X\\to X$ be a contraction with constant $K$ and let $x,y\\in X$ be fixed points of $f$. Then $x=y$ or $d(x,y)=\\infty$."}
{"formal_statement": "theorem card_fintype_Ioo_of_lt (a b : \u2124) (h : a < b) :\n\t\u2191(fintype.card \u21a5(set.Ioo a b)) = b - a - 1", "decl_tp": "\u2200 (a b : \u2124), a < b \u2192 \u2191(fintype.card \u21a5(set.Ioo a b)) = b - a - 1", "decl_nm": "int.card_fintype_Ioo_of_lt", "nl_statement_of_codex": "If $a<b$, then the cardinality of the set $\\{a+1,a+2,\\ldots,b-1\\}$ is $b-a-1$."}
{"formal_statement": "theorem times_cont_diff_within_at_univ {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} {n : with_top \u2115} :\n\ttimes_cont_diff_within_at \ud835\udd5c n f set.univ x \u2194 times_cont_diff_at \ud835\udd5c n f x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} {n : with_top \u2115}, times_cont_diff_within_at \ud835\udd5c n f set.univ x \u2194 times_cont_diff_at \ud835\udd5c n f x", "decl_nm": "times_cont_diff_within_at_univ", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ and $x\\in E$. Then $f$ is $n$-times continuously differentiable at $x$ if and only if $f$ is $n$-times continuously differentiable at $x$ on $E$."}
{"formal_statement": "theorem trans {\u03b1 : Type*} {m : measurable_space \u03b1} {L M N : Type*} [add_comm_monoid L]\n\t[topological_space L] [add_comm_monoid M] [topological_space M] [add_comm_monoid N]\n\t[topological_space N] {v : measure_theory.vector_measure \u03b1 M} {w : measure_theory.vector_measure \u03b1 N}\n\t{u : measure_theory.vector_measure \u03b1 L} (huv : u.absolutely_continuous v)\n\t(hvw : v.absolutely_continuous w) :\n\tu.absolutely_continuous w", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {L : Type u_3} {M : Type u_4} {N : Type u_5} [_inst_1 : add_comm_monoid L] [_inst_2 : topological_space L] [_inst_3 : add_comm_monoid M] [_inst_4 : topological_space M] [_inst_5 : add_comm_monoid N] [_inst_6 : topological_space N] {v : measure_theory.vector_measure \u03b1 M} {w : measure_theory.vector_measure \u03b1 N} {u : measure_theory.vector_measure \u03b1 L}, u.absolutely_continuous v \u2192 v.absolutely_continuous w \u2192 u.absolutely_continuous w", "decl_nm": "measure_theory.vector_measure.absolutely_continuous.trans", "nl_statement_of_codex": "Let $m$ be a measure space, $L, M, N$ be topological abelian groups, $v$ be a vector measure from $m$ to $M$, $w$ be a vector measure from $m$ to $N$, and $u$ be a vector measure from $m$ to $L$. If $u$ is absolutely continuous with respect to $v$ and $v$ is absolutely continuous with respect to $w$, then $u$ is absolutely continuous with respect to $w$."}
{"formal_statement": "theorem coe_inv_le {r : nnreal} :\n\t\u2191r\u207b\u00b9 \u2264 (\u2191r)\u207b\u00b9", "decl_tp": "\u2200 {r : nnreal}, \u2191r\u207b\u00b9 \u2264 (\u2191r)\u207b\u00b9", "decl_nm": "ennreal.coe_inv_le", "nl_statement_of_codex": "The reciprocal of a nonnegative real number is less than or equal to the reciprocal of its image under the coe function."}
{"formal_statement": "theorem tan_nat_mul_pi (n : \u2115) :\n\tcomplex.tan (\u2191n * \u2191real.pi) = 0", "decl_tp": "\u2200 (n : \u2115), complex.tan (\u2191n * \u2191real.pi) = 0", "decl_nm": "complex.tan_nat_mul_pi", "nl_statement_of_codex": "$\\tan(n\\pi)=0$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem mem_at_bot_sets {\u03b1 : Type*} [nonempty \u03b1] [semilattice_inf \u03b1] {s : set \u03b1} :\n\ts \u2208 filter.at_bot \u2194 \u2203 (a : \u03b1), \u2200 (b : \u03b1), b \u2264 a \u2192 b \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_3} [_inst_1 : nonempty \u03b1] [_inst_2 : semilattice_inf \u03b1] {s : set \u03b1}, s \u2208 filter.at_bot \u2194 \u2203 (a : \u03b1), \u2200 (b : \u03b1), b \u2264 a \u2192 b \u2208 s", "decl_nm": "filter.mem_at_bot_sets", "nl_statement_of_codex": "A set $s$ is in the filter at the bottom if and only if there is an element $a$ such that $s$ contains all elements less than or equal to $a$."}
{"formal_statement": "theorem preimage_of_open_map {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t[topological_space \u03b2] {s : set \u03b2} (hs : is_connected s) (hinj : function.injective f)\n\t(hf : is_open_map f) (hsf : s \u2286 set.range f) :\n\t\u2200 {f : \u03b1 \u2192 \u03b2},    is_connected (f \u207b\u00b9' s)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {s : set \u03b2}, is_connected s \u2192 \u2200 {f : \u03b1 \u2192 \u03b2}, function.injective f \u2192 is_open_map f \u2192 s \u2286 set.range f \u2192 is_connected (f \u207b\u00b9' s)", "decl_nm": "is_connected.preimage_of_open_map", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous, injective map. If $Y$ is connected and $f$ is an open map, then $X$ is connected."}
{"formal_statement": "theorem div_lt_iff {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b c : \u03b1} (hc : 0 < c) :\n\t(b / c < a \u2194 b < a * c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b c : \u03b1}, 0 < c \u2192 (b / c < a \u2194 b < a * c)", "decl_nm": "div_lt_iff", "nl_statement_of_codex": "Let $a,b,c$ be real numbers such that $c>0$. Then $b/c<a$ if and only if $b<ac$."}
{"formal_statement": "theorem mul_inv_cancel {G : Type*} [group G] {a b : G} (h : commute a b) :\n\ta * b * a\u207b\u00b9 = b", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {a b : G}, commute a b \u2192 a * b * a\u207b\u00b9 = b", "decl_nm": "commute.mul_inv_cancel", "nl_statement_of_codex": "Let $G$ be a group and let $a, b\\in G$. If $a$ and $b$ commute, then $a*b*a^{-1}=b$."}
{"formal_statement": "theorem add_smul {R : Type u} {M : Type w} [semiring R] [add_comm_monoid M]\n\t[module R M] (r s : R) (x : M) :\n\t(r + s) \u2022 x = r \u2022 x + s \u2022 x", "decl_tp": "\u2200 {R : Type u} {M : Type w} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] (r s : R) (x : M), (r + s) \u2022 x = r \u2022 x + s \u2022 x", "decl_nm": "add_smul", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module. Then $(r+s)x=rx+sx$ for all $r,s\\in R$ and $x\\in M$."}
{"formal_statement": "theorem mul_inv_lt_iff' {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b c : \u03b1}\n\t(h : 0 < b) :\n\t(a * b\u207b\u00b9 < c \u2194 a < c * b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b c : \u03b1}, 0 < b \u2192 (a * b\u207b\u00b9 < c \u2194 a < c * b)", "decl_nm": "mul_inv_lt_iff'", "nl_statement_of_codex": "Let $a, b, c$ be real numbers. If $b>0$, then $a/b<c$ if and only if $a<bc$."}
{"formal_statement": "theorem ff_eq_to_bool_iff {p : Prop} [decidable p] :\n\tbool.ff = decidable.to_bool p \u2194 \u00acp", "decl_tp": "\u2200 {p : Prop} [_inst_1 : decidable p], bool.ff = decidable.to_bool p \u2194 \u00acp", "decl_nm": "bool.ff_eq_to_bool_iff", "nl_statement_of_codex": "The proposition $p$ is false if and only if $p$ is not true."}
{"formal_statement": "theorem complete_of_cauchy_seq_tendsto {\u03b1 : Type u} [pseudo_emetric_space \u03b1] :\n\t(\u2200 (u : \u2115 \u2192 \u03b1), cauchy_seq u \u2192 (\u2203 (a : \u03b1), filter.tendsto u filter.at_top (nhds a))) \u2192 complete_space \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1], (\u2200 (u : \u2115 \u2192 \u03b1), cauchy_seq u \u2192 (\u2203 (a : \u03b1), filter.tendsto u filter.at_top (nhds a))) \u2192 complete_space \u03b1", "decl_nm": "emetric.complete_of_cauchy_seq_tendsto", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. If every Cauchy sequence in $X$ converges, then $X$ is complete."}
{"formal_statement": "theorem augment_X_zero {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t(C : cochain_complex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0) :\n\t(C.augment f w).X 0 = X", "decl_tp": "\u2200 {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] (C : cochain_complex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0), (C.augment f w).X 0 = X", "decl_nm": "cochain_complex.augment_X_zero", "nl_statement_of_codex": "Let $C$ be a cochain complex in a category $V$ with zero morphisms. Let $X$ be an object of $V$ and let $f:X\\to C_0$ be a morphism. If $f$ is a cocycle, then the augmented complex $C^+$ has $C^+_0=X$."}
{"formal_statement": "theorem trans {\u03b1 \u03b2 \u03b3 : Type*} [primcodable \u03b1] [primcodable \u03b2] [primcodable \u03b3]\n\t{p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (\u1fb0 : one_one_equiv p q) (\u1fb0 : one_one_equiv q r) :\n\tone_one_equiv p r", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_3 : primcodable \u03b3] {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop}, one_one_equiv p q \u2192 one_one_equiv q r \u2192 one_one_equiv p r", "decl_nm": "one_one_equiv.trans", "nl_statement_of_codex": "Let $p, q, r$ be properties of types $\u03b1, \u03b2, \u03b3$ respectively. If $p$ and $q$ are one-to-one equivalent and $q$ and $r$ are one-to-one equivalent, then $p$ and $r$ are one-to-one equivalent."}
{"formal_statement": "theorem coe_comp {M N P : Type*} [mul_zero_one_class M] [mul_zero_one_class N]\n\t[mul_zero_one_class P] (g : monoid_with_zero_hom N P) (f : monoid_with_zero_hom M N) :\n\t\u21d1(g.comp f) = \u21d1g \u2218 \u21d1f", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {P : Type u_3} [_inst_1 : mul_zero_one_class M] [_inst_2 : mul_zero_one_class N] [_inst_3 : mul_zero_one_class P] (g : monoid_with_zero_hom N P) (f : monoid_with_zero_hom M N), \u21d1(g.comp f) = \u21d1g \u2218 \u21d1f", "decl_nm": "monoid_with_zero_hom.coe_comp", "nl_statement_of_codex": "Let $M, N, P$ be monoids with zero. Let $f:M\\to N$ and $g:N\\to P$ be monoid homomorphisms. Then the composition $g\\circ f$ is a monoid homomorphism from $M$ to $P$ and $(g\\circ f)^*=g^*\\circ f^*$."}
{"formal_statement": "theorem dense_range_coe {X : Type*} [topological_space X] [noncompact_space X] :\n\tdense_range coe", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] [_inst_2 : noncompact_space X], dense_range coe", "decl_nm": "alexandroff.dense_range_coe", "nl_statement_of_codex": "The range of the function $f:X\\to\\mathbb{R}$ defined by $f(x)=x$ is dense in $\\mathbb{R}$."}
{"formal_statement": "theorem chain_of_chain_map {\u03b1 : Type u} {\u03b2 : Type v} {R : \u03b1 \u2192 \u03b1 \u2192 Prop}\n\t{S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (p : list.chain S (f a) (list.map f l)) :\n\t(\u2200 (a b : \u03b1), S (f a) (f b) \u2192 R a b) \u2192 \u2200 {a : \u03b1} {l : list \u03b1},  list.chain R a l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2), (\u2200 (a b : \u03b1), S (f a) (f b) \u2192 R a b) \u2192 \u2200 {a : \u03b1} {l : list \u03b1}, list.chain S (f a) (list.map f l) \u2192 list.chain R a l", "decl_nm": "list.chain_of_chain_map", "nl_statement_of_codex": "Let $f:A\\to B$ be a function between partially ordered sets. If $f$ is a chain map, then $f$ preserves chains."}
{"formal_statement": "theorem restrict_scalars_bot (R : Type*) {S M : Type*} [semiring R] [semiring S]\n\t[add_comm_monoid M] [module R M] [module S M] [has_scalar S R] [is_scalar_tower S R M] :\n\tsubmodule.restrict_scalars S \u22a5 = \u22a5", "decl_tp": "\u2200 (R : Type u_1) {S : Type u_2} {M : Type u_3} [_inst_1 : semiring R] [_inst_2 : semiring S] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M] [_inst_5 : module S M] [_inst_6 : has_scalar S R] [_inst_7 : is_scalar_tower S R M], submodule.restrict_scalars S \u22a5 = \u22a5", "decl_nm": "submodule.restrict_scalars_bot", "nl_statement_of_codex": "Let $R$ be a semiring, $S$ a subsemiring of $R$, and $M$ an $R$-module. Then the restriction of scalars of $M$ from $R$ to $S$ is the zero submodule of $M$."}
{"formal_statement": "theorem pow {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {s : set \ud835\udd5c}\n\t{c : \ud835\udd5c \u2192 \ud835\udd5c} {n : \u2115} (hc : differentiable_within_at \ud835\udd5c c s x) :\n\tdifferentiable_within_at \ud835\udd5c (\u03bb (x : \ud835\udd5c), c x ^ n) s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {x : \ud835\udd5c} {s : set \ud835\udd5c} {c : \ud835\udd5c \u2192 \ud835\udd5c} {n : \u2115}, differentiable_within_at \ud835\udd5c c s x \u2192 differentiable_within_at \ud835\udd5c (\u03bb (x : \ud835\udd5c), c x ^ n) s x", "decl_nm": "differentiable_within_at.pow", "nl_statement_of_codex": "Let $c:S\\to\\mathbb{K}$ be a differentiable function on a set $S\\subset\\mathbb{K}$. Then the function $x\\mapsto c(x)^n$ is differentiable on $S$."}
{"formal_statement": "theorem tsum_top {\u03b1 : Type*} [nonempty \u03b1] :\n\t\u2211' (a : \u03b1), \u22a4 = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : nonempty \u03b1], \u2211' (a : \u03b1), \u22a4 = \u22a4", "decl_nm": "ennreal.tsum_top", "nl_statement_of_codex": "The sum of the top element over a nonempty type is the top element."}
{"formal_statement": "theorem coe_lift_right {M N : Type*} [monoid M] [monoid N] (f : M \u2192* N)\n\t(hf : \u2200 (x : M), is_unit (\u21d1f x)) (x : M) :\n\t\u2191(\u21d1(is_unit.lift_right f hf) x) = \u21d1f x", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : monoid M] [_inst_2 : monoid N] (f : M \u2192* N) (hf : \u2200 (x : M), is_unit (\u21d1f x)) (x : M), \u2191(\u21d1(is_unit.lift_right f hf) x) = \u21d1f x", "decl_nm": "is_unit.coe_lift_right", "nl_statement_of_codex": "Let $M$ and $N$ be monoids and let $f:M\\to N$ be a monoid homomorphism. If $f$ is surjective, then the map $g:M\\to N$ defined by $g(x)=f(x)^{-1}f(x)$ is a monoid homomorphism."}
{"formal_statement": "theorem symm_diff_eq {\u03b1 : Type*} [boolean_algebra \u03b1] (a b : \u03b1) :\n\ta \u0394 b = a \u2293 b\u1d9c \u2294 b \u2293 a\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : boolean_algebra \u03b1] (a b : \u03b1), a \u0394 b = a \u2293 b\u1d9c \u2294 b \u2293 a\u1d9c", "decl_nm": "symm_diff_eq", "nl_statement_of_codex": "The symmetric difference of two elements $a$ and $b$ of a boolean algebra is equal to the union of the intersection of $a$ and the complement of $b$ with the intersection of $b$ and the complement of $a$."}
{"formal_statement": "theorem exp {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u211d} {x : \u03b1} (h : continuous_at f x) :\n\tcontinuous_at (\u03bb (y : \u03b1), real.exp (f y)) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u211d} {x : \u03b1}, continuous_at f x \u2192 continuous_at (\u03bb (y : \u03b1), real.exp (f y)) x", "decl_nm": "continuous_at.exp", "nl_statement_of_codex": "Let $f:X\\to\\mathbb{R}$ be a continuous function. Then the function $g:X\\to\\mathbb{R}$ defined by $g(x)=e^{f(x)}$ is continuous."}
{"formal_statement": "theorem deriv_circle_map_ne_zero {c : \u2102} {R \u03b8 : \u211d} (hR : R \u2260 0) :\n\tderiv (circle_map c R) \u03b8 \u2260 0", "decl_tp": "\u2200 {c : \u2102} {R \u03b8 : \u211d}, R \u2260 0 \u2192 deriv (circle_map c R) \u03b8 \u2260 0", "decl_nm": "deriv_circle_map_ne_zero", "nl_statement_of_codex": "The derivative of the circle map $z\\mapsto c+Re^{i\\theta}$ is nonzero."}
{"formal_statement": "theorem vadd {M \u03b1 \u03b2 : Type*} [topological_space M] [topological_space \u03b1]\n\t[has_vadd M \u03b1] [has_continuous_vadd M \u03b1] [topological_space \u03b2] {f : \u03b2 \u2192 M}\n\t{g : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : set \u03b2} (hf : continuous_within_at f s b) (hg : continuous_within_at g s b) :\n\tcontinuous_within_at (\u03bb (x : \u03b2), f x +\u1d65 g x) s b", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_2} {\u03b2 : Type u_3} [_inst_1 : topological_space M] [_inst_2 : topological_space \u03b1] [_inst_3 : has_vadd M \u03b1] [_inst_4 : has_continuous_vadd M \u03b1] [_inst_5 : topological_space \u03b2] {f : \u03b2 \u2192 M} {g : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : set \u03b2}, continuous_within_at f s b \u2192 continuous_within_at g s b \u2192 continuous_within_at (\u03bb (x : \u03b2), f x +\u1d65 g x) s b", "decl_nm": "continuous_within_at.vadd", "nl_statement_of_codex": "Let $M$ be a topological space, let $\u03b1$ and $\u03b2$ be topological spaces, and let $f:\u03b2\\to M$ and $g:\u03b2\\to \u03b1$.\nIf $f$ and $g$ are continuous at $b$, then $f+g$ is continuous at $b$."}
{"formal_statement": "theorem le_iff_specializes {R : Type u} [comm_ring R] (x y : prime_spectrum R) :\n\tx \u2264 y \u2194 x \u2933 y", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] (x y : prime_spectrum R), x \u2264 y \u2194 x \u2933 y", "decl_nm": "prime_spectrum.le_iff_specializes", "nl_statement_of_codex": "Let $R$ be a commutative ring. Then $x\\leq y$ if and only if $x$ specializes to $y$."}
{"formal_statement": "theorem piecewise_mem_Icc {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), preorder (\u03b1 i)]\n\t{s : set \u03b9} [\u03a0 (j : \u03b9), decidable (j \u2208 s)] {f\u2081 f\u2082 g\u2081 g\u2082 : \u03a0 (i : \u03b9), \u03b1 i} :\n\t(\u2200 (i : \u03b9), i \u2208 s \u2192 f\u2081 i \u2208 set.Icc (g\u2081 i) (g\u2082 i)) \u2192 (\u2200 (i : \u03b9), i \u2209 s \u2192 f\u2082 i \u2208 set.Icc (g\u2081 i)\n\t(g\u2082 i)) \u2192 s.piecewise f\u2081 f\u2082 \u2208 set.Icc g\u2081 g\u2082", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), preorder (\u03b1 i)] {s : set \u03b9} [_inst_2 : \u03a0 (j : \u03b9), decidable (j \u2208 s)] {f\u2081 f\u2082 g\u2081 g\u2082 : \u03a0 (i : \u03b9), \u03b1 i}, (\u2200 (i : \u03b9), i \u2208 s \u2192 f\u2081 i \u2208 set.Icc (g\u2081 i) (g\u2082 i)) \u2192 (\u2200 (i : \u03b9), i \u2209 s \u2192 f\u2082 i \u2208 set.Icc (g\u2081 i) (g\u2082 i)) \u2192 s.piecewise f\u2081 f\u2082 \u2208 set.Icc g\u2081 g\u2082", "decl_nm": "set.piecewise_mem_Icc", "nl_statement_of_codex": "Let $s$ be a set and let $f_1, f_2, g_1, g_2:s\\to\\mathbb{R}$. Suppose that $f_1(i)\\in[g_1(i),g_2(i)]$ for all $i\\in s$ and that $f_2(i)\\in[g_1(i),g_2(i)]$ for all $i\\notin s$. Then $f_1(i)$ for $i\\in s$ and $f_2(i)$ for $i\\notin s$ is in $[g_1(i),g_2(i"}
{"formal_statement": "theorem cyclic_left {\u03b1 : Type*} [circular_preorder \u03b1] {a b c : \u03b1} (h : has_btw.btw a b c) :\n\thas_btw.btw b c a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : circular_preorder \u03b1] {a b c : \u03b1}, has_btw.btw a b c \u2192 has_btw.btw b c a", "decl_nm": "has_btw.btw.cyclic_left", "nl_statement_of_codex": "Let $a,b,c$ be elements of a circular preorder. If $a$ is between $b$ and $c$, then $b$ is between $c$ and $a$."}
{"formal_statement": "theorem nodup_iff_le {\u03b1 : Type*} {s : multiset \u03b1} :\n\ts.nodup \u2194 \u2200 (a : \u03b1), \u00aca ::\u2098 a ::\u2098 0 \u2264 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : multiset \u03b1}, s.nodup \u2194 \u2200 (a : \u03b1), \u00aca ::\u2098 a ::\u2098 0 \u2264 s", "decl_nm": "multiset.nodup_iff_le", "nl_statement_of_codex": "A multiset $s$ has no duplicates if and only if $a\\not\\leq s$ for all $a\\in s$."}
{"formal_statement": "theorem preimage_eq_iff_eq_image {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) (s : set \u03b2)\n\t(t : set \u03b1) :\n\t\u21d1e \u207b\u00b9' s = t \u2194 s = \u21d1e '' t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : \u03b1 \u2243 \u03b2) (s : set \u03b2) (t : set \u03b1), \u21d1e \u207b\u00b9' s = t \u2194 s = \u21d1e '' t", "decl_nm": "equiv.preimage_eq_iff_eq_image", "nl_statement_of_codex": "Let $e:A\\to B$ be a bijection. Then $e^{-1}(s)=t$ if and only if $e(t)=s$."}
{"formal_statement": "theorem factors_chain_2 (n : \u2115) :\n\tlist.chain has_le.le 2 n.factors", "decl_tp": "\u2200 (n : \u2115), list.chain has_le.le 2 n.factors", "decl_nm": "nat.factors_chain_2", "nl_statement_of_codex": "The list of prime factors of $n$ is a chain with respect to the divisibility relation."}
{"formal_statement": "theorem mker_zero {M N : Type*} [add_zero_class M] [add_zero_class N] :\n\t0.mker = \u22a4", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N], 0.mker = \u22a4", "decl_nm": "add_monoid_hom.mker_zero", "nl_statement_of_codex": "The kernel of the zero map is the whole space."}
{"formal_statement": "theorem tsub_mul {\u03b1 : Type u} [canonically_ordered_comm_semiring \u03b1] [has_sub \u03b1]\n\t[has_ordered_sub \u03b1] [is_total \u03b1 has_le.le] [contravariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t(a b c : \u03b1) :\n\t(a - b) * c = a * c - b * c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : canonically_ordered_comm_semiring \u03b1] [_inst_2 : has_sub \u03b1] [_inst_3 : has_ordered_sub \u03b1] [_inst_4 : is_total \u03b1 has_le.le] [_inst_5 : contravariant_class \u03b1 \u03b1 has_add.add has_le.le] (a b c : \u03b1), (a - b) * c = a * c - b * c", "decl_nm": "tsub_mul", "nl_statement_of_codex": "Let $R$ be a commutative ring with unity. Then $(a-b)c=ac-bc$ for all $a,b,c\\in R$."}
{"formal_statement": "theorem sqrt {\u03b1 : Type*} [measurable_space \u03b1] {f : \u03b1 \u2192 \u211d} (hf : measurable f) :\n\tmeasurable (\u03bb (x : \u03b1), real.sqrt (f x))", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {f : \u03b1 \u2192 \u211d}, measurable f \u2192 measurable (\u03bb (x : \u03b1), real.sqrt (f x))", "decl_nm": "measurable.sqrt", "nl_statement_of_codex": "The square root of a measurable function is measurable."}
{"formal_statement": "theorem pow_e_pf_exp {\u03b1 : Type u} [comm_semiring \u03b1] {pps p : \u03b1} {ps qs psqs : \u2115}\n\t(pps_pf : pps = p ^ ps) (psqs_pf : ps * qs = psqs) :\n\tpps ^ qs = p ^ psqs", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : comm_semiring \u03b1] {pps p : \u03b1} {ps qs psqs : \u2115}, pps = p ^ ps \u2192 ps * qs = psqs \u2192 pps ^ qs = p ^ psqs", "decl_nm": "tactic.ring_exp.pow_e_pf_exp", "nl_statement_of_codex": "Let $p$ be a prime number and let $ps, qs, psqs$ be natural numbers. Then $p^{ps}q^s=p^{psqs}$."}
{"formal_statement": "theorem at_bot_eq (\u03b1 : Type*) [partial_order \u03b1] [order_bot \u03b1] :\n\tfilter.at_bot = has_pure.pure \u22a5", "decl_tp": "\u2200 (\u03b1 : Type u_1) [_inst_1 : partial_order \u03b1] [_inst_2 : order_bot \u03b1], filter.at_bot = has_pure.pure \u22a5", "decl_nm": "filter.order_bot.at_bot_eq", "nl_statement_of_codex": "The filter at the bottom of a poset is the filter generated by the bottom element."}
{"formal_statement": "theorem zeroth_denominator_eq_one {K : Type*} {g : generalized_continued_fraction K}\n\t[division_ring K] :\n\tg.denominators 0 = 1", "decl_tp": "\u2200 {K : Type u_1} {g : generalized_continued_fraction K} [_inst_1 : division_ring K], g.denominators 0 = 1", "decl_nm": "generalized_continued_fraction.zeroth_denominator_eq_one", "nl_statement_of_codex": "The denominator of the zeroth convergent of a generalized continued fraction is 1."}
{"formal_statement": "theorem nat_cast_injective :\n\tfunction.injective coe", "decl_tp": "function.injective coe", "decl_nm": "cardinal.nat_cast_injective", "nl_statement_of_codex": "The function $\\mathbb{N}\\to\\mathbb{Z}$ given by $n\\mapsto n$ is injective."}
{"formal_statement": "theorem ae_lt_of_ess_sup_lt {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[complete_linear_order \u03b2] {f : \u03b1 \u2192 \u03b2} {x : \u03b2} (hf : ess_sup f \u03bc < x) :\n\t(\u2200\u1d50 (y : \u03b1) \u2202\u03bc, f y < x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : complete_linear_order \u03b2] {f : \u03b1 \u2192 \u03b2} {x : \u03b2}, ess_sup f \u03bc < x \u2192 (\u2200\u1d50 (y : \u03b1) \u2202\u03bc, f y < x)", "decl_nm": "ae_lt_of_ess_sup_lt", "nl_statement_of_codex": "Let $f:X\\to\\mathbb{R}$ be a measurable function on a measure space $(X,\\mathcal{A},\\mu)$. If $\\sup_{\\mu}f<x$, then $f<x$ almost everywhere."}
{"formal_statement": "theorem iff_well_founded_associates {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1] :\n\twf_dvd_monoid \u03b1 \u2194 well_founded has_lt.lt", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1], wf_dvd_monoid \u03b1 \u2194 well_founded has_lt.lt", "decl_nm": "wf_dvd_monoid.iff_well_founded_associates", "nl_statement_of_codex": "The relation $a\\lt b$ is well-founded if and only if the relation $a\\mid b$ is well-founded."}
{"formal_statement": "theorem to_local_equiv_target {\u03b1 \u03b2 : Type*} [nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) (s : set \u03b1)\n\t(t : set \u03b2) (hf : set.bij_on f s t) :\n\t(set.bij_on.to_local_equiv f s t hf).target = t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) (s : set \u03b1) (t : set \u03b2) (hf : set.bij_on f s t), (set.bij_on.to_local_equiv f s t hf).target = t", "decl_nm": "set.bij_on.to_local_equiv_target", "nl_statement_of_codex": "Let $f:A\\to B$ be a bijection between $A$ and $B$. Then the target of the local homeomorphism $f:A\\to B$ is $B$."}
{"formal_statement": "theorem conj_zero {d : \u2124} :\n\t0.conj = 0", "decl_tp": "\u2200 {d : \u2124}, 0.conj = 0", "decl_nm": "zsqrtd.conj_zero", "nl_statement_of_codex": "The conjugate of $0$ is $0$."}
{"formal_statement": "theorem is_bounded_bilinear_map_deriv_coe {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {G : Type*} [normed_group G] [normed_space \ud835\udd5c G] {f : E \u00d7 F \u2192 G}\n\t(h : is_bounded_bilinear_map \ud835\udd5c f) (p q : E \u00d7 F) :\n\t\u21d1(h.deriv p) q = f (p.fst, q.snd) + f (q.fst, p.snd)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {f : E \u00d7 F \u2192 G} (h : is_bounded_bilinear_map \ud835\udd5c f) (p q : E \u00d7 F), \u21d1(h.deriv p) q = f (p.fst, q.snd) + f (q.fst, p.snd)", "decl_nm": "is_bounded_bilinear_map_deriv_coe", "nl_statement_of_codex": "Let $E, F, G$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\times F\\to G$ be a bounded bilinear map. Then the derivative of $f$ at $(p,q)$ is given by $f(p_1,q_2)+f(q_1,p_2)$."}
{"formal_statement": "theorem isometry_subsingleton {\u03b1 : Type u} {\u03b2 : Type v} [pseudo_emetric_space \u03b1]\n\t[pseudo_emetric_space \u03b2] {f : \u03b1 \u2192 \u03b2} [subsingleton \u03b1] :\n\tisometry f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {f : \u03b1 \u2192 \u03b2} [_inst_4 : subsingleton \u03b1], isometry f", "decl_nm": "isometry_subsingleton", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between pseudo-metric spaces. If $X$ is a singleton, then $f$ is an isometry."}
{"formal_statement": "theorem map_neighbor_set_apply_coe {V : Type u} {W : Type v} {G : simple_graph V}\n\t{G' : simple_graph W} (f : G \u21aag G') (v : V) (w : \u21a5(G.neighbor_set v)) :\n\t\u2191(\u21d1(f.map_neighbor_set v) w) = \u21d1f \u2191w", "decl_tp": "\u2200 {V : Type u} {W : Type v} {G : simple_graph V} {G' : simple_graph W} (f : G \u21aag G') (v : V) (w : \u21a5(G.neighbor_set v)), \u2191(\u21d1(f.map_neighbor_set v) w) = \u21d1f \u2191w", "decl_nm": "simple_graph.embedding.map_neighbor_set_apply_coe", "nl_statement_of_codex": "Let $G$ and $G'$ be simple graphs and let $f:G\\to G'$ be a graph homomorphism. Let $v$ be a vertex of $G$ and let $w$ be a neighbor of $v$ in $G$. Then $f(w)$ is a neighbor of $f(v)$ in $G'$."}
{"formal_statement": "theorem lt_neg_iff_add_neg' {\u03b1 : Type u} [add_group \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_lt.lt]\n\t{a b : \u03b1} :\n\ta < -b \u2194 b + a < 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_lt.lt] {a b : \u03b1}, a < -b \u2194 b + a < 0", "decl_nm": "lt_neg_iff_add_neg'", "nl_statement_of_codex": "Let $a, b$ be elements of an additive group $G$ with a total order. Then $a<-b$ if and only if $b+a<0$."}
{"formal_statement": "theorem is_closed_of_closure_subset {\u03b1 : Type u} [topological_space \u03b1]\n\t{s : set \u03b1} (h : closure s \u2286 s) :\n\tis_closed s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, closure s \u2286 s \u2192 is_closed s", "decl_nm": "is_closed_of_closure_subset", "nl_statement_of_codex": "Let $X$ be a topological space and let $A$ be a subset of $X$. If $A$ contains the closure of $A$, then $A$ is closed."}
{"formal_statement": "theorem is_O_cofinite_iff {\u03b1 E' F' : Type*} [normed_group E'] [normed_group F']\n\t{f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} :\n\t(\u2200 (x : \u03b1), g' x = 0 \u2192 f' x = 0) \u2192 (asymptotics.is_O f' g' filter.cofinite \u2194 \u2203 (C : \u211d), \u2200 (x : \u03b1), \u2225f' x\u2225 \u2264 C * \u2225g' x\u2225)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E' : Type u_6} {F' : Type u_7} [_inst_4 : normed_group E'] [_inst_5 : normed_group F'] {f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'}, (\u2200 (x : \u03b1), g' x = 0 \u2192 f' x = 0) \u2192 (asymptotics.is_O f' g' filter.cofinite \u2194 \u2203 (C : \u211d), \u2200 (x : \u03b1), \u2225f' x\u2225 \u2264 C * \u2225g' x\u2225)", "decl_nm": "asymptotics.is_O_cofinite_iff", "nl_statement_of_codex": "Let $E'$ and $F'$ be normed groups and let $f', g': \\alpha\\to E'$ be functions. If $g'(x)=0$ implies $f'(x)=0$, then $f'$ is $O(g')$ on the cofinite filter if and only if there is a constant $C$ such that $\\|f'(x)\\|\\leq C\\|g'(x)\\|$ for all $x\\in\\alpha$."}
{"formal_statement": "theorem count_cons_self {\u03b1 : Type*} [decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1) :\n\tlist.count a (a :: l) = (list.count a l).succ", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (l : list \u03b1), list.count a (a :: l) = (list.count a l).succ", "decl_nm": "list.count_cons_self", "nl_statement_of_codex": "Let $a$ be an element of a list $l$. Then the number of occurrences of $a$ in the list $a::l$ is one more than the number of occurrences of $a$ in $l$."}
{"formal_statement": "theorem neg_coe_set {G : Type*} [add_group G] (H : add_subgroup G) :\n\t-\u2191H = \u2191H", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] (H : add_subgroup G), -\u2191H = \u2191H", "decl_nm": "add_subgroup.neg_coe_set", "nl_statement_of_codex": "The negative of a subgroup is the same as the subgroup."}
{"formal_statement": "theorem comp_to_ring_hom {R : Type u} {A : Type v} {B : Type w} {C : Type u\u2081}\n\t[comm_semiring R] [semiring A] [semiring B] [semiring C] [algebra R A]\n\t[algebra R B] [algebra R C] (\u03c6\u2081 : B \u2192\u2090[R] C) (\u03c6\u2082 : A \u2192\u2090[R] B) :\n\t\u21d1\u2191(\u03c6\u2081.comp \u03c6\u2082) = \u21d1(\u2191\u03c6\u2081.comp \u2191\u03c6\u2082)", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} {C : Type u\u2081} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : semiring B] [_inst_4 : semiring C] [_inst_6 : algebra R A] [_inst_7 : algebra R B] [_inst_8 : algebra R C] (\u03c6\u2081 : B \u2192\u2090[R] C) (\u03c6\u2082 : A \u2192\u2090[R] B), \u21d1\u2191(\u03c6\u2081.comp \u03c6\u2082) = \u21d1(\u2191\u03c6\u2081.comp \u2191\u03c6\u2082)", "decl_nm": "alg_hom.comp_to_ring_hom", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A, B, C$ be $R$-algebras. Then the map $\u03c6_1\\circ \u03c6_2:A\\to C$ is an $R$-algebra homomorphism."}
{"formal_statement": "theorem summable_coe_of_nonneg {\u03b1 : Type*} {f : \u03b1 \u2192 \u211d} (hf\u2081 : \u2200 (n : \u03b1), 0 \u2264 f n) :\n\tsummable (\u03bb (n : \u03b1), \u27e8f n, _\u27e9) \u2194 summable f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u211d} (hf\u2081 : \u2200 (n : \u03b1), 0 \u2264 f n), summable (\u03bb (n : \u03b1), \u27e8f n, _\u27e9) \u2194 summable f", "decl_nm": "nnreal.summable_coe_of_nonneg", "nl_statement_of_codex": "If $f:\\alpha\\to\\mathbb{R}$ is nonnegative, then $f$ is summable if and only if $\\sum_{n\\in\\alpha}f(n)$ is finite."}
{"formal_statement": "theorem nat_abs_inj_of_nonpos_of_nonneg {a b : \u2124} (ha : a \u2264 0) (hb : 0 \u2264 b) :\n\t(a.nat_abs = b.nat_abs \u2194 -a = b)", "decl_tp": "\u2200 {a b : \u2124}, a \u2264 0 \u2192 0 \u2264 b \u2192 (a.nat_abs = b.nat_abs \u2194 -a = b)", "decl_nm": "int.nat_abs_inj_of_nonpos_of_nonneg", "nl_statement_of_codex": "Let $a, b\\in\\mathbb{Z}$. If $a\\leq 0$ and $b\\geq 0$, then $|a|=|b|$ if and only if $-a=b$."}
{"formal_statement": "theorem right_op_id {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {F : C\u1d52\u1d56 \u2964 D} :\n\tcategory_theory.nat_trans.right_op (\ud835\udfd9 F) = \ud835\udfd9 F.right_op", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {F : C\u1d52\u1d56 \u2964 D}, category_theory.nat_trans.right_op (\ud835\udfd9 F) = \ud835\udfd9 F.right_op", "decl_nm": "category_theory.nat_trans.right_op_id", "nl_statement_of_codex": "The right adjoint of the identity functor is the identity functor."}
{"formal_statement": "theorem mem_or_mem_of_mem_union {\u03b1 : Type u} {x : \u03b1} {a b : set \u03b1} (H : x \u2208 a \u222a b) :\n\tx \u2208 a \u2228 x \u2208 b", "decl_tp": "\u2200 {\u03b1 : Type u} {x : \u03b1} {a b : set \u03b1}, x \u2208 a \u222a b \u2192 x \u2208 a \u2228 x \u2208 b", "decl_nm": "set.mem_or_mem_of_mem_union", "nl_statement_of_codex": "Let $A$ and $B$ be sets. If $x\\in A\\cup B$, then $x\\in A$ or $x\\in B$."}
{"formal_statement": "theorem trans {\u03b1 : Type*} [topological_space \u03b1] {x y z : \u03b1} :\n\tx \u2933 y \u2192 y \u2933 z \u2192 x \u2933 z", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {x y z : \u03b1}, x \u2933 y \u2192 y \u2933 z \u2192 x \u2933 z", "decl_nm": "specializes.trans", "nl_statement_of_codex": "Let $X$ be a topological space. If $x\\to y$ and $y\\to z$, then $x\\to z$."}
{"formal_statement": "theorem tendsto_const_nhds_iff {\u03b1 : Type u} [topological_space \u03b1] [t2_space \u03b1]\n\t{l : filter \u03b1} [l.ne_bot] {c d : \u03b1} :\n\tfilter.tendsto (\u03bb (x : \u03b1), c) l (nhds d) \u2194 c = d", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : t2_space \u03b1] {l : filter \u03b1} [_inst_3 : l.ne_bot] {c d : \u03b1}, filter.tendsto (\u03bb (x : \u03b1), c) l (nhds d) \u2194 c = d", "decl_nm": "tendsto_const_nhds_iff", "nl_statement_of_codex": "Let $X$ be a topological space. Let $c,d\\in X$. Then the constant function $f:X\\to X$ with $f(x)=c$ converges to $d$ if and only if $c=d$."}
{"formal_statement": "theorem functor_obj_obj_one {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] [category_theory.monoidal_category D]\n\t(A : Mon_ (C \u2964 D)) (X : C) :\n\t((category_theory.monoidal.Mon_functor_category_equivalence.functor.obj A).obj X).one = A.one.app X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.monoidal_category D] (A : Mon_ (C \u2964 D)) (X : C), ((category_theory.monoidal.Mon_functor_category_equivalence.functor.obj A).obj X).one = A.one.app X", "decl_nm": "category_theory.monoidal.Mon_functor_category_equivalence.functor_obj_obj_one", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $A$ be a monoidal functor from $C$ to $D$. Then the identity morphism of $A(X)$ is $A(1_X)$."}
{"formal_statement": "theorem dimH_univ {X Y : Type*} [emetric_space X] [emetric_space Y] (e : X \u2243\u1d62 Y) :\n\tdimH set.univ = dimH set.univ", "decl_tp": "\u2200 {X : Type u_2} {Y : Type u_3} [_inst_1 : emetric_space X] [_inst_2 : emetric_space Y], X \u2243\u1d62 Y \u2192 dimH set.univ = dimH set.univ", "decl_nm": "isometric.dimH_univ", "nl_statement_of_codex": "The Hausdorff dimension of the universe is invariant under isometric embeddings."}
{"formal_statement": "theorem mk_range_le_lift {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} :\n\t(cardinal.mk \u21a5(set.range f)).lift \u2264 (cardinal.mk \u03b1).lift", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}, (cardinal.mk \u21a5(set.range f)).lift \u2264 (cardinal.mk \u03b1).lift", "decl_nm": "cardinal.mk_range_le_lift", "nl_statement_of_codex": "The cardinality of the range of a function $f:A\\to B$ is less than or equal to the cardinality of $A$."}
{"formal_statement": "theorem eventually_eq {\u03b1 \u03b2 : Type*} {s : set \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : set.eq_on f g s) :\n\tf =\u1da0[filter.principal s] g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : set \u03b1} {f g : \u03b1 \u2192 \u03b2}, set.eq_on f g s \u2192 f =\u1da0[filter.principal s] g", "decl_nm": "set.eq_on.eventually_eq", "nl_statement_of_codex": "Let $f,g:\\alpha\\to\\beta$ be functions and let $s\\subset\\alpha$. Then $f=g$ on $s$ if and only if $f$ and $g$ are eventually equal on $s$."}
{"formal_statement": "theorem adj_symm {V : Type u} {G : simple_graph V} (G' : G.subgraph) {u v : V}\n\t(h : G'.adj u v) :\n\tG'.adj v u", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} (G' : G.subgraph) {u v : V}, G'.adj u v \u2192 G'.adj v u", "decl_nm": "simple_graph.subgraph.adj_symm", "nl_statement_of_codex": "Let $G$ be a simple graph and let $G'$ be a subgraph of $G$. If $u$ and $v$ are adjacent in $G'$, then $v$ and $u$ are adjacent in $G'$."}
{"formal_statement": "theorem gc (R : Type u) [comm_ring R] :\n\tgalois_connection (\u03bb (I : ideal R), prime_spectrum.zero_locus \u2191I) (\u03bb (t : order_dual (set (prime_spectrum R))), prime_spectrum.vanishing_ideal t)", "decl_tp": "\u2200 (R : Type u) [_inst_1 : comm_ring R], galois_connection (\u03bb (I : ideal R), prime_spectrum.zero_locus \u2191I) (\u03bb (t : order_dual (set (prime_spectrum R))), prime_spectrum.vanishing_ideal t)", "decl_nm": "prime_spectrum.gc", "nl_statement_of_codex": "The zero locus of an ideal $I$ is the vanishing ideal of the set of primes not in $I$."}
{"formal_statement": "theorem coe_comp {X Y Z : Profinite} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n\t\u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f", "decl_tp": "\u2200 {X Y Z : Profinite} (f : X \u27f6 Y) (g : Y \u27f6 Z), \u21d1(f \u226b g) = \u21d1g \u2218 \u21d1f", "decl_nm": "Profinite.coe_comp", "nl_statement_of_codex": "Let $X, Y, Z$ be profinite groups. Let $f:X\\to Y$ and $g:Y\\to Z$ be continuous homomorphisms. Then the continuous homomorphism $g\\circ f:X\\to Z$ is the composition of the continuous homomorphisms $f$ and $g$."}
{"formal_statement": "theorem coe_trans_symm {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] (e : local_homeomorph \u03b1 \u03b2) (e' : local_homeomorph \u03b2 \u03b3) :\n\t\u21d1((e.trans e').symm) = \u21d1(e.symm) \u2218 \u21d1(e'.symm)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] (e : local_homeomorph \u03b1 \u03b2) (e' : local_homeomorph \u03b2 \u03b3), \u21d1((e.trans e').symm) = \u21d1(e.symm) \u2218 \u21d1(e'.symm)", "decl_nm": "local_homeomorph.coe_trans_symm", "nl_statement_of_codex": "Let $e:X\\to Y$ and $e':Y\\to Z$ be local homeomorphisms. Then $(e'\\circ e)^{-1}=e^{-1}\\circ e'^{-1}$."}
{"formal_statement": "theorem right {\u03b1 : Type*} [preorder \u03b1] {s : \u2115} {l : ordnode \u03b1} {x : \u03b1}\n\t{r : ordnode \u03b1} {o\u2081 : with_bot \u03b1} {o\u2082 : with_top \u03b1} (H : ordnode.valid' o\u2081 (ordnode.node s l x r) o\u2082) :\n\tordnode.valid' \u2191x r o\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {s : \u2115} {l : ordnode \u03b1} {x : \u03b1} {r : ordnode \u03b1} {o\u2081 : with_bot \u03b1} {o\u2082 : with_top \u03b1}, ordnode.valid' o\u2081 (ordnode.node s l x r) o\u2082 \u2192 ordnode.valid' \u2191x r o\u2082", "decl_nm": "ordnode.valid'.right", "nl_statement_of_codex": "Let $X$ be a preorder and let $l,x,r$ be elements of $X$. If $l\\leq x\\leq r$, then $x\\leq r$."}
{"formal_statement": "theorem degree_le_iff_coeff_zero {R : Type u} [semiring R] (f : polynomial R)\n\t(n : with_bot \u2115) :\n\tf.degree \u2264 n \u2194 \u2200 (m : \u2115), n < \u2191m \u2192 f.coeff m = 0", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (f : polynomial R) (n : with_bot \u2115), f.degree \u2264 n \u2194 \u2200 (m : \u2115), n < \u2191m \u2192 f.coeff m = 0", "decl_nm": "polynomial.degree_le_iff_coeff_zero", "nl_statement_of_codex": "Let $f$ be a polynomial over a semiring $R$. Then $f$ has degree at most $n$ if and only if $f$ has coefficient $0$ for all $m>n$."}
{"formal_statement": "theorem coe_mul {\u03b1 : Type u} [topological_space \u03b1] {R : Type*} [normed_ring R]\n\t(f g : bounded_continuous_function \u03b1 R) :\n\t\u21d1(f * g) = \u21d1f * \u21d1g", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {R : Type u_1} [_inst_2 : normed_ring R] (f g : bounded_continuous_function \u03b1 R), \u21d1(f * g) = \u21d1f * \u21d1g", "decl_nm": "bounded_continuous_function.coe_mul", "nl_statement_of_codex": "Let $f,g:\\alpha\\to R$ be bounded continuous functions. Then the function $f\\cdot g:\\alpha\\to R$ is bounded continuous and $(f\\cdot g)^*=f^*\\cdot g^*$."}
{"formal_statement": "theorem elim_to_inhabited {\u03b1 : Sort u_1} [h : nonempty \u03b1] {p : Prop} :\n\t(inhabited \u03b1 \u2192 p) \u2192 p", "decl_tp": "\u2200 {\u03b1 : Sort u_1} [h : nonempty \u03b1] {p : Prop}, (inhabited \u03b1 \u2192 p) \u2192 p", "decl_nm": "nonempty.elim_to_inhabited", "nl_statement_of_codex": "If $\u03b1$ is nonempty, then any proposition $p$ that holds for all inhabited types holds for $\u03b1$."}
{"formal_statement": "theorem open_target {H : Type u} {M : Type*} [topological_space H] (c : charted_space_core H M)\n\t{e : local_equiv M H} (he : e \u2208 c.atlas) :\n\tis_open e.target", "decl_tp": "\u2200 {H : Type u} {M : Type u_2} [_inst_1 : topological_space H] (c : charted_space_core H M) {e : local_equiv M H}, e \u2208 c.atlas \u2192 is_open e.target", "decl_nm": "charted_space_core.open_target", "nl_statement_of_codex": "Let $M$ be a manifold and let $H$ be a topological space. Let $c$ be a charted space core on $M$ and let $e$ be a local equivalence from $M$ to $H$. If $e$ is in the atlas of $c$, then the target of $e$ is open."}
{"formal_statement": "theorem eventually_measure_lt_top {\u03b1 : Type*} [metric_space \u03b1] {m0 : measurable_space \u03b1}\n\t{\u03bc : measure_theory.measure \u03b1} (v : vitali_family \u03bc) [measure_theory.is_locally_finite_measure \u03bc]\n\t(x : \u03b1) :\n\t\u2200\u1da0 (a : set \u03b1) in v.filter_at x, \u21d1\u03bc a < \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : metric_space \u03b1] {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (v : vitali_family \u03bc) [_inst_2 : measure_theory.is_locally_finite_measure \u03bc] (x : \u03b1), \u2200\u1da0 (a : set \u03b1) in v.filter_at x, \u21d1\u03bc a < \u22a4", "decl_nm": "vitali_family.eventually_measure_lt_top", "nl_statement_of_codex": "Let $X$ be a metric space and let $\\mu$ be a locally finite measure on $X$. Then for each $x\\in X$ there is a neighborhood $U$ of $x$ such that $\\mu(U)<\\infty$."}
{"formal_statement": "theorem neighbor_finset_def {V : Type u} (G : simple_graph V) (v : V) [fintype \u21a5(G.neighbor_set v)] :\n\tG.neighbor_finset v = (G.neighbor_set v).to_finset", "decl_tp": "\u2200 {V : Type u} (G : simple_graph V) (v : V) [_inst_1 : fintype \u21a5(G.neighbor_set v)], G.neighbor_finset v = (G.neighbor_set v).to_finset", "decl_nm": "simple_graph.neighbor_finset_def", "nl_statement_of_codex": "Let $G$ be a simple graph and let $v$ be a vertex of $G$. Then the set of neighbors of $v$ is finite."}
{"formal_statement": "theorem equivalence_mk'_counit {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (functor : C \u2964 D) (inverse : D \u2964 C)\n\t(unit_iso : \ud835\udfed C \u2245 functor \u22d9 inverse) (counit_iso : inverse \u22d9 functor \u2245 \ud835\udfed D)\n\t(f : auto_param (\u2200 (X : C), functor.map (unit_iso.hom.app X) \u226b counit_iso.hom.app (functor.obj X) = \ud835\udfd9 (functor.obj X))\n\t(name.mk_string \"obviously\" name.anonymous)) :\n\t{functor := functor, inverse := inverse, unit_iso := unit_iso, counit_iso := counit_iso, functor_unit_iso_comp' := f}.counit = counit_iso.hom", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (functor : C \u2964 D) (inverse : D \u2964 C) (unit_iso : \ud835\udfed C \u2245 functor \u22d9 inverse) (counit_iso : inverse \u22d9 functor \u2245 \ud835\udfed D) (f : auto_param (\u2200 (X : C), functor.map (unit_iso.hom.app X) \u226b counit_iso.hom.app (functor.obj X) = \ud835\udfd9 (functor.obj X)) (name.mk_string \"obviously\" name.anonymous)), {functor := functor, inverse := inverse, unit_iso := unit_iso, counit_iso := counit_iso, functor_unit_iso_comp' := f}.counit = counit_iso.hom", "decl_nm": "category_theory.equivalence.equivalence_mk'_counit", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ and $G:D\\to C$ be functors. Let $\\eta:1_C\\to GF$ and $\\epsilon:FG\\to 1_D$ be natural transformations. Then $\\epsilon$ is the counit of the adjunction $(F,G,\\eta,\\epsilon)$."}
{"formal_statement": "theorem ker_rel {M P : Type*} [add_zero_class M] [add_zero_class P] (f : M \u2192+ P)\n\t{x y : M} :\n\t\u21d1(add_con.ker f) x y \u2194 \u21d1f x = \u21d1f y", "decl_tp": "\u2200 {M : Type u_1} {P : Type u_3} [_inst_1 : add_zero_class M] [_inst_3 : add_zero_class P] (f : M \u2192+ P) {x y : M}, \u21d1(add_con.ker f) x y \u2194 \u21d1f x = \u21d1f y", "decl_nm": "add_con.ker_rel", "nl_statement_of_codex": "Let $f:M\\to P$ be a group homomorphism. Then $x\\sim y$ if and only if $f(x)=f(y)$."}
{"formal_statement": "theorem eq_to_hom_map {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] (F : C \u2964 D) {X Y : C} (p : X = Y) :\n\tF.map (category_theory.eq_to_hom p) = category_theory.eq_to_hom _", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C \u2964 D) {X Y : C} (p : X = Y), F.map (category_theory.eq_to_hom p) = category_theory.eq_to_hom _", "decl_nm": "category_theory.eq_to_hom_map", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor. Then $F$ maps the morphism $X\\to Y$ induced by an equality $X=Y$ to the morphism $FX\\to FY$ induced by the equality $FX=FY$."}
{"formal_statement": "theorem decorate_error_success {\u03b1 : Type} {msg : thunk string} {p : parser \u03b1}\n\t{cb : char_buffer} {n n' : \u2115} {a : \u03b1} (h : p cb n = parse_result.done n' a) :\n\tparser.decorate_error msg p cb n = parse_result.done n' a", "decl_tp": "\u2200 {\u03b1 : Type} {msg : thunk string} {p : parser \u03b1} {cb : char_buffer} {n n' : \u2115} {a : \u03b1}, p cb n = parse_result.done n' a \u2192 parser.decorate_error msg p cb n = parse_result.done n' a", "decl_nm": "parser.decorate_error_success", "nl_statement_of_codex": "If $p$ is a parser and $cb$ is a character buffer, then $p$ succeeds on $cb$ if and only if $p$ succeeds on $cb$."}
{"formal_statement": "theorem inter_subset_right {\u03b1 : Type*} [decidable_eq \u03b1] (s\u2081 s\u2082 : finset \u03b1) :\n\ts\u2081 \u2229 s\u2082 \u2286 s\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s\u2081 s\u2082 : finset \u03b1), s\u2081 \u2229 s\u2082 \u2286 s\u2082", "decl_nm": "finset.inter_subset_right", "nl_statement_of_codex": "Let $s_1$ and $s_2$ be finite sets. Then $s_1\\cap s_2\\subset s_2$."}
{"formal_statement": "theorem infi_dite {\u03b1 : Type*} {\u03b9 : Sort u_4} [complete_lattice \u03b1] (p : \u03b9 \u2192 Prop)\n\t[decidable_pred p] (f : \u03a0 (i : \u03b9), p i \u2192 \u03b1) (g : \u03a0 (i : \u03b9), \u00acp i \u2192 \u03b1) :\n\t(\u2a05 (i : \u03b9), dite (p i) (\u03bb (h : p i), f i h) (\u03bb (h : \u00acp i), g i h)) = (\u2a05 (i : \u03b9)\n\t(h : p i), f i h) \u2293 \u2a05 (i : \u03b9) (h : \u00acp i), g i h", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_4} [_inst_1 : complete_lattice \u03b1] (p : \u03b9 \u2192 Prop) [_inst_2 : decidable_pred p] (f : \u03a0 (i : \u03b9), p i \u2192 \u03b1) (g : \u03a0 (i : \u03b9), \u00acp i \u2192 \u03b1), (\u2a05 (i : \u03b9), dite (p i) (\u03bb (h : p i), f i h) (\u03bb (h : \u00acp i), g i h)) = (\u2a05 (i : \u03b9) (h : p i), f i h) \u2293 \u2a05 (i : \u03b9) (h : \u00acp i), g i h", "decl_nm": "infi_dite", "nl_statement_of_codex": "Let $X$ be a complete lattice. Let $p$ be a predicate on an index set $I$. Let $f$ and $g$ be functions from $I$ to $X$. Then\n$$\\inf_{i\\in I} \\begin{cases} f(i) & \\text{if } p(i) \\\\ g(i) & \\text{if } \\neg p(i) \\end{cases} = \\inf_{i\\in I, p(i)} f(i) \\wedge \\inf_{i\\in I, \\neg p(i)} g(i).$$"}
{"formal_statement": "theorem neg {\u03b1 : Type u} {\u03b2 : Type v} [ordered_add_comm_group \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t{a : \u03b1} {l : filter \u03b1} (hf : is_max_filter f l a) :\n\tis_min_filter (\u03bb (x : \u03b1), -f x) l a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : ordered_add_comm_group \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : filter \u03b1}, is_max_filter f l a \u2192 is_min_filter (\u03bb (x : \u03b1), -f x) l a", "decl_nm": "is_max_filter.neg", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{R}$ be a function and let $a\\in X$. If $f$ is a max filter at $a$, then $-f$ is a min filter at $a$."}
{"formal_statement": "theorem translation_number_conj_eq' (f : units circle_deg1_lift) (g : circle_deg1_lift) :\n\t(\u2191f\u207b\u00b9 * g * \u2191f).translation_number = g.translation_number", "decl_tp": "\u2200 (f : units circle_deg1_lift) (g : circle_deg1_lift), (\u2191f\u207b\u00b9 * g * \u2191f).translation_number = g.translation_number", "decl_nm": "circle_deg1_lift.translation_number_conj_eq'", "nl_statement_of_codex": "Let $f$ be a unit in the group of circle homeomorphisms and let $g$ be a circle homeomorphism. Then the translation number of $g$ is equal to the translation number of $f^{-1}gf$."}
{"formal_statement": "theorem of_comp_iso_m {C : Type u} [category_theory.category C] {X Y : C}\n\t{f : X \u27f6 Y} {Y' : C} {g : Y \u27f6 Y'} [category_theory.is_iso g] (F : category_theory.limits.mono_factorisation (f \u226b g)) :\n\tF.of_comp_iso.m = F.m \u226b category_theory.inv g", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f : X \u27f6 Y} {Y' : C} {g : Y \u27f6 Y'} [_inst_2 : category_theory.is_iso g] (F : category_theory.limits.mono_factorisation (f \u226b g)), F.of_comp_iso.m = F.m \u226b category_theory.inv g", "decl_nm": "category_theory.limits.mono_factorisation.of_comp_iso_m", "nl_statement_of_codex": "Let $C$ be a category, let $X, Y, Y'$ be objects of $C$, let $f:X\\to Y$ and $g:Y\\to Y'$ be morphisms of $C$, and suppose that $g$ is an isomorphism. Let $F$ be a mono-factorization of $f\\circ g$. Then the morphism $F.of_comp_iso.m$ is equal to the composition of $F.m$ with the inverse of $g$."}
{"formal_statement": "theorem top_eq :\n\t\u22a4 = punit.star", "decl_tp": "\u22a4 = punit.star", "decl_nm": "punit.top_eq", "nl_statement_of_codex": "The top element of the poset of types is the unit type."}
{"formal_statement": "theorem zip_with_comm {\u03b1 : Type u} {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) :\n\t(\u2200 (x y : \u03b1), f x y = f y x) \u2192 \u2200 (l l' : list \u03b1), list.zip_with f l l' = list.zip_with f l' l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type u_1} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2), (\u2200 (x y : \u03b1), f x y = f y x) \u2192 \u2200 (l l' : list \u03b1), list.zip_with f l l' = list.zip_with f l' l", "decl_nm": "list.zip_with_comm", "nl_statement_of_codex": "Let $f:A\\times A\\to B$ be a function. If $f$ is commutative, then $f$ is commutative when applied to lists."}
{"formal_statement": "theorem add_lsb_eq_twice_add_one {x : \u2115} {b : bool} :\n\tbitvec.add_lsb x b = 2 * x + cond b 1 0", "decl_tp": "\u2200 {x : \u2115} {b : bool}, bitvec.add_lsb x b = 2 * x + cond b 1 0", "decl_nm": "bitvec.add_lsb_eq_twice_add_one", "nl_statement_of_codex": "The function $f:\\mathbb{N}\\times\\{0,1\\}\\to\\mathbb{N}$ defined by $f(x,b)=2x+b$ is equal to the function $g:\\mathbb{N}\\times\\{0,1\\}\\to\\mathbb{N}$ defined by $g(x,b)=x+2b$."}
{"formal_statement": "theorem refine_apply {C : Type u} [category_theory.category C] {J : category_theory.grothendieck_topology C}\n\t{D : Type w} [category_theory.category D] [category_theory.concrete_category D]\n\t{X : C} {P : C\u1d52\u1d56 \u2964 D} {S T : J.cover X} (x : category_theory.meq P T)\n\t(e : S \u27f6 T) (I : S.arrow) :\n\t\u21d1(x.refine e) I = \u21d1x {Y := I.Y, f := I.f, hf := _}", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {J : category_theory.grothendieck_topology C} {D : Type w} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.concrete_category D] {X : C} {P : C\u1d52\u1d56 \u2964 D} {S T : J.cover X} (x : category_theory.meq P T) (e : S \u27f6 T) (I : S.arrow), \u21d1(x.refine e) I = \u21d1x {Y := I.Y, f := I.f, hf := _}", "decl_nm": "category_theory.meq.refine_apply", "nl_statement_of_codex": "Let $C$ be a category, $J$ a Grothendieck topology on $C$, $D$ a category, $X$ an object of $C$, $P$ a presheaf on $C$, $S$ and $T$ covers of $X$. If $x$ is a morphism from $P$ to $T$ and $e$ is a morphism from $S$ to $T$, then the morphism from $P$ to $S$ obtained by refining $e$ with $x$ is equal to the morphism from $P$ to $S$ obtained by refining $x$ with $I$."}
{"formal_statement": "theorem card_union_le {\u03b1 : Type*} [decidable_eq \u03b1] (s t : finset \u03b1) :\n\t(s \u222a t).card \u2264 s.card + t.card", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s t : finset \u03b1), (s \u222a t).card \u2264 s.card + t.card", "decl_nm": "finset.card_union_le", "nl_statement_of_codex": "The cardinality of the union of two finite sets is less than or equal to the sum of the cardinalities of the two sets."}
{"formal_statement": "theorem is_antisymm {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : is_antichain r set.univ) :\n\tis_antisymm \u03b1 r", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, is_antichain r set.univ \u2192 is_antisymm \u03b1 r", "decl_nm": "is_antichain.is_antisymm", "nl_statement_of_codex": "Let $r$ be a relation on a set $X$. If $r$ is an antichain on $X$, then $r$ is antisymmetric."}
{"formal_statement": "theorem sum_apply {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} {\u03b9\u2081 : Type u\u2081} [decidable_eq \u03b9\u2081]\n\t{\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [\u03a0 (i\u2081 : \u03b9\u2081), has_zero (\u03b2\u2081 i\u2081)] [\u03a0 (i : \u03b9\u2081) (x : \u03b2\u2081 i), decidable (x \u2260 0)]\n\t[\u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)] {f : \u03a0\u2080 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081} {g : \u03a0 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081 \u2192 (\u03a0\u2080 (i : \u03b9), \u03b2 i)}\n\t{i\u2082 : \u03b9} :\n\t\u21d1(f.sum g) i\u2082 = f.sum (\u03bb (i\u2081 : \u03b9\u2081) (b : \u03b2\u2081 i\u2081), \u21d1(g i\u2081 b) i\u2082)", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} {\u03b9\u2081 : Type u\u2081} [_inst_1 : decidable_eq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [_inst_2 : \u03a0 (i\u2081 : \u03b9\u2081), has_zero (\u03b2\u2081 i\u2081)] [_inst_3 : \u03a0 (i : \u03b9\u2081) (x : \u03b2\u2081 i), decidable (x \u2260 0)] [_inst_4 : \u03a0 (i : \u03b9), add_comm_monoid (\u03b2 i)] {f : \u03a0\u2080 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081} {g : \u03a0 (i\u2081 : \u03b9\u2081), \u03b2\u2081 i\u2081 \u2192 (\u03a0\u2080 (i : \u03b9), \u03b2 i)} {i\u2082 : \u03b9}, \u21d1(f.sum g) i\u2082 = f.sum (\u03bb (i\u2081 : \u03b9\u2081) (b : \u03b2\u2081 i\u2081), \u21d1(g i\u2081 b) i\u2082)", "decl_nm": "dfinsupp.sum_apply", "nl_statement_of_codex": "Let $f$ be a function from a set $I_1$ to a set $B_1$ and let $g$ be a function from $I_1$ to the set of functions from $I$ to $B$. Then the sum of $f$ and $g$ is the function from $I$ to $B$ given by $i\\mapsto \\sum_{i_1\\in I_1} f(i_1)g(i_1)(i)$."}
{"formal_statement": "theorem of_set_univ {\u03b1 : Type u} :\n\tpequiv.of_set set.univ = pequiv.refl \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u}, pequiv.of_set set.univ = pequiv.refl \u03b1", "decl_nm": "pequiv.of_set_univ", "nl_statement_of_codex": "The partial equivalence relation on a set $X$ that is the identity on $X$ is the same as the partial equivalence relation on $X$ that is the identity on $X$."}
{"formal_statement": "theorem Ioc_union_Ioc_right {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} :\n\tset.Ioc a b \u222a set.Ioc a c = set.Ioc a (linear_order.max b c)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, set.Ioc a b \u222a set.Ioc a c = set.Ioc a (linear_order.max b c)", "decl_nm": "set.Ioc_union_Ioc_right", "nl_statement_of_codex": "Let $a,b,c$ be elements of a linear order. Then $(a,b)\\cup(a,c)=(a,\\max(b,c))$."}
{"formal_statement": "theorem fderiv {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] (e : E \u2192L[\ud835\udd5c] F)\n\t{x : E} :\n\tfderiv \ud835\udd5c \u21d1e x = e", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] (e : E \u2192L[\ud835\udd5c] F) {x : E}, fderiv \ud835\udd5c \u21d1e x = e", "decl_nm": "continuous_linear_map.fderiv", "nl_statement_of_codex": "The derivative of a linear map $e:E\\to F$ at a point $x\\in E$ is $e$."}
{"formal_statement": "theorem antisymm_iff {\u03b1 : Type*} {s\u2081 s\u2082 : finset \u03b1} :\n\ts\u2081 = s\u2082 \u2194 s\u2081 \u2286 s\u2082 \u2227 s\u2082 \u2286 s\u2081", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s\u2081 s\u2082 : finset \u03b1}, s\u2081 = s\u2082 \u2194 s\u2081 \u2286 s\u2082 \u2227 s\u2082 \u2286 s\u2081", "decl_nm": "finset.subset.antisymm_iff", "nl_statement_of_codex": "Two finite sets $A$ and $B$ are equal if and only if $A\\subset B$ and $B\\subset A$."}
{"formal_statement": "theorem disj_union_boxes {\u03b9 : Type*} {I : box_integral.box \u03b9} (\u03c0\u2081 \u03c0\u2082 : box_integral.prepartition I)\n\t(h : disjoint \u03c0\u2081.Union \u03c0\u2082.Union) :\n\t(\u03c0\u2081.disj_union \u03c0\u2082 h).boxes = \u03c0\u2081.boxes \u222a \u03c0\u2082.boxes", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} (\u03c0\u2081 \u03c0\u2082 : box_integral.prepartition I) (h : disjoint \u03c0\u2081.Union \u03c0\u2082.Union), (\u03c0\u2081.disj_union \u03c0\u2082 h).boxes = \u03c0\u2081.boxes \u222a \u03c0\u2082.boxes", "decl_nm": "box_integral.prepartition.disj_union_boxes", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $\\pi_1, \\pi_2$ be prepartitions of $I$. If $\\pi_1$ and $\\pi_2$ are disjoint, then the boxes of the disjoint union of $\\pi_1$ and $\\pi_2$ are the union of the boxes of $\\pi_1$ and $\\pi_2$."}
{"formal_statement": "theorem nodup_rotate {\u03b1 : Type u} {l : list \u03b1} {n : \u2115} :\n\t(l.rotate n).nodup \u2194 l.nodup", "decl_tp": "\u2200 {\u03b1 : Type u} {l : list \u03b1} {n : \u2115}, (l.rotate n).nodup \u2194 l.nodup", "decl_nm": "list.nodup_rotate", "nl_statement_of_codex": "The list $l$ has no duplicates if and only if the list $l$ rotated by $n$ has no duplicates."}
{"formal_statement": "theorem measurable_set_eq {\u03b1 : Type*} [measurable_space \u03b1] [measurable_singleton_class \u03b1]\n\t{a : \u03b1} :\n\tmeasurable_set {x : \u03b1 | x = a}", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_singleton_class \u03b1] {a : \u03b1}, measurable_set {x : \u03b1 | x = a}", "decl_nm": "measurable_set_eq", "nl_statement_of_codex": "The singleton set $\\{a\\}$ is measurable."}
{"formal_statement": "theorem exists_forall_ge {\u03b1 \u03b2 : Type*} [conditionally_complete_linear_order \u03b1]\n\t[topological_space \u03b1] [order_topology \u03b1] [topological_space \u03b2] {s : set \u03b2} :\n\tis_compact s \u2192 s.nonempty \u2192 \u2200 {f : \u03b2 \u2192 \u03b1}, continuous_on f s \u2192 (\u2203 (x : \u03b2)\n\t(H : x \u2208 s), \u2200 (y : \u03b2), y \u2208 s \u2192 f y \u2264 f x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : topological_space \u03b2] {s : set \u03b2}, is_compact s \u2192 s.nonempty \u2192 \u2200 {f : \u03b2 \u2192 \u03b1}, continuous_on f s \u2192 (\u2203 (x : \u03b2) (H : x \u2208 s), \u2200 (y : \u03b2), y \u2208 s \u2192 f y \u2264 f x)", "decl_nm": "is_compact.exists_forall_ge", "nl_statement_of_codex": "Let $s$ be a compact subset of a topological space $X$. Suppose that $s$ is nonempty. Let $f:s\\to\\mathbb{R}$ be a continuous function. Then there is an element $x\\in s$ such that $f(x)\\leq f(y)$ for all $y\\in s$."}
{"formal_statement": "theorem diam_eq_zero_of_unbounded {\u03b1 : Type u} [pseudo_metric_space \u03b1]\n\t{s : set \u03b1} (h : \u00acmetric.bounded s) :\n\tmetric.diam s = 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {s : set \u03b1}, \u00acmetric.bounded s \u2192 metric.diam s = 0", "decl_nm": "metric.diam_eq_zero_of_unbounded", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $A$ be a subset of $X$. If $A$ is unbounded, then the diameter of $A$ is zero."}
{"formal_statement": "theorem mem_powers_iff_mem_range_order_of {G : Type u} {x y : G} [fintype G]\n\t[left_cancel_monoid G] [decidable_eq G] :\n\ty \u2208 submonoid.powers x \u2194 y \u2208 finset.image (has_pow.pow x) (finset.range (order_of x))", "decl_tp": "\u2200 {G : Type u} {x y : G} [_inst_1 : fintype G] [_inst_3 : left_cancel_monoid G] [_inst_5 : decidable_eq G], y \u2208 submonoid.powers x \u2194 y \u2208 finset.image (has_pow.pow x) (finset.range (order_of x))", "decl_nm": "mem_powers_iff_mem_range_order_of", "nl_statement_of_codex": "Let $G$ be a finite group and let $x,y\\in G$. Then $y\\in\\langle x\\rangle$ if and only if $y=x^n$ for some $n\\in\\{0,1,\\ldots,\\operatorname{ord}(x)-1\\}$."}
{"formal_statement": "theorem piecewise_target {\u03b1 \u03b2 : Type*} (e e' : local_equiv \u03b1 \u03b2) (s : set \u03b1)\n\t(t : set \u03b2) [\u03a0 (x : \u03b1), decidable (x \u2208 s)] [\u03a0 (y : \u03b2), decidable (y \u2208 t)]\n\t(H : e.is_image s t) (H' : e'.is_image s t) :\n\t(e.piecewise e' s t H H').target = t.ite e.target e'.target", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e e' : local_equiv \u03b1 \u03b2) (s : set \u03b1) (t : set \u03b2) [_inst_1 : \u03a0 (x : \u03b1), decidable (x \u2208 s)] [_inst_2 : \u03a0 (y : \u03b2), decidable (y \u2208 t)] (H : e.is_image s t) (H' : e'.is_image s t), (e.piecewise e' s t H H').target = t.ite e.target e'.target", "decl_nm": "local_equiv.piecewise_target", "nl_statement_of_codex": "Let $e, e':X\\to Y$ be local homeomorphisms. Let $s\\subset X$ and $t\\subset Y$ be subsets such that $e(s)=t=e'(s)$. Then the target of the piecewise local homeomorphism $e\\cup e'$ is $t$."}
{"formal_statement": "theorem left_unitor_inv_app {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] [category_theory.monoidal_category D]\n\t{F : C \u2964 D} {X : C} :\n\t(\u03bb_ F).inv.app X = (\u03bb_ (F.obj X)).inv", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.monoidal_category D] {F : C \u2964 D} {X : C}, (\u03bb_ F).inv.app X = (\u03bb_ (F.obj X)).inv", "decl_nm": "category_theory.monoidal.left_unitor_inv_app", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $F:C\\to D$ be a functor. Then the left unitor of $F$ is the inverse of the left unitor of $F(X)$."}
{"formal_statement": "theorem kronecker {\u03b1 n m : Type*} [mul_zero_class \u03b1] {A : matrix m m \u03b1}\n\t{B : matrix n n \u03b1} (hA : A.is_diag) (hB : B.is_diag) :\n\t(matrix.kronecker_map has_mul.mul A B).is_diag", "decl_tp": "\u2200 {\u03b1 : Type u_1} {n : Type u_4} {m : Type u_5} [_inst_1 : mul_zero_class \u03b1] {A : matrix m m \u03b1} {B : matrix n n \u03b1}, A.is_diag \u2192 B.is_diag \u2192 (matrix.kronecker_map has_mul.mul A B).is_diag", "decl_nm": "matrix.is_diag.kronecker", "nl_statement_of_codex": "Let $A$ and $B$ be diagonal matrices. Then the Kronecker product $A\\otimes B$ is a diagonal matrix."}
{"formal_statement": "theorem comp_continuous_iff {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082]\n\t{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t[semi_normed_group E] [semi_normed_group E\u2082] [module R E] [module R\u2082 E\u2082]\n\t(e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) {\u03b1 : Type*0} [topological_space \u03b1] {f : \u03b1 \u2192 E} :\n\tcontinuous (\u21d1e \u2218 f) \u2194 continuous f", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_5 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_6 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) {\u03b1 : Type u_10} [_inst_35 : topological_space \u03b1] {f : \u03b1 \u2192 E}, continuous (\u21d1e \u2218 f) \u2194 continuous f", "decl_nm": "linear_isometry_equiv.comp_continuous_iff", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $E$ and $E'$ be semi-normed groups over $R$ and $R'$, respectively, and let $e:E\\to E'$ be an isomorphism of $R$-modules. Then $e\\circ f$ is continuous if and only if $f$ is continuous."}
{"formal_statement": "theorem bounded {\u03b1 : Type u} [pseudo_metric_space \u03b1] {s : set \u03b1} :\n\ts.finite \u2192 metric.bounded s", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {s : set \u03b1}, s.finite \u2192 metric.bounded s", "decl_nm": "set.finite.bounded", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space and let $S$ be a finite subset of $X$. Then $S$ is bounded."}
{"formal_statement": "theorem le_bot_iff {\u03b1 : Type u} [partial_order \u03b1] [order_bot \u03b1] {a : \u03b1} :\n\ta \u2264 \u22a5 \u2194 a = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] [_inst_2 : order_bot \u03b1] {a : \u03b1}, a \u2264 \u22a5 \u2194 a = \u22a5", "decl_nm": "le_bot_iff", "nl_statement_of_codex": "Let $\u03b1$ be a partially ordered set with a bottom element. Then $a\\leq \\bot$ if and only if $a=\\bot$."}
{"formal_statement": "theorem convex_Inter {\ud835\udd5c E : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[has_scalar \ud835\udd5c E] {\u03b9 : Sort u_3} {s : \u03b9 \u2192 set E} :\n\t(\u2200 (i : \u03b9), convex \ud835\udd5c (s i)) \u2192 convex \ud835\udd5c (\u22c2 (i : \u03b9), s i)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : has_scalar \ud835\udd5c E] {\u03b9 : Sort u_3} {s : \u03b9 \u2192 set E}, (\u2200 (i : \u03b9), convex \ud835\udd5c (s i)) \u2192 convex \ud835\udd5c (\u22c2 (i : \u03b9), s i)", "decl_nm": "convex_Inter", "nl_statement_of_codex": "Let $E$ be a vector space over an ordered field $K$. Let $S_1,\\ldots,S_n$ be convex subsets of $E$. Then $\\bigcap_{i=1}^n S_i$ is convex."}
{"formal_statement": "theorem to_SheafedSpace_hom_base {C : Type u} [category_theory.category C]\n\t[category_theory.limits.has_products C] {X : algebraic_geometry.PresheafedSpace C}\n\t(Y : algebraic_geometry.SheafedSpace C) (f : X \u27f6 Y.to_PresheafedSpace)\n\t[H : algebraic_geometry.PresheafedSpace.is_open_immersion f] :\n\t(algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace_hom Y f).base = f.base", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_products C] {X : algebraic_geometry.PresheafedSpace C} (Y : algebraic_geometry.SheafedSpace C) (f : X \u27f6 Y.to_PresheafedSpace) [H : algebraic_geometry.PresheafedSpace.is_open_immersion f], (algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace_hom Y f).base = f.base", "decl_nm": "algebraic_geometry.PresheafedSpace.is_open_immersion.to_SheafedSpace_hom_base", "nl_statement_of_codex": "Let $C$ be a category with products. Let $X$ be a presheafed space over $C$ and let $Y$ be a sheafed space over $C$.\nLet $f:X\\to Y$ be a morphism of presheafed spaces. If $f$ is an open immersion, then the base of the morphism\n$f$ is equal to the base of the morphism $f$."}
{"formal_statement": "theorem inf_ne_bot_iff_frequently_right {\u03b1 : Type*} {f g : filter \u03b1} :\n\t(f \u2293 g).ne_bot \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in g, p x) \u2192 (\u2203\u1da0 (x : \u03b1) in f, p x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f g : filter \u03b1}, (f \u2293 g).ne_bot \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 (x : \u03b1) in g, p x) \u2192 (\u2203\u1da0 (x : \u03b1) in f, p x)", "decl_nm": "filter.inf_ne_bot_iff_frequently_right", "nl_statement_of_codex": "The infimum of two filters $f$ and $g$ is non-empty if and only if for every property $p$ that holds frequently in $g$, it also holds frequently in $f$."}
{"formal_statement": "theorem is_artinian_ring_iff {R : Type*} [ring R] :\n\tis_artinian_ring R \u2194 is_artinian R R", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : ring R], is_artinian_ring R \u2194 is_artinian R R", "decl_nm": "is_artinian_ring_iff", "nl_statement_of_codex": "A ring $R$ is Artinian if and only if the module $R$ over itself is Artinian."}
{"formal_statement": "theorem id {\u03b1 : Type*} {m0 : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1) :\n\tmeasure_theory.measure.quasi_measure_preserving id \u03bc \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1), measure_theory.measure.quasi_measure_preserving id \u03bc \u03bc", "decl_nm": "measure_theory.measure.quasi_measure_preserving.id", "nl_statement_of_codex": "The identity function is measure preserving."}
{"formal_statement": "theorem mem_comap {R : Type u} {S : Type v} [ring R] [ring S] {s : subring S}\n\t{f : R \u2192+* S} {x : R} :\n\tx \u2208 subring.comap f s \u2194 \u21d1f x \u2208 s", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : ring R] [_inst_2 : ring S] {s : subring S} {f : R \u2192+* S} {x : R}, x \u2208 subring.comap f s \u2194 \u21d1f x \u2208 s", "decl_nm": "subring.mem_comap", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f:R\\to S$ be a ring homomorphism. Let $s$ be a subring of $S$. Then $x\\in f^{-1}(s)$ if and only if $f(x)\\in s$."}
{"formal_statement": "theorem mem_supr_iff_exists_finset {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] {\u03b9 : Type*} {p : \u03b9 \u2192 submodule R M} {m : M} :\n\t(m \u2208 \u2a06 (i : \u03b9), p i) \u2194 \u2203 (s : finset \u03b9), m \u2208 \u2a06 (i : \u03b9) (H : i \u2208 s), p i", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] {\u03b9 : Type u_3} {p : \u03b9 \u2192 submodule R M} {m : M}, (m \u2208 \u2a06 (i : \u03b9), p i) \u2194 \u2203 (s : finset \u03b9), m \u2208 \u2a06 (i : \u03b9) (H : i \u2208 s), p i", "decl_nm": "submodule.mem_supr_iff_exists_finset", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $p:\\mathbb{N}\\to M$ a function. Then $m\\in\\bigcup_{i\\in\\mathbb{N}}p(i)$ if and only if there is a finite set $S\\subset\\mathbb{N}$ such that $m\\in\\bigcup_{i\\in S}p(i)$."}
{"formal_statement": "theorem trivial_ker_of_injective {G H : Type*} [group G] [group H] {f : G \u2192 H}\n\t(hf : is_group_hom f) (h : function.injective f) :\n\tis_group_hom.ker f = is_subgroup.trivial G", "decl_tp": "\u2200 {G : Type u_1} {H : Type u_2} [_inst_1 : group G] [_inst_2 : group H] {f : G \u2192 H}, is_group_hom f \u2192 function.injective f \u2192 is_group_hom.ker f = is_subgroup.trivial G", "decl_nm": "is_group_hom.trivial_ker_of_injective", "nl_statement_of_codex": "Let $G$ and $H$ be groups and let $f:G\\to H$ be a group homomorphism. If $f$ is injective, then $\\ker f$ is trivial."}
{"formal_statement": "theorem fix {\u03b1 : Type} {F : parser \u03b1 \u2192 parser \u03b1} :\n\t(\u2200 (p : parser \u03b1), p.err_static \u2192 (F p).err_static) \u2192 (parser.fix F).err_static", "decl_tp": "\u2200 {\u03b1 : Type} {F : parser \u03b1 \u2192 parser \u03b1}, (\u2200 (p : parser \u03b1), p.err_static \u2192 (F p).err_static) \u2192 (parser.fix F).err_static", "decl_nm": "parser.err_static.fix", "nl_statement_of_codex": "Let $F$ be a parser. If $F$ is static, then the fixed point of $F$ is static."}
{"formal_statement": "theorem list_prod_mem {K : Type u} [field K] (s : subfield K) {l : list K} :\n\t(\u2200 (x : K), x \u2208 l \u2192 x \u2208 s) \u2192 l.prod \u2208 s", "decl_tp": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K) {l : list K}, (\u2200 (x : K), x \u2208 l \u2192 x \u2208 s) \u2192 l.prod \u2208 s", "decl_nm": "subfield.list_prod_mem", "nl_statement_of_codex": "Let $K$ be a field and let $s$ be a subfield of $K$. Let $l$ be a list of elements of $K$. If every element of $l$ is in $s$, then the product of the elements of $l$ is in $s$."}
{"formal_statement": "theorem is_unit {M : Type*} [comm_monoid M] {k : \u2115} {\u03b6 : M} (h : is_primitive_root \u03b6 k)\n\t(h0 : 0 < k) :\n\tis_unit \u03b6", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {k : \u2115} {\u03b6 : M}, is_primitive_root \u03b6 k \u2192 0 < k \u2192 is_unit \u03b6", "decl_nm": "is_primitive_root.is_unit", "nl_statement_of_codex": "Let $M$ be a commutative monoid and let $k$ be a positive integer. If $\\zeta$ is a primitive $k$-th root of unity in $M$, then $\\zeta$ is a unit in $M$."}
{"formal_statement": "theorem sequence_mono_nat {\u03b1 \u03b2 : Type*} [encodable \u03b1] [inhabited \u03b1] {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\n\t{f : \u03b1 \u2192 \u03b2} (hf : directed r f) (n : \u2115) :\n\tr (f (directed.sequence f hf n)) (f (directed.sequence f hf (n + 1)))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : encodable \u03b1] [_inst_2 : inhabited \u03b1] {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : directed r f) (n : \u2115), r (f (directed.sequence f hf n)) (f (directed.sequence f hf (n + 1)))", "decl_nm": "directed.sequence_mono_nat", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\beta$ be a directed sequence. Then $f(n)\\leq f(n+1)$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem mul_pos {d : \u2115} [dnsq : zsqrtd.nonsquare d] (a b : \u2124\u221a\u2191d) (a0 : 0 < a)\n\t(b0 : 0 < b) :\n\t0 < a * b", "decl_tp": "\u2200 {d : \u2115} [dnsq : zsqrtd.nonsquare d] (a b : \u2124\u221a\u2191d), 0 < a \u2192 0 < b \u2192 0 < a * b", "decl_nm": "zsqrtd.mul_pos", "nl_statement_of_codex": "Let $d$ be a non-square integer. Let $a, b$ be positive elements of $\\mathbb{Z}\\sqrt{d}$. Then $ab$ is positive."}
{"formal_statement": "theorem tsum_eq_zero_iff {\u03b1 \u03b2 : Type*} [canonically_ordered_add_monoid \u03b1]\n\t[topological_space \u03b1] [order_closed_topology \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : summable f) :\n\t(\u2211' (i : \u03b2), f i = 0 \u2194 \u2200 (x : \u03b2), f x = 0)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : canonically_ordered_add_monoid \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_closed_topology \u03b1] {f : \u03b2 \u2192 \u03b1}, summable f \u2192 (\u2211' (i : \u03b2), f i = 0 \u2194 \u2200 (x : \u03b2), f x = 0)", "decl_nm": "tsum_eq_zero_iff", "nl_statement_of_codex": "Let $f:B\\to A$ be a summable function. Then $\\sum_{i\\in B}f(i)=0$ if and only if $f(x)=0$ for all $x\\in B$."}
{"formal_statement": "theorem mul_neg {m n o : Type*} {\u03b1 : Type v} [ring \u03b1] [fintype n] (M : matrix m n \u03b1)\n\t(N : matrix n o \u03b1) :\n\tM.mul (-N) = -M.mul N", "decl_tp": "\u2200 {m : Type u_2} {n : Type u_3} {o : Type u_4} {\u03b1 : Type v} [_inst_1 : ring \u03b1] [_inst_2 : fintype n] (M : matrix m n \u03b1) (N : matrix n o \u03b1), M.mul (-N) = -M.mul N", "decl_nm": "matrix.mul_neg", "nl_statement_of_codex": "Let $M$ be an $m\\times n$ matrix and $N$ be an $n\\times o$ matrix. Then $M\\cdot (-N)=-M\\cdot N$."}
{"formal_statement": "theorem continuous_at_pow {M : Type*} [topological_space M] [monoid M]\n\t[has_continuous_mul M] (x : M) (n : \u2115) :\n\tcontinuous_at (\u03bb (x : M), x ^ n) x", "decl_tp": "\u2200 {M : Type u_4} [_inst_2 : topological_space M] [_inst_3 : monoid M] [_inst_4 : has_continuous_mul M] (x : M) (n : \u2115), continuous_at (\u03bb (x : M), x ^ n) x", "decl_nm": "continuous_at_pow", "nl_statement_of_codex": "The function $x\\mapsto x^n$ is continuous at $x$."}
{"formal_statement": "theorem mul_at_bot {\u03b1 : Type u} {\u03b2 : Type v} [linear_ordered_field \u03b1] [topological_space \u03b1]\n\t[order_topology \u03b1] {l : filter \u03b2} {f g : \u03b2 \u2192 \u03b1} {C : \u03b1} (hC : 0 < C) (hf : filter.tendsto f l (nhds C))\n\t(hg : filter.tendsto g l filter.at_bot) :\n\tfilter.tendsto (\u03bb (x : \u03b2), f x * g x) l filter.at_bot", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : linear_ordered_field \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] {l : filter \u03b2} {f g : \u03b2 \u2192 \u03b1} {C : \u03b1}, 0 < C \u2192 filter.tendsto f l (nhds C) \u2192 filter.tendsto g l filter.at_bot \u2192 filter.tendsto (\u03bb (x : \u03b2), f x * g x) l filter.at_bot", "decl_nm": "filter.tendsto.mul_at_bot", "nl_statement_of_codex": "Let $f,g:X\\to\\mathbb{R}$ be functions and let $C>0$. If $f$ tends to $C$ and $g$ tends to $0$, then $f\\cdot g$ tends to $0$."}
{"formal_statement": "theorem mem_closure_iff_ball {\u03b1 : Type*} [uniform_space \u03b1] {s : set \u03b1}\n\t{x : \u03b1} (x : \u03b1) :\n\tx \u2208 closure s \u2194 \u2200 {V : set (\u03b1 \u00d7 \u03b1)}, V \u2208 uniformity  (uniform_space.ball x V \u2229 s).nonempty", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1] {s : set \u03b1} {x : \u03b1}, x \u2208 closure s \u2194 \u2200 {V : set (\u03b1 \u00d7 \u03b1)}, V \u2208 uniformity \u03b1 \u2192 (uniform_space.ball x V \u2229 s).nonempty", "decl_nm": "uniform_space.mem_closure_iff_ball", "nl_statement_of_codex": "Let $X$ be a uniform space and let $s$ be a subset of $X$. Then $x\\in\\overline{s}$ if and only if for every entourage $V$ of $X$, the intersection of $V[x]$ and $s$ is nonempty."}
{"formal_statement": "theorem dist {\u03b1 : Type u} [pseudo_metric_space \u03b1] :\n\tlipschitz_with 2 (function.uncurry has_dist.dist)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1], lipschitz_with 2 (function.uncurry has_dist.dist)", "decl_nm": "lipschitz_with.dist", "nl_statement_of_codex": "The distance function is Lipschitz with constant 2."}
{"formal_statement": "theorem coe_to_lie_subalgebra_to_submodule (R : Type u) (L : Type v) [comm_ring R]\n\t[lie_ring L] [lie_algebra R L] (I : lie_ideal R L) :\n\t\u2191\u2191I = \u2191I", "decl_tp": "\u2200 (R : Type u) (L : Type v) [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] (I : lie_ideal R L), \u2191\u2191I = \u2191I", "decl_nm": "lie_ideal.coe_to_lie_subalgebra_to_submodule", "nl_statement_of_codex": "Let $R$ be a commutative ring, $L$ a Lie ring over $R$, and $I$ a Lie ideal of $L$. Then $I$ is a Lie subalgebra of $L$."}
{"formal_statement": "theorem abs_dist_sub_le {\u03b1 : Type u} [pseudo_metric_space \u03b1] (x y z : \u03b1) :\n\t|has_dist.dist x z - has_dist.dist y z| \u2264 has_dist.dist x y", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] (x y z : \u03b1), |has_dist.dist x z - has_dist.dist y z| \u2264 has_dist.dist x y", "decl_nm": "abs_dist_sub_le", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. Then for all $x,y,z\\in X$, $|d(x,z)-d(y,z)|\\leq d(x,y)$."}
{"formal_statement": "theorem convex_halfspace_re_le (r : \u211d) :\n\tconvex \u211d {c : \u2102 | c.re \u2264 r}", "decl_tp": "\u2200 (r : \u211d), convex \u211d {c : \u2102 | c.re \u2264 r}", "decl_nm": "convex_halfspace_re_le", "nl_statement_of_codex": "The set of complex numbers with real part less than or equal to $r$ is convex."}
{"formal_statement": "theorem le_stable {\u03b1 : Type u} (s : computation \u03b1) {a : \u03b1} {m n : \u2115} (h : m \u2264 n) :\n\ts.val m = option.some a \u2192 s.val n = option.some a", "decl_tp": "\u2200 {\u03b1 : Type u} (s : computation \u03b1) {a : \u03b1} {m n : \u2115}, m \u2264 n \u2192 s.val m = option.some a \u2192 s.val n = option.some a", "decl_nm": "computation.le_stable", "nl_statement_of_codex": "Let $s$ be a computation. If $s$ terminates with value $a$ at step $m$, then $s$ terminates with value $a$ at step $n$ for all $n\\geq m$."}
{"formal_statement": "theorem length_scanl {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2} (a : \u03b2)\n\t(l : list \u03b1) :\n\t(list.scanl f a l).length = l.length + 1", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2} (a : \u03b2) (l : list \u03b1), (list.scanl f a l).length = l.length + 1", "decl_nm": "list.length_scanl", "nl_statement_of_codex": "The length of the list obtained by applying scanl to a list $l$ is one more than the length of $l$."}
{"formal_statement": "theorem has_fderiv_within_at_inter {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s t : set E}\n\t(h : t \u2208 nhds x) :\n\t(has_fderiv_within_at f f' (s \u2229 t) x \u2194 has_fderiv_within_at f f' s x)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s t : set E}, t \u2208 nhds x \u2192 (has_fderiv_within_at f f' (s \u2229 t) x \u2194 has_fderiv_within_at f f' s x)", "decl_nm": "has_fderiv_within_at_inter", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ and $f':E\\to F$ be functions. Let $x\\in E$ and let $s,t\\subset E$ be sets. Then $f$ has a derivative at $x$ in the direction of $s\\cap t$ if and only if $f$ has a derivative at $x$ in the direction of $s$."}
{"formal_statement": "theorem mul_inv {k : Type*} [field k] (\u03c6 : power_series k) (h : \u21d1(power_series.constant_coeff k) \u03c6 \u2260 0) :\n\t\u03c6 * \u03c6\u207b\u00b9 = 1", "decl_tp": "\u2200 {k : Type u_2} [_inst_1 : field k] (\u03c6 : power_series k), \u21d1(power_series.constant_coeff k) \u03c6 \u2260 0 \u2192 \u03c6 * \u03c6\u207b\u00b9 = 1", "decl_nm": "power_series.mul_inv", "nl_statement_of_codex": "Let $k$ be a field and let $\\phi$ be a power series with nonzero constant coefficient. Then $\\phi\\phi^{-1}=1$."}
{"formal_statement": "theorem div_lt_one_of_neg {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1}\n\t(hb : b < 0) :\n\t(a / b < 1 \u2194 b < a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b : \u03b1}, b < 0 \u2192 (a / b < 1 \u2194 b < a)", "decl_nm": "div_lt_one_of_neg", "nl_statement_of_codex": "Let $a, b$ be real numbers such that $b<0$. Then $a/b<1$ if and only if $b<a$."}
{"formal_statement": "theorem proj_some_index {\u03b9 \u03b1 : Type*} {s : \u03b9 \u2192 set \u03b1} (hs : indexed_partition s)\n\t(x : \u03b1) :\n\ths.proj (hs.some (hs.index x)) = hs.proj x", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {s : \u03b9 \u2192 set \u03b1} (hs : indexed_partition s) (x : \u03b1), hs.proj (hs.some (hs.index x)) = hs.proj x", "decl_nm": "indexed_partition.proj_some_index", "nl_statement_of_codex": "Let $s$ be an indexed partition of a set $X$. Then for any $x\\in X$, $s(s(x))=s(x)$."}
{"formal_statement": "theorem map_smul\u209b\u2097\u2082 {R : Type*} [semiring R] {S : Type*} [semiring S] {R\u2082 : Type*}\n\t[semiring R\u2082] {S\u2082 : Type*} [semiring S\u2082] {M N P : Type*} [add_comm_monoid M]\n\t[add_comm_monoid N] [add_comm_monoid P] [module R M] [module S N] [module R\u2082 P]\n\t[module S\u2082 P] [smul_comm_class S\u2082 R\u2082 P] {\u03c1\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2081\u2082 : S \u2192+* S\u2082}\n\t(f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (r : R) (x : M) (y : N) :\n\t\u21d1(\u21d1f (r \u2022 x)) y = \u21d1\u03c1\u2081\u2082 r \u2022 \u21d1(\u21d1f x) y", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : semiring R] {S : Type u_2} [_inst_2 : semiring S] {R\u2082 : Type u_3} [_inst_3 : semiring R\u2082] {S\u2082 : Type u_4} [_inst_4 : semiring S\u2082] {M : Type u_5} {N : Type u_6} {P : Type u_7} [_inst_5 : add_comm_monoid M] [_inst_6 : add_comm_monoid N] [_inst_7 : add_comm_monoid P] [_inst_13 : module R M] [_inst_14 : module S N] [_inst_15 : module R\u2082 P] [_inst_16 : module S\u2082 P] [_inst_23 : smul_comm_class S\u2082 R\u2082 P] {\u03c1\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2081\u2082 : S \u2192+* S\u2082} (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (r : R) (x : M) (y : N), \u21d1(\u21d1f (r \u2022 x)) y = \u21d1\u03c1\u2081\u2082 r \u2022 \u21d1(\u21d1f x) y", "decl_nm": "linear_map.map_smul\u209b\u2097\u2082", "nl_statement_of_codex": "Let $R, S, R_2, S_2$ be semirings, $M, N, P$ be abelian monoids, $R$-modules, $S$-modules, $R_2$-modules, $S_2$-modules, respectively. Let $R_2$ be a $S_2$-module via a commutative action. Let $f:M\\to N\\to P$ be a bilinear map. Then $f(r\\cdot x, y)=r\\cdot f(x, y)$."}
{"formal_statement": "theorem map_tmul {R : Type*} [comm_semiring R] {M N P Q : Type*} [add_comm_monoid M]\n\t[add_comm_monoid N] [add_comm_monoid P] [add_comm_monoid Q] [module R M]\n\t[module R N] [module R P] [module R Q] (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q)\n\t(m : M) (n : N) :\n\t\u21d1(tensor_product.map f g) (m \u2297\u209c[R] n) = \u21d1f m \u2297\u209c[R] \u21d1g n", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] {M : Type u_4} {N : Type u_5} {P : Type u_6} {Q : Type u_7} [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid N] [_inst_6 : add_comm_monoid P] [_inst_7 : add_comm_monoid Q] [_inst_9 : module R M] [_inst_10 : module R N] [_inst_11 : module R P] [_inst_12 : module R Q] (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) (m : M) (n : N), \u21d1(tensor_product.map f g) (m \u2297\u209c[R] n) = \u21d1f m \u2297\u209c[R] \u21d1g n", "decl_nm": "tensor_product.map_tmul", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $M, N, P, Q$ be $R$-modules. Let $f:M\\to P$ and $g:N\\to Q$ be $R$-linear maps. Then the map $f\\otimes g:M\\otimes_RN\\to P\\otimes_RQ$ is given by $f\\otimes g(m\\otimes n)=f(m)\\otimes g(n)$."}
{"formal_statement": "theorem ext {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{H : Type*} [topological_space H] {H' : Type*} [topological_space H']\n\t{I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'} {M : Type*}\n\t[topological_space M] [charted_space H M] {M' : Type*} [topological_space M']\n\t[charted_space H' M'] {n : with_top \u2115} {h h' : diffeomorph I I' M M' n} :\n\t(\u2200 (x : M), \u21d1h x = \u21d1h' x) \u2192 h = h'", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_3} [_inst_4 : normed_group E'] [_inst_5 : normed_space \ud835\udd5c E'] {H : Type u_5} [_inst_8 : topological_space H] {H' : Type u_6} [_inst_9 : topological_space H'] {I : model_with_corners \ud835\udd5c E H} {I' : model_with_corners \ud835\udd5c E' H'} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M] {M' : Type u_9} [_inst_13 : topological_space M'] [_inst_14 : charted_space H' M'] {n : with_top \u2115} {h h' : diffeomorph I I' M M' n}, (\u2200 (x : M), \u21d1h x = \u21d1h' x) \u2192 h = h'", "decl_nm": "diffeomorph.ext", "nl_statement_of_codex": "Let $I$ and $I'$ be models with corners, $M$ and $M'$ be manifolds, and $h, h':I\\to I'$ be diffeomorphisms. Then $h=h'$ if and only if $h(x)=h'(x)$ for all $x\\in M$."}
{"formal_statement": "theorem order_le_of_coeff_ne_zero {R : Type*} [has_zero R] {\u0393 : Type*}\n\t[linear_ordered_cancel_add_comm_monoid \u0393] {x : hahn_series \u0393 R} {g : \u0393}\n\t(h : x.coeff g \u2260 0) :\n\tx.order \u2264 g", "decl_tp": "\u2200 {R : Type u_2} [_inst_2 : has_zero R] {\u0393 : Type u_1} [_inst_4 : linear_ordered_cancel_add_comm_monoid \u0393] {x : hahn_series \u0393 R} {g : \u0393}, x.coeff g \u2260 0 \u2192 x.order \u2264 g", "decl_nm": "hahn_series.order_le_of_coeff_ne_zero", "nl_statement_of_codex": "Let $x$ be a Hahn series with coefficients in a ring $R$ and let $g$ be an element of the indexing set. If the coefficient of $g$ in $x$ is nonzero, then the order of $x$ is less than or equal to $g$."}
{"formal_statement": "theorem degrees_add_of_disjoint {R : Type u} {\u03c3 : Type*} [comm_semiring R]\n\t{p q : mv_polynomial \u03c3 R} (h : p.degrees.disjoint q.degrees) :\n\t(p + q).degrees = p.degrees \u222a q.degrees", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] {p q : mv_polynomial \u03c3 R}, p.degrees.disjoint q.degrees \u2192 (p + q).degrees = p.degrees \u222a q.degrees", "decl_nm": "mv_polynomial.degrees_add_of_disjoint", "nl_statement_of_codex": "Let $p$ and $q$ be multivariate polynomials over a commutative semiring $R$. If the degrees of $p$ and $q$ are disjoint, then the degrees of $p+q$ are the union of the degrees of $p$ and $q$."}
{"formal_statement": "theorem to_power_series_apply {R : Type*} [semiring R] (f : hahn_series \u2115 R) :\n\t\u21d1hahn_series.to_power_series f = power_series.mk f.coeff", "decl_tp": "\u2200 {R : Type u_2} [_inst_1 : semiring R] (f : hahn_series \u2115 R), \u21d1hahn_series.to_power_series f = power_series.mk f.coeff", "decl_nm": "hahn_series.to_power_series_apply", "nl_statement_of_codex": "The power series associated to a Hahn series is the power series with the same coefficients."}
{"formal_statement": "theorem times_cont_diff_on_univ {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {n : with_top \u2115} :\n\ttimes_cont_diff_on \ud835\udd5c n f set.univ \u2194 times_cont_diff \ud835\udd5c n f", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {n : with_top \u2115}, times_cont_diff_on \ud835\udd5c n f set.univ \u2194 times_cont_diff \ud835\udd5c n f", "decl_nm": "times_cont_diff_on_univ", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Then $f:E\\to F$ is $n$-times continuously differentiable if and only if $f$ is $n$-times continuously differentiable on $E$."}
{"formal_statement": "theorem map_\u03c3 {\u03b1 \u03b2 : Type*} (m : \u03b1 \u2192 \u03b2) {f : filter \u03b1} (F : f.realizer) :\n\t(filter.realizer.map m F).\u03c3 = F.\u03c3", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (m : \u03b1 \u2192 \u03b2) {f : filter \u03b1} (F : f.realizer), (filter.realizer.map m F).\u03c3 = F.\u03c3", "decl_nm": "filter.realizer.map_\u03c3", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Let $F$ be a filter on $X$. Then $f(F)$ is a filter on $Y$."}
{"formal_statement": "theorem union_inter_distrib_left {\u03b1 : Type u} {s t u : set \u03b1} :\n\ts \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)", "decl_tp": "\u2200 {\u03b1 : Type u} {s t u : set \u03b1}, s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)", "decl_nm": "set.union_inter_distrib_left", "nl_statement_of_codex": "$(A\\cup B)\\cap C = (A\\cap C)\\cup (B\\cap C)$."}
{"formal_statement": "theorem add_lt_of_add_lt_left {\u03b1 : Type*} {a b c d : \u03b1} [preorder \u03b1] [has_add \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] (h : a + b < c) (hle : d \u2264 b) :\n\ta + d < c", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a b c d : \u03b1} [_inst_1 : preorder \u03b1] [_inst_2 : has_add \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le], a + b < c \u2192 d \u2264 b \u2192 a + d < c", "decl_nm": "add_lt_of_add_lt_left", "nl_statement_of_codex": "Let $a,b,c,d$ be elements of a preorder with addition. If $a+b<c$ and $d\\leq b$, then $a+d<c$."}
{"formal_statement": "theorem mul_left_bijective_of_fintype\u2080 {M : Type*} [cancel_monoid_with_zero M]\n\t[fintype M] {a : M} (ha : a \u2260 0) :\n\tfunction.bijective (\u03bb (b : M), b * a)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : cancel_monoid_with_zero M] [_inst_2 : fintype M] {a : M}, a \u2260 0 \u2192 function.bijective (\u03bb (b : M), b * a)", "decl_nm": "mul_left_bijective_of_fintype\u2080", "nl_statement_of_codex": "Let $M$ be a finite monoid with zero. If $a\\in M$ is nonzero, then the map $b\\mapsto ab$ is a bijection."}
{"formal_statement": "theorem map_one {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b1] [group \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(hf : is_group_hom f) :\n\tf 1 = 1", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group \u03b1] [_inst_2 : group \u03b2] {f : \u03b1 \u2192 \u03b2}, is_group_hom f \u2192 f 1 = 1", "decl_nm": "is_group_hom.map_one", "nl_statement_of_codex": "Let $f:G\\to H$ be a group homomorphism. Then $f(1)=1$."}
{"formal_statement": "theorem to_equiv_symm_apply {\u03b1 : Sort u} (f : \u03b1 \u2192 \u03b1) (h : function.involutive f)\n\t(\u1fb0 : \u03b1) :\n\t\u21d1((function.involutive.to_equiv f h).symm) \u1fb0 = f \u1fb0", "decl_tp": "\u2200 {\u03b1 : Sort u} (f : \u03b1 \u2192 \u03b1) (h : function.involutive f) (\u1fb0 : \u03b1), \u21d1((function.involutive.to_equiv f h).symm) \u1fb0 = f \u1fb0", "decl_nm": "function.involutive.to_equiv_symm_apply", "nl_statement_of_codex": "Let $f:A\\to A$ be an involution. Then the inverse of the equivalence $f$ is given by $f$."}
{"formal_statement": "theorem map_multiset_sum {\u03b2 : Type u} {\u03b3 : Type w} [non_assoc_semiring \u03b2]\n\t[non_assoc_semiring \u03b3] (f : \u03b2 \u2192+* \u03b3) (s : multiset \u03b2) :\n\t\u21d1f s.sum = (multiset.map \u21d1f s).sum", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b3 : Type w} [_inst_1 : non_assoc_semiring \u03b2] [_inst_2 : non_assoc_semiring \u03b3] (f : \u03b2 \u2192+* \u03b3) (s : multiset \u03b2), \u21d1f s.sum = (multiset.map \u21d1f s).sum", "decl_nm": "ring_hom.map_multiset_sum", "nl_statement_of_codex": "Let $f:R\\to S$ be a ring homomorphism. Then $f(s_1+\\cdots+s_n)=f(s_1)+\\cdots+f(s_n)$ for all $s_1,\\ldots,s_n\\in R$."}
{"formal_statement": "theorem unipotent_upper_inv {C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t[category_theory.limits.has_binary_biproducts C] {X\u2081 X\u2082 : C} (r : X\u2081 \u27f6 X\u2082) :\n\t(category_theory.biprod.unipotent_upper r).inv = category_theory.biprod.of_components (\ud835\udfd9 X\u2081)\n\t(-r) 0 (\ud835\udfd9 X\u2082)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.limits.has_binary_biproducts C] {X\u2081 X\u2082 : C} (r : X\u2081 \u27f6 X\u2082), (category_theory.biprod.unipotent_upper r).inv = category_theory.biprod.of_components (\ud835\udfd9 X\u2081) (-r) 0 (\ud835\udfd9 X\u2082)", "decl_nm": "category_theory.biprod.unipotent_upper_inv", "nl_statement_of_codex": "The inverse of the unipotent upper morphism is the morphism with components $(\\mathrm{id}_{X_1}, -r, 0, \\mathrm{id}_{X_2})$."}
{"formal_statement": "theorem forget_map {J : Type u\u2081} [category_theory.category J] {C : Type u\u2083}\n\t[category_theory.category C] (F : J \u2964 C) (s t : category_theory.limits.cocone F)\n\t(f : s \u27f6 t) :\n\t(category_theory.limits.cocones.forget F).map f = f.hom", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2083} [_inst_3 : category_theory.category C] (F : J \u2964 C) (s t : category_theory.limits.cocone F) (f : s \u27f6 t), (category_theory.limits.cocones.forget F).map f = f.hom", "decl_nm": "category_theory.limits.cocones.forget_map", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor. Let $s$ and $t$ be cocones over $F$. Let $f:s\\to t$ be a morphism of cocones. Then the morphism $f$ is equal to the morphism $f$ induced by the forgetful functor from cocones over $F$ to $C$."}
{"formal_statement": "theorem zpow_pos {a : ennreal} (ha : a \u2260 0) (h'a : a \u2260 \u22a4) :\n\t\u2200 (n : \u2124), 0 < a ^ n", "decl_tp": "\u2200 {a : ennreal}, a \u2260 0 \u2192 a \u2260 \u22a4 \u2192 \u2200 (n : \u2124), 0 < a ^ n", "decl_nm": "ennreal.zpow_pos", "nl_statement_of_codex": "Let $a$ be a positive real number. Then $a^n$ is positive for all $n\\in\\mathbb{Z}$."}
{"formal_statement": "theorem eq_zero_of_dvd_of_div_eq_zero {a b : \u2115} (w : a \u2223 b) (h : b / a = 0) :\n\tb = 0", "decl_tp": "\u2200 {a b : \u2115}, a \u2223 b \u2192 b / a = 0 \u2192 b = 0", "decl_nm": "nat.eq_zero_of_dvd_of_div_eq_zero", "nl_statement_of_codex": "If $a$ divides $b$ and $b/a=0$, then $b=0$."}
{"formal_statement": "theorem val_to_finset {\u03b1 : Type*} [decidable_eq \u03b1] (s : finset \u03b1) :\n\ts.val.to_finset = s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s : finset \u03b1), s.val.to_finset = s", "decl_nm": "finset.val_to_finset", "nl_statement_of_codex": "The finset associated to a finset is the finset itself."}
{"formal_statement": "theorem head_eq_destruct {\u03b1 : Type u} (s : seq \u03b1) :\n\ts.head = prod.fst <$> s.destruct", "decl_tp": "\u2200 {\u03b1 : Type u} (s : seq \u03b1), s.head = prod.fst <$> s.destruct", "decl_nm": "seq.head_eq_destruct", "nl_statement_of_codex": "The head of a sequence is the first element of the sequence."}
{"formal_statement": "theorem set_bInter_singleton {\u03b1 \u03b2 : Type*} (a : \u03b1) (s : \u03b1 \u2192 set \u03b2) :\n\t(\u22c2 (x : \u03b1) (H : x \u2208 {a}), s x) = s a", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (a : \u03b1) (s : \u03b1 \u2192 set \u03b2), (\u22c2 (x : \u03b1) (H : x \u2208 {a}), s x) = s a", "decl_nm": "finset.set_bInter_singleton", "nl_statement_of_codex": "Let $a$ be an element of a set $A$ and let $s:A\\to\\mathcal{P}(B)$ be a function. Then $\\bigcap_{x\\in\\{a\\}}s(x)=s(a)$."}
{"formal_statement": "theorem of_free_monoid_comp_free_mk {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) :\n\tmonoid.foldl.of_free_monoid f \u2218 traversable.free.mk = monoid.foldl.mk \u2218 flip f", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1), monoid.foldl.of_free_monoid f \u2218 traversable.free.mk = monoid.foldl.mk \u2218 flip f", "decl_nm": "traversable.foldl.of_free_monoid_comp_free_mk", "nl_statement_of_codex": "Let $f:\\alpha\\times\\beta\\to\\alpha$. Then $\\mathrm{foldl}(f)\\circ\\mathrm{mk}=\\mathrm{mk}\\circ f$."}
{"formal_statement": "theorem forall {\u03b1 : Type*} {p : option \u03b1 \u2192 Prop} :\n\t(\u2200 (x : option \u03b1), p x) \u2194 p option.none \u2227 \u2200 (x : \u03b1), p (option.some x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {p : option \u03b1 \u2192 Prop}, (\u2200 (x : option \u03b1), p x) \u2194 p option.none \u2227 \u2200 (x : \u03b1), p (option.some x)", "decl_nm": "option.forall", "nl_statement_of_codex": "For all $x\\in\\alpha$, $p(x)$ holds if and only if $p(none)$ holds and $p(some(x))$ holds for all $x\\in\\alpha$."}
{"formal_statement": "theorem exists_left_complement'_of_coprime {G : Type u} [group G] {N : subgroup G}\n\t[N.normal] (hN : (nat.card \u21a5N).coprime N.index) :\n\t(\u2203 (H : subgroup G), H.is_complement' N)", "decl_tp": "\u2200 {G : Type u} [_inst_1 : group G] {N : subgroup G} [_inst_2 : N.normal], (nat.card \u21a5N).coprime N.index \u2192 (\u2203 (H : subgroup G), H.is_complement' N)", "decl_nm": "subgroup.exists_left_complement'_of_coprime", "nl_statement_of_codex": "Let $G$ be a group and let $N$ be a normal subgroup of $G$. If $|N|$ and $[G:N]$ are coprime, then $G$ has a complement to $N$."}
{"formal_statement": "theorem prod_eq_foldr {\u03b1 : Type*} [comm_monoid \u03b1] (s : multiset \u03b1) :\n\ts.prod = multiset.foldr has_mul.mul _ 1 s", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_1 : comm_monoid \u03b1] (s : multiset \u03b1), s.prod = multiset.foldr has_mul.mul _ 1 s", "decl_nm": "multiset.prod_eq_foldr", "nl_statement_of_codex": "The product of the elements of a multiset $s$ is equal to the fold of the multiset $s$."}
{"formal_statement": "theorem comp_neg {C : Type u} [category_theory.category C] [category_theory.preadditive C]\n\t{P Q R : C} (f : P \u27f6 Q) (g : Q \u27f6 R) :\n\tf \u226b -g = -f \u226b g", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] {P Q R : C} (f : P \u27f6 Q) (g : Q \u27f6 R), f \u226b -g = -f \u226b g", "decl_nm": "category_theory.preadditive.comp_neg", "nl_statement_of_codex": "Let $C$ be a preadditive category. Let $f:P\\to Q$ and $g:Q\\to R$ be morphisms in $C$. Then $f\\circ (-g)=(-f)\\circ g$."}
{"formal_statement": "theorem supr_disjoint_iff {\u03b1 : Type u} {\u03b9 : Sort w} [complete_distrib_lattice \u03b1]\n\t{a : \u03b1} {f : \u03b9 \u2192 \u03b1} :\n\tdisjoint (\u2a06 (i : \u03b9), f i) a \u2194 \u2200 (i : \u03b9), disjoint (f i) a", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b9 : Sort w} [_inst_1 : complete_distrib_lattice \u03b1] {a : \u03b1} {f : \u03b9 \u2192 \u03b1}, disjoint (\u2a06 (i : \u03b9), f i) a \u2194 \u2200 (i : \u03b9), disjoint (f i) a", "decl_nm": "supr_disjoint_iff", "nl_statement_of_codex": "Let $\u03b1$ be a complete distributive lattice and let $f:I\\to \u03b1$ be a function. Then $\\bigvee_{i\\in I}f(i)$ is disjoint from $a$ if and only if $f(i)$ is disjoint from $a$ for all $i\\in I$."}
{"formal_statement": "theorem le_is_glb_image {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (Hf : monotone f) (Ha : is_glb s a) (Hb : is_glb (f '' s) b) :\n\t\u2200 {a : \u03b1} {s : set \u03b1},  \u2200 {b : \u03b2},  f a \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, monotone f \u2192 \u2200 {a : \u03b1} {s : set \u03b1}, is_glb s a \u2192 \u2200 {b : \u03b2}, is_glb (f '' s) b \u2192 f a \u2264 b", "decl_nm": "monotone.le_is_glb_image", "nl_statement_of_codex": "Let $f:A\\to B$ be a monotone function. Let $a$ be the greatest lower bound of $A$ and let $b$ be the greatest lower bound of $f(A)$. Then $f(a)\\leq b$."}
{"formal_statement": "theorem admissible_D' (n : \u2115+) :\n\tADE_inequality.admissible (ADE_inequality.D' n)", "decl_tp": "\u2200 (n : \u2115+), ADE_inequality.admissible (ADE_inequality.D' n)", "decl_nm": "ADE_inequality.admissible_D'", "nl_statement_of_codex": "The function $D'_n$ is admissible."}
{"formal_statement": "theorem preimage_mul_const_Iic_of_neg {k : Type u} [linear_ordered_field k]\n\t(a : k) {c : k} (h : c < 0) :\n\t(\u03bb (x : k), x * c) \u207b\u00b9' set.Iic a = set.Ici (a / c)", "decl_tp": "\u2200 {k : Type u} [_inst_1 : linear_ordered_field k] (a : k) {c : k}, c < 0 \u2192 (\u03bb (x : k), x * c) \u207b\u00b9' set.Iic a = set.Ici (a / c)", "decl_nm": "set.preimage_mul_const_Iic_of_neg", "nl_statement_of_codex": "Let $k$ be a linear ordered field, let $a\\in k$, and let $c\\in k$ be negative. Then the preimage of the interval $(a,\\infty)$ under the function $x\\mapsto cx$ is the interval $(a/c,\\infty)$."}
{"formal_statement": "theorem card_Ico (a b : \u2115+) :\n\t(finset.Ico a b).card = \u2191b - \u2191a", "decl_tp": "\u2200 (a b : \u2115+), (finset.Ico a b).card = \u2191b - \u2191a", "decl_nm": "pnat.card_Ico", "nl_statement_of_codex": "The cardinality of the set $\\{a, a+1, \\ldots, b-1\\}$ is $b-a$."}
{"formal_statement": "theorem le_Prop_eq has_le.le = \u03bb (_x _y : Prop) :\n\t_x \u2192 _y", "decl_tp": "has_le.le = \u03bb (_x _y : Prop), _x \u2192 _y", "decl_nm": "le_Prop_eq", "nl_statement_of_codex": "The relation $x\\leq y$ on propositions is the implication $x\\to y$."}
{"formal_statement": "theorem ne_of_irrefl {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [is_irrefl \u03b1 r] {x y : \u03b1}\n\t(\u1fb0 : r x y) :\n\tx \u2260 y", "decl_tp": "\u2200 {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : is_irrefl \u03b1 r] {x y : \u03b1}, r x y \u2192 x \u2260 y", "decl_nm": "ne_of_irrefl", "nl_statement_of_codex": "Let $r$ be a reflexive relation on $X$. If $r$ is irreflexive, then $x\\neq y$ whenever $x$ is related to $y$ by $r$."}
{"formal_statement": "theorem coe_sub {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [has_sub \u03b2] (f g : measure_theory.simple_func \u03b1 \u03b2) :\n\t\u21d1(f - g) = \u21d1f - \u21d1g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : has_sub \u03b2] (f g : measure_theory.simple_func \u03b1 \u03b2), \u21d1(f - g) = \u21d1f - \u21d1g", "decl_nm": "measure_theory.simple_func.coe_sub", "nl_statement_of_codex": "Let $f,g:\\Omega\\to\\mathbb{R}$ be simple functions. Then $\\chi_{\\{f>g\\}}=\\chi_{\\{f>g\\}}-\\chi_{\\{f\\leq g\\}}$."}
{"formal_statement": "theorem erase_dup_add {\u03b1 : Type*} [decidable_eq \u03b1] (s t : multiset \u03b1) :\n\t(s + t).erase_dup = s.ndunion t.erase_dup", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s t : multiset \u03b1), (s + t).erase_dup = s.ndunion t.erase_dup", "decl_nm": "multiset.erase_dup_add", "nl_statement_of_codex": "Let $s$ and $t$ be multisets. Then $(s+t)_{\\text{nd}}=s_{\\text{nd}}\\cup t_{\\text{nd}}$."}
{"formal_statement": "theorem truncate_map_f {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V]\n\t(C D : cochain_complex V \u2115) (f : C \u27f6 D) (i : \u2115) :\n\t(cochain_complex.truncate.map f).f i = f.f (i + 1)", "decl_tp": "\u2200 {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] (C D : cochain_complex V \u2115) (f : C \u27f6 D) (i : \u2115), (cochain_complex.truncate.map f).f i = f.f (i + 1)", "decl_nm": "cochain_complex.truncate_map_f", "nl_statement_of_codex": "Let $C$ and $D$ be cochain complexes over a category $V$ with zero morphisms. Let $f:C\\to D$ be a morphism of cochain complexes. Then the map $f$ induces a map $f_i:C_i\\to D_i$ for each $i\\in\\mathbb{N}$."}
{"formal_statement": "theorem decode_eq_of_nat (\u03b1 : Type*) [denumerable \u03b1] (n : \u2115) :\n\tencodable.decode \u03b1 n = option.some (denumerable.of_nat \u03b1 n)", "decl_tp": "\u2200 (\u03b1 : Type u_1) [_inst_3 : denumerable \u03b1] (n : \u2115), encodable.decode \u03b1 n = option.some (denumerable.of_nat \u03b1 n)", "decl_nm": "denumerable.decode_eq_of_nat", "nl_statement_of_codex": "Let $\u03b1$ be a denumerable type. Then the $n$-th element of $\u03b1$ is $n$."}
{"formal_statement": "theorem ker_inclusion {G : Type*} [group G] {H K : subgroup G} (h : H \u2264 K) :\n\t(subgroup.inclusion h).ker = \u22a5", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H K : subgroup G} (h : H \u2264 K), (subgroup.inclusion h).ker = \u22a5", "decl_nm": "subgroup.ker_inclusion", "nl_statement_of_codex": "Let $G$ be a group and let $H$ and $K$ be subgroups of $G$. If $H\\leq K$, then the kernel of the inclusion map $H\\to K$ is trivial."}
{"formal_statement": "theorem \u03c0_of_\u03c0 {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C]\n\t{X Y P : C} (f : X \u27f6 Y) (\u03c0 : Y \u27f6 P) (w : f \u226b \u03c0 = 0) :\n\tcategory_theory.limits.cofork.\u03c0 (category_theory.limits.cokernel_cofork.of_\u03c0 \u03c0 w) = \u03c0", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] {X Y P : C} (f : X \u27f6 Y) (\u03c0 : Y \u27f6 P) (w : f \u226b \u03c0 = 0), category_theory.limits.cofork.\u03c0 (category_theory.limits.cokernel_cofork.of_\u03c0 \u03c0 w) = \u03c0", "decl_nm": "category_theory.limits.cokernel_cofork.\u03c0_of_\u03c0", "nl_statement_of_codex": "Let $C$ be a category with zero morphisms. Let $X, Y, P$ be objects of $C$ and let $f:X\\to Y$ and $\\pi:Y\\to P$ be morphisms of $C$. If $f\\circ \\pi=0$, then the cokernel of $\\pi$ is the same as the cokernel of $f$."}
{"formal_statement": "theorem subset_closure_image_preimage_of_is_open {\u03b2 : Type*} [topological_space \u03b2]\n\t{\u03ba : Type*} {f : \u03ba \u2192 \u03b2} (hf : dense_range f) (hs : is_open s) :\n\t\u2200 {s : set \u03b2},  s \u2286 closure (f '' (f \u207b\u00b9' s))", "decl_tp": "\u2200 {\u03b2 : Type u_2} [_inst_2 : topological_space \u03b2] {\u03ba : Type u_5} {f : \u03ba \u2192 \u03b2}, dense_range f \u2192 \u2200 {s : set \u03b2}, is_open s \u2192 s \u2286 closure (f '' (f \u207b\u00b9' s))", "decl_nm": "dense_range.subset_closure_image_preimage_of_is_open", "nl_statement_of_codex": "Let $f:X\\to Y$ be a dense map between topological spaces. Then for any open set $U\\subset Y$, $U$ is contained in the closure of $f(f^{-1}(U))$."}
{"formal_statement": "theorem limsup_slope_le {f : \u211d \u2192 \u211d} {f' : \u211d} {s : set \u211d} {x r : \u211d} (hf : has_deriv_within_at f f' s x)\n\t(hr : f' < r) :\n\t(\u2200\u1da0 (z : \u211d) in nhds_within x (s \\ {x}), (z - x)\u207b\u00b9 * (f z - f x) < r)", "decl_tp": "\u2200 {f : \u211d \u2192 \u211d} {f' : \u211d} {s : set \u211d} {x r : \u211d}, has_deriv_within_at f f' s x \u2192 f' < r \u2192 (\u2200\u1da0 (z : \u211d) in nhds_within x (s \\ {x}), (z - x)\u207b\u00b9 * (f z - f x) < r)", "decl_nm": "has_deriv_within_at.limsup_slope_le", "nl_statement_of_codex": "Let $f: \\mathbb{R}\\to\\mathbb{R}$ be differentiable at $x$ with derivative $f'(x)$. If $f'(x)<r$, then for all $z$ sufficiently close to $x$ we have $(z-x)^{-1}(f(z)-f(x))<r$."}
{"formal_statement": "theorem antitone_app {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [preorder \u03b1]\n\t[preorder \u03b3] (f : \u03b2 \u2192 \u03b1 \u2192 \u03b3) (b : \u03b2) (hf : antitone (\u03bb (a : \u03b1) (b : \u03b2), f b a)) :\n\tantitone (f b)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b3] (f : \u03b2 \u2192 \u03b1 \u2192 \u03b3) (b : \u03b2), antitone (\u03bb (a : \u03b1) (b : \u03b2), f b a) \u2192 antitone (f b)", "decl_nm": "antitone_app", "nl_statement_of_codex": "Let $f: \\beta\\times\\alpha\\to\\gamma$ be a function. If $f$ is antitone in its first argument, then $f(b,\\cdot)$ is antitone for each $b\\in\\beta$."}
{"formal_statement": "theorem ret_left {\u03b1 : Type u} {\u03b2 : Type v} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : computation \u03b1 \u2192 computation \u03b2 \u2192 Prop)\n\t(a : \u03b1) (cb : computation \u03b2) :\n\tcomputation.lift_rel_aux R C (sum.inl a) cb.destruct \u2194 \u2203 {b : \u03b2}, b \u2208 cb \u2227 R a b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : computation \u03b1 \u2192 computation \u03b2 \u2192 Prop) (a : \u03b1) (cb : computation \u03b2), computation.lift_rel_aux R C (sum.inl a) cb.destruct \u2194 \u2203 {b : \u03b2}, b \u2208 cb \u2227 R a b", "decl_nm": "computation.lift_rel_aux.ret_left", "nl_statement_of_codex": "Let $R$ and $C$ be relations on $\\alpha$ and $\\beta$, respectively. Let $a$ be an element of $\\alpha$ and let $cb$ be a computation on $\\beta$. Then $a$ is related to $cb$ by $C$ if and only if there is an element $b$ of $cb$ such that $a$ is related to $b$ by $R$."}
{"formal_statement": "theorem dvd_left_injective :\n\tfunction.injective has_dvd.dvd", "decl_tp": "function.injective has_dvd.dvd", "decl_nm": "nat.dvd_left_injective", "nl_statement_of_codex": "The relation $a\\mid b$ is left-injective."}
{"formal_statement": "theorem lintegral_zero {\u03b1 : Type*} [measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} :\n\t0.lintegral = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1}, 0.lintegral = 0", "decl_nm": "measure_theory.ae_eq_fun.lintegral_zero", "nl_statement_of_codex": "The Lebesgue integral of the zero function is zero."}
{"formal_statement": "theorem coe_comp_tendsto {\u03b1 \u03b2 \u03b3 : Type*} {l : filter \u03b1} (f : \u03b1 \u2192 \u03b2) {lc : filter \u03b3}\n\t{g : \u03b3 \u2192 \u03b1} (hg : filter.tendsto g lc l) :\n\t\u2191f.comp_tendsto g hg = \u2191(f \u2218 g)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {l : filter \u03b1} (f : \u03b1 \u2192 \u03b2) {lc : filter \u03b3} {g : \u03b3 \u2192 \u03b1} (hg : filter.tendsto g lc l), \u2191f.comp_tendsto g hg = \u2191(f \u2218 g)", "decl_nm": "filter.germ.coe_comp_tendsto", "nl_statement_of_codex": "Let $f:X\\to Y$ and $g:Z\\to X$ be functions. Then $\\lim_{z\\to z_0} f(g(z))=f(\\lim_{z\\to z_0} g(z))$."}
{"formal_statement": "theorem sub' {G \u03b1 : Type*} [measurable_space G] [has_sub G] [measurable_space \u03b1]\n\t[has_measurable_sub\u2082 G] {f g : \u03b1 \u2192 G} (hf : measurable f) (hg : measurable g) :\n\tmeasurable (f - g)", "decl_tp": "\u2200 {G : Type u_1} {\u03b1 : Type u_2} [_inst_1 : measurable_space G] [_inst_2 : has_sub G] [_inst_3 : measurable_space \u03b1] [_inst_4 : has_measurable_sub\u2082 G] {f g : \u03b1 \u2192 G}, measurable f \u2192 measurable g \u2192 measurable (f - g)", "decl_nm": "measurable.sub'", "nl_statement_of_codex": "Let $G$ be a measurable space and let $f,g:\\alpha\\to G$ be measurable functions. Then $f-g$ is measurable."}
{"formal_statement": "theorem mem_map_of_mem {G : Type*} [group G] {N : Type*} [group N] (f : G \u2192* N)\n\t{K : subgroup G} {x : G} (hx : x \u2208 K) :\n\t\u21d1f x \u2208 subgroup.map f K", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] (f : G \u2192* N) {K : subgroup G} {x : G}, x \u2208 K \u2192 \u21d1f x \u2208 subgroup.map f K", "decl_nm": "subgroup.mem_map_of_mem", "nl_statement_of_codex": "Let $G$ be a group and let $N$ be a normal subgroup of $G$. Let $K$ be a subgroup of $G$. Then the image of $K$ under the quotient map $G\\to G/N$ is a subgroup of $G/N$."}
{"formal_statement": "theorem dim_le_of_surjective {R : Type u} [ring R] {M : Type v} [add_comm_group M]\n\t[module R M] {M\u2081 : Type v} [add_comm_group M\u2081] [module R M\u2081] (f : M \u2192\u2097[R] M\u2081)\n\t(h : function.surjective \u21d1f) :\n\tmodule.rank R M\u2081 \u2264 module.rank R M", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {M : Type v} [_inst_2 : add_comm_group M] [_inst_3 : module R M] {M\u2081 : Type v} [_inst_6 : add_comm_group M\u2081] [_inst_7 : module R M\u2081] (f : M \u2192\u2097[R] M\u2081), function.surjective \u21d1f \u2192 module.rank R M\u2081 \u2264 module.rank R M", "decl_nm": "linear_map.dim_le_of_surjective", "nl_statement_of_codex": "Let $R$ be a ring, $M$ and $M_1$ be $R$-modules. If $f:M\\to M_1$ is a surjective $R$-linear map, then $\\dim_R M_1\\leq \\dim_R M$."}
{"formal_statement": "theorem csupr_false {\u03b1 : Type*} [conditionally_complete_linear_order_bot \u03b1]\n\t(f : false \u2192 \u03b1) :\n\t(\u2a06 (i : false), f i) = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : conditionally_complete_linear_order_bot \u03b1] (f : false \u2192 \u03b1), (\u2a06 (i : false), f i) = \u22a5", "decl_nm": "csupr_false", "nl_statement_of_codex": "Let $X$ be a conditionally complete linear order with bottom. Then $\\sup_{i\\in\\emptyset} f(i)=\\bot$."}
{"formal_statement": "theorem map_matrix_apply {m : Type*} {\u03b1 : Type v} {\u03b2 : Type w} [fintype m]\n\t[decidable_eq m] [non_assoc_semiring \u03b1] [non_assoc_semiring \u03b2] (f : \u03b1 \u2192+* \u03b2)\n\t(M : matrix m m \u03b1) :\n\t\u21d1(f.map_matrix) M = M.map \u21d1f", "decl_tp": "\u2200 {m : Type u_2} {\u03b1 : Type v} {\u03b2 : Type w} [_inst_1 : fintype m] [_inst_2 : decidable_eq m] [_inst_3 : non_assoc_semiring \u03b1] [_inst_4 : non_assoc_semiring \u03b2] (f : \u03b1 \u2192+* \u03b2) (M : matrix m m \u03b1), \u21d1(f.map_matrix) M = M.map \u21d1f", "decl_nm": "ring_hom.map_matrix_apply", "nl_statement_of_codex": "Let $f:A\\to B$ be a ring homomorphism. Then $f$ induces a ring homomorphism $f:M_n(A)\\to M_n(B)$ by $f(M)=f(M_{ij})$."}
{"formal_statement": "theorem maps_to {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2}\n\t{f' : \u03b2 \u2192 \u03b1} (h : set.left_inv_on f' f s) (hf : set.surj_on f s t) :\n\tset.maps_to f' t s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1}, set.left_inv_on f' f s \u2192 set.surj_on f s t \u2192 set.maps_to f' t s", "decl_nm": "set.left_inv_on.maps_to", "nl_statement_of_codex": "Let $f:A\\to B$ and $f':B\\to A$ be functions. If $f'$ is a left inverse of $f$ and $f$ is surjective, then $f'$ is a right inverse of $f$."}
{"formal_statement": "theorem is_subring {R : Type u} [ring R] {s : set R} :\n\tis_subring (ring.closure s)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {s : set R}, is_subring (ring.closure s)", "decl_nm": "ring.closure.is_subring", "nl_statement_of_codex": "The closure of a subset $s$ of a ring $R$ is a subring of $R$."}
{"formal_statement": "theorem is_wf_sup {\u03b1 \u03b9 : Type*} [partial_order \u03b1] (f : finset \u03b9) (g : \u03b9 \u2192 set \u03b1) :\n\t(\u2200 (i : \u03b9), i \u2208 f \u2192 (g i).is_wf) \u2192 (f.sup g).is_wf", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : partial_order \u03b1] (f : finset \u03b9) (g : \u03b9 \u2192 set \u03b1), (\u2200 (i : \u03b9), i \u2208 f \u2192 (g i).is_wf) \u2192 (f.sup g).is_wf", "decl_nm": "finset.is_wf_sup", "nl_statement_of_codex": "Let $f$ be a finite set and let $g:f\\to \\mathcal{P}(X)$ be a function. If $g(i)$ is well-founded for each $i\\in f$, then $\\bigcup_{i\\in f}g(i)$ is well-founded."}
{"formal_statement": "theorem upper_semicontinuous_on_const {\u03b1 : Type*} [topological_space \u03b1]\n\t{\u03b2 : Type*} [preorder \u03b2] {s : set \u03b1} {z : \u03b2} :\n\tupper_semicontinuous_on (\u03bb (x : \u03b1), z) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {s : set \u03b1} {z : \u03b2}, upper_semicontinuous_on (\u03bb (x : \u03b1), z) s", "decl_nm": "upper_semicontinuous_on_const", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a preordered set. Then the constant function $f:X\\to Y$ is upper semicontinuous."}
{"formal_statement": "theorem cod_restrict_apply {\u03b1 \u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n\t(p : set \u03b2) (f : r \u21aar s) (H : \u2200 (a : \u03b1), \u21d1f a \u2208 p) (a : \u03b1) :\n\t\u21d1(rel_embedding.cod_restrict p f H) a = \u27e8\u21d1f a, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (p : set \u03b2) (f : r \u21aar s) (H : \u2200 (a : \u03b1), \u21d1f a \u2208 p) (a : \u03b1), \u21d1(rel_embedding.cod_restrict p f H) a = \u27e8\u21d1f a, _\u27e9", "decl_nm": "rel_embedding.cod_restrict_apply", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Let $p$ be a subset of $B$. Let $H$ be a predicate on $A$. Then the function $f':A\\to p$ defined by $f'(a)=f(a)$ if $H(a)$ and $f'(a)=\\bot$ otherwise is a restriction of $f$."}
{"formal_statement": "theorem of_braided_obj_fst {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t[category_theory.braided_category C] (X : C) :\n\t(category_theory.center.of_braided_obj X).fst = X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] [_inst_3 : category_theory.braided_category C] (X : C), (category_theory.center.of_braided_obj X).fst = X", "decl_nm": "category_theory.center.of_braided_obj_fst", "nl_statement_of_codex": "The first component of the center of a braided object $X$ is $X$."}
{"formal_statement": "theorem parallel_pair_diagram_map {C : Type u} [category_theory.category C]\n\t(I : category_theory.limits.multicospan_index C) [category_theory.limits.has_product I.left]\n\t[category_theory.limits.has_product I.right] (x y : category_theory.limits.walking_parallel_pair)\n\t(h : x \u27f6 y) :\n\tI.parallel_pair_diagram.map h = category_theory.limits.parallel_pair._match_2 I.fst_pi_map I.snd_pi_map x y h", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (I : category_theory.limits.multicospan_index C) [_inst_2 : category_theory.limits.has_product I.left] [_inst_3 : category_theory.limits.has_product I.right] (x y : category_theory.limits.walking_parallel_pair) (h : x \u27f6 y), I.parallel_pair_diagram.map h = category_theory.limits.parallel_pair._match_2 I.fst_pi_map I.snd_pi_map x y h", "decl_nm": "category_theory.limits.multicospan_index.parallel_pair_diagram_map", "nl_statement_of_codex": "Let $C$ be a category, $I$ a multicospan index, $x,y$ a walking parallel pair, and $h:x\\to y$. Then the map $I.parallel_pair_diagram.map h$ is equal to the map $I.fst_pi_map$ and $I.snd_pi_map$."}
{"formal_statement": "theorem eq_zero_of_eval_eq_zero {F' : Type u} [field F'] (s' : finset F')\n\t{f : polynomial F'} (hf1 : f.degree < \u2191(s'.card)) :\n\t(\u2200 (x : F'), x \u2208 s' \u2192 polynomial.eval x f = 0) \u2192 f = 0", "decl_tp": "\u2200 {F' : Type u} [_inst_3 : field F'] (s' : finset F') {f : polynomial F'}, f.degree < \u2191(s'.card) \u2192 (\u2200 (x : F'), x \u2208 s' \u2192 polynomial.eval x f = 0) \u2192 f = 0", "decl_nm": "lagrange.eq_zero_of_eval_eq_zero", "nl_statement_of_codex": "Let $F'$ be a field and let $s'$ be a finite subset of $F'$. Let $f$ be a polynomial over $F'$ of degree less than $|s'|$. If $f$ evaluates to zero at every point of $s'$, then $f$ is the zero polynomial."}
{"formal_statement": "theorem is_open_analytic_at (\ud835\udd5c : Type*) [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t[complete_space F] (f : E \u2192 F) :\n\tis_open {x : E | analytic_at \ud835\udd5c f x}", "decl_tp": "\u2200 (\ud835\udd5c : Type u_1) [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] [_inst_8 : complete_space F] (f : E \u2192 F), is_open {x : E | analytic_at \ud835\udd5c f x}", "decl_nm": "is_open_analytic_at", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$. Then the set of points where $f$ is analytic is open in $E$."}
{"formal_statement": "theorem rel_head {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {x y : \u03b1} {l : list \u03b1}\n\t(h : list.chain' R (x :: y :: l)) :\n\tR x y", "decl_tp": "\u2200 {\u03b1 : Type u} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {x y : \u03b1} {l : list \u03b1}, list.chain' R (x :: y :: l) \u2192 R x y", "decl_nm": "list.chain'.rel_head", "nl_statement_of_codex": "Let $R$ be a relation on a type $\u03b1$. Let $x,y$ be elements of $\u03b1$ and let $l$ be a list of elements of $\u03b1$.\nIf $R$ is a chain on $x::y::l$, then $R$ holds for $x$ and $y$."}
{"formal_statement": "theorem map_const_rev_eq_done {\u03b1 \u03b2 : Type} {p : parser \u03b1} {cb : char_buffer}\n\t{n n' : \u2115} {b b' : \u03b2} :\n\t(p $> b) cb n = parse_result.done n' b' \u2194 \u2203 (a : \u03b1), p cb n = parse_result.done n' a \u2227 b = b'", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type} {p : parser \u03b1} {cb : char_buffer} {n n' : \u2115} {b b' : \u03b2}, (p $> b) cb n = parse_result.done n' b' \u2194 \u2203 (a : \u03b1), p cb n = parse_result.done n' a \u2227 b = b'", "decl_nm": "parser.map_const_rev_eq_done", "nl_statement_of_codex": "Let $p$ be a parser of type $\\alpha$ and let $b$ be a value of type $\\beta$. Then $p$ succeeds with value $b$ if and only if $p$ succeeds with some value $a$ of type $\\alpha$ and $b=b'$."}
{"formal_statement": "theorem eq_bot_of_top_is_compl {\u03b1 : Type u} [lattice \u03b1] [bounded_order \u03b1]\n\t{x : \u03b1} (h : is_compl \u22a4 x) :\n\tx = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : bounded_order \u03b1] {x : \u03b1}, is_compl \u22a4 x \u2192 x = \u22a5", "decl_nm": "eq_bot_of_top_is_compl", "nl_statement_of_codex": "Let $L$ be a bounded lattice. If $x$ is the complement of $\\top$, then $x=\\bot$."}
{"formal_statement": "theorem to_real_add_le {a b : ennreal} :\n\t(a + b).to_real \u2264 a.to_real + b.to_real", "decl_tp": "\u2200 {a b : ennreal}, (a + b).to_real \u2264 a.to_real + b.to_real", "decl_nm": "ennreal.to_real_add_le", "nl_statement_of_codex": "For any extended nonnegative real numbers $a, b$, we have $a+b\\leq a.to\\_real+b.to\\_real$."}
{"formal_statement": "theorem chromatic_number_bdd_below {V : Type u} {G : simple_graph V} :\n\tbdd_below {n : \u2115 | G.colorable n}", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V}, bdd_below {n : \u2115 | G.colorable n}", "decl_nm": "simple_graph.chromatic_number_bdd_below", "nl_statement_of_codex": "The chromatic number of a simple graph is bounded below by the natural numbers."}
{"formal_statement": "theorem left_add_coset_equivalence_rel {\u03b1 : Type*} [has_add \u03b1] (s : set \u03b1) :\n\tequivalence (left_add_coset_equivalence s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_add \u03b1] (s : set \u03b1), equivalence (left_add_coset_equivalence s)", "decl_nm": "left_add_coset_equivalence_rel", "nl_statement_of_codex": "The relation $x\\sim y$ if and only if $x-y\\in s$ is an equivalence relation on $\\alpha$."}
{"formal_statement": "theorem of_inf_ae {\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{f : filter \u03b1} :\n\t\u03bc.finite_at_filter (f \u2293 \u03bc.ae) \u2192 \u03bc.finite_at_filter f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : filter \u03b1}, \u03bc.finite_at_filter (f \u2293 \u03bc.ae) \u2192 \u03bc.finite_at_filter f", "decl_nm": "measure_theory.measure.finite_at_filter.of_inf_ae", "nl_statement_of_codex": "Let $f$ be a filter on a measurable space $(X,\\mathcal{A})$ and let $\\mu$ be a measure on $\\mathcal{A}$. If $\\mu$ is finite on the filter $f\\wedge\\mu$-almost everywhere, then $\\mu$ is finite on $f$."}
{"formal_statement": "theorem nat_iso_hom_app {C : Type u\u2082} [category_theory.category C] {I : Type u\u2081}\n\t{F G : category_theory.discrete I \u2964 C} (f : \u03a0 (i : category_theory.discrete I), F.obj i \u2245 G.obj i)\n\t(i : I) :\n\t(category_theory.discrete.nat_iso f).hom.app i = (f i).hom", "decl_tp": "\u2200 {C : Type u\u2082} [_inst_1 : category_theory.category C] {I : Type u\u2081} {F G : category_theory.discrete I \u2964 C} (f : \u03a0 (i : category_theory.discrete I), F.obj i \u2245 G.obj i) (i : I), (category_theory.discrete.nat_iso f).hom.app i = (f i).hom", "decl_nm": "category_theory.discrete.nat_iso_hom_app", "nl_statement_of_codex": "Let $F,G:I\\to C$ be functors from a discrete category $I$ to a category $C$. Let $f:F\\to G$ be a natural transformation. Then $f_i:F(i)\\to G(i)$ is a morphism in $C$ for each $i\\in I$."}
{"formal_statement": "theorem ae_measurable_one {\u03b1 \u03b2 : Type*} [measurable_space \u03b1] [measurable_space \u03b2]\n\t{\u03bc : measure_theory.measure \u03b1} [has_one \u03b2] :\n\tae_measurable (\u03bb (a : \u03b1), 1) \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} [_inst_3 : has_one \u03b2], ae_measurable (\u03bb (a : \u03b1), 1) \u03bc", "decl_nm": "ae_measurable_one", "nl_statement_of_codex": "The function $f:\\alpha\\to\\beta$ defined by $f(a)=1$ is measurable."}
{"formal_statement": "theorem insert_val_of_not_mem {\u03b1 : Type*} [decidable_eq \u03b1] {a : \u03b1} {s : finset \u03b1}\n\t(h : a \u2209 s) :\n\t(has_insert.insert a s).val = a ::\u2098 s.val", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {s : finset \u03b1}, a \u2209 s \u2192 (has_insert.insert a s).val = a ::\u2098 s.val", "decl_nm": "finset.insert_val_of_not_mem", "nl_statement_of_codex": "Let $s$ be a finite set of elements of a type $\u03b1$ with decidable equality. If $a$ is not in $s$, then the list of elements of $s$ with $a$ inserted is $a$ followed by the list of elements of $s$."}
{"formal_statement": "theorem mk_coe {\u03b1 : Type u} [monoid \u03b1] (u : units \u03b1) (y : \u03b1) (h\u2081 : \u2191u * y = 1)\n\t(h\u2082 : y * \u2191u = 1) :\n\t{val := \u2191u, inv := y, val_inv := h\u2081, inv_val := h\u2082} = u", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] (u : units \u03b1) (y : \u03b1) (h\u2081 : \u2191u * y = 1) (h\u2082 : y * \u2191u = 1), {val := \u2191u, inv := y, val_inv := h\u2081, inv_val := h\u2082} = u", "decl_nm": "units.mk_coe", "nl_statement_of_codex": "Let $R$ be a monoid and let $u\\in R^\\times$. Then the unit $u$ is equal to the unit $({val:=u, inv:=y, val_inv:=h_1, inv_val:=h_2})$ if and only if $u\\cdot y=1$ and $y\\cdot u=1$."}
{"formal_statement": "theorem image2_singleton_left {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {t : set \u03b2}\n\t{a : \u03b1} :\n\tset.image2 f {a} t = f a '' t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {t : set \u03b2} {a : \u03b1}, set.image2 f {a} t = f a '' t", "decl_nm": "set.image2_singleton_left", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. Then $f(a,B)=f(a,\\cdot)''B$."}
{"formal_statement": "theorem eval\u2082_hom_C_id_eq_join\u2081 (\u03c3 R : Type*) [comm_semiring R] (\u03c6 : mv_polynomial (mv_polynomial \u03c3 R) R) :\n\t\u21d1(mv_polynomial.eval\u2082_hom mv_polynomial.C id) \u03c6 = \u21d1mv_polynomial.join\u2081 \u03c6", "decl_tp": "\u2200 (\u03c3 : Type u_1) (R : Type u_3) [_inst_1 : comm_semiring R] (\u03c6 : mv_polynomial (mv_polynomial \u03c3 R) R), \u21d1(mv_polynomial.eval\u2082_hom mv_polynomial.C id) \u03c6 = \u21d1mv_polynomial.join\u2081 \u03c6", "decl_nm": "mv_polynomial.eval\u2082_hom_C_id_eq_join\u2081", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $\\sigma$ be a type. Let $\\phi$ be a multivariate polynomial over $R$ with coefficients in $R[\\sigma]$. Then the evaluation of $\\phi$ at $1$ is equal to the join of $\\phi$."}
{"formal_statement": "theorem neg_le_self {\u03b1 : Type u} [add_group \u03b1] [preorder \u03b1] [covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le]\n\t{a : \u03b1} (h : 0 \u2264 a) :\n\t-a \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : preorder \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a : \u03b1}, 0 \u2264 a \u2192 -a \u2264 a", "decl_nm": "right.neg_le_self", "nl_statement_of_codex": "Let $R$ be a preordered additive group. Then $-a\\leq a$ for all $a\\in R$."}
{"formal_statement": "theorem map_id {F : Type u \u2192 Type v} {\u03b1 : Type u} [functor F] [is_lawful_functor F] :\n\tfunctor.map id = id", "decl_tp": "\u2200 {F : Type u \u2192 Type v} {\u03b1 : Type u} [_inst_1 : functor F] [_inst_2 : is_lawful_functor F], functor.map id = id", "decl_nm": "functor.map_id", "nl_statement_of_codex": "The identity function on a functor is the identity function."}
{"formal_statement": "theorem sqrt {f : \u211d \u2192 \u211d} {s : set \u211d} {f' x : \u211d} (hf : has_deriv_within_at f f' s x)\n\t(hx : f x \u2260 0) :\n\thas_deriv_within_at (\u03bb (y : \u211d), real.sqrt (f y)) (f' / (2 * real.sqrt (f x))) s x", "decl_tp": "\u2200 {f : \u211d \u2192 \u211d} {s : set \u211d} {f' x : \u211d}, has_deriv_within_at f f' s x \u2192 f x \u2260 0 \u2192 has_deriv_within_at (\u03bb (y : \u211d), real.sqrt (f y)) (f' / (2 * real.sqrt (f x))) s x", "decl_nm": "has_deriv_within_at.sqrt", "nl_statement_of_codex": "Let $f$ be a function defined on an open set $s$ and let $x$ be a point in $s$. If $f$ is differentiable at $x$ and $f(x)\\neq 0$, then $\\sqrt{f}$ is differentiable at $x$ and $(\\sqrt{f})'(x)=\\frac{f'(x)}{2\\sqrt{f(x)}}$."}
{"formal_statement": "theorem weighted_vsub_indicator_subset {k V P : Type*} [ring k] [add_comm_group V]\n\t[module k V] [S : add_torsor V P] {\u03b9 : Type*} (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P)\n\t{s\u2081 s\u2082 : finset \u03b9} (h : s\u2081 \u2286 s\u2082) :\n\t\u21d1(s\u2081.weighted_vsub p) w = \u21d1(s\u2082.weighted_vsub p) (\u2191s\u2081.indicator w)", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [S : add_torsor V P] {\u03b9 : Type u_4} (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) {s\u2081 s\u2082 : finset \u03b9}, s\u2081 \u2286 s\u2082 \u2192 \u21d1(s\u2081.weighted_vsub p) w = \u21d1(s\u2082.weighted_vsub p) (\u2191s\u2081.indicator w)", "decl_nm": "finset.weighted_vsub_indicator_subset", "nl_statement_of_codex": "Let $k$ be a ring, $V$ be a $k$-module, $P$ be an abelian group, and $S$ be a $P$-torsor. Let $w:\\iota\\to k$ and $p:\\iota\\to P$ be functions. Let $s_1, s_2$ be finite subsets of $\\iota$. If $s_1\\subset s_2$, then $\\sum_{i\\in s_1}w(i)p(i)=\\sum_{i\\in s_2}w(i)p(i)$."}
{"formal_statement": "theorem one_div_mul_cancel {G\u2080 : Type*} [group_with_zero G\u2080] {a : G\u2080} (h : a \u2260 0) :\n\t1 / a * a = 1", "decl_tp": "\u2200 {G\u2080 : Type u_2} [_inst_1 : group_with_zero G\u2080] {a : G\u2080}, a \u2260 0 \u2192 1 / a * a = 1", "decl_nm": "one_div_mul_cancel", "nl_statement_of_codex": "Let $G$ be a group with zero. Let $a\\in G$ be nonzero. Then $1/a\\cdot a=1$."}
{"formal_statement": "theorem hfunext {\u03b1 \u03b1' : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b2' : \u03b1' \u2192 Sort v} {f : \u03a0 (a : \u03b1), \u03b2 a}\n\t{f' : \u03a0 (a : \u03b1'), \u03b2' a} (h\u03b1 : \u03b1 = \u03b1') :\n\t(\u2200 (a : \u03b1) (a' : \u03b1'), a == a' \u2192 f a == f' a') \u2192 f == f'", "decl_tp": "\u2200 {\u03b1 \u03b1' : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b2' : \u03b1' \u2192 Sort v} {f : \u03a0 (a : \u03b1), \u03b2 a} {f' : \u03a0 (a : \u03b1'), \u03b2' a}, \u03b1 = \u03b1' \u2192 (\u2200 (a : \u03b1) (a' : \u03b1'), a == a' \u2192 f a == f' a') \u2192 f == f'", "decl_nm": "function.hfunext", "nl_statement_of_codex": "Let $f, f':A\\to B$ be functions. If $A=A'$ and $f(a)=f'(a)$ for all $a\\in A$, then $f=f'$."}
{"formal_statement": "theorem dvd_index_map {G : Type*} [group G] (H : subgroup G) {G' : Type*}\n\t[group G'] {f : G \u2192* G'} (hf : f.ker \u2264 H) :\n\tH.index \u2223 (subgroup.map f H).index", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (H : subgroup G) {G' : Type u_2} [_inst_2 : group G'] {f : G \u2192* G'}, f.ker \u2264 H \u2192 H.index \u2223 (subgroup.map f H).index", "decl_nm": "subgroup.dvd_index_map", "nl_statement_of_codex": "Let $G$ be a group and let $H$ be a subgroup of $G$. Let $G'$ be a group and let $f:G\\to G'$ be a group homomorphism.\nIf $f(H)\\subseteq H$, then $[G:H]$ divides $[G':f(H)]$."}
{"formal_statement": "theorem le_sup_inf {\u03b1 : Type u} [distrib_lattice \u03b1] {x y z : \u03b1} :\n\t(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 y \u2293 z", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : distrib_lattice \u03b1] {x y z : \u03b1}, (x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 y \u2293 z", "decl_nm": "le_sup_inf", "nl_statement_of_codex": "Let $x,y,z$ be elements of a distributive lattice. Then $(x\\vee y)\\wedge (x\\vee z)\\leq (x\\vee y)\\wedge z$."}
{"formal_statement": "theorem ext (G H : Group) (f\u2081 f\u2082 : G \u27f6 H) :\n\t(\u2200 (x : \u21a5G), \u21d1f\u2081 x = \u21d1f\u2082 x) \u2192 f\u2081 = f\u2082", "decl_tp": "\u2200 (G H : Group) (f\u2081 f\u2082 : G \u27f6 H), (\u2200 (x : \u21a5G), \u21d1f\u2081 x = \u21d1f\u2082 x) \u2192 f\u2081 = f\u2082", "decl_nm": "Group.ext", "nl_statement_of_codex": "Let $G$ and $H$ be groups and let $f_1, f_2:G\\to H$ be group homomorphisms. If $f_1(x)=f_2(x)$ for all $x\\in G$, then $f_1=f_2$."}
{"formal_statement": "theorem inl_apply {M N : Type*} [add_zero_class M] [add_zero_class N] (x : M) :\n\t\u21d1(add_monoid_hom.inl M N) x = (x, 0)", "decl_tp": "\u2200 {M : Type u_5} {N : Type u_6} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (x : M), \u21d1(add_monoid_hom.inl M N) x = (x, 0)", "decl_nm": "add_monoid_hom.inl_apply", "nl_statement_of_codex": "The function $f:M\\to M\\oplus N$ defined by $f(x)=(x,0)$ is a monoid homomorphism."}
{"formal_statement": "theorem nat_cases' {\u03b1 \u03b2 : Type*} [primcodable \u03b1] [primcodable \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t{g : \u03b1 \u2192 \u2115 \u2192 \u03b2} (hf : primrec f) (hg : primrec\u2082 g) :\n\tprimrec\u2082 (\u03bb (a : \u03b1), nat.cases (f a) (g a))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u2115 \u2192 \u03b2}, primrec f \u2192 primrec\u2082 g \u2192 primrec\u2082 (\u03bb (a : \u03b1), nat.cases (f a) (g a))", "decl_nm": "primrec.nat_cases'", "nl_statement_of_codex": "The function $f:\\mathbb{N}\\to\\mathbb{N}$ defined by $f(n)=\\begin{cases}\n\tf(n) & \\text{if $n=0$} \\\\\n\tg(n,k) & \\text{if $n=2^k$}\n\\end{cases}$ is primitive recursive."}
{"formal_statement": "theorem lower_bounds_Ioo {\u03b3 : Type w} [semilattice_sup \u03b3] [densely_ordered \u03b3]\n\t{a b : \u03b3} (hab : a < b) :\n\tlower_bounds (set.Ioo a b) = set.Iic a", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : semilattice_sup \u03b3] [_inst_4 : densely_ordered \u03b3] {a b : \u03b3}, a < b \u2192 lower_bounds (set.Ioo a b) = set.Iic a", "decl_nm": "lower_bounds_Ioo", "nl_statement_of_codex": "Let $a<b$ be elements of a dense linear order. Then the lower bounds of the interval $(a,b)$ are exactly the elements of the interval $[a,b)$."}
{"formal_statement": "theorem compl_supr {\u03b1 : Type u} {\u03b9 : Sort w} [complete_boolean_algebra \u03b1]\n\t{f : \u03b9 \u2192 \u03b1} :\n\t(supr f)\u1d9c = \u2a05 (i : \u03b9), (f i)\u1d9c", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b9 : Sort w} [_inst_1 : complete_boolean_algebra \u03b1] {f : \u03b9 \u2192 \u03b1}, (supr f)\u1d9c = \u2a05 (i : \u03b9), (f i)\u1d9c", "decl_nm": "compl_supr", "nl_statement_of_codex": "Let $A$ be a complete boolean algebra and let $f:I\\to A$ be a function. Then $(\\sup_{i\\in I}f(i))^c=\\inf_{i\\in I}f(i)^c$."}
{"formal_statement": "theorem trans {M : Type*} [has_add M] (c : add_con M) {x y z : M} :\n\t\u21d1c x y \u2192 \u21d1c y z \u2192 \u21d1c x z", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : has_add M] (c : add_con M) {x y z : M}, \u21d1c x y \u2192 \u21d1c y z \u2192 \u21d1c x z", "decl_nm": "add_con.trans", "nl_statement_of_codex": "Let $M$ be a set with an addition operation. Let $c$ be an equivalence relation on $M$ that is compatible with the addition operation. Then $c$ is transitive."}
{"formal_statement": "theorem cancel_counit_inv_right {C : Type u\u2081} [category_theory.category C]\n\t{D : Type u\u2082} [category_theory.category D] (e : C \u224c D) {X Y : D} (f f' : X \u27f6 Y) :\n\tf \u226b e.counit_inv.app Y = f' \u226b e.counit_inv.app Y \u2194 f = f'", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (e : C \u224c D) {X Y : D} (f f' : X \u27f6 Y), f \u226b e.counit_inv.app Y = f' \u226b e.counit_inv.app Y \u2194 f = f'", "decl_nm": "category_theory.equivalence.cancel_counit_inv_right", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $e:C\\to D$ be an equivalence of categories. Then for any objects $X,Y$ of $D$ and any morphisms $f,f':X\\to Y$ in $D$, we have $f\\circ e^{-1}=f'\\circ e^{-1}$ if and only if $f=f'$."}
{"formal_statement": "theorem coe_div {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E']\n\t{H : Type*} [topological_space H] {I : model_with_corners \ud835\udd5c E H} {H' : Type*}\n\t[topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {N : Type*} [topological_space N]\n\t[charted_space H N] {G : Type*} [group G] [topological_space G] [charted_space H' G]\n\t[lie_group I' G] (f g : times_cont_mdiff_map I I' N G \u22a4) :\n\t\u21d1(f / g) = \u21d1f / \u21d1g", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_3} [_inst_4 : normed_group E'] [_inst_5 : normed_space \ud835\udd5c E'] {H : Type u_4} [_inst_6 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {H' : Type u_5} [_inst_7 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {N : Type u_6} [_inst_8 : topological_space N] [_inst_9 : charted_space H N] {G : Type u_7} [_inst_15 : group G] [_inst_16 : topological_space G] [_inst_17 : charted_space H' G] [_inst_18 : lie_group I' G] (f g : times_cont_mdiff_map I I' N G \u22a4), \u21d1(f / g) = \u21d1f / \u21d1g", "decl_nm": "smooth_map.coe_div", "nl_statement_of_codex": "Let $f,g:N\\to G$ be smooth maps. Then the map $f/g:N\\to G$ is smooth and its derivative is given by the formula\n$D(f/g)=Df/Dg$."}
{"formal_statement": "theorem sum_strict_mono {\u03b9 M : Type*} [fintype \u03b9] [ordered_cancel_add_comm_monoid M] :\n\tstrict_mono (\u03bb (f : \u03b9 \u2192 M), finset.univ.sum (\u03bb (x : \u03b9), f x))", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : Type u_4} [_inst_1 : fintype \u03b9] [_inst_2 : ordered_cancel_add_comm_monoid M], strict_mono (\u03bb (f : \u03b9 \u2192 M), finset.univ.sum (\u03bb (x : \u03b9), f x))", "decl_nm": "fintype.sum_strict_mono", "nl_statement_of_codex": "The function $f:\\mathbb{N}^n\\to\\mathbb{N}$ defined by $f(x_1,\\ldots,x_n)=x_1+\\cdots+x_n$ is strictly monotone."}
{"formal_statement": "theorem has_deriv_at_iff_is_o_nhds_zero {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F}\n\t{x : \ud835\udd5c} :\n\thas_deriv_at f f' x \u2194 asymptotics.is_o (\u03bb (h : \ud835\udd5c), f (x + h) - f x - h \u2022 f')\n\t(\u03bb (h : \ud835\udd5c), h) (nhds 0)", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c}, has_deriv_at f f' x \u2194 asymptotics.is_o (\u03bb (h : \ud835\udd5c), f (x + h) - f x - h \u2022 f') (\u03bb (h : \ud835\udd5c), h) (nhds 0)", "decl_nm": "has_deriv_at_iff_is_o_nhds_zero", "nl_statement_of_codex": "Let $f: \\mathbb{R}\\to F$ be a function from the reals to a normed space $F$. Then $f$ has a derivative at $x$ if and only if $f(x+h)-f(x)-hf'(x)$ is $o(h)$ as $h\\to 0$."}
{"formal_statement": "theorem generate {\u03b1 : Type*} (B : filter_basis \u03b1) :\n\tfilter.generate B.sets = B.filter", "decl_tp": "\u2200 {\u03b1 : Type u_1} (B : filter_basis \u03b1), filter.generate B.sets = B.filter", "decl_nm": "filter_basis.generate", "nl_statement_of_codex": "The filter generated by a filter basis is the filter basis itself."}
{"formal_statement": "theorem of_set_eq_some_self_iff {\u03b1 : Type u} {s : set \u03b1} {h : decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)}\n\t{a : \u03b1} :\n\t\u21d1(pequiv.of_set s) a = option.some a \u2194 a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1} {h : decidable_pred (\u03bb (_x : \u03b1), _x \u2208 s)} {a : \u03b1}, \u21d1(pequiv.of_set s) a = option.some a \u2194 a \u2208 s", "decl_nm": "pequiv.of_set_eq_some_self_iff", "nl_statement_of_codex": "Let $s$ be a set and let $a$ be an element of $s$. Then $a$ is in the image of the function $f:s\\to s$ defined by $f(x)=x$ if and only if $a$ is in $s$."}
{"formal_statement": "theorem Union_Ioi_eq {\u03b9 : Sort u} {\u03b1 : Type v} [linear_order \u03b1] {a : \u03b1}\n\t{f : \u03b9 \u2192 \u03b1} (h : is_glb (set.range f) a) :\n\t(\u22c3 (x : \u03b9), set.Ioi (f x)) = set.Ioi a", "decl_tp": "\u2200 {\u03b9 : Sort u} {\u03b1 : Type v} [_inst_1 : linear_order \u03b1] {a : \u03b1} {f : \u03b9 \u2192 \u03b1}, is_glb (set.range f) a \u2192 (\u22c3 (x : \u03b9), set.Ioi (f x)) = set.Ioi a", "decl_nm": "is_glb.Union_Ioi_eq", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\mathbb{R}$ be a sequence of real numbers. Then $\\bigcup_{i\\in\\mathbb{N}}(f(i),\\infty)=(\\inf_{i\\in\\mathbb{N}}f(i),\\infty)$."}
{"formal_statement": "theorem coe_eq_to_one_hom {M N : Type*} {mM : mul_one_class M} {mN : mul_one_class N}\n\t(f : M \u2192* N) :\n\t\u2191f = f.to_one_hom", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} {mM : mul_one_class M} {mN : mul_one_class N} (f : M \u2192* N), \u2191f = f.to_one_hom", "decl_nm": "monoid_hom.coe_eq_to_one_hom", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity. Let $f:M\\to N$ be a monoid homomorphism. Then $f$ is a monoid homomorphism with identity."}
{"formal_statement": "theorem infi_mul_left {\u03b9 : Sort u_1} [nonempty \u03b9] {f : \u03b9 \u2192 ennreal} {a : ennreal} :\n\t(a = \u22a4 \u2192 (\u2a05 (i : \u03b9), f i) = 0 \u2192 (\u2203 (i : \u03b9), f i = 0)) \u2192 ((\u2a05 (i : \u03b9), a * f i) = a * \u2a05 (i : \u03b9), f i)", "decl_tp": "\u2200 {\u03b9 : Sort u_1} [_inst_1 : nonempty \u03b9] {f : \u03b9 \u2192 ennreal} {a : ennreal}, (a = \u22a4 \u2192 (\u2a05 (i : \u03b9), f i) = 0 \u2192 (\u2203 (i : \u03b9), f i = 0)) \u2192 ((\u2a05 (i : \u03b9), a * f i) = a * \u2a05 (i : \u03b9), f i)", "decl_nm": "ennreal.infi_mul_left", "nl_statement_of_codex": "Let $f_i:\\mathbb{N}\\to\\mathbb{R}$ be a family of functions. If $a=\\infty$ and $\\inf_i f_i=0$, then there is an $i$ such that $f_i=0$.\n"}
{"formal_statement": "theorem Ioi_diff_Ici {\u03b1 : Type u} [linear_order \u03b1] {a b : \u03b1} :\n\tset.Ioi a \\ set.Ici b = set.Ioo a b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b : \u03b1}, set.Ioi a \\ set.Ici b = set.Ioo a b", "decl_nm": "set.Ioi_diff_Ici", "nl_statement_of_codex": "Let $a,b\\in\\alpha$ where $\\alpha$ is a linear order. Then $(a,\\infty)\\setminus[b,\\infty)=(a,b)$."}
{"formal_statement": "theorem lt_one_iff {n : \u2115} :\n\tn < 1 \u2194 n = 0", "decl_tp": "\u2200 {n : \u2115}, n < 1 \u2194 n = 0", "decl_nm": "nat.lt_one_iff", "nl_statement_of_codex": "$n<1$ if and only if $n=0$."}
{"formal_statement": "theorem mono_right {\u03b1 : Type*} [preorder \u03b1] {x y : \u03b1} (xy : x \u2264 y) (\u1fb0 : t.bounded o \u2191x) :\n\t\u2200 {t : ordnode \u03b1} {o : with_bot \u03b1},  t.bounded o \u2191y", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {x y : \u03b1}, x \u2264 y \u2192 \u2200 {t : ordnode \u03b1} {o : with_bot \u03b1}, t.bounded o \u2191x \u2192 t.bounded o \u2191y", "decl_nm": "ordnode.bounded.mono_right", "nl_statement_of_codex": "Let $x,y$ be elements of a preorder $P$ such that $x\\leq y$. If $t$ is a bounded subset of $P$ containing $x$, then $t$ is a bounded subset of $P$ containing $y$."}
{"formal_statement": "theorem smul_def {\u03b1 : Type*} [add_monoid \u03b1] (f : add_monoid.End \u03b1) (a : \u03b1) :\n\tf \u2022 a = \u21d1f a", "decl_tp": "\u2200 {\u03b1 : Type u_6} [_inst_1 : add_monoid \u03b1] (f : add_monoid.End \u03b1) (a : \u03b1), f \u2022 a = \u21d1f a", "decl_nm": "add_monoid.End.smul_def", "nl_statement_of_codex": "Let $f$ be an endomorphism of an additive monoid $A$. Then $f(a)=f\\cdot a$."}
{"formal_statement": "theorem nodup_roots {R : Type u} [comm_ring R] [is_domain R] {p : polynomial R}\n\t(hsep : p.separable) :\n\tp.roots.nodup", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] {p : polynomial R}, p.separable \u2192 p.roots.nodup", "decl_nm": "polynomial.nodup_roots", "nl_statement_of_codex": "If $p$ is a separable polynomial over a domain $R$, then the roots of $p$ are distinct."}
{"formal_statement": "theorem contains_iff {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] (m : hash_map \u03b1 \u03b2)\n\t(a : \u03b1) :\n\t\u21a5(m.contains a) \u2194 a \u2208 m.keys", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] (m : hash_map \u03b1 \u03b2) (a : \u03b1), \u21a5(m.contains a) \u2194 a \u2208 m.keys", "decl_nm": "hash_map.contains_iff", "nl_statement_of_codex": "Let $m$ be a hash map. Then $m$ contains $a$ if and only if $a$ is a key of $m$."}
{"formal_statement": "theorem ptendsto_iff_rtendsto {\u03b1 : Type u} {\u03b2 : Type v} (l\u2081 : filter \u03b1)\n\t(l\u2082 : filter \u03b2) (f : \u03b1 \u2192. \u03b2) :\n\tfilter.ptendsto f l\u2081 l\u2082 \u2194 filter.rtendsto f.graph' l\u2081 l\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (l\u2081 : filter \u03b1) (l\u2082 : filter \u03b2) (f : \u03b1 \u2192. \u03b2), filter.ptendsto f l\u2081 l\u2082 \u2194 filter.rtendsto f.graph' l\u2081 l\u2082", "decl_nm": "filter.ptendsto_iff_rtendsto", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function between topological spaces. Then $f$ is continuous if and only if the graph of $f$ is closed."}
{"formal_statement": "theorem mem_Lp {\u03b1 E : Type*} {m0 : measurable_space \u03b1} {p : ennreal} {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space E] [normed_group E] [borel_space E] [topological_space.second_countable_topology E]\n\t[topological_space \u03b1] [borel_space \u03b1] [measure_theory.is_finite_measure \u03bc]\n\t(f : bounded_continuous_function \u03b1 E) :\n\tcontinuous_map.to_ae_eq_fun \u03bc f.to_continuous_map \u2208 measure_theory.Lp E p \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} {m0 : measurable_space \u03b1} {p : ennreal} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_space E] [_inst_2 : normed_group E] [_inst_5 : borel_space E] [_inst_6 : topological_space.second_countable_topology E] [_inst_7 : topological_space \u03b1] [_inst_8 : borel_space \u03b1] [_inst_9 : measure_theory.is_finite_measure \u03bc] (f : bounded_continuous_function \u03b1 E), continuous_map.to_ae_eq_fun \u03bc f.to_continuous_map \u2208 measure_theory.Lp E p \u03bc", "decl_nm": "bounded_continuous_function.mem_Lp", "nl_statement_of_codex": "Let $E$ be a normed group, $\u03b1$ a topological space, $\u03bc$ a finite measure on $\u03b1$, and $f:\u03b1\\to E$ a bounded continuous function. Then $f$ is in $L^p(\u03b1,\u03bc)$."}
{"formal_statement": "theorem second_countable_of_almost_dense_set {\u03b1 : Type u} [pseudo_emetric_space \u03b1]\n\t(\u03b50 : \u03b5 > 0) :\n\t(\u2200 (\u03b5 : ennreal),  (\u2203 (t : set \u03b1), t.countable \u2227 (\u22c3 (x : \u03b1) (H : x \u2208 t), emetric.closed_ball x \u03b5) = set.univ)) \u2192 topological_space.second_countable_topology \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1], (\u2200 (\u03b5 : ennreal), \u03b5 > 0 \u2192 (\u2203 (t : set \u03b1), t.countable \u2227 (\u22c3 (x : \u03b1) (H : x \u2208 t), emetric.closed_ball x \u03b5) = set.univ)) \u2192 topological_space.second_countable_topology \u03b1", "decl_nm": "emetric.second_countable_of_almost_dense_set", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. If for each $\\epsilon>0$ there is a countable set $T$ such that the union of the closed balls of radius $\\epsilon$ centered at points of $T$ is $X$, then $X$ is second countable."}
{"formal_statement": "theorem induction_on_primes {P : \u2115 \u2192 Prop} (h\u2080 : P 0) (h\u2081 : P 1) :\n\t(\u2200 (p a : \u2115), nat.prime p \u2192 P a \u2192 P (p * a)) \u2192 \u2200 (n : \u2115), P n", "decl_tp": "\u2200 {P : \u2115 \u2192 Prop}, P 0 \u2192 P 1 \u2192 (\u2200 (p a : \u2115), nat.prime p \u2192 P a \u2192 P (p * a)) \u2192 \u2200 (n : \u2115), P n", "decl_nm": "induction_on_primes", "nl_statement_of_codex": "Let $P$ be a property of natural numbers. If $P(0)$ and $P(1)$ hold, and if $P(a)$ holds whenever $a$ is a product of primes, then $P(n)$ holds for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem is_integral_tower_top_of_is_integral {R S T : Type*} [comm_ring R]\n\t[comm_ring S] [comm_ring T] (f : R \u2192+* S) (g : S \u2192+* T) (h : (g.comp f).is_integral) :\n\tg.is_integral", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_4} {T : Type u_5} [_inst_1 : comm_ring R] [_inst_4 : comm_ring S] [_inst_5 : comm_ring T] (f : R \u2192+* S) (g : S \u2192+* T), (g.comp f).is_integral \u2192 g.is_integral", "decl_nm": "ring_hom.is_integral_tower_top_of_is_integral", "nl_statement_of_codex": "Let $R, S, T$ be commutative rings and let $f:R\\to S$ and $g:S\\to T$ be ring homomorphisms. If $g\\circ f$ is integral, then $g$ is integral."}
{"formal_statement": "theorem mul {M : Type*} [has_mul M] [preorder M] [covariant_class M M has_mul.mul has_le.le]\n\t[covariant_class M M (function.swap has_mul.mul) has_le.le] {s t : set M}\n\t(hs : bdd_below s) (ht : bdd_below t) :\n\tbdd_below (s * t)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : has_mul M] [_inst_2 : preorder M] [_inst_3 : covariant_class M M has_mul.mul has_le.le] [_inst_4 : covariant_class M M (function.swap has_mul.mul) has_le.le] {s t : set M}, bdd_below s \u2192 bdd_below t \u2192 bdd_below (s * t)", "decl_nm": "bdd_below.mul", "nl_statement_of_codex": "Let $M$ be a preordered monoid. If $s$ and $t$ are bounded below, then $s\\cdot t$ is bounded below."}
{"formal_statement": "theorem im {\u03b1 \ud835\udd5c : Type*} [is_R_or_C \ud835\udd5c] [measurable_space \u03b1] {f : \u03b1 \u2192 \ud835\udd5c}\n\t{\u03bc : measure_theory.measure \u03b1} (hf : ae_measurable f \u03bc) :\n\tae_measurable (\u03bb (x : \u03b1), \u21d1is_R_or_C.im (f x)) \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\ud835\udd5c : Type u_2} [_inst_1 : is_R_or_C \ud835\udd5c] [_inst_2 : measurable_space \u03b1] {f : \u03b1 \u2192 \ud835\udd5c} {\u03bc : measure_theory.measure \u03b1}, ae_measurable f \u03bc \u2192 ae_measurable (\u03bb (x : \u03b1), \u21d1is_R_or_C.im (f x)) \u03bc", "decl_nm": "ae_measurable.im", "nl_statement_of_codex": "Let $f:X\\to \\mathbb{C}$ be a measurable function. Then the function $x\\mapsto \\operatorname{Im}(f(x))$ is measurable."}
{"formal_statement": "theorem comap_coe_nhds {X : Type*} [topological_space X] (x : X) :\n\tfilter.comap coe (nhds \u2191x) = nhds x", "decl_tp": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] (x : X), filter.comap coe (nhds \u2191x) = nhds x", "decl_nm": "alexandroff.comap_coe_nhds", "nl_statement_of_codex": "Let $X$ be a topological space and let $x\\in X$. Then the filter of neighborhoods of $x$ is equal to the filter of neighborhoods of $x$ in $X$."}
{"formal_statement": "theorem is_connected_univ_pi {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), topological_space (\u03c0 i)]\n\t{s : \u03a0 (i : \u03b9), set (\u03c0 i)} :\n\tis_connected (set.univ.pi s) \u2194 \u2200 (i : \u03b9), is_connected (s i)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03c0 : \u03b9 \u2192 Type u_2} [_inst_2 : \u03a0 (i : \u03b9), topological_space (\u03c0 i)] {s : \u03a0 (i : \u03b9), set (\u03c0 i)}, is_connected (set.univ.pi s) \u2194 \u2200 (i : \u03b9), is_connected (s i)", "decl_nm": "is_connected_univ_pi", "nl_statement_of_codex": "Let $\\pi$ be a family of topological spaces. Then $\\prod_{i\\in I}\\pi_i$ is connected if and only if each $\\pi_i$ is connected."}
{"formal_statement": "theorem of_le_arrow {C : Type u\u2081} [category_theory.category C] {B : C}\n\t{X Y : category_theory.subobject B} (h : X \u2264 Y) :\n\tX.of_le Y h \u226b Y.arrow = X.arrow", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {B : C} {X Y : category_theory.subobject B} (h : X \u2264 Y), X.of_le Y h \u226b Y.arrow = X.arrow", "decl_nm": "category_theory.subobject.of_le_arrow", "nl_statement_of_codex": "Let $C$ be a category and let $B$ be an object of $C$. Let $X$ and $Y$ be subobjects of $B$. If $X\\leq Y$, then $X\\leq Y$ is a monomorphism."}
{"formal_statement": "theorem smul_const {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{\ud835\udd5c' : Type*} [nondiscrete_normed_field \ud835\udd5c'] [normed_algebra \ud835\udd5c \ud835\udd5c'] [normed_space \ud835\udd5c' F]\n\t[is_scalar_tower \ud835\udd5c \ud835\udd5c' F] {c : E \u2192 \ud835\udd5c'} (hc : differentiable \ud835\udd5c c) :\n\t\u2200 (f : F), differentiable \ud835\udd5c (\u03bb (y : E), c y \u2022 f)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {\ud835\udd5c' : Type u_6} [_inst_10 : nondiscrete_normed_field \ud835\udd5c'] [_inst_11 : normed_algebra \ud835\udd5c \ud835\udd5c'] [_inst_12 : normed_space \ud835\udd5c' F] [_inst_13 : is_scalar_tower \ud835\udd5c \ud835\udd5c' F] {c : E \u2192 \ud835\udd5c'}, differentiable \ud835\udd5c c \u2192 \u2200 (f : F), differentiable \ud835\udd5c (\u03bb (y : E), c y \u2022 f)", "decl_nm": "differentiable.smul_const", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$ and let $K'$ be a nondiscrete normed field\nsuch that $K'$ is a normed algebra over $K$ and $F$ is a normed space over $K'$. Let $c:E\\to K'$ be differentiable.\nThen for each $f:F\\to F$, the function $y\\mapsto c(y)f$ is differentiable."}
{"formal_statement": "theorem pairwise_to_opens_le_cover_obj_2 {X : Top} {\u03b9 : Type v} (U : \u03b9 \u2192 topological_space.opens \u21a5X)\n\t(\u1fb0 : category_theory.pairwise \u03b9) :\n\t(Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover U).obj \u1fb0 = Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj U \u1fb0", "decl_tp": "\u2200 {X : Top} {\u03b9 : Type v} (U : \u03b9 \u2192 topological_space.opens \u21a5X) (\u1fb0 : category_theory.pairwise \u03b9), (Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover U).obj \u1fb0 = Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj U \u1fb0", "decl_nm": "Top.presheaf.sheaf_condition.pairwise_to_opens_le_cover_obj_2", "nl_statement_of_codex": "Let $X$ be a topological space and let $\\{U_i\\}_{i\\in I}$ be a family of open subsets of $X$. Then the family $\\{U_i\\}_{i\\in I}$ is a cover of $X$ if and only if for each $x\\in X$ there is an $i\\in I$ such that $x\\in U_i$ and for each $i,j\\in I$ with $i\\neq j$ we have $U_i\\cap U_j=\\emptyset$."}
{"formal_statement": "theorem erase_dup_cons_of_not_mem {\u03b1 : Type u} [decidable_eq \u03b1] {a : \u03b1}\n\t{l : list \u03b1} (h : a \u2209 l) :\n\t(a :: l).erase_dup = a :: l.erase_dup", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {l : list \u03b1}, a \u2209 l \u2192 (a :: l).erase_dup = a :: l.erase_dup", "decl_nm": "list.erase_dup_cons_of_not_mem", "nl_statement_of_codex": "Let $a$ be an element of a list $l$. If $a$ is not in $l$, then $a$ is the first element of the list $l$ with duplicates removed."}
{"formal_statement": "theorem exp_mul_I_periodic :\n\tfunction.periodic (\u03bb (x : \u2102), complex.exp (x * complex.I)) (2 * \u2191real.pi)", "decl_tp": "function.periodic (\u03bb (x : \u2102), complex.exp (x * complex.I)) (2 * \u2191real.pi)", "decl_nm": "complex.exp_mul_I_periodic", "nl_statement_of_codex": "The function $f(x)=e^{ix}$ is periodic with period $2\\pi$."}
{"formal_statement": "theorem inv_closure {G : Type w} [topological_space G] [group G] [topological_group G]\n\t(s : set G) :\n\t(closure s)\u207b\u00b9 = closure s\u207b\u00b9", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : group G] [_inst_3 : topological_group G] (s : set G), (closure s)\u207b\u00b9 = closure s\u207b\u00b9", "decl_nm": "inv_closure", "nl_statement_of_codex": "Let $G$ be a topological group. Then the closure of the inverse of a set $S$ is the inverse of the closure of $S$."}
{"formal_statement": "theorem add_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v}\n\t[normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {L : filter \ud835\udd5c}\n\t(hf : has_deriv_at_filter f f' x L) :\n\t\u2200 (c : F), has_deriv_at_filter (\u03bb (y : \ud835\udd5c), f y + c) f' x L", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {L : filter \ud835\udd5c}, has_deriv_at_filter f f' x L \u2192 \u2200 (c : F), has_deriv_at_filter (\u03bb (y : \ud835\udd5c), f y + c) f' x L", "decl_nm": "has_deriv_at_filter.add_const", "nl_statement_of_codex": "Let $f: \\mathbb{K}\\to F$ be a function, where $F$ is a normed space over a nondiscrete normed field $\\mathbb{K}$.\nIf $f$ has a derivative at $x\\in \\mathbb{K}$, then $f+c$ has a derivative at $x$ for any constant $c\\in F$."}
{"formal_statement": "theorem to_linear_equiv_apply (R : Type*) {S : Type*} (M : Type*) [semiring R]\n\t[add_comm_monoid M] [module R M] [group S] [distrib_mul_action S M] [smul_comm_class S R M]\n\t(s : S) (\u1fb0 : M) :\n\t\u21d1(distrib_mul_action.to_linear_equiv R M s) \u1fb0 = (distrib_mul_action.to_add_equiv M s).to_fun \u1fb0", "decl_tp": "\u2200 (R : Type u_1) {S : Type u_6} (M : Type u_7) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] [_inst_4 : group S] [_inst_5 : distrib_mul_action S M] [_inst_6 : smul_comm_class S R M] (s : S) (\u1fb0 : M), \u21d1(distrib_mul_action.to_linear_equiv R M s) \u1fb0 = (distrib_mul_action.to_add_equiv M s).to_fun \u1fb0", "decl_nm": "distrib_mul_action.to_linear_equiv_apply", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $S$ a group. Suppose that $S$ acts on $M$ by $R$-linear maps. Then the linear map $M\\to M$ induced by the action of $s\\in S$ is the same as the map $M\\to M$ induced by the action of $s$ on $M$ as an additive group."}
{"formal_statement": "theorem le_sup {\u03b9 : Type*} (f : \u03b9 \u2192 cardinal) (i : \u03b9) :\n\tf i \u2264 cardinal.sup f", "decl_tp": "\u2200 {\u03b9 : Type u_1} (f : \u03b9 \u2192 cardinal) (i : \u03b9), f i \u2264 cardinal.sup f", "decl_nm": "cardinal.le_sup", "nl_statement_of_codex": "For any function $f:\\iota\\to\\mathrm{Card}$ and any $i\\in\\iota$, we have $f(i)\\leq\\sup_{j\\in\\iota}f(j)$."}
{"formal_statement": "theorem exists_lt_of_cInf_lt {\u03b1 : Type*} [conditionally_complete_linear_order \u03b1]\n\t{s : set \u03b1} {b : \u03b1} (hs : s.nonempty) (hb : has_Inf.Inf s < b) :\n\t(\u2203 (a : \u03b1) (H : a \u2208 s), a < b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : conditionally_complete_linear_order \u03b1] {s : set \u03b1} {b : \u03b1}, s.nonempty \u2192 has_Inf.Inf s < b \u2192 (\u2203 (a : \u03b1) (H : a \u2208 s), a < b)", "decl_nm": "exists_lt_of_cInf_lt", "nl_statement_of_codex": "Let $s$ be a nonempty set of real numbers. If $\\inf s<b$, then there is an element $a\\in s$ such that $a<b$."}
{"formal_statement": "theorem mul_move_left_inr {x y : pgame} {i : x.right_moves} {j : y.right_moves} :\n\t(x * y).move_left (\u21d1((x.left_moves_mul y).symm) (sum.inr (i, j))) = x.move_right i * y + x * y.move_right j - x.move_right i * y.move_right j", "decl_tp": "\u2200 {x y : pgame} {i : x.right_moves} {j : y.right_moves}, (x * y).move_left (\u21d1((x.left_moves_mul y).symm) (sum.inr (i, j))) = x.move_right i * y + x * y.move_right j - x.move_right i * y.move_right j", "decl_nm": "pgame.mul_move_left_inr", "nl_statement_of_codex": "Let $x$ and $y$ be two impartial games. Let $i$ be a move of $x$ and $j$ be a move of $y$. Then the left move of $x*y$ corresponding to the pair $(i,j)$ is equal to the sum of the right move of $x$ corresponding to $i$, the game $y$, the right move of $y$ corresponding to $j$, and the negative of the product of the right move of $x$ corresponding to $i$ and the right move of $y$ corresponding to $j$."}
{"formal_statement": "theorem edist {\u03b1 \u03b2 : Type*} [pseudo_emetric_space \u03b1] {f g : \u03b2 \u2192 \u03b1} {x : filter \u03b2}\n\t{a b : \u03b1} (hf : filter.tendsto f x (nhds a)) (hg : filter.tendsto g x (nhds b)) :\n\tfilter.tendsto (\u03bb (x : \u03b2), has_edist.edist (f x) (g x)) x (nhds (has_edist.edist a b))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : pseudo_emetric_space \u03b1] {f g : \u03b2 \u2192 \u03b1} {x : filter \u03b2} {a b : \u03b1}, filter.tendsto f x (nhds a) \u2192 filter.tendsto g x (nhds b) \u2192 filter.tendsto (\u03bb (x : \u03b2), has_edist.edist (f x) (g x)) x (nhds (has_edist.edist a b))", "decl_nm": "filter.tendsto.edist", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. Let $f,g:Y\\to X$ be functions and let $x\\in Y$. If $f(x)\\to a$ and $g(x)\\to b$ as $x\\to x$, then $d(f(x),g(x))\\to d(a,b)$ as $x\\to x$."}
{"formal_statement": "theorem symmetric {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : symmetric r) :\n\tsymmetric (relation.refl_trans_gen r)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, symmetric r \u2192 symmetric (relation.refl_trans_gen r)", "decl_nm": "relation.refl_trans_gen.symmetric", "nl_statement_of_codex": "If $r$ is a symmetric relation on $A$, then the transitive closure of $r$ is symmetric."}
{"formal_statement": "theorem out_eq' {\u03b1 : Sort u_1} {s\u2081 : setoid \u03b1} (q : quotient s\u2081) :\n\tquotient.mk' q.out' = q", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {s\u2081 : setoid \u03b1} (q : quotient s\u2081), quotient.mk' q.out' = q", "decl_nm": "quotient.out_eq'", "nl_statement_of_codex": "Let $q$ be an element of the quotient set $A/\\sim$. Then $q$ is equal to the equivalence class of $q.out'$."}
{"formal_statement": "theorem Union_fintype {\u03b9 \u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[fintype \u03b9] {f : \u03b9 \u2192 set \u03b1} :\n\t(\u2200 (b : \u03b9), measure_theory.null_measurable_set (f b) \u03bc) \u2192 measure_theory.null_measurable_set (\u22c3 (b : \u03b9), f b) \u03bc", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_2} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : fintype \u03b9] {f : \u03b9 \u2192 set \u03b1}, (\u2200 (b : \u03b9), measure_theory.null_measurable_set (f b) \u03bc) \u2192 measure_theory.null_measurable_set (\u22c3 (b : \u03b9), f b) \u03bc", "decl_nm": "measure_theory.null_measurable_set.Union_fintype", "nl_statement_of_codex": "Let $X$ be a measurable space and let $\\mu$ be a measure on $X$. Let $\\{A_i\\}_{i\\in I}$ be a finite collection of measurable sets. If each $A_i$ is $\\mu$-null, then $\\bigcup_{i\\in I}A_i$ is $\\mu$-null."}
{"formal_statement": "theorem ker_lift_range_eq {M P : Type*} [add_zero_class M] [add_zero_class P]\n\t{f : M \u2192+ P} :\n\t(add_con.ker_lift f).mrange = f.mrange", "decl_tp": "\u2200 {M : Type u_1} {P : Type u_3} [_inst_1 : add_zero_class M] [_inst_3 : add_zero_class P] {f : M \u2192+ P}, (add_con.ker_lift f).mrange = f.mrange", "decl_nm": "add_con.ker_lift_range_eq", "nl_statement_of_codex": "Let $f:M\\to P$ be a linear map. Then the range of the linear map $f$ is equal to the range of the linear map $f$."}
{"formal_statement": "theorem to_fraction_ring_ring_equiv_apply (K : Type u) [hring : comm_ring K]\n\t(self : ratfunc K) :\n\t\u21d1(ratfunc.to_fraction_ring_ring_equiv K) self = self.to_fraction_ring", "decl_tp": "\u2200 (K : Type u) [hring : comm_ring K] (self : ratfunc K), \u21d1(ratfunc.to_fraction_ring_ring_equiv K) self = self.to_fraction_ring", "decl_nm": "ratfunc.to_fraction_ring_ring_equiv_apply", "nl_statement_of_codex": "The ring of rational functions over a commutative ring $K$ is isomorphic to the fraction ring of the polynomial ring over $K$."}
{"formal_statement": "theorem dense_inducing_coe {\u03b1 : Type*} [uniform_space \u03b1] :\n\tdense_inducing coe", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : uniform_space \u03b1], dense_inducing coe", "decl_nm": "uniform_space.completion.dense_inducing_coe", "nl_statement_of_codex": "The map $f\\mapsto f$ is dense inducing."}
{"formal_statement": "theorem explicit_cokernel_desc_norm_le {X Y Z : SemiNormedGroup} {f : X \u27f6 Y}\n\t{g : Y \u27f6 Z} (w : f \u226b g = 0) :\n\t\u2225SemiNormedGroup.explicit_cokernel_desc w\u2225 \u2264 \u2225g\u2225", "decl_tp": "\u2200 {X Y Z : SemiNormedGroup} {f : X \u27f6 Y} {g : Y \u27f6 Z} (w : f \u226b g = 0), \u2225SemiNormedGroup.explicit_cokernel_desc w\u2225 \u2264 \u2225g\u2225", "decl_nm": "SemiNormedGroup.explicit_cokernel_desc_norm_le", "nl_statement_of_codex": "Let $X, Y, Z$ be seminormed groups and let $f:X\\to Y$ and $g:Y\\to Z$ be morphisms. If $f\\circ g=0$, then the seminorm of the cokernel of $f$ is less than or equal to the seminorm of $g$."}
{"formal_statement": "theorem coe_to_add_monoid_hom {M N : Type*} [add_zero_class M] [add_zero_class N]\n\t(e : M \u2243+ N) :\n\t\u21d1(e.to_add_monoid_hom) = \u21d1e", "decl_tp": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_5 : add_zero_class M] [_inst_6 : add_zero_class N] (e : M \u2243+ N), \u21d1(e.to_add_monoid_hom) = \u21d1e", "decl_nm": "add_equiv.coe_to_add_monoid_hom", "nl_statement_of_codex": "The map $M\\to N$ induced by an additive isomorphism $M\\cong N$ is the same as the map induced by the additive isomorphism."}
{"formal_statement": "theorem mem_or_eq_of_mem_update_nth {\u03b1 : Type u} {l : list \u03b1} {n : \u2115} {a b : \u03b1}\n\t(h : a \u2208 l.update_nth n b) :\n\ta \u2208 l \u2228 a = b", "decl_tp": "\u2200 {\u03b1 : Type u} {l : list \u03b1} {n : \u2115} {a b : \u03b1}, a \u2208 l.update_nth n b \u2192 a \u2208 l \u2228 a = b", "decl_nm": "list.mem_or_eq_of_mem_update_nth", "nl_statement_of_codex": "Let $l$ be a list of elements of type $\\alpha$ and let $n$ be a natural number. Let $a$ and $b$ be elements of $\\alpha$. If $a$ is in the list obtained by replacing the $n$-th element of $l$ by $b$, then $a$ is in $l$ or $a=b$."}
{"formal_statement": "theorem prod_sUnion {\u03b1 \u03b2 : Type*} {s : set \u03b1} {C : set (set \u03b2)} :\n\ts.prod (\u22c3\u2080 C) = \u22c3\u2080((\u03bb (t : set \u03b2), s.prod t) '' C)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : set \u03b1} {C : set (set \u03b2)}, s.prod (\u22c3\u2080 C) = \u22c3\u2080((\u03bb (t : set \u03b2), s.prod t) '' C)", "decl_nm": "set.prod_sUnion", "nl_statement_of_codex": "Let $s$ be a set and let $C$ be a collection of subsets of a set $B$. Then $s\\times (\\bigcup C)=\\bigcup_{t\\in C}(s\\times t)$."}
{"formal_statement": "theorem one_val {n : \u2115} :\n\t1.val = 1 % (n + 1)", "decl_tp": "\u2200 {n : \u2115}, 1.val = 1 % (n + 1)", "decl_nm": "fin.one_val", "nl_statement_of_codex": "The value of the constant function $1:\\mathbb{N}\\to\\mathbb{Z}$ is $1$."}
{"formal_statement": "theorem bdd_above_neg {G : Type*} [add_group G] [preorder G] [covariant_class G G has_add.add has_le.le]\n\t[covariant_class G G (function.swap has_add.add) has_le.le] {s : set G} :\n\tbdd_above (-s) \u2194 bdd_below s", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] [_inst_2 : preorder G] [_inst_3 : covariant_class G G has_add.add has_le.le] [_inst_4 : covariant_class G G (function.swap has_add.add) has_le.le] {s : set G}, bdd_above (-s) \u2194 bdd_below s", "decl_nm": "bdd_above_neg", "nl_statement_of_codex": "Let $G$ be an additive group and let $s\\subset G$. Then $s$ is bounded above if and only if $-s$ is bounded below."}
{"formal_statement": "theorem tsum_of_nnnorm_bounded {\u03b9 E : Type*} [semi_normed_group E] {f : \u03b9 \u2192 E}\n\t{g : \u03b9 \u2192 nnreal} {a : nnreal} (hg : has_sum g a) :\n\t(\u2200 (i : \u03b9), \u2225f i\u2225\u208a \u2264 g i) \u2192 \u2225\u2211' (i : \u03b9), f i\u2225\u208a \u2264 a", "decl_tp": "\u2200 {\u03b9 : Type u_1} {E : Type u_3} [_inst_1 : semi_normed_group E] {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 nnreal} {a : nnreal}, has_sum g a \u2192 (\u2200 (i : \u03b9), \u2225f i\u2225\u208a \u2264 g i) \u2192 \u2225\u2211' (i : \u03b9), f i\u2225\u208a \u2264 a", "decl_nm": "tsum_of_nnnorm_bounded", "nl_statement_of_codex": "Let $E$ be a semi-normed group and let $f,g:\\iota\\to E$ be functions. If $g$ is summable and $\\|f(i)\\|\\leq g(i)$ for all $i\\in\\iota$, then $\\|\\sum_{i\\in\\iota}f(i)\\|\\leq\\sum_{i\\in\\iota}g(i)$."}
{"formal_statement": "theorem comap_id {R M : Type*} [semiring R] [add_comm_monoid M] [module R M]\n\t(p : submodule R M) :\n\tsubmodule.comap linear_map.id p = p", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_9} [_inst_1 : semiring R] [_inst_4 : add_comm_monoid M] [_inst_8 : module R M] (p : submodule R M), submodule.comap linear_map.id p = p", "decl_nm": "submodule.comap_id", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, and $p$ a submodule of $M$. Then the comap of $p$ under the identity map on $M$ is $p$."}
{"formal_statement": "theorem is_complement'_top_right {G : Type*} [group G] {H : subgroup G} :\n\tH.is_complement' \u22a4 \u2194 H = \u22a5", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {H : subgroup G}, H.is_complement' \u22a4 \u2194 H = \u22a5", "decl_nm": "subgroup.is_complement'_top_right", "nl_statement_of_codex": "A subgroup $H$ of $G$ is a complement of $G$ if and only if $H$ is trivial."}
{"formal_statement": "theorem mv_polynomial_X_map_matrix_eval {m R : Type*} [fintype m] [decidable_eq m]\n\t[comm_semiring R] (A : matrix m m R) :\n\t\u21d1((mv_polynomial.eval (\u03bb (p : m \u00d7 m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A", "decl_tp": "\u2200 {m : Type u_1} {R : Type u_3} [_inst_1 : fintype m] [_inst_2 : decidable_eq m] [_inst_3 : comm_semiring R] (A : matrix m m R), \u21d1((mv_polynomial.eval (\u03bb (p : m \u00d7 m), A p.fst p.snd)).map_matrix) (matrix.mv_polynomial_X m m R) = A", "decl_nm": "matrix.mv_polynomial_X_map_matrix_eval", "nl_statement_of_codex": "Let $A$ be an $m\\times m$ matrix over a commutative semiring $R$. Then the matrix $X$ is mapped to $A$ under the evaluation map."}
{"formal_statement": "theorem Icc_diff_both {\u03b1 : Type u} [partial_order \u03b1] {a b : \u03b1} :\n\tset.Icc a b \\ {a, b} = set.Ioo a b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] {a b : \u03b1}, set.Icc a b \\ {a, b} = set.Ioo a b", "decl_nm": "set.Icc_diff_both", "nl_statement_of_codex": "The set $\\{x\\in\\mathbb{R}:a<x<b\\}$ is equal to the set $\\{x\\in\\mathbb{R}:a\\leq x\\leq b\\}$ with the endpoints removed."}
{"formal_statement": "theorem find_min'_all {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} (t : ordnode \u03b1) (x : \u03b1)\n\t(\u1fb0 : ordnode.all P t) (\u1fb0 : P x) :\n\tP (t.find_min' x)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {P : \u03b1 \u2192 Prop} (t : ordnode \u03b1) (x : \u03b1), ordnode.all P t \u2192 P x \u2192 P (t.find_min' x)", "decl_nm": "ordnode.find_min'_all", "nl_statement_of_codex": "Let $t$ be an ordered node and let $x$ be an element of the ordered node. If $t$ satisfies the property $P$ and $x$ satisfies the property $P$, then the minimum of $t$ and $x$ satisfies the property $P$."}
{"formal_statement": "theorem coe_add_monoid_hom_apply {\u03b1 : Type*} [measurable_space \u03b1] (\u1fb0 : measure_theory.finite_measure \u03b1) :\n\t\u21d1measure_theory.finite_measure.coe_add_monoid_hom \u1fb0 = \u2191\u1fb0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (\u1fb0 : measure_theory.finite_measure \u03b1), \u21d1measure_theory.finite_measure.coe_add_monoid_hom \u1fb0 = \u2191\u1fb0", "decl_nm": "measure_theory.finite_measure.coe_add_monoid_hom_apply", "nl_statement_of_codex": "The function $f:\\mathbb{R}_{\\geq 0}\\to \\mathbb{R}_{\\geq 0}$ defined by $f(x)=x$ is a monoid homomorphism."}
{"formal_statement": "theorem free_add_semigroup_free_add_magma_add {\u03b1 : Type u} (x y : add_magma.free_add_semigroup (free_add_magma \u03b1)) :\n\t\u21d1(free_add_semigroup_free_add_magma \u03b1) (x + y) = \u21d1(free_add_semigroup_free_add_magma \u03b1) x + \u21d1(free_add_semigroup_free_add_magma \u03b1) y", "decl_tp": "\u2200 {\u03b1 : Type u} (x y : add_magma.free_add_semigroup (free_add_magma \u03b1)), \u21d1(free_add_semigroup_free_add_magma \u03b1) (x + y) = \u21d1(free_add_semigroup_free_add_magma \u03b1) x + \u21d1(free_add_semigroup_free_add_magma \u03b1) y", "decl_nm": "free_add_semigroup_free_add_magma_add", "nl_statement_of_codex": "Let $x,y$ be elements of the free semigroup on a set $A$. Then the image of $x+y$ under the canonical map from the free semigroup to the free magma is the sum of the images of $x$ and $y$."}
{"formal_statement": "theorem nhds_basis_support {E : Type uE} [normed_group E] [normed_space \u211d E]\n\t[finite_dimensional \u211d E] {H : Type uH} [topological_space H] (I : model_with_corners \u211d E H)\n\t{M : Type uM} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]\n\t{c : M} [t2_space M] {s : set M} (hs : s \u2208 nhds c) :\n\t(nhds c).has_basis (\u03bb (f : smooth_bump_function I c), closure (function.support \u21d1f) \u2286 s)\n\t(\u03bb (f : smooth_bump_function I c), function.support \u21d1f)", "decl_tp": "\u2200 {E : Type uE} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] [_inst_3 : finite_dimensional \u211d E] {H : Type uH} [_inst_4 : topological_space H] (I : model_with_corners \u211d E H) {M : Type uM} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [_inst_7 : smooth_manifold_with_corners I M] {c : M} [_inst_8 : t2_space M] {s : set M}, s \u2208 nhds c \u2192 (nhds c).has_basis (\u03bb (f : smooth_bump_function I c), closure (function.support \u21d1f) \u2286 s) (\u03bb (f : smooth_bump_function I c), function.support \u21d1f)", "decl_nm": "smooth_bump_function.nhds_basis_support", "nl_statement_of_codex": "Let $M$ be a smooth manifold with corners. Then the set of smooth bump functions on $M$ is a basis for the topology of $M$."}
{"formal_statement": "theorem whiskering_map_app_app (C : Type u) [category_theory.category C]\n\t(D : Type*) [category_theory.category D] (G H : C \u2964 D) (\u03c4 : G \u27f6 H) (F : simplex_category \u2964 C)\n\t(c : simplex_category) :\n\t(((category_theory.cosimplicial_object.whiskering C D).map \u03c4).app F).app c = \u03c4.app (F.obj c)", "decl_tp": "\u2200 (C : Type u) [_inst_1 : category_theory.category C] (D : Type u_1) [_inst_2 : category_theory.category D] (G H : C \u2964 D) (\u03c4 : G \u27f6 H) (F : simplex_category \u2964 C) (c : simplex_category), (((category_theory.cosimplicial_object.whiskering C D).map \u03c4).app F).app c = \u03c4.app (F.obj c)", "decl_nm": "category_theory.cosimplicial_object.whiskering_map_app_app", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $G, H:C\\to D$ be functors. Let $\\tau:G\\to H$ be a natural transformation. Let $F: \\Delta\\to C$ be a simplicial object. Then $\\tau_*(F)_n=\\tau(F_n)$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem comp_neg {R\u2081 R\u2082 R\u2083 M N\u2082 : Type*4} {N\u2083 : Type*5} [semiring R\u2081] [semiring R\u2082]\n\t[semiring R\u2083] [add_comm_monoid M] [add_comm_group N\u2082] [add_comm_group N\u2083]\n\t[module R\u2081 M] [module R\u2082 N\u2082] [module R\u2083 N\u2083] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083}\n\t{\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083} [ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082)\n\t(g : N\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] N\u2083) :\n\tg.comp (-f) = -g.comp f", "decl_tp": "\u2200 {R\u2081 : Type u_2} {R\u2082 : Type u_3} {R\u2083 : Type u_4} {M : Type u_9} {N\u2082 : Type u_14} {N\u2083 : Type u_15} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] [_inst_3 : semiring R\u2083] [_inst_4 : add_comm_monoid M] [_inst_8 : add_comm_group N\u2082] [_inst_9 : add_comm_group N\u2083] [_inst_10 : module R\u2081 M] [_inst_14 : module R\u2082 N\u2082] [_inst_15 : module R\u2083 N\u2083] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083} [_inst_16 : ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) (g : N\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] N\u2083), g.comp (-f) = -g.comp f", "decl_nm": "linear_map.comp_neg", "nl_statement_of_codex": "Let $R_1, R_2, R_3$ be semirings, $M$ an $R_1$-module, $N_2$ an $R_2$-module, and $N_3$ an $R_3$-module. Let $\\sigma_{12}:R_1\\to R_2$ and $\\sigma_{23}:R_2\\to R_3$ be ring homomorphisms. Then $\\sigma_{23}\\circ(-f)= -(\\sigma_{23}\\circ f)$."}
{"formal_statement": "theorem fst_image_prod_subset {\u03b1 \u03b2 : Type*} (s : set \u03b1) (t : set \u03b2) :\n\tprod.fst '' s.prod t \u2286 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (s : set \u03b1) (t : set \u03b2), prod.fst '' s.prod t \u2286 s", "decl_nm": "set.fst_image_prod_subset", "nl_statement_of_codex": "Let $s$ and $t$ be sets. Then the projection of $s\\times t$ onto the first coordinate is a subset of $s$."}
{"formal_statement": "theorem eval_bit1 {R : Type u} [semiring R] {p : polynomial R} {x : R} :\n\tpolynomial.eval x (bit1 p) = bit1 (polynomial.eval x p)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {p : polynomial R} {x : R}, polynomial.eval x (bit1 p) = bit1 (polynomial.eval x p)", "decl_nm": "polynomial.eval_bit1", "nl_statement_of_codex": "Let $R$ be a semiring and let $p$ be a polynomial over $R$. Then $p(x)$ is odd if and only if $p(x)$ is odd."}
{"formal_statement": "theorem erase_sub {\u03b9 : Type u} [dec : decidable_eq \u03b9] {\u03b2 : \u03b9 \u2192 Type v}\n\t[\u03a0 (i : \u03b9), add_group (\u03b2 i)] (i : \u03b9) (f g : \u03a0\u2080 (i : \u03b9), \u03b2 i) :\n\tdfinsupp.erase i (f - g) = dfinsupp.erase i f - dfinsupp.erase i g", "decl_tp": "\u2200 {\u03b9 : Type u} [dec : decidable_eq \u03b9] {\u03b2 : \u03b9 \u2192 Type v} [_inst_2 : \u03a0 (i : \u03b9), add_group (\u03b2 i)] (i : \u03b9) (f g : \u03a0\u2080 (i : \u03b9), \u03b2 i), dfinsupp.erase i (f - g) = dfinsupp.erase i f - dfinsupp.erase i g", "decl_nm": "dfinsupp.erase_sub", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to R$ be two finitely supported functions. Then the finitely supported function $f-g$ is equal to the finitely supported function $f-g$ with the $i$-th component erased."}
{"formal_statement": "theorem continuous_within_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t(I : model_with_corners \ud835\udd5c E H) {s : set H} {x : H} :\n\tcontinuous_within_at \u21d1I s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] (I : model_with_corners \ud835\udd5c E H) {s : set H} {x : H}, continuous_within_at \u21d1I s x", "decl_nm": "model_with_corners.continuous_within_at", "nl_statement_of_codex": "Let $E$ be a normed group and let $H$ be a topological space. Let $I:E\\to H$ be a model with corners. Then $I$ is continuous at $x$."}
{"formal_statement": "theorem ext {C : Type u\u2081} [category_theory.category C] {P : C\u1d52\u1d56 \u2964 Type w}\n\t{X : C} {R : category_theory.presieve X} (hR : category_theory.presieve.is_separated_for P R) :\n\t\u2200 {t\u2081 t\u2082 : P.obj (opposite.op X)}, (\u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R f \u2192 P.map f.op t\u2081 = P.map f.op t\u2082) \u2192 t\u2081 = t\u2082", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {P : C\u1d52\u1d56 \u2964 Type w} {X : C} {R : category_theory.presieve X}, category_theory.presieve.is_separated_for P R \u2192 \u2200 {t\u2081 t\u2082 : P.obj (opposite.op X)}, (\u2200 \u2983Y : C\u2984 \u2983f : Y \u27f6 X\u2984, R f \u2192 P.map f.op t\u2081 = P.map f.op t\u2082) \u2192 t\u2081 = t\u2082", "decl_nm": "category_theory.presieve.is_separated_for.ext", "nl_statement_of_codex": "Let $C$ be a category, $P:C^{op}\\to Set$ a functor, $X$ an object of $C$, and $R$ a presieve on $X$. If $R$ is separated for $P$, then for any $t_1, t_2\\in P(X)$, if $P(f)(t_1)=P(f)(t_2)$ for all $f:Y\\to X$ in $R$, then $t_1=t_2$."}
{"formal_statement": "theorem mem_append_stream_right {\u03b1 : Type u} {a : \u03b1} (l : list \u03b1) {s : stream \u03b1}\n\t(\u1fb0 : a \u2208 s) :\n\ta \u2208 l++\u209b s", "decl_tp": "\u2200 {\u03b1 : Type u} {a : \u03b1} (l : list \u03b1) {s : stream \u03b1}, a \u2208 s \u2192 a \u2208 l++\u209b s", "decl_nm": "stream.mem_append_stream_right", "nl_statement_of_codex": "Let $s$ be a stream and let $l$ be a list. If $a$ is in $s$, then $a$ is in $l++s$."}
{"formal_statement": "theorem supported_le_supported_iff {\u03c3 : Type*} {R : Type u} [comm_semiring R]\n\t{s t : set \u03c3} [nontrivial R] :\n\tmv_polynomial.supported R s \u2264 mv_polynomial.supported R t \u2194 s \u2286 t", "decl_tp": "\u2200 {\u03c3 : Type u_1} {R : Type u} [_inst_1 : comm_semiring R] {s t : set \u03c3} [_inst_2 : nontrivial R], mv_polynomial.supported R s \u2264 mv_polynomial.supported R t \u2194 s \u2286 t", "decl_nm": "mv_polynomial.supported_le_supported_iff", "nl_statement_of_codex": "Let $R$ be a nontrivial commutative semiring. Let $s, t$ be subsets of $\\sigma$. Then $s\\subset t$ if and only if the ideal generated by $s$ is contained in the ideal generated by $t$."}
{"formal_statement": "theorem is_multiplicative_sigma {k : \u2115} :\n\t(nat.arithmetic_function.sigma k).is_multiplicative", "decl_tp": "\u2200 {k : \u2115}, (nat.arithmetic_function.sigma k).is_multiplicative", "decl_nm": "nat.arithmetic_function.is_multiplicative_sigma", "nl_statement_of_codex": "The function $\\sigma_k:\\mathbb{N}\\to\\mathbb{N}$ is multiplicative."}
{"formal_statement": "theorem source_inter_preimage_eq {\u03b1 \u03b2 : Type*} {e e' : local_equiv \u03b1 \u03b2}\n\t(he : e \u2248 e') :\n\t\u2200 (s : set \u03b2), e.source \u2229 \u21d1e \u207b\u00b9' s = e'.source \u2229 \u21d1e' \u207b\u00b9' s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {e e' : local_equiv \u03b1 \u03b2}, e \u2248 e' \u2192 \u2200 (s : set \u03b2), e.source \u2229 \u21d1e \u207b\u00b9' s = e'.source \u2229 \u21d1e' \u207b\u00b9' s", "decl_nm": "local_equiv.eq_on_source.source_inter_preimage_eq", "nl_statement_of_codex": "Let $e, e':X\\to Y$ be local homeomorphisms. If $e$ and $e'$ are equivalent, then $e^{-1}(s)\\cap X=e'^{-1}(s)\\cap X$ for all $s\\subset Y$."}
{"formal_statement": "theorem convex_hull_subset_space {\ud835\udd5c E : Type*} [ordered_ring \ud835\udd5c] [add_comm_group E]\n\t[module \ud835\udd5c E] {K : geometry.simplicial_complex \ud835\udd5c E} {s : finset E} (hs : s \u2208 K.faces) :\n\t\u21d1(convex_hull \ud835\udd5c) \u2191s \u2286 K.space", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : module \ud835\udd5c E] {K : geometry.simplicial_complex \ud835\udd5c E} {s : finset E}, s \u2208 K.faces \u2192 \u21d1(convex_hull \ud835\udd5c) \u2191s \u2286 K.space", "decl_nm": "geometry.simplicial_complex.convex_hull_subset_space", "nl_statement_of_codex": "Let $K$ be a simplicial complex in a vector space $E$ over a field $\\mathbb{K}$. Let $s$ be a face of $K$. Then the convex hull of $s$ is contained in $K$."}
{"formal_statement": "theorem sum_pi_single {\u03b9 : Type*} {M : \u03b9 \u2192 Type*} [decidable_eq \u03b9] [\u03a0 (i : \u03b9), add_comm_monoid (M i)]\n\t(i : \u03b9) (f : \u03a0 (i : \u03b9), M i) (s : finset \u03b9) :\n\ts.sum (\u03bb (j : \u03b9), pi.single j (f j) i) = ite (i \u2208 s) (f i) 0", "decl_tp": "\u2200 {\u03b9 : Type u_1} {M : \u03b9 \u2192 Type u_2} [_inst_2 : decidable_eq \u03b9] [_inst_3 : \u03a0 (i : \u03b9), add_comm_monoid (M i)] (i : \u03b9) (f : \u03a0 (i : \u03b9), M i) (s : finset \u03b9), s.sum (\u03bb (j : \u03b9), pi.single j (f j) i) = ite (i \u2208 s) (f i) 0", "decl_nm": "finset.sum_pi_single", "nl_statement_of_codex": "Let $M$ be a family of commutative monoids indexed by a set $I$. Let $f:I\\to M$ be a function and let $s$ be a finite subset of $I$. Then\n$$\\sum_{j\\in s} \\pi_{i,j}(f(j))=\\begin{cases} f(i) & \\text{if $i\\in s$} \\\\ 0 & \\text{if $i\\notin s$} \\end{cases}$$\nwhere $\\pi_{i,j}$ is the projection from $M$ to the $j$-th component."}
{"formal_statement": "theorem mop_tensor_obj {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t(X Y : C\u1d39\u1d52\u1d56) :\n\tX \u2297 Y = category_theory.monoidal_opposite.mop (category_theory.monoidal_opposite.unmop Y \u2297 category_theory.monoidal_opposite.unmop X)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] (X Y : C\u1d39\u1d52\u1d56), X \u2297 Y = category_theory.monoidal_opposite.mop (category_theory.monoidal_opposite.unmop Y \u2297 category_theory.monoidal_opposite.unmop X)", "decl_nm": "category_theory.mop_tensor_obj", "nl_statement_of_codex": "The tensor product of two objects in the monoidal opposite category is the tensor product of the underlying objects in the original category."}
{"formal_statement": "theorem inj_on_range {\u03b1 : Type u} {\u03b2 : Type v} {fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} (h : function.semiconj f fa fb) (ha : function.injective fa)\n\t(hf : set.inj_on f (set.range fa)) :\n\tset.inj_on fb (set.range f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2}, function.semiconj f fa fb \u2192 function.injective fa \u2192 set.inj_on f (set.range fa) \u2192 set.inj_on fb (set.range f)", "decl_nm": "function.semiconj.inj_on_range", "nl_statement_of_codex": "Let $f:A\\to B$ be a function. Let $f_A:A\\to A$ and $f_B:B\\to B$ be functions such that $f_B\\circ f=f\\circ f_A$.\nIf $f_A$ is injective and $f$ is injective on the range of $f_A$, then $f_B$ is injective on the range of $f$."}
{"formal_statement": "theorem sum_induction_nonempty {\u03b1 : Type*} [add_comm_monoid \u03b1] {s : multiset \u03b1}\n\t(p : \u03b1 \u2192 Prop) (hs : s \u2260 \u2205) :\n\t(\u2200 (a b : \u03b1), p a \u2192 p b \u2192 p (a + b)) \u2192  (\u2200 (a : \u03b1), a \u2208 s \u2192 p a) \u2192 p s.sum", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_1 : add_comm_monoid \u03b1] {s : multiset \u03b1} (p : \u03b1 \u2192 Prop), (\u2200 (a b : \u03b1), p a \u2192 p b \u2192 p (a + b)) \u2192 s \u2260 \u2205 \u2192 (\u2200 (a : \u03b1), a \u2208 s \u2192 p a) \u2192 p s.sum", "decl_nm": "multiset.sum_induction_nonempty", "nl_statement_of_codex": "Let $s$ be a nonempty multiset of elements of an additive commutative monoid $A$. Suppose that $p$ is a property of elements of $A$ such that $p(a+b)$ holds whenever $p(a)$ and $p(b)$ hold. Then $p(s)$ holds."}
{"formal_statement": "theorem coe_copy {R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = \u2191S) :\n\t\u2191(S.copy s hs) = s", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] (S : subring R) (s : set R) (hs : s = \u2191S), \u2191(S.copy s hs) = s", "decl_nm": "subring.coe_copy", "nl_statement_of_codex": "Let $R$ be a ring and let $S$ be a subring of $R$. Let $s$ be a subset of $R$ such that $s=S$. Then $s$ is a subring of $R$."}
{"formal_statement": "theorem comp_lower_semicontinuous_at {\u03b1 : Type*} [topological_space \u03b1]\n\t{x : \u03b1} {\u03b3 : Type*} [linear_order \u03b3] [topological_space \u03b3] [order_topology \u03b3]\n\t{\u03b4 : Type*} [linear_order \u03b4] [topological_space \u03b4] [order_topology \u03b4]\n\t{g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3} (hg : continuous_at g (f x)) (hf : lower_semicontinuous_at f x)\n\t(gmon : monotone g) :\n\tlower_semicontinuous_at (g \u2218 f) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {x : \u03b1} {\u03b3 : Type u_3} [_inst_3 : linear_order \u03b3] [_inst_4 : topological_space \u03b3] [_inst_5 : order_topology \u03b3] {\u03b4 : Type u_4} [_inst_6 : linear_order \u03b4] [_inst_7 : topological_space \u03b4] [_inst_8 : order_topology \u03b4] {g : \u03b3 \u2192 \u03b4} {f : \u03b1 \u2192 \u03b3}, continuous_at g (f x) \u2192 lower_semicontinuous_at f x \u2192 monotone g \u2192 lower_semicontinuous_at (g \u2218 f) x", "decl_nm": "continuous_at.comp_lower_semicontinuous_at", "nl_statement_of_codex": "Let $X$ be a topological space, let $Y$ and $Z$ be ordered topological spaces, and let $f:X\\to Y$ and $g:Y\\to Z$ be functions. If $g$ is continuous at $f(x)$ and $f$ is lower semicontinuous at $x$, then $g\\circ f$ is lower semicontinuous at $x$."}
{"formal_statement": "theorem dvd {n a b : \u2115} :\n\ta \u2261 b [MOD n] \u2192 \u2191n \u2223 \u2191b - \u2191a", "decl_tp": "\u2200 {n a b : \u2115}, a \u2261 b [MOD n] \u2192 \u2191n \u2223 \u2191b - \u2191a", "decl_nm": "nat.modeq.dvd", "nl_statement_of_codex": "If $a\\equiv b\\pmod{n}$, then $n$ divides $b-a$."}
{"formal_statement": "theorem image_subset_image_iff {\u03b1 : Type u} {\u03b2 : Type v} {s t : set \u03b1}\n\t{f : \u03b1 \u2192 \u03b2} (hf : function.injective f) :\n\t(f '' s \u2286 f '' t \u2194 s \u2286 t)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s t : set \u03b1} {f : \u03b1 \u2192 \u03b2}, function.injective f \u2192 (f '' s \u2286 f '' t \u2194 s \u2286 t)", "decl_nm": "set.image_subset_image_iff", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $f(A)\\subset f(B)$ if and only if $A\\subset B$."}
{"formal_statement": "theorem comp_injective {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} (f : \u03b1 \u2192 \u03b2)\n\t(e : \u03b2 \u2243 \u03b3) :\n\tfunction.injective (\u21d1e \u2218 f) \u2194 function.injective f", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} (f : \u03b1 \u2192 \u03b2) (e : \u03b2 \u2243 \u03b3), function.injective (\u21d1e \u2218 f) \u2194 function.injective f", "decl_nm": "equiv.comp_injective", "nl_statement_of_codex": "Let $f:A\\to B$ and $e:B\\to C$ be functions. Then $f$ is injective if and only if $e\\circ f$ is injective."}
{"formal_statement": "theorem top_add {\u03b1 : Type u} [linear_ordered_add_comm_monoid_with_top \u03b1]\n\t(a : \u03b1) :\n\t\u22a4 + a = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_add_comm_monoid_with_top \u03b1] (a : \u03b1), \u22a4 + a = \u22a4", "decl_nm": "top_add", "nl_statement_of_codex": "Let $\u03b1$ be a linear ordered add commutative monoid with top. Then $\u22a4+a=\u22a4$ for all $a\\in \u03b1$."}
{"formal_statement": "theorem tsub_eq_of_eq_add {\u03b1 : Type*} [partial_order \u03b1] [add_comm_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] {a b c : \u03b1} [contravariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t(h : a = c + b) :\n\ta - b = c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : add_comm_monoid \u03b1] [_inst_3 : has_sub \u03b1] [_inst_4 : has_ordered_sub \u03b1] {a b c : \u03b1} [_inst_5 : contravariant_class \u03b1 \u03b1 has_add.add has_le.le], a = c + b \u2192 a - b = c", "decl_nm": "tsub_eq_of_eq_add", "nl_statement_of_codex": "Let $a,b,c$ be elements of a partially ordered abelian monoid with subtraction. If $a=c+b$, then $a-b=c$."}
{"formal_statement": "theorem self_act_act_eq {R : Type*} [rack R] {x y : R} :\n\tshelf.act (shelf.act x x) y = shelf.act x y", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : rack R] {x y : R}, shelf.act (shelf.act x x) y = shelf.act x y", "decl_nm": "rack.self_act_act_eq", "nl_statement_of_codex": "Let $R$ be a rack. Then for all $x,y\\in R$, $x\\trid x\\trid y=x\\trid y$."}
{"formal_statement": "theorem sub_apply {\u03b9 : Type v} {\u03b2 : \u03b9 \u2192 Type w} [\u03a0 (i : \u03b9), add_comm_group (\u03b2 i)]\n\t(g\u2081 g\u2082 : direct_sum \u03b9 (\u03bb (i : \u03b9), \u03b2 i)) (i : \u03b9) :\n\t\u21d1(g\u2081 - g\u2082) i = \u21d1g\u2081 i - \u21d1g\u2082 i", "decl_tp": "\u2200 {\u03b9 : Type v} {\u03b2 : \u03b9 \u2192 Type w} [_inst_1 : \u03a0 (i : \u03b9), add_comm_group (\u03b2 i)] (g\u2081 g\u2082 : direct_sum \u03b9 (\u03bb (i : \u03b9), \u03b2 i)) (i : \u03b9), \u21d1(g\u2081 - g\u2082) i = \u21d1g\u2081 i - \u21d1g\u2082 i", "decl_nm": "direct_sum.sub_apply", "nl_statement_of_codex": "Let $g_1, g_2$ be elements of the direct sum $\\bigoplus_{i\\in I}G_i$. Then the $i$-th component of $g_1-g_2$ is the difference of the $i$-th components of $g_1$ and $g_2$."}
{"formal_statement": "theorem pairwise_disjoint_fiber {\u03b1 \u03b9 : Type*} (f : \u03b9 \u2192 \u03b1) (s : set \u03b1) :\n\ts.pairwise_disjoint (\u03bb (a : \u03b1), f \u207b\u00b9' {a})", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} (f : \u03b9 \u2192 \u03b1) (s : set \u03b1), s.pairwise_disjoint (\u03bb (a : \u03b1), f \u207b\u00b9' {a})", "decl_nm": "set.pairwise_disjoint_fiber", "nl_statement_of_codex": "Let $f:I\\to A$ be a function and let $S$ be a subset of $A$. Then the sets $f^{-1}(a)$ for $a\\in S$ are pairwise disjoint."}
{"formal_statement": "theorem snd_comp_inr {M N : Type*} [add_zero_class M] [add_zero_class N] :\n\t(add_monoid_hom.snd M N).comp (add_monoid_hom.inr M N) = add_monoid_hom.id N", "decl_tp": "\u2200 {M : Type u_5} {N : Type u_6} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N], (add_monoid_hom.snd M N).comp (add_monoid_hom.inr M N) = add_monoid_hom.id N", "decl_nm": "add_monoid_hom.snd_comp_inr", "nl_statement_of_codex": "The composition of the second projection and the inclusion is the identity."}
{"formal_statement": "theorem nhds_within_singleton {\u03b1 : Type*} [topological_space \u03b1] (a : \u03b1) :\n\tnhds_within a {a} = has_pure.pure a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] (a : \u03b1), nhds_within a {a} = has_pure.pure a", "decl_nm": "nhds_within_singleton", "nl_statement_of_codex": "The neighborhood filter of $a$ in the singleton set $\\{a\\}$ is the pure filter at $a$."}
{"formal_statement": "theorem equiv_relation {J : Type u\u2081} [category_theory.category J] [category_theory.is_connected J]\n\t(r : J \u2192 J \u2192 Prop) (hr : equivalence r) :\n\t(\u2200 {j\u2081 j\u2082 : J}, (j\u2081 \u27f6 j\u2082) \u2192 r j\u2081 j\u2082) \u2192 \u2200 (j\u2081 j\u2082 : J), r j\u2081 j\u2082", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] [_inst_3 : category_theory.is_connected J] (r : J \u2192 J \u2192 Prop), equivalence r \u2192 (\u2200 {j\u2081 j\u2082 : J}, (j\u2081 \u27f6 j\u2082) \u2192 r j\u2081 j\u2082) \u2192 \u2200 (j\u2081 j\u2082 : J), r j\u2081 j\u2082", "decl_nm": "category_theory.equiv_relation", "nl_statement_of_codex": "Let $J$ be a connected category. Let $r$ be an equivalence relation on $J$. If for any two objects $j_1, j_2$ of $J$, there is a morphism from $j_1$ to $j_2$ if and only if $r(j_1, j_2)$, then $r$ is the identity relation."}
{"formal_statement": "theorem continuous_at_iff {\u03b1 \u03b2 \u03b3 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t[topological_space \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : inducing g) :\n\t\u2200 {x : \u03b1}, continuous_at f x \u2194 continuous_at (g \u2218 f) x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}, inducing g \u2192 \u2200 {x : \u03b1}, continuous_at f x \u2194 continuous_at (g \u2218 f) x", "decl_nm": "inducing.continuous_at_iff", "nl_statement_of_codex": "Let $f:X\\to Y$ and $g:Y\\to Z$ be functions between topological spaces. Then $f$ is continuous at $x\\in X$ if and only if $g\\circ f$ is continuous at $x$."}
{"formal_statement": "theorem sizeof_append_lt_left {\u03b1 : Type u} [has_sizeof \u03b1] {xs ys ys' : list \u03b1}\n\t(h : sizeof ys < sizeof ys') :\n\tsizeof (xs ++ ys) < sizeof (xs ++ ys')", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : has_sizeof \u03b1] {xs ys ys' : list \u03b1}, sizeof ys < sizeof ys' \u2192 sizeof (xs ++ ys) < sizeof (xs ++ ys')", "decl_nm": "slim_check.list.sizeof_append_lt_left", "nl_statement_of_codex": "Let $xs, ys, ys'$ be lists of elements of a type $\u03b1$ with a size function. If the size of $ys$ is less than the size of $ys'$, then the size of $xs++ys$ is less than the size of $xs++ys'$."}
{"formal_statement": "theorem fst {\u03b1 \u03b2 : Type*} [primcodable \u03b1] [primcodable \u03b2] :\n\tcomputable prod.fst", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2], computable prod.fst", "decl_nm": "computable.fst", "nl_statement_of_codex": "The function $\\pi_1:\\alpha\\times\\beta\\to\\alpha$ is computable."}
{"formal_statement": "theorem inv_lt_iff_one_lt_mul' {\u03b1 : Type u} [group \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt]\n\t{a b : \u03b1} :\n\ta\u207b\u00b9 < b \u2194 1 < a * b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt] {a b : \u03b1}, a\u207b\u00b9 < b \u2194 1 < a * b", "decl_nm": "inv_lt_iff_one_lt_mul'", "nl_statement_of_codex": "Let $G$ be a group with a total order. Then $a^{-1}<b$ if and only if $1<ab$."}
{"formal_statement": "theorem forall_mem_inter_of_forall_right {\u03b1 : Type*} {l\u2082 : list \u03b1} {p : \u03b1 \u2192 Prop}\n\t[decidable_eq \u03b1] (l\u2081 : list \u03b1) :\n\t(\u2200 (x : \u03b1), x \u2208 l\u2082 \u2192 p x) \u2192 \u2200 (x : \u03b1), x \u2208 l\u2081 \u2229 l\u2082 \u2192 p x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l\u2082 : list \u03b1} {p : \u03b1 \u2192 Prop} [_inst_1 : decidable_eq \u03b1] (l\u2081 : list \u03b1), (\u2200 (x : \u03b1), x \u2208 l\u2082 \u2192 p x) \u2192 \u2200 (x : \u03b1), x \u2208 l\u2081 \u2229 l\u2082 \u2192 p x", "decl_nm": "list.forall_mem_inter_of_forall_right", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of elements of a type $\u03b1$. If $p$ is a property of elements of $\u03b1$ such that $p(x)$ holds for all $x\\in l_2$, then $p(x)$ holds for all $x\\in l_1\\cap l_2$."}
{"formal_statement": "theorem append_nil {\u03b1 : Type u} (s : wseq \u03b1) :\n\ts.append wseq.nil = s", "decl_tp": "\u2200 {\u03b1 : Type u} (s : wseq \u03b1), s.append wseq.nil = s", "decl_nm": "wseq.append_nil", "nl_statement_of_codex": "The concatenation of a word sequence $s$ with the empty word sequence is $s$."}
{"formal_statement": "theorem inner_content_le {G : Type w} [topological_space G] (\u03bc : measure_theory.content G)\n\t(U : topological_space.opens G) (K : topological_space.compacts G) (h2 : \u2191U \u2286 K.val) :\n\t\u03bc.inner_content U \u2264 \u21d1\u03bc K", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] (\u03bc : measure_theory.content G) (U : topological_space.opens G) (K : topological_space.compacts G), \u2191U \u2286 K.val \u2192 \u03bc.inner_content U \u2264 \u21d1\u03bc K", "decl_nm": "measure_theory.content.inner_content_le", "nl_statement_of_codex": "Let $G$ be a topological space and let $\\mu$ be a content on $G$. Let $U$ be an open subset of $G$ and let $K$ be a compact subset of $G$. If $U\\subset K$, then $\\mu(U)\\leq\\mu(K)$."}
{"formal_statement": "theorem sum_cases_left {\u03b1 \u03b2 \u03b3 \u03c3 : Type*} [primcodable \u03b1] [primcodable \u03b2]\n\t[primcodable \u03b3] [primcodable \u03c3] {f : \u03b1 \u2192 \u03b2 \u2295 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192 \u03c3}\n\t(hf : computable f) (hg : partrec\u2082 g) (hh : computable\u2082 h) :\n\tpartrec (\u03bb (a : \u03b1), (f a).cases_on (g a) (\u03bb (c : \u03b3), part.some (h a c)))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03c3 : Type u_4} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_3 : primcodable \u03b3] [_inst_4 : primcodable \u03c3] {f : \u03b1 \u2192 \u03b2 \u2295 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192 \u03c3}, computable f \u2192 partrec\u2082 g \u2192 computable\u2082 h \u2192 partrec (\u03bb (a : \u03b1), (f a).cases_on (g a) (\u03bb (c : \u03b3), part.some (h a c)))", "decl_nm": "partrec.sum_cases_left", "nl_statement_of_codex": "Let $f:A\\to B\\oplus C$ be a computable function. Let $g:A\\times B\\to D$ be a partial recursive function. Let $h:A\\times C\\to D$ be a computable function. Then the function $f':A\\to D$ defined by $f'(a)=g(a,b)$ if $f(a)=inl(b)$ and $f'(a)=h(a,c)$ if $f(a)=inr(c)$ is partial recursive."}
{"formal_statement": "theorem set_index_subset {\u03b1 : Type*} {\u03b9 : Sort u_4} {l : filter \u03b1} {p : \u03b9 \u2192 Prop}\n\t{s : \u03b9 \u2192 set \u03b1} {t : set \u03b1} (h : l.has_basis p s) (ht : t \u2208 l) :\n\ts \u2191(h.index t ht) \u2286 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_4} {l : filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 set \u03b1} {t : set \u03b1} (h : l.has_basis p s) (ht : t \u2208 l), s \u2191(h.index t ht) \u2286 t", "decl_nm": "filter.has_basis.set_index_subset", "nl_statement_of_codex": "Let $l$ be a filter on a set $X$ and let $p$ be a property of the index set $I$ of $l$. Let $s$ be a function from $I$ to the subsets of $X$. Suppose that $l$ has a basis $p$ and $s$. Let $t$ be a subset of $X$. Then $s(i)\\subset t$ for some $i\\in I$."}
{"formal_statement": "theorem insert {\u03b3 : Type w} [linear_order \u03b3] (a : \u03b3) {b : \u03b3} {s : set \u03b3}\n\t(hs : is_least s b) :\n\tis_least (has_insert.insert a s) (linear_order.min a b)", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_3 : linear_order \u03b3] (a : \u03b3) {b : \u03b3} {s : set \u03b3}, is_least s b \u2192 is_least (has_insert.insert a s) (linear_order.min a b)", "decl_nm": "is_least.insert", "nl_statement_of_codex": "Let $S$ be a set with a least element $b$. Then the set $S\\cup\\{a\\}$ has a least element $\\min(a,b)$."}
{"formal_statement": "theorem lt_inv_iff_mul_lt_one' {\u03b1 : Type u} [group \u03b1] [has_lt \u03b1] [covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt]\n\t{a b : \u03b1} :\n\ta < b\u207b\u00b9 \u2194 b * a < 1", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt] {a b : \u03b1}, a < b\u207b\u00b9 \u2194 b * a < 1", "decl_nm": "lt_inv_iff_mul_lt_one'", "nl_statement_of_codex": "Let $G$ be a group and let $a, b\\in G$. Then $a<b^{-1}$ if and only if $ba<1$."}
{"formal_statement": "theorem map_midpoint {R V V' P P' : Type*} [ring R] [invertible 2] [add_comm_group V]\n\t[module R V] [add_torsor V P] [add_comm_group V'] [module R V'] [add_torsor V' P']\n\t(f : P \u2192\u1d43[R] P') (a b : P) :\n\t\u21d1f (midpoint R a b) = midpoint R (\u21d1f a) (\u21d1f b)", "decl_tp": "\u2200 {R : Type u_1} {V : Type u_2} {V' : Type u_3} {P : Type u_4} {P' : Type u_5} [_inst_1 : ring R] [_inst_2 : invertible 2] [_inst_3 : add_comm_group V] [_inst_4 : module R V] [_inst_5 : add_torsor V P] [_inst_6 : add_comm_group V'] [_inst_7 : module R V'] [_inst_8 : add_torsor V' P'] (f : P \u2192\u1d43[R] P') (a b : P), \u21d1f (midpoint R a b) = midpoint R (\u21d1f a) (\u21d1f b)", "decl_nm": "affine_map.map_midpoint", "nl_statement_of_codex": "Let $R$ be a ring, $V$ and $V'$ be $R$-modules, $P$ and $P'$ be $R$-torsors over $V$ and $V'$, respectively.\nLet $f:P\\to P'$ be an $R$-equivariant map. Then $f$ maps the midpoint of $a$ and $b$ to the midpoint of $f(a)$ and $f(b)$."}
{"formal_statement": "theorem insert_ae_eq_self {\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measure_theory.has_no_atoms \u03bc] (a : \u03b1) (s : set \u03b1) :\n\thas_insert.insert a s =\u1d50[\u03bc] s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : measure_theory.has_no_atoms \u03bc] (a : \u03b1) (s : set \u03b1), has_insert.insert a s =\u1d50[\u03bc] s", "decl_nm": "measure_theory.insert_ae_eq_self", "nl_statement_of_codex": "Let $A$ be a set with no atoms. Then $A\\cup\\{a\\}$ is equal to $A$ almost everywhere."}
{"formal_statement": "theorem finsupp_lequiv_dfinsupp_symm_apply {\u03b9 : Type*} (R : Type*) {M : Type*}\n\t[decidable_eq \u03b9] [semiring R] [add_comm_monoid M] [\u03a0 (m : M), decidable (m \u2260 0)]\n\t[module R M] :\n\t\u21d1((finsupp_lequiv_dfinsupp R).symm) = dfinsupp.to_finsupp", "decl_tp": "\u2200 {\u03b9 : Type u_1} (R : Type u_2) {M : Type u_3} [_inst_1 : decidable_eq \u03b9] [_inst_2 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : \u03a0 (m : M), decidable (m \u2260 0)] [_inst_5 : module R M], \u21d1((finsupp_lequiv_dfinsupp R).symm) = dfinsupp.to_finsupp", "decl_nm": "finsupp_lequiv_dfinsupp_symm_apply", "nl_statement_of_codex": "The map from finitely supported functions to decidable finitely supported functions is the inverse of the map from decidable finitely supported functions to finitely supported functions."}
{"formal_statement": "theorem intermediate_value_Iic {X : Type u} {\u03b1 : Type v} [topological_space X]\n\t[linear_order \u03b1] [topological_space \u03b1] [order_closed_topology \u03b1] {s : set X}\n\t(hs : is_preconnected s) (a : X) (ha : a \u2208 s) (hl : l \u2264 filter.principal s)\n\t(hf : continuous_on f s) (ht : filter.tendsto f l filter.at_bot) :\n\t\u2200 {a : X} {l : filter X},  \u2200 [l.ne_bot],  \u2200 {f :  \u03b1},   set.Iic (f a) \u2286 f '' s", "decl_tp": "\u2200 {X : Type u} {\u03b1 : Type v} [_inst_1 : topological_space X] [_inst_2 : linear_order \u03b1] [_inst_3 : topological_space \u03b1] [_inst_4 : order_closed_topology \u03b1] {s : set X}, is_preconnected s \u2192 \u2200 {a : X} {l : filter X}, a \u2208 s \u2192 \u2200 [_inst_5 : l.ne_bot], l \u2264 filter.principal s \u2192 \u2200 {f : X \u2192 \u03b1}, continuous_on f s \u2192 filter.tendsto f l filter.at_bot \u2192 set.Iic (f a) \u2286 f '' s", "decl_nm": "is_preconnected.intermediate_value_Iic", "nl_statement_of_codex": "Let $X$ be a topological space and let $s$ be a preconnected subset of $X$. Let $f:X\\to \\mathbb{R}$ be a continuous function. Then $f(s)$ is an interval."}
{"formal_statement": "theorem head_induction_on {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {b : \u03b1} {P : \u03a0 (a : \u03b1), relation.refl_trans_gen r a b \u2192 Prop}\n\t{a : \u03b1} (h : relation.refl_trans_gen r a b) (refl : P b relation.refl_trans_gen.refl) :\n\t(\u2200 {a c : \u03b1} (h' : r a c) (h : relation.refl_trans_gen r c b), P c h \u2192 P a _) \u2192 P a h", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {b : \u03b1} {P : \u03a0 (a : \u03b1), relation.refl_trans_gen r a b \u2192 Prop} {a : \u03b1} (h : relation.refl_trans_gen r a b), P b relation.refl_trans_gen.refl \u2192 (\u2200 {a c : \u03b1} (h' : r a c) (h : relation.refl_trans_gen r c b), P c h \u2192 P a _) \u2192 P a h", "decl_nm": "relation.refl_trans_gen.head_induction_on", "nl_statement_of_codex": "Let $r$ be a relation on a type $\u03b1$. Let $b$ be an element of $\u03b1$. Let $P$ be a property of elements of $\u03b1$ and proofs of $r$-transitivity from $b$. Let $a$ be an element of $\u03b1$ and let $h$ be a proof of $r$-transitivity from $a$ to $b$. Suppose that $P$ holds for $b$ and that $P$ holds for $c$ whenever $r$ holds from $a$ to $c$ and $P$ holds for $c$ and $r$-transitivity from $c$ to $b$. Then $P$ holds for $a"}
{"formal_statement": "theorem inf_to_subfield {F : Type*} [field F] {E : Type*} [field E] [algebra F E]\n\t(S T : intermediate_field F E) :\n\t(S \u2293 T).to_subfield = S.to_subfield \u2293 T.to_subfield", "decl_tp": "\u2200 {F : Type u_1} [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E] (S T : intermediate_field F E), (S \u2293 T).to_subfield = S.to_subfield \u2293 T.to_subfield", "decl_nm": "intermediate_field.inf_to_subfield", "nl_statement_of_codex": "Let $F$ be a field and let $E$ be a field extension of $F$. Let $S$ and $T$ be intermediate fields of $F$ and $E$. Then the intersection of $S$ and $T$ is equal to the intersection of the subfields of $E$ generated by $S$ and $T$."}
{"formal_statement": "theorem induction_on_pi_max {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [fintype \u03b9] [decidable_eq \u03b9]\n\t[\u03a0 (i : \u03b9), decidable_eq (\u03b1 i)] [\u03a0 (i : \u03b9), linear_order (\u03b1 i)] {p : (\u03a0 (i : \u03b9), finset (\u03b1 i)) \u2192 Prop}\n\t(f : \u03a0 (i : \u03b9), finset (\u03b1 i)) (h0 : p (\u03bb (_x : \u03b9), \u2205)) :\n\t(\u2200 (g : \u03a0 (i : \u03b9), finset (\u03b1 i)) (i : \u03b9) (x : \u03b1 i), (\u2200 (y : \u03b1 i), y \u2208 g i \u2192 y < x) \u2192 p g \u2192 p (function.update g i (has_insert.insert x (g i)))) \u2192 p f", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} [_inst_1 : fintype \u03b9] [_inst_2 : decidable_eq \u03b9] [_inst_3 : \u03a0 (i : \u03b9), decidable_eq (\u03b1 i)] [_inst_4 : \u03a0 (i : \u03b9), linear_order (\u03b1 i)] {p : (\u03a0 (i : \u03b9), finset (\u03b1 i)) \u2192 Prop} (f : \u03a0 (i : \u03b9), finset (\u03b1 i)), p (\u03bb (_x : \u03b9), \u2205) \u2192 (\u2200 (g : \u03a0 (i : \u03b9), finset (\u03b1 i)) (i : \u03b9) (x : \u03b1 i), (\u2200 (y : \u03b1 i), y \u2208 g i \u2192 y < x) \u2192 p g \u2192 p (function.update g i (has_insert.insert x (g i)))) \u2192 p f", "decl_nm": "finset.induction_on_pi_max", "nl_statement_of_codex": "Let $\\alpha$ be a family of linear orders indexed by a finite set $\\iota$. Let $p$ be a property of finite subsets of $\\alpha$. Suppose that $p$ holds for the empty set. Suppose that $p$ holds for a finite subset $g$ of $\\alpha$ if $p$ holds for $g$ and $g$ is extended by a new element $x$ in some $\\alpha_i$ which is smaller than all elements of $g$ in $\\alpha_i$. Then $p$ holds for any finite subset of $\\alpha$."}
{"formal_statement": "theorem mul_mul_inv_of_self_cancel {\u03b1 : Type u} [monoid \u03b1] (a b : \u03b1) [invertible b] :\n\ta * b * \u215f b = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : monoid \u03b1] (a b : \u03b1) [_inst_2 : invertible b], a * b * \u215f b = a", "decl_nm": "mul_mul_inv_of_self_cancel", "nl_statement_of_codex": "Let $a, b$ be elements of a monoid $M$ such that $b$ is invertible. Then $a\\cdot b\\cdot b^{-1}=a$."}
{"formal_statement": "theorem of_semiring {\u03b1 : Type u} {\u03b2 : Type v} [ring \u03b1] [ring \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t(H : is_semiring_hom f) :\n\tis_ring_hom f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : ring \u03b1] [_inst_2 : ring \u03b2] {f : \u03b1 \u2192 \u03b2}, is_semiring_hom f \u2192 is_ring_hom f", "decl_nm": "is_ring_hom.of_semiring", "nl_statement_of_codex": "If $f:R\\to S$ is a semiring homomorphism, then $f$ is a ring homomorphism."}
{"formal_statement": "theorem lt_Inf_add_pos {s : set \u211d} (h : s.nonempty) (h\u03b5 : 0 < \u03b5) :\n\t\u2200 {\u03b5 : \u211d},  (\u2203 (a : \u211d) (H : a \u2208 s), a < has_Inf.Inf s + \u03b5)", "decl_tp": "\u2200 {s : set \u211d}, s.nonempty \u2192 \u2200 {\u03b5 : \u211d}, 0 < \u03b5 \u2192 (\u2203 (a : \u211d) (H : a \u2208 s), a < has_Inf.Inf s + \u03b5)", "decl_nm": "real.lt_Inf_add_pos", "nl_statement_of_codex": "Let $s$ be a nonempty set of real numbers. Then for every $\\epsilon>0$ there is an element $a\\in s$ such that $a<\\inf s+\\epsilon$."}
{"formal_statement": "theorem is_periodic_pt_iff_minimal_period_dvd {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {x : \u03b1}\n\t{n : \u2115} :\n\tfunction.is_periodic_pt f n x \u2194 function.minimal_period f x \u2223 n", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {n : \u2115}, function.is_periodic_pt f n x \u2194 function.minimal_period f x \u2223 n", "decl_nm": "function.is_periodic_pt_iff_minimal_period_dvd", "nl_statement_of_codex": "Let $f:X\\to X$ be a function and let $x\\in X$. Then $f$ is periodic at $x$ with period $n$ if and only if $n$ divides the minimal period of $f$ at $x$."}
{"formal_statement": "theorem functor_obj_obj_X {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] [category_theory.monoidal_category D] (A : Mon_ (C \u2964 D))\n\t(X : C) :\n\t((category_theory.monoidal.Mon_functor_category_equivalence.functor.obj A).obj X).X = A.X.obj X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.monoidal_category D] (A : Mon_ (C \u2964 D)) (X : C), ((category_theory.monoidal.Mon_functor_category_equivalence.functor.obj A).obj X).X = A.X.obj X", "decl_nm": "category_theory.monoidal.Mon_functor_category_equivalence.functor_obj_obj_X", "nl_statement_of_codex": "Let $C$ and $D$ be categories and let $A$ be a monoidal functor from $C$ to $D$. Then the functor $A$ is equivalent to the functor $A'$ defined by $A'(X)=A(X)$."}
{"formal_statement": "theorem add {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*} [normed_group E]\n\t[normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F] {n : with_top \u2115}\n\t{f g : E \u2192 F} (hf : times_cont_diff \ud835\udd5c n f) (hg : times_cont_diff \ud835\udd5c n g) :\n\ttimes_cont_diff \ud835\udd5c n (\u03bb (x : E), f x + g x)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {n : with_top \u2115} {f g : E \u2192 F}, times_cont_diff \ud835\udd5c n f \u2192 times_cont_diff \ud835\udd5c n g \u2192 times_cont_diff \ud835\udd5c n (\u03bb (x : E), f x + g x)", "decl_nm": "times_cont_diff.add", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f,g:E\\to F$ be $n$-times continuously differentiable. Then $f+g$ is $n$-times continuously differentiable."}
{"formal_statement": "theorem square_to_snd_left {C : Type u} [category_theory.category C] {X Y Z : C}\n\t{i : category_theory.arrow C} {f : X \u27f6 Y} {g : Y \u27f6 Z} (sq : i \u27f6 category_theory.arrow.mk (f \u226b g)) :\n\t(category_theory.arrow.square_to_snd sq).left = sq.left \u226b f", "decl_tp": "\u2200 {C : Type u} [_inst_2 : category_theory.category C] {X Y Z : C} {i : category_theory.arrow C} {f : X \u27f6 Y} {g : Y \u27f6 Z} (sq : i \u27f6 category_theory.arrow.mk (f \u226b g)), (category_theory.arrow.square_to_snd sq).left = sq.left \u226b f", "decl_nm": "category_theory.arrow.square_to_snd_left", "nl_statement_of_codex": "Let $C$ be a category. Let $X, Y, Z$ be objects of $C$ and let $f:X\\to Y$ and $g:Y\\to Z$ be morphisms. Let $i$ be an object of $C$ and let $sq$ be a square in $C$ with $sq.left=f$ and $sq.right=g$. Then $(category_theory.arrow.square_to_snd sq).left=sq.left\\circ f$."}
{"formal_statement": "theorem left_op_obj {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] (F : C \u2964 D\u1d52\u1d56) (X : C\u1d52\u1d56) :\n\tF.left_op.obj X = opposite.unop (F.obj (opposite.unop X))", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (F : C \u2964 D\u1d52\u1d56) (X : C\u1d52\u1d56), F.left_op.obj X = opposite.unop (F.obj (opposite.unop X))", "decl_nm": "category_theory.functor.left_op_obj", "nl_statement_of_codex": "Let $F:C\\to D^{\\mathrm{op}}$ be a functor. Then $F$ induces a functor $F^{\\mathrm{op}}:C^{\\mathrm{op}}\\to D$ by $F^{\\mathrm{op}}(X)=F(X^{\\mathrm{op}})^{\\mathrm{op}}$."}
{"formal_statement": "theorem uniform_embedding {\u03b1 : Type u} [emetric_space \u03b1] :\n\tuniform_embedding topological_space.nonempty_compacts.to_closeds", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : emetric_space \u03b1], uniform_embedding topological_space.nonempty_compacts.to_closeds", "decl_nm": "emetric.nonempty_compacts.to_closeds.uniform_embedding", "nl_statement_of_codex": "The map from nonempty compact subsets of a metric space to closed subsets is a uniform embedding."}
{"formal_statement": "theorem le_of_forall_pos_le_add {a b : nnreal} :\n\t(\u2200 (\u03b5 : nnreal), 0 < \u03b5 \u2192 a \u2264 b + \u03b5) \u2192 a \u2264 b", "decl_tp": "\u2200 {a b : nnreal}, (\u2200 (\u03b5 : nnreal), 0 < \u03b5 \u2192 a \u2264 b + \u03b5) \u2192 a \u2264 b", "decl_nm": "nnreal.le_of_forall_pos_le_add", "nl_statement_of_codex": "Let $a,b$ be nonnegative real numbers. If for all $\\epsilon>0$, $a\\leq b+\\epsilon$, then $a\\leq b$."}
{"formal_statement": "theorem left_distrib (a b c : cardinal) :\n\ta * (b + c) = a * b + a * c", "decl_tp": "\u2200 (a b c : cardinal), a * (b + c) = a * b + a * c", "decl_nm": "cardinal.left_distrib", "nl_statement_of_codex": "The left distributive law holds for cardinal multiplication."}
{"formal_statement": "theorem mem_nsmul {\u03b1 : Type*} {a : \u03b1} {s : multiset \u03b1} {n : \u2115} (h0 : n \u2260 0) :\n\t(a \u2208 n \u2022 s \u2194 a \u2208 s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {a : \u03b1} {s : multiset \u03b1} {n : \u2115}, n \u2260 0 \u2192 (a \u2208 n \u2022 s \u2194 a \u2208 s)", "decl_nm": "multiset.mem_nsmul", "nl_statement_of_codex": "Let $a$ be an element of a multiset $s$. Then $a$ is an element of $n\\cdot s$ if and only if $a$ is an element of $s$."}
{"formal_statement": "theorem integral_deriv_eq_sub {E : Type*} [measurable_space E] [normed_group E]\n\t[topological_space.second_countable_topology E] [complete_space E] [normed_space \u211d E]\n\t[borel_space E] {f : \u211d \u2192 E} {a b : \u211d} (hint : interval_integrable (deriv f) measure_theory.measure_space.volume a b) :\n\t(\u2200 (x : \u211d), x \u2208 set.interval a b \u2192 differentiable_at \u211d f x) \u2192  \u222b (y : \u211d) in a..b, deriv f y = f b - f a", "decl_tp": "\u2200 {E : Type u_4} [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : topological_space.second_countable_topology E] [_inst_6 : complete_space E] [_inst_7 : normed_space \u211d E] [_inst_8 : borel_space E] {f : \u211d \u2192 E} {a b : \u211d}, (\u2200 (x : \u211d), x \u2208 set.interval a b \u2192 differentiable_at \u211d f x) \u2192 interval_integrable (deriv f) measure_theory.measure_space.volume a b \u2192 \u222b (y : \u211d) in a..b, deriv f y = f b - f a", "decl_nm": "interval_integral.integral_deriv_eq_sub", "nl_statement_of_codex": "Let $f:\\mathbb{R}\\to E$ be a function. If $f$ is differentiable on $[a,b]$ and the derivative of $f$ is integrable on $[a,b]$, then $\\int_a^b f'(x)dx=f(b)-f(a)$."}
{"formal_statement": "theorem mk_coe' {M N : Type*} [has_add M] [has_add N] (e : M \u2243+ N) (f : N \u2192 M)\n\t(h\u2081 : function.left_inverse \u21d1e f) (h\u2082 : function.right_inverse \u21d1e f) (h\u2083 : \u2200 (x y : N), f (x + y) = f x + f y) :\n\t{to_fun := f, inv_fun := \u21d1e, left_inv := h\u2081, right_inv := h\u2082, map_add' := h\u2083} = e.symm", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : has_add M] [_inst_2 : has_add N] (e : M \u2243+ N) (f : N \u2192 M) (h\u2081 : function.left_inverse \u21d1e f) (h\u2082 : function.right_inverse \u21d1e f) (h\u2083 : \u2200 (x y : N), f (x + y) = f x + f y), {to_fun := f, inv_fun := \u21d1e, left_inv := h\u2081, right_inv := h\u2082, map_add' := h\u2083} = e.symm", "decl_nm": "add_equiv.mk_coe'", "nl_statement_of_codex": "Let $M$ and $N$ be two types with addition. Let $e:M\\to N$ be an additive equivalence. Let $f:N\\to M$ be a function such that $f\\circ e=\\mathrm{id}_M$, $e\\circ f=\\mathrm{id}_N$, and $f(x+y)=f(x)+f(y)$ for all $x,y\\in N$. Then $f$ is an additive equivalence from $N$ to $M$."}
{"formal_statement": "theorem smul_pi\u2080 {K \u03b9 : Type*} {R : \u03b9 \u2192 Type*} [group_with_zero K] [\u03a0 (i : \u03b9), mul_action K (R i)]\n\t{r : K} (S : set \u03b9) (t : \u03a0 (i : \u03b9), set (R i)) (hr : r \u2260 0) :\n\tr \u2022 S.pi t = S.pi (r \u2022 t)", "decl_tp": "\u2200 {K : Type u_1} {\u03b9 : Type u_2} {R : \u03b9 \u2192 Type u_3} [_inst_1 : group_with_zero K] [_inst_2 : \u03a0 (i : \u03b9), mul_action K (R i)] {r : K} (S : set \u03b9) (t : \u03a0 (i : \u03b9), set (R i)), r \u2260 0 \u2192 r \u2022 S.pi t = S.pi (r \u2022 t)", "decl_nm": "smul_pi\u2080", "nl_statement_of_codex": "Let $K$ be a group with zero and let $R_i$ be a $K$-module for each $i\\in I$. Let $r\\in K$ be nonzero and let $S\\subset I$. Then $r\\cdot\\prod_{i\\in S}R_i=\\prod_{i\\in S}r\\cdot R_i$."}
{"formal_statement": "theorem to_nnreal_mono :\n\tmonotone real.to_nnreal", "decl_tp": "monotone real.to_nnreal", "decl_nm": "real.to_nnreal_mono", "nl_statement_of_codex": "The function $x\\mapsto x^+$ is monotone."}
{"formal_statement": "theorem measurable_embedding {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [measurable_space \u03b1]\n\t[borel_space \u03b1] [topological_space \u03b2] [measurable_space \u03b2] [borel_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (h : open_embedding f) :\n\tmeasurable_embedding f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : measurable_space \u03b1] [_inst_3 : borel_space \u03b1] [_inst_4 : topological_space \u03b2] [_inst_5 : measurable_space \u03b2] [_inst_6 : borel_space \u03b2] {f : \u03b1 \u2192 \u03b2}, open_embedding f \u2192 measurable_embedding f", "decl_nm": "open_embedding.measurable_embedding", "nl_statement_of_codex": "Let $f:X\\to Y$ be an open embedding. Then $f$ is a measurable embedding."}
{"formal_statement": "theorem congr_set {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v}\n\t[normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {s t u : set \ud835\udd5c}\n\t(hu : u \u2208 nhds x) (h : s \u2229 u = t \u2229 u) :\n\thas_deriv_within_at f f' s x \u2192 has_deriv_within_at f f' t x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {s t u : set \ud835\udd5c}, u \u2208 nhds x \u2192 s \u2229 u = t \u2229 u \u2192 has_deriv_within_at f f' s x \u2192 has_deriv_within_at f f' t x", "decl_nm": "has_deriv_within_at.congr_set", "nl_statement_of_codex": "Let $f: \\mathbb{K}\\to F$ be a function, where $F$ is a normed space over a nondiscrete normed field $\\mathbb{K}$.\nLet $s, t, u$ be subsets of $\\mathbb{K}$ and let $x\\in \\mathbb{K}$. Suppose that $u$ is a neighborhood of $x$ and that $s\\cap u=t\\cap u$. If $f$ is differentiable at $x$ on $s$, then $f$ is differentiable at $x$ on $t$."}
{"formal_statement": "theorem dvd_mul_of_dvd_right {\u03b1 : Type*} [comm_monoid \u03b1] {a b : \u03b1} (h : a \u2223 b) :\n\t\u2200 (c : \u03b1), a \u2223 c * b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : comm_monoid \u03b1] {a b : \u03b1}, a \u2223 b \u2192 \u2200 (c : \u03b1), a \u2223 c * b", "decl_nm": "dvd_mul_of_dvd_right", "nl_statement_of_codex": "Let $a,b,c$ be elements of a commutative monoid. If $a$ divides $b$, then $a$ divides $c\\cdot b$."}
{"formal_statement": "theorem zero_pow_eq_zero {M : Type*} [monoid_with_zero M] [nontrivial M]\n\t{n : \u2115} :\n\t0 ^ n = 0 \u2194 0 < n", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : monoid_with_zero M] [_inst_2 : nontrivial M] {n : \u2115}, 0 ^ n = 0 \u2194 0 < n", "decl_nm": "zero_pow_eq_zero", "nl_statement_of_codex": "Let $M$ be a nontrivial monoid with zero. Then $0^n=0$ if and only if $n>0$."}
{"formal_statement": "theorem eq_of_iso {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {F\u2081 F\u2082 : D \u2964 C} [\u2200 (X Y : C), subsingleton (X \u27f6 Y)]\n\t(hC : category_theory.skeletal C) :\n\t(F\u2081 \u2245 F\u2082) \u2192 F\u2081 = F\u2082", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {F\u2081 F\u2082 : D \u2964 C} [_inst_4 : \u2200 (X Y : C), subsingleton (X \u27f6 Y)], category_theory.skeletal C \u2192 (F\u2081 \u2245 F\u2082) \u2192 F\u2081 = F\u2082", "decl_nm": "category_theory.functor.eq_of_iso", "nl_statement_of_codex": "Let $C$ and $D$ be categories. Let $F_1, F_2:D\\to C$ be functors. If $C$ is skeletal and $F_1$ and $F_2$ are isomorphic, then $F_1=F_2$."}
{"formal_statement": "theorem dual_left {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n\t{s : set \u03b1} (hf : strict_mono_on f s) :\n\tstrict_anti_on (f \u2218 \u21d1order_dual.of_dual) s", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : set \u03b1}, strict_mono_on f s \u2192 strict_anti_on (f \u2218 \u21d1order_dual.of_dual) s", "decl_nm": "strict_mono_on.dual_left", "nl_statement_of_codex": "Let $f:A\\to B$ be a strict monotone function on a subset $A$ of a preorder $X$. Then the function $f^*:B^*\\to A^*$ is a strict anti-monotone function."}
{"formal_statement": "theorem length_of_fn_aux {\u03b1 : Type u} {n : \u2115} (f : fin n \u2192 \u03b1) (m : \u2115) (h : m \u2264 n)\n\t(l : list \u03b1) :\n\t(list.of_fn_aux f m h l).length = l.length + m", "decl_tp": "\u2200 {\u03b1 : Type u} {n : \u2115} (f : fin n \u2192 \u03b1) (m : \u2115) (h : m \u2264 n) (l : list \u03b1), (list.of_fn_aux f m h l).length = l.length + m", "decl_nm": "list.length_of_fn_aux", "nl_statement_of_codex": "Let $f: \\{0,\\ldots,n-1\\}\\to \\alpha$ and let $l$ be a list of elements of $\\alpha$. Then the length of the list $l$ concatenated with the list $f(0),\\ldots,f(m-1)$ is the sum of the lengths of $l$ and $f(0),\\ldots,f(m-1)$."}
{"formal_statement": "theorem le_comap_of_map_le {R : Type u} {S : Type v} [semiring R] [semiring S]\n\t{f : R \u2192+* S} {I : ideal R} {K : ideal S} :\n\tideal.map f I \u2264 K \u2192 I \u2264 ideal.comap f K", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_1 : semiring R] [_inst_2 : semiring S] {f : R \u2192+* S} {I : ideal R} {K : ideal S}, ideal.map f I \u2264 K \u2192 I \u2264 ideal.comap f K", "decl_nm": "ideal.le_comap_of_map_le", "nl_statement_of_codex": "Let $R$ and $S$ be semirings and let $f:R\\to S$ be a ring homomorphism. Let $I$ be an ideal of $R$ and let $K$ be an ideal of $S$. If $f(I)\\subset K$, then $I\\subset f^{-1}(K)$."}
{"formal_statement": "theorem map\u2082_right'_nil_right {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : option \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n\t(as : list \u03b1) :\n\tlist.map\u2082_right' f as list.nil = (list.nil \u03b3, as)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (f : option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : list \u03b1), list.map\u2082_right' f as list.nil = (list.nil \u03b3, as)", "decl_nm": "list.map\u2082_right'_nil_right", "nl_statement_of_codex": "Let $f: \\mathrm{option}\\,\\alpha\\to\\beta\\to\\gamma$ be a function. Then $\\mathrm{map}\\,f$ applied to a list of $\\alpha$'s and the empty list is the empty list of $\\gamma$'s."}
{"formal_statement": "theorem is_closed_of_pairwise_le_dist {\u03b3 : Type w} [metric_space \u03b3] {s : set \u03b3}\n\t{\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) (hs : s.pairwise (\u03bb (x y : \u03b3), \u03b5 \u2264 has_dist.dist x y)) :\n\tis_closed s", "decl_tp": "\u2200 {\u03b3 : Type w} [_inst_2 : metric_space \u03b3] {s : set \u03b3} {\u03b5 : \u211d}, 0 < \u03b5 \u2192 s.pairwise (\u03bb (x y : \u03b3), \u03b5 \u2264 has_dist.dist x y) \u2192 is_closed s", "decl_nm": "metric.is_closed_of_pairwise_le_dist", "nl_statement_of_codex": "Let $s$ be a set of points in a metric space $(\\gamma,d)$. If $s$ is pairwise $\\epsilon$-separated, then $s$ is closed."}
{"formal_statement": "theorem norm_def {\ud835\udd5c V W : Type*} [normed_group V] [normed_group W] [nondiscrete_normed_field \ud835\udd5c]\n\t[normed_space \ud835\udd5c V] [normed_space \ud835\udd5c W] (f : V \u2192A[\ud835\udd5c] W) :\n\t\u2225f\u2225 = linear_order.max \u2225\u21d1f 0\u2225 \u2225f.cont_linear\u2225", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {V : Type u_3} {W : Type u_4} [_inst_1 : normed_group V] [_inst_4 : normed_group W] [_inst_14 : nondiscrete_normed_field \ud835\udd5c] [_inst_15 : normed_space \ud835\udd5c V] [_inst_16 : normed_space \ud835\udd5c W] (f : V \u2192A[\ud835\udd5c] W), \u2225f\u2225 = linear_order.max \u2225\u21d1f 0\u2225 \u2225f.cont_linear\u2225", "decl_nm": "continuous_affine_map.norm_def", "nl_statement_of_codex": "The norm of a linear map $f:V\\to W$ is the maximum of the norm of the constant term and the norm of the linear part."}
{"formal_statement": "theorem has_deriv_within_at_Ioi_iff_Ici {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{F : Type v} [normed_group F] [normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F}\n\t{x : \ud835\udd5c} [partial_order \ud835\udd5c] :\n\thas_deriv_within_at f f' (set.Ioi x) x \u2194 has_deriv_within_at f f' (set.Ici x) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} [_inst_6 : partial_order \ud835\udd5c], has_deriv_within_at f f' (set.Ioi x) x \u2194 has_deriv_within_at f f' (set.Ici x) x", "decl_nm": "has_deriv_within_at_Ioi_iff_Ici", "nl_statement_of_codex": "Let $f:I\\to F$ be a function defined on an interval $I$ and let $x\\in I$. Then $f$ is differentiable at $x$ from the right if and only if $f$ is differentiable at $x$ from the left."}
{"formal_statement": "theorem lcm_singleton {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1] [normalized_gcd_monoid \u03b1]\n\t{a : \u03b1} :\n\t{a}.lcm = \u21d1normalize a", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] {a : \u03b1}, {a}.lcm = \u21d1normalize a", "decl_nm": "multiset.lcm_singleton", "nl_statement_of_codex": "The least common multiple of a singleton set is the normalization of the element of the set."}
{"formal_statement": "theorem closure_union {G : Type*} [group G] (s t : set G) :\n\tsubgroup.closure (s \u222a t) = subgroup.closure s \u2294 subgroup.closure t", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (s t : set G), subgroup.closure (s \u222a t) = subgroup.closure s \u2294 subgroup.closure t", "decl_nm": "subgroup.closure_union", "nl_statement_of_codex": "Let $G$ be a group and let $s,t\\subset G$. Then the closure of $s\\cup t$ is the join of the closures of $s$ and $t$."}
{"formal_statement": "theorem dist_le_two_norm {\u03b1 E : Type*} [topological_space \u03b1] [compact_space \u03b1]\n\t[normed_group E] (f : C(\u03b1, E)) (x y : \u03b1) :\n\thas_dist.dist (\u21d1f x) (\u21d1f y) \u2264 2 * \u2225f\u2225", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : compact_space \u03b1] [_inst_4 : normed_group E] (f : C(\u03b1, E)) (x y : \u03b1), has_dist.dist (\u21d1f x) (\u21d1f y) \u2264 2 * \u2225f\u2225", "decl_nm": "continuous_map.dist_le_two_norm", "nl_statement_of_codex": "Let $f:X\\to E$ be a continuous function from a compact space $X$ to a normed group $E$. Then the distance between $f(x)$ and $f(y)$ is less than or equal to $2\\|f\\|$."}
{"formal_statement": "theorem direction_inf_of_mem_inf {k V P : Type*} [ring k] [add_comm_group V]\n\t[module k V] [S : add_torsor V P] {s\u2081 s\u2082 : affine_subspace k P} {p : P}\n\t(h : p \u2208 s\u2081 \u2293 s\u2082) :\n\t(s\u2081 \u2293 s\u2082).direction = s\u2081.direction \u2293 s\u2082.direction", "decl_tp": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [S : add_torsor V P] {s\u2081 s\u2082 : affine_subspace k P} {p : P}, p \u2208 s\u2081 \u2293 s\u2082 \u2192 (s\u2081 \u2293 s\u2082).direction = s\u2081.direction \u2293 s\u2082.direction", "decl_nm": "affine_subspace.direction_inf_of_mem_inf", "nl_statement_of_codex": "Let $P$ be an affine space over a field $k$ and let $s_1, s_2$ be affine subspaces of $P$. Then the direction of $s_1\\cap s_2$ is the intersection of the directions of $s_1$ and $s_2$."}
{"formal_statement": "theorem add_le_add_iff_right {\u03b1 : Type*} [has_le \u03b1] [add_comm_semigroup \u03b1]\n\t[covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a b c : \u03b1} (ha : add_le_cancellable a) :\n\t(b + a \u2264 c + a \u2194 b \u2264 c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_le \u03b1] [_inst_2 : add_comm_semigroup \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a b c : \u03b1}, add_le_cancellable a \u2192 (b + a \u2264 c + a \u2194 b \u2264 c)", "decl_nm": "add_le_cancellable.add_le_add_iff_right", "nl_statement_of_codex": "Let $a, b, c$ be elements of an additive commutative semigroup with a partial order. Then $b+a\\leq c+a$ if and only if $b\\leq c$."}
{"formal_statement": "theorem image2_empty_right {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1} :\n\tset.image2 f s \u2205 = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1}, set.image2 f s \u2205 = \u2205", "decl_nm": "set.image2_empty_right", "nl_statement_of_codex": "The image of the product of two sets $A$ and $B$ under a function $f$ is empty if and only if $B$ is empty."}
{"formal_statement": "theorem zmod_repr_spec {p : \u2115} [hp_prime : fact (nat.prime p)] (x : \u2124_[p]) :\n\tx.zmod_repr < p \u2227 x - \u2191(x.zmod_repr) \u2208 local_ring.maximal_ideal \u2124_[p]", "decl_tp": "\u2200 {p : \u2115} [hp_prime : fact (nat.prime p)] (x : \u2124_[p]), x.zmod_repr < p \u2227 x - \u2191(x.zmod_repr) \u2208 local_ring.maximal_ideal \u2124_[p]", "decl_nm": "padic_int.zmod_repr_spec", "nl_statement_of_codex": "Let $p$ be a prime number. Then for each $x\\in\\mathbb{Z}_p$ there is a unique $y\\in\\mathbb{Z}$ such that $y<p$ and $x-y\\in p\\mathbb{Z}_p$."}
{"formal_statement": "theorem fderiv_fst {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{p : E \u00d7 F} :\n\tfderiv \ud835\udd5c prod.fst p = continuous_linear_map.fst \ud835\udd5c E F", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {p : E \u00d7 F}, fderiv \ud835\udd5c prod.fst p = continuous_linear_map.fst \ud835\udd5c E F", "decl_nm": "fderiv_fst", "nl_statement_of_codex": "The derivative of the projection map $f:E\\times F\\to E$ is the linear map $T:E\\times F\\to E$ given by $T(x,y)=x$."}
{"formal_statement": "theorem symm {\u03b1 : Type*} {f g : equiv.perm \u03b1} :\n\tf.disjoint g \u2192 g.disjoint f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f g : equiv.perm \u03b1}, f.disjoint g \u2192 g.disjoint f", "decl_nm": "equiv.perm.disjoint.symm", "nl_statement_of_codex": "Let $f$ and $g$ be permutations of a set $X$. If $f$ and $g$ are disjoint, then $g$ and $f$ are disjoint."}
{"formal_statement": "theorem preimage_eq {\u03b1 \u03b2 : Type*} {e : local_equiv \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2} :\n\te.is_image s t \u2192 e.source \u2229 \u21d1e \u207b\u00b9' t = e.source \u2229 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {e : local_equiv \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2}, e.is_image s t \u2192 e.source \u2229 \u21d1e \u207b\u00b9' t = e.source \u2229 s", "decl_nm": "local_equiv.is_image.preimage_eq", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. Let $A\\subset X$ and $B\\subset Y$. Then $e(A)=B$ if and only if $e^{-1}(B)=A$."}
{"formal_statement": "theorem id_\u03bc (C : Type u\u2081) [category_theory.category C] :\n\t(category_theory.monad.id C).\u03bc = \ud835\udfd9 (\ud835\udfed C)", "decl_tp": "\u2200 (C : Type u\u2081) [_inst_1 : category_theory.category C], (category_theory.monad.id C).\u03bc = \ud835\udfd9 (\ud835\udfed C)", "decl_nm": "category_theory.monad.id_\u03bc", "nl_statement_of_codex": "The multiplication of the identity monad is the identity functor."}
{"formal_statement": "theorem isometric_bounded_of_compact_symm_apply (\u03b1 \u03b2 : Type*) [topological_space \u03b1]\n\t[compact_space \u03b1] [metric_space \u03b2] :\n\t\u21d1((continuous_map.isometric_bounded_of_compact \u03b1 \u03b2).symm) = bounded_continuous_function.to_continuous_map", "decl_tp": "\u2200 (\u03b1 : Type u_1) (\u03b2 : Type u_2) [_inst_1 : topological_space \u03b1] [_inst_2 : compact_space \u03b1] [_inst_3 : metric_space \u03b2], \u21d1((continuous_map.isometric_bounded_of_compact \u03b1 \u03b2).symm) = bounded_continuous_function.to_continuous_map", "decl_nm": "continuous_map.isometric_bounded_of_compact_symm_apply", "nl_statement_of_codex": "Let $X$ be a compact metric space and $Y$ be a metric space. Then the map $f\\mapsto f^{-1}$ is a bijection between the set of isometric embeddings $X\\to Y$ and the set of continuous maps $Y\\to X$."}
{"formal_statement": "theorem colimit_rep_eq_iff_exists {C : Type u} [category_theory.category C]\n\t[category_theory.concrete_category C] {J : Type v} [category_theory.small_category J]\n\t(F : J \u2964 C) [category_theory.limits.preserves_colimit F (category_theory.forget C)]\n\t[category_theory.is_filtered J] [category_theory.limits.has_colimit F]\n\t{i j : J} (x : \u21a5(F.obj i)) (y : \u21a5(F.obj j)) :\n\t\u21d1(category_theory.limits.colimit.\u03b9 F i) x = \u21d1(category_theory.limits.colimit.\u03b9 F j) y \u2194 \u2203 (k : J)\n\t(f : i \u27f6 k) (g : j \u27f6 k), \u21d1(F.map f) x = \u21d1(F.map g) y", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.concrete_category C] {J : Type v} [_inst_3 : category_theory.small_category J] (F : J \u2964 C) [_inst_4 : category_theory.limits.preserves_colimit F (category_theory.forget C)] [_inst_5 : category_theory.is_filtered J] [_inst_6 : category_theory.limits.has_colimit F] {i j : J} (x : \u21a5(F.obj i)) (y : \u21a5(F.obj j)), \u21d1(category_theory.limits.colimit.\u03b9 F i) x = \u21d1(category_theory.limits.colimit.\u03b9 F j) y \u2194 \u2203 (k : J) (f : i \u27f6 k) (g : j \u27f6 k), \u21d1(F.map f) x = \u21d1(F.map g) y", "decl_nm": "category_theory.limits.concrete.colimit_rep_eq_iff_exists", "nl_statement_of_codex": "Let $F:J\\to C$ be a functor from a filtered category $J$ to a category $C$. Let $i,j\\in J$ and $x\\in F(i)$, $y\\in F(j)$. Then $x$ and $y$ are equal in the colimit of $F$ if and only if there is an object $k\\in J$ and morphisms $f:i\\to k$ and $g:j\\to k$ such that $F(f)(x)=F(g)(y)$."}
{"formal_statement": "theorem mem_inf {M : Type*} [add_zero_class M] {p p' : add_submonoid M}\n\t{x : M} :\n\tx \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] {p p' : add_submonoid M} {x : M}, x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "decl_nm": "add_submonoid.mem_inf", "nl_statement_of_codex": "Let $M$ be an additive monoid with zero. Let $p, p'$ be submonoids of $M$. Then $x\\in p\\cap p'$ if and only if $x\\in p$ and $x\\in p'$."}
{"formal_statement": "theorem to_bool_coe (b : bool) {h : decidable \u21a5b} :\n\tdecidable.to_bool \u21a5b = b", "decl_tp": "\u2200 (b : bool) {h : decidable \u21a5b}, decidable.to_bool \u21a5b = b", "decl_nm": "bool.to_bool_coe", "nl_statement_of_codex": "The function `to_bool` is the identity on `bool`."}
{"formal_statement": "theorem gcd_left (k : \u2115) {m n : \u2115} (hmn : m.coprime n) :\n\t(k.gcd m).coprime n", "decl_tp": "\u2200 (k : \u2115) {m n : \u2115}, m.coprime n \u2192 (k.gcd m).coprime n", "decl_nm": "nat.coprime.gcd_left", "nl_statement_of_codex": "If $m$ and $n$ are coprime, then $k$ and $n$ are coprime."}
{"formal_statement": "theorem support_one {\u0393 R : Type*} [ordered_cancel_add_comm_monoid \u0393] [mul_zero_one_class R]\n\t[nontrivial R] :\n\t1.support = {0}", "decl_tp": "\u2200 {\u0393 : Type u_1} {R : Type u_2} [_inst_1 : ordered_cancel_add_comm_monoid \u0393] [_inst_2 : mul_zero_one_class R] [_inst_3 : nontrivial R], 1.support = {0}", "decl_nm": "hahn_series.support_one", "nl_statement_of_codex": "The support of the constant function $1:\\Gamma\\to R$ is $\\{0\\}$."}
{"formal_statement": "theorem congr {X Y : Type*} [normed_group X] [normed_group Y] [normed_space \u211d X]\n\t[normed_space \u211d Y] {f g : X \u2192 Y} {x : X} {u : set X} (hx : x \u2208 u) (hu : is_open u)\n\t(hf : conformal_at f x) :\n\t(\u2200 (x : X),  g x = f x) \u2192 conformal_at g x", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : normed_group X] [_inst_2 : normed_group Y] [_inst_4 : normed_space \u211d X] [_inst_5 : normed_space \u211d Y] {f g : X \u2192 Y} {x : X} {u : set X}, x \u2208 u \u2192 is_open u \u2192 conformal_at f x \u2192 (\u2200 (x : X), x \u2208 u \u2192 g x = f x) \u2192 conformal_at g x", "decl_nm": "conformal_at.congr", "nl_statement_of_codex": "Let $X$ and $Y$ be normed groups and let $f,g:X\\to Y$. If $f$ is conformal at $x\\in X$, then $g$ is conformal at $x$ if and only if $g(x)=f(x)$."}
{"formal_statement": "theorem lift_symm_apply {\u03b1 : Type u} {\u03b2 : Type v} [group \u03b2] (g : free_group \u03b1 \u2192* \u03b2)\n\t(\u1fb0 : \u03b1) :\n\t\u21d1(free_group.lift.symm) g \u1fb0 = (\u21d1g \u2218 free_group.of) \u1fb0", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : group \u03b2] (g : free_group \u03b1 \u2192* \u03b2) (\u1fb0 : \u03b1), \u21d1(free_group.lift.symm) g \u1fb0 = (\u21d1g \u2218 free_group.of) \u1fb0", "decl_nm": "free_group.lift_symm_apply", "nl_statement_of_codex": "Let $g:F_\\alpha\\to G$ be a homomorphism of groups. Then $g\\circ\\iota_\\alpha=\\iota_\\beta\\circ g$."}
{"formal_statement": "theorem map_pure {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n\tf <$> has_pure.pure x = has_pure.pure (f x)", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (x : \u03b1), f <$> has_pure.pure x = has_pure.pure (f x)", "decl_nm": "free_group.map_pure", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $x\\in A$. Then $f(x)$ is the pure element of $B$."}
{"formal_statement": "theorem foldl_ext {\u03b1 : Type u} {\u03b2 : Type v} (f g : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) {l : list \u03b2} :\n\t(\u2200 (a : \u03b1) (b : \u03b2), b \u2208 l \u2192 f a b = g a b) \u2192 list.foldl f a l = list.foldl g a l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f g : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) {l : list \u03b2}, (\u2200 (a : \u03b1) (b : \u03b2), b \u2208 l \u2192 f a b = g a b) \u2192 list.foldl f a l = list.foldl g a l", "decl_nm": "list.foldl_ext", "nl_statement_of_codex": "Let $f,g:\\alpha\\times\\beta\\to\\alpha$ be functions and let $a\\in\\alpha$. Then $\\mathrm{foldl}(f,a,l)=\\mathrm{foldl}(g,a,l)$ if and only if $f(a,b)=g(a,b)$ for all $b\\in l$."}
{"formal_statement": "theorem summable_geometric {r : nnreal} (hr : r < 1) :\n\tsummable (\u03bb (n : \u2115), r ^ n)", "decl_tp": "\u2200 {r : nnreal}, r < 1 \u2192 summable (\u03bb (n : \u2115), r ^ n)", "decl_nm": "nnreal.summable_geometric", "nl_statement_of_codex": "The geometric series $\\sum_{n=0}^\\infty r^n$ is summable if $r<1$."}
{"formal_statement": "theorem support_binop_subset {\u03b1 M N P : Type*} [has_zero M] [has_zero N]\n\t[has_zero P] (op : M \u2192 N \u2192 P) (op1 : op 0 0 = 0) (x : \u03b1) :\n\t\u2200 (f :  M) (g :  N), function.support (\u03bb (x : \u03b1), op (f x) (g x)) \u2286 function.support f \u222a function.support g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} {N : Type u_6} {P : Type u_7} [_inst_1 : has_zero M] [_inst_2 : has_zero N] [_inst_3 : has_zero P] (op : M \u2192 N \u2192 P), op 0 0 = 0 \u2192 \u2200 (f : \u03b1 \u2192 M) (g : \u03b1 \u2192 N), function.support (\u03bb (x : \u03b1), op (f x) (g x)) \u2286 function.support f \u222a function.support g", "decl_nm": "function.support_binop_subset", "nl_statement_of_codex": "Let $f,g:\\alpha\\to M,N$ be functions. Then the support of $f+g$ is a subset of the union of the supports of $f$ and $g$."}
{"formal_statement": "theorem eq_bot_or_eq_top {G : Type*} [group G] [is_simple_group G] {H : subgroup G}\n\t(Hn : H.normal) :\n\tH = \u22a5 \u2228 H = \u22a4", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] [_inst_4 : is_simple_group G] {H : subgroup G}, H.normal \u2192 H = \u22a5 \u2228 H = \u22a4", "decl_nm": "subgroup.normal.eq_bot_or_eq_top", "nl_statement_of_codex": "Let $G$ be a simple group and let $H$ be a normal subgroup of $G$. Then $H$ is either trivial or $G$."}
{"formal_statement": "theorem max_is_maximal {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [is_strict_weak_order \u03b1 lt]\n\t{k : \u03b1} {v : \u03b2} {m : rbmap \u03b1 \u03b2 lt} (h : m.max = option.some (k, v)) (hm : k' \u2208 m) :\n\t\u2200 {k' : \u03b1},  strict_weak_order.equiv k k' \u2228 lt k' k", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : is_strict_weak_order \u03b1 lt] {k : \u03b1} {v : \u03b2} {m : rbmap \u03b1 \u03b2 lt}, m.max = option.some (k, v) \u2192 \u2200 {k' : \u03b1}, k' \u2208 m \u2192 strict_weak_order.equiv k k' \u2228 lt k' k", "decl_nm": "rbmap.max_is_maximal", "nl_statement_of_codex": "Let $m$ be a red-black tree with maximal element $(k,v)$. Then $k$ is maximal in $m$."}
{"formal_statement": "theorem colimit_cocone_of_comp_is_colimit {C : Type v} [category_theory.small_category C]\n\t{D : Type v} [category_theory.small_category D] (F : C \u2964 D) [F.final]\n\t{E : Type u} [category_theory.category E] {G : D \u2964 E} (t : category_theory.limits.colimit_cocone (F \u22d9 G)) :\n\t(category_theory.functor.final.colimit_cocone_of_comp F t).is_colimit = \u21d1((category_theory.functor.final.is_colimit_extend_cocone_equiv F t.cocone).symm) t.is_colimit", "decl_tp": "\u2200 {C : Type v} [_inst_1 : category_theory.small_category C] {D : Type v} [_inst_2 : category_theory.small_category D] (F : C \u2964 D) [_inst_3 : F.final] {E : Type u} [_inst_4 : category_theory.category E] {G : D \u2964 E} (t : category_theory.limits.colimit_cocone (F \u22d9 G)), (category_theory.functor.final.colimit_cocone_of_comp F t).is_colimit = \u21d1((category_theory.functor.final.is_colimit_extend_cocone_equiv F t.cocone).symm) t.is_colimit", "decl_nm": "category_theory.functor.final.colimit_cocone_of_comp_is_colimit", "nl_statement_of_codex": "Let $F:C\\to D$ be a functor between small categories. Let $G:D\\to E$ be a functor between categories. Let $t$ be a colimit cocone of $G\\circ F$. Then the colimit cocone of $F$ is the colimit cocone of $G\\circ F$."}
{"formal_statement": "theorem iso_diag_hom {C : Type u\u2081} [category_theory.category C] {A : C}\n\t(hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] :\n\thA.iso_diag.hom = category_theory.inv (category_theory.limits.diag A)", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [_inst_2 : category_theory.limits.has_binary_product A A], hA.iso_diag.hom = category_theory.inv (category_theory.limits.diag A)", "decl_nm": "category_theory.is_subterminal.iso_diag_hom", "nl_statement_of_codex": "Let $C$ be a category and let $A$ be a subterminal object of $C$. Then the morphism $A\\to A\\times A$ is the inverse of the diagonal morphism $A\\to A\\times A$."}
{"formal_statement": "theorem of_rat_div (q : \u211a) {x : \u211d} (h : irrational (\u2191q / x)) :\n\tirrational x", "decl_tp": "\u2200 (q : \u211a) {x : \u211d}, irrational (\u2191q / x) \u2192 irrational x", "decl_nm": "irrational.of_rat_div", "nl_statement_of_codex": "If $q$ is rational and $x$ is irrational, then $x$ is irrational."}
{"formal_statement": "theorem rat_div {x : \u211d} (h : irrational x) (hq : q \u2260 0) :\n\t\u2200 {q : \u211a},  irrational (\u2191q / x)", "decl_tp": "\u2200 {x : \u211d}, irrational x \u2192 \u2200 {q : \u211a}, q \u2260 0 \u2192 irrational (\u2191q / x)", "decl_nm": "irrational.rat_div", "nl_statement_of_codex": "If $x$ is irrational, then $q/x$ is irrational for all $q\\in\\mathbb{Q}$."}
{"formal_statement": "theorem merge {\u03b1 : Type*} [preorder \u03b1] {l r : ordnode \u03b1} (hl : l.valid)\n\t(hr : r.valid) (sep : ordnode.all (\u03bb (x : \u03b1), ordnode.all (\u03bb (y : \u03b1), x < y) r) l) :\n\t(l.merge r).valid", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {l r : ordnode \u03b1}, l.valid \u2192 r.valid \u2192 ordnode.all (\u03bb (x : \u03b1), ordnode.all (\u03bb (y : \u03b1), x < y) r) l \u2192 (l.merge r).valid", "decl_nm": "ordnode.valid.merge", "nl_statement_of_codex": "Let $l$ and $r$ be valid ordered nodes. If $l$ is less than $r$, then $l\\cup r$ is a valid ordered node."}
{"formal_statement": "theorem lt_succ {a b : cardinal} :\n\ta < b.succ \u2194 a \u2264 b", "decl_tp": "\u2200 {a b : cardinal}, a < b.succ \u2194 a \u2264 b", "decl_nm": "cardinal.lt_succ", "nl_statement_of_codex": "$a<b+1$ if and only if $a\\leq b$."}
{"formal_statement": "theorem sum_le_sum_sum {\u03b1 : Type*} [ordered_add_comm_monoid \u03b1] {s : multiset \u03b1}\n\t(f : \u03b1 \u2192 \u03b1) :\n\t(\u2200 (x : \u03b1), x \u2208 s \u2192 x \u2264 f x) \u2192 s.sum \u2264 (multiset.map f s).sum", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_1 : ordered_add_comm_monoid \u03b1] {s : multiset \u03b1} (f : \u03b1 \u2192 \u03b1), (\u2200 (x : \u03b1), x \u2208 s \u2192 x \u2264 f x) \u2192 s.sum \u2264 (multiset.map f s).sum", "decl_nm": "multiset.sum_le_sum_sum", "nl_statement_of_codex": "Let $s$ be a multiset of elements of an ordered additive commutative monoid $M$. Let $f:M\\to M$ be a function. If $x\\leq f(x)$ for all $x\\in s$, then $\\sum_{x\\in s}x\\leq \\sum_{x\\in s}f(x)$."}
{"formal_statement": "theorem symm {\u03b1 : Type u} [lattice \u03b1] [bounded_order \u03b1] {x y : \u03b1} (h : is_compl x y) :\n\tis_compl y x", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : bounded_order \u03b1] {x y : \u03b1}, is_compl x y \u2192 is_compl y x", "decl_nm": "is_compl.symm", "nl_statement_of_codex": "Let $L$ be a bounded lattice. If $x$ is the complement of $y$, then $y$ is the complement of $x$."}
{"formal_statement": "theorem is_compact_iff_is_compact_image {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1]\n\t{s : set \u03b1} [topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : embedding f) :\n\t(is_compact s \u2194 is_compact (f '' s))", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] {s : set \u03b1} [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, embedding f \u2192 (is_compact s \u2194 is_compact (f '' s))", "decl_nm": "embedding.is_compact_iff_is_compact_image", "nl_statement_of_codex": "Let $f:X\\to Y$ be an embedding. Then $X$ is compact if and only if $f(X)$ is compact."}
{"formal_statement": "theorem append_fun_id_id {n : \u2115} {\u03b1 : typevec n} {\u03b2 : Type*} :\n\ttypevec.id ::: id = typevec.id", "decl_tp": "\u2200 {n : \u2115} {\u03b1 : typevec n} {\u03b2 : Type u_1}, typevec.id ::: id = typevec.id", "decl_nm": "typevec.append_fun_id_id", "nl_statement_of_codex": "The identity function on a type vector is equal to the identity function on the type vector followed by the identity function on the type."}
{"formal_statement": "theorem finsum_eq_dif {M : Type*} [add_comm_monoid M] {p : Prop} [decidable p]\n\t(f : p \u2192 M) :\n\tfinsum (\u03bb (i : p), f i) = dite p (\u03bb (h : p), f h) (\u03bb (h : \u00acp), 0)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_comm_monoid M] {p : Prop} [_inst_3 : decidable p] (f : p \u2192 M), finsum (\u03bb (i : p), f i) = dite p (\u03bb (h : p), f h) (\u03bb (h : \u00acp), 0)", "decl_nm": "finsum_eq_dif", "nl_statement_of_codex": "Let $M$ be an additive commutative monoid. Let $p$ be a proposition. Let $f:p\\to M$. Then $\\sum_{i\\in p}f(i)=f(p)$."}
{"formal_statement": "theorem mul_equiv_of_localizations_apply {M : Type*} [comm_monoid M] {S : submonoid M}\n\t{N : Type*} [comm_monoid N] {P : Type*} [comm_monoid P] (f : S.localization_map N)\n\t{k : S.localization_map P} {x : N} :\n\t\u21d1(f.mul_equiv_of_localizations k) x = \u21d1(f.lift _) x", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {S : submonoid M} {N : Type u_2} [_inst_2 : comm_monoid N] {P : Type u_3} [_inst_3 : comm_monoid P] (f : S.localization_map N) {k : S.localization_map P} {x : N}, \u21d1(f.mul_equiv_of_localizations k) x = \u21d1(f.lift _) x", "decl_nm": "submonoid.localization_map.mul_equiv_of_localizations_apply", "nl_statement_of_codex": "Let $M$ be a commutative monoid, let $S$ be a submonoid of $M$, let $N$ be a commutative monoid, let $P$ be a commutative monoid, let $f:S^{-1}M\\to N$ be a morphism of commutative monoids, let $k:S^{-1}M\\to P$ be a morphism of commutative monoids, and let $x\\in N$. Then $f\\circ k(x)=f(k(x))$."}
{"formal_statement": "theorem nnnorm_coe_nat (n : \u2115) :\n\t\u2225\u2191n\u2225\u208a = \u2191n", "decl_tp": "\u2200 (n : \u2115), \u2225\u2191n\u2225\u208a = \u2191n", "decl_nm": "int.nnnorm_coe_nat", "nl_statement_of_codex": "The norm of a natural number $n$ is $n$."}
{"formal_statement": "theorem mem_right_add_coset_iff {\u03b1 : Type*} [add_group \u03b1] {s : set \u03b1} {x : \u03b1}\n\t(a : \u03b1) :\n\tx \u2208 right_add_coset s a \u2194 x + -a \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : add_group \u03b1] {s : set \u03b1} {x : \u03b1} (a : \u03b1), x \u2208 right_add_coset s a \u2194 x + -a \u2208 s", "decl_nm": "mem_right_add_coset_iff", "nl_statement_of_codex": "Let $G$ be an abelian group and let $a\\in G$. Then $x\\in a+H$ if and only if $x-a\\in H$."}
{"formal_statement": "theorem inf_lt_inf_of_lt_of_sup_le_sup {\u03b1 : Type*} [lattice \u03b1] [is_modular_lattice \u03b1]\n\t{x y z : \u03b1} (hxy : x < y) (hinf : y \u2294 z \u2264 x \u2294 z) :\n\tx \u2293 z < y \u2293 z", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : lattice \u03b1] [_inst_2 : is_modular_lattice \u03b1] {x y z : \u03b1}, x < y \u2192 y \u2294 z \u2264 x \u2294 z \u2192 x \u2293 z < y \u2293 z", "decl_nm": "inf_lt_inf_of_lt_of_sup_le_sup", "nl_statement_of_codex": "Let $x,y,z$ be elements of a modular lattice. If $x<y$ and $y\\vee z\\leq x\\vee z$, then $x\\wedge z<y\\wedge z$."}
{"formal_statement": "theorem tendsto_uniformly_on_univ {\u03b1 \u03b2 \u03b9 : Type*} [uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n\t{f : \u03b1 \u2192 \u03b2} {p : filter \u03b9} :\n\ttendsto_uniformly_on F f p set.univ \u2194 tendsto_uniformly F f p", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b9 : Type u_4} [_inst_1 : uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : filter \u03b9}, tendsto_uniformly_on F f p set.univ \u2194 tendsto_uniformly F f p", "decl_nm": "tendsto_uniformly_on_univ", "nl_statement_of_codex": "Let $F:\\mathbb{N}\\times\\mathbb{R}\\to\\mathbb{R}$ be a function. Then $F$ converges uniformly to $f:\\mathbb{R}\\to\\mathbb{R}$ if and only if $F$ converges uniformly to $f$ on $\\mathbb{R}$."}
{"formal_statement": "theorem bag_inter_sublist_left {\u03b1 : Type*} [decidable_eq \u03b1] (l\u2081 l\u2082 : list \u03b1) :\n\tl\u2081.bag_inter l\u2082 <+ l\u2081", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (l\u2081 l\u2082 : list \u03b1), l\u2081.bag_inter l\u2082 <+ l\u2081", "decl_nm": "list.bag_inter_sublist_left", "nl_statement_of_codex": "The bag intersection of two lists $l_1$ and $l_2$ is a sublist of $l_1$."}
{"formal_statement": "theorem cmp_self_eq_eq {\u03b1 : Type*} [linear_order \u03b1] (x : \u03b1) :\n\tcmp x x = ordering.eq", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] (x : \u03b1), cmp x x = ordering.eq", "decl_nm": "cmp_self_eq_eq", "nl_statement_of_codex": "For any linear order $X$, $cmp(x,x)=eq$."}
{"formal_statement": "theorem one_eq_bit1 {n : \u2115} :\n\t1 = bit1 n \u2194 n = 0", "decl_tp": "\u2200 {n : \u2115}, 1 = bit1 n \u2194 n = 0", "decl_nm": "nat.one_eq_bit1", "nl_statement_of_codex": "$1=2^n$ if and only if $n=0$."}
{"formal_statement": "theorem join_cons {\u03b1 : Type*} (s : multiset \u03b1) (S : multiset (multiset \u03b1)) :\n\t(s ::\u2098 S).join = s + S.join", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : multiset \u03b1) (S : multiset (multiset \u03b1)), (s ::\u2098 S).join = s + S.join", "decl_nm": "multiset.join_cons", "nl_statement_of_codex": "Let $s$ be a multiset and $S$ a multiset of multisets. Then the join of $s$ and $S$ is equal to the join of $s$ and the join of $S$."}
{"formal_statement": "theorem sUnion_subset {\u03b1 : Type*} {S : set (set \u03b1)} {t : set \u03b1} :\n\t(\u2200 (t' : set \u03b1), t' \u2208 S \u2192 t' \u2286 t) \u2192 \u22c3\u2080 S \u2286 t", "decl_tp": "\u2200 {\u03b1 : Type u_1} {S : set (set \u03b1)} {t : set \u03b1}, (\u2200 (t' : set \u03b1), t' \u2208 S \u2192 t' \u2286 t) \u2192 \u22c3\u2080 S \u2286 t", "decl_nm": "set.sUnion_subset", "nl_statement_of_codex": "Let $S$ be a set of sets. If $t$ is a set such that $t'\\subset t$ for all $t'\\in S$, then $\\bigcup S\\subset t$."}
{"formal_statement": "theorem upper_semicontinuous_on_indicator {\u03b1 : Type*} [topological_space \u03b1]\n\t{\u03b2 : Type*} [preorder \u03b2] {s t : set \u03b1} {y : \u03b2} [has_zero \u03b2] (hs : is_closed s)\n\t(hy : 0 \u2264 y) :\n\tupper_semicontinuous_on (s.indicator (\u03bb (x : \u03b1), y)) t", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {s t : set \u03b1} {y : \u03b2} [_inst_3 : has_zero \u03b2], is_closed s \u2192 0 \u2264 y \u2192 upper_semicontinuous_on (s.indicator (\u03bb (x : \u03b1), y)) t", "decl_nm": "is_closed.upper_semicontinuous_on_indicator", "nl_statement_of_codex": "Let $X$ be a topological space, let $Y$ be a preordered set, let $s$ be a closed subset of $X$, and let $y$ be an element of $Y$ such that $0\\leq y$. Then the function $f:X\\to Y$ defined by $f(x)=y$ if $x\\in s$ and $f(x)=0$ otherwise is upper semicontinuous on $X$."}
{"formal_statement": "theorem keys_empty {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} :\n\t\u2205.keys = list.nil", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v}, \u2205.keys = list.nil", "decl_nm": "alist.keys_empty", "nl_statement_of_codex": "The keys of the empty map are the empty list."}
{"formal_statement": "theorem measurable_neg_iff {\u03b1 : Type*} [measurable_space \u03b1] {G : Type*}\n\t[add_group G] [measurable_space G] [has_measurable_neg G] {f : \u03b1 \u2192 G} :\n\tmeasurable (\u03bb (x : \u03b1), -f x) \u2194 measurable f", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_4 : measurable_space \u03b1] {G : Type u_1} [_inst_5 : add_group G] [_inst_6 : measurable_space G] [_inst_7 : has_measurable_neg G] {f : \u03b1 \u2192 G}, measurable (\u03bb (x : \u03b1), -f x) \u2194 measurable f", "decl_nm": "measurable_neg_iff", "nl_statement_of_codex": "Let $G$ be a measurable space with a measurable negation. Then the negation of a measurable function $f:X\\to G$ is measurable if and only if $f$ is measurable."}
{"formal_statement": "theorem order_of_le_of_pow_eq_one {G : Type u} {x : G} {n : \u2115} [monoid G]\n\t(hn : 0 < n) (h : x ^ n = 1) :\n\torder_of x \u2264 n", "decl_tp": "\u2200 {G : Type u} {x : G} {n : \u2115} [_inst_1 : monoid G], 0 < n \u2192 x ^ n = 1 \u2192 order_of x \u2264 n", "decl_nm": "order_of_le_of_pow_eq_one", "nl_statement_of_codex": "Let $G$ be a monoid and let $x\\in G$. If $x^n=1$ for some $n>0$, then the order of $x$ divides $n$."}
{"formal_statement": "theorem tsub_add_eq_tsub_tsub_swap {\u03b1 : Type*} [partial_order \u03b1] [add_comm_monoid \u03b1]\n\t[has_sub \u03b1] [has_ordered_sub \u03b1] [covariant_class \u03b1 \u03b1 has_add.add has_le.le]\n\t(a b c : \u03b1) :\n\ta - (b + c) = a - c - b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : add_comm_monoid \u03b1] [_inst_3 : has_sub \u03b1] [_inst_4 : has_ordered_sub \u03b1] [_inst_5 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] (a b c : \u03b1), a - (b + c) = a - c - b", "decl_nm": "tsub_add_eq_tsub_tsub_swap", "nl_statement_of_codex": "Let $a, b, c$ be elements of a partially ordered additive commutative monoid with subtraction. Then $a-(b+c)=(a-c)-b$."}
{"formal_statement": "theorem add' {M \u03b1 : Type*} [measurable_space M] [has_add M] [measurable_space \u03b1]\n\t[has_measurable_add\u2082 M] {\u03bc : measure_theory.measure \u03b1} {f g : \u03b1 \u2192 M} (hf : ae_measurable f \u03bc)\n\t(hg : ae_measurable g \u03bc) :\n\tae_measurable (f + g) \u03bc", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_2} [_inst_1 : measurable_space M] [_inst_2 : has_add M] [_inst_3 : measurable_space \u03b1] [_inst_4 : has_measurable_add\u2082 M] {\u03bc : measure_theory.measure \u03b1} {f g : \u03b1 \u2192 M}, ae_measurable f \u03bc \u2192 ae_measurable g \u03bc \u2192 ae_measurable (f + g) \u03bc", "decl_nm": "ae_measurable.add'", "nl_statement_of_codex": "Let $M$ be a measurable space and let $f,g:X\\to M$ be measurable functions. Then $f+g$ is measurable."}
{"formal_statement": "theorem symm_diff_eq_top {\u03b1 : Type*} [boolean_algebra \u03b1] (a b : \u03b1) (h : is_compl a b) :\n\ta \u0394 b = \u22a4", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : boolean_algebra \u03b1] (a b : \u03b1), is_compl a b \u2192 a \u0394 b = \u22a4", "decl_nm": "is_compl.symm_diff_eq_top", "nl_statement_of_codex": "Let $A$ be a Boolean algebra and let $a,b\\in A$. If $a$ and $b$ are complements, then $a\\Delta b=1$."}
{"formal_statement": "theorem sqrt {\u03b1 : Type*} [topological_space \u03b1] {f : \u03b1 \u2192 \u211d} {s : set \u03b1}\n\t{x : \u03b1} (h : continuous_within_at f s x) :\n\tcontinuous_within_at (\u03bb (x : \u03b1), real.sqrt (f x)) s x", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {f : \u03b1 \u2192 \u211d} {s : set \u03b1} {x : \u03b1}, continuous_within_at f s x \u2192 continuous_within_at (\u03bb (x : \u03b1), real.sqrt (f x)) s x", "decl_nm": "continuous_within_at.sqrt", "nl_statement_of_codex": "Let $X$ be a topological space and let $f:X\\to\\mathbb{R}$. If $f$ is continuous at $x\\in X$, then $\\sqrt{f}$ is continuous at $x$."}
{"formal_statement": "theorem disjoint_union_eq_piecewise {\u03b1 \u03b2 : Type*} (e e' : local_equiv \u03b1 \u03b2)\n\t(hs : disjoint e.source e'.source) (ht : disjoint e.target e'.target)\n\t[\u03a0 (x : \u03b1), decidable (x \u2208 e.source)] [\u03a0 (y : \u03b2), decidable (y \u2208 e.target)] :\n\te.disjoint_union e' hs ht = e.piecewise e' e.source e.target _ _", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e e' : local_equiv \u03b1 \u03b2) (hs : disjoint e.source e'.source) (ht : disjoint e.target e'.target) [_inst_1 : \u03a0 (x : \u03b1), decidable (x \u2208 e.source)] [_inst_2 : \u03a0 (y : \u03b2), decidable (y \u2208 e.target)], e.disjoint_union e' hs ht = e.piecewise e' e.source e.target _ _", "decl_nm": "local_equiv.disjoint_union_eq_piecewise", "nl_statement_of_codex": "Let $e$ and $e'$ be local equivalences between $\u03b1$ and $\u03b2$. If $e$ and $e'$ have disjoint source and target, then $e\\cup e'$ is equal to the piecewise function $e\\cup e'$."}
{"formal_statement": "theorem pow_succ_le_asc_factorial (n k : \u2115) :\n\t(n + 1) ^ k \u2264 n.asc_factorial k", "decl_tp": "\u2200 (n k : \u2115), (n + 1) ^ k \u2264 n.asc_factorial k", "decl_nm": "nat.pow_succ_le_asc_factorial", "nl_statement_of_codex": "For all $n,k\\in\\mathbb{N}$, $(n+1)^k\\leq n!_a(k)$."}
{"formal_statement": "theorem coe_pred {n : \u2115} (j : fin (n + 1)) (h : j \u2260 0) :\n\t\u2191(j.pred h) = \u2191j - 1", "decl_tp": "\u2200 {n : \u2115} (j : fin (n + 1)) (h : j \u2260 0), \u2191(j.pred h) = \u2191j - 1", "decl_nm": "fin.coe_pred", "nl_statement_of_codex": "Let $n$ be a natural number and let $j$ be a natural number less than $n+1$. If $j\\neq 0$, then $j-1$ is the predecessor of $j$."}
{"formal_statement": "theorem coe_fn_eq_coe {n : Type u} [decidable_eq n] [fintype n] {R : Type v}\n\t[comm_ring R] (s : matrix.special_linear_group n R) :\n\t\u21d1s = \u2191s", "decl_tp": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {R : Type v} [_inst_3 : comm_ring R] (s : matrix.special_linear_group n R), \u21d1s = \u2191s", "decl_nm": "matrix.special_linear_group.coe_fn_eq_coe", "nl_statement_of_codex": "Let $R$ be a commutative ring and let $n$ be a finite type. Then the map $s\\mapsto \\overline{s}$ is an isomorphism from the special linear group $SL_n(R)$ to the group of units of $R$."}
{"formal_statement": "theorem coe_equiv_map_of_injective_apply {G : Type*} [add_group G] {N : Type*}\n\t[add_group N] (H : add_subgroup G) (f : G \u2192+ N) (hf : function.injective \u21d1f)\n\t(h : \u21a5H) :\n\t\u2191(\u21d1(H.equiv_map_of_injective f hf) h) = \u21d1f \u2191h", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {N : Type u_3} [_inst_3 : add_group N] (H : add_subgroup G) (f : G \u2192+ N) (hf : function.injective \u21d1f) (h : \u21a5H), \u2191(\u21d1(H.equiv_map_of_injective f hf) h) = \u21d1f \u2191h", "decl_nm": "add_subgroup.coe_equiv_map_of_injective_apply", "nl_statement_of_codex": "Let $G$ be an abelian group and let $H$ be a subgroup of $G$. Let $N$ be an abelian group and let $f:G\\to N$ be a group homomorphism. If $f$ is injective, then the induced map $f:G/H\\to N$ is injective."}
{"formal_statement": "theorem covers_iff {C : Type u} [category_theory.category C] {X Y : C}\n\t(J : category_theory.grothendieck_topology C) (S : category_theory.sieve X)\n\t(f : Y \u27f6 X) :\n\tJ.covers S f \u2194 category_theory.sieve.pullback f S \u2208 \u21d1J Y", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} (J : category_theory.grothendieck_topology C) (S : category_theory.sieve X) (f : Y \u27f6 X), J.covers S f \u2194 category_theory.sieve.pullback f S \u2208 \u21d1J Y", "decl_nm": "category_theory.grothendieck_topology.covers_iff", "nl_statement_of_codex": "Let $C$ be a category, $J$ a Grothendieck topology on $C$, $X$ and $Y$ objects of $C$, and $f:Y\\to X$ a morphism. Then $f$ is a cover of $X$ with respect to $J$ if and only if the pullback of $S$ along $f$ is a cover of $Y$ with respect to $J$."}
{"formal_statement": "theorem sum_compl_apply_symm_of_neg {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [decidable_pred p]\n\t(a : \u03b1) (h : \u00acp a) :\n\t\u21d1((equiv.sum_compl p).symm) a = sum.inr \u27e8a, h\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] (a : \u03b1) (h : \u00acp a), \u21d1((equiv.sum_compl p).symm) a = sum.inr \u27e8a, h\u27e9", "decl_nm": "equiv.sum_compl_apply_symm_of_neg", "nl_statement_of_codex": "Let $p$ be a decidable predicate on a type $\u03b1$. Let $a$ be an element of $\u03b1$ such that $p(a)$ is false. Then the symmetric of the sum complement of $p$ applied to $a$ is equal to the right summand of $a$."}
{"formal_statement": "theorem mul_nonneg_le_one_le {\u03b1 : Type*} [ordered_semiring \u03b1] {a b c : \u03b1} :\n\t0 \u2264 c \u2192 a \u2264 c \u2192 0 \u2264 b \u2192 b \u2264 1 \u2192 a * b \u2264 c", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_2 : ordered_semiring \u03b1] {a b c : \u03b1}, 0 \u2264 c \u2192 a \u2264 c \u2192 0 \u2264 b \u2192 b \u2264 1 \u2192 a * b \u2264 c", "decl_nm": "mul_nonneg_le_one_le", "nl_statement_of_codex": "Let $a,b,c$ be elements of an ordered semiring. If $0\\leq c$, $a\\leq c$, $0\\leq b$, and $b\\leq 1$, then $ab\\leq c$."}
{"formal_statement": "theorem circumcenter_circumradius_unique_dist_eq {V P : Type*} [inner_product_space \u211d V]\n\t[metric_space P] [normed_add_torsor V P] {n : \u2115} (s : affine.simplex \u211d P n) :\n\t(s.circumcenter_circumradius.fst \u2208 affine_span \u211d (set.range s.points) \u2227 \u2200 (i : fin (n + 1)), has_dist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) \u2227 \u2200 (cccr : P \u00d7 \u211d), (cccr.fst \u2208 affine_span \u211d (set.range s.points) \u2227 \u2200 (i : fin (n + 1)), has_dist.dist (s.points i) cccr.fst = cccr.snd) \u2192 cccr = s.circumcenter_circumradius", "decl_tp": "\u2200 {V : Type u_1} {P : Type u_2} [_inst_1 : inner_product_space \u211d V] [_inst_2 : metric_space P] [_inst_3 : normed_add_torsor V P] {n : \u2115} (s : affine.simplex \u211d P n), (s.circumcenter_circumradius.fst \u2208 affine_span \u211d (set.range s.points) \u2227 \u2200 (i : fin (n + 1)), has_dist.dist (s.points i) s.circumcenter_circumradius.fst = s.circumcenter_circumradius.snd) \u2227 \u2200 (cccr : P \u00d7 \u211d), (cccr.fst \u2208 affine_span \u211d (set.range s.points) \u2227 \u2200 (i : fin (n + 1)), has_dist.dist (s.points i) cccr.fst = cccr.snd) \u2192 cccr = s.circumcenter_circumradius", "decl_nm": "affine.simplex.circumcenter_circumradius_unique_dist_eq", "nl_statement_of_codex": "Let $P$ be a metric space and let $V$ be a normed add torsor over $P$. Let $s$ be an $n$-simplex in $V$. Then the circumcenter and circumradius of $s$ are unique."}
{"formal_statement": "theorem bounded_range {\u03b1 : Type u} {\u03b2 : Type v} [topological_space \u03b1] [metric_space \u03b2]\n\t(f : bounded_continuous_function \u03b1 \u03b2) :\n\tmetric.bounded (set.range \u21d1f)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : metric_space \u03b2] (f : bounded_continuous_function \u03b1 \u03b2), metric.bounded (set.range \u21d1f)", "decl_nm": "bounded_continuous_function.bounded_range", "nl_statement_of_codex": "Let $f:X\\to Y$ be a bounded continuous function. Then the range of $f$ is bounded."}
{"formal_statement": "theorem coe_zero (\u03b1 : Type u) :\n\t\u21910 = 0", "decl_tp": "\u2200 (\u03b1 : Type u), \u21910 = 0", "decl_nm": "free_ring.coe_zero", "nl_statement_of_codex": "The coercion from a type $\u03b1$ to its underlying type is the identity function."}
{"formal_statement": "theorem continuous_sigma_map {\u03b9 : Type*} {\u03c3 : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), topological_space (\u03c3 i)]\n\t{\u03ba : Type*} {\u03c4 : \u03ba \u2192 Type*} [\u03a0 (k : \u03ba), topological_space (\u03c4 k)] {f\u2081 : \u03b9 \u2192 \u03ba}\n\t{f\u2082 : \u03a0 (i : \u03b9), \u03c3 i \u2192 \u03c4 (f\u2081 i)} :\n\t(\u2200 (i : \u03b9), continuous (f\u2082 i)) \u2192 continuous (sigma.map f\u2081 f\u2082)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03c3 : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), topological_space (\u03c3 i)] {\u03ba : Type u_3} {\u03c4 : \u03ba \u2192 Type u_4} [_inst_2 : \u03a0 (k : \u03ba), topological_space (\u03c4 k)] {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u03a0 (i : \u03b9), \u03c3 i \u2192 \u03c4 (f\u2081 i)}, (\u2200 (i : \u03b9), continuous (f\u2082 i)) \u2192 continuous (sigma.map f\u2081 f\u2082)", "decl_nm": "continuous_sigma_map", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces and let $f:X\\to Y$ be a continuous function. Then the function $g:X\\to Y\\times Y$ defined by $g(x)=(f(x),f(x))$ is continuous."}
{"formal_statement": "theorem union {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {s t : set \ud835\udd5c} (hs : has_deriv_within_at f f' s x)\n\t(ht : has_deriv_within_at f f' t x) :\n\thas_deriv_within_at f f' (s \u222a t) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {f : \ud835\udd5c \u2192 F} {f' : F} {x : \ud835\udd5c} {s t : set \ud835\udd5c}, has_deriv_within_at f f' s x \u2192 has_deriv_within_at f f' t x \u2192 has_deriv_within_at f f' (s \u222a t) x", "decl_nm": "has_deriv_within_at.union", "nl_statement_of_codex": "Let $f: \\mathbb{K}\\to F$ be a function, where $F$ is a normed group and $\\mathbb{K}$ is a nondiscrete normed field.\nLet $s, t\\subset \\mathbb{K}$ and suppose that $f$ has a derivative at $x$ on $s$ and on $t$. Then $f$ has a derivative at $x$ on $s\\cup t$."}
{"formal_statement": "theorem sub_martingale {\u03b1 E \u03b9 : Type*} [preorder \u03b9] [measurable_space E]\n\t{m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [normed_group E]\n\t[normed_space \u211d E] [complete_space E] [borel_space E] [topological_space.second_countable_topology E]\n\t{f g : \u03b9 \u2192 \u03b1 \u2192 E} {\u2131 : measure_theory.filtration \u03b9 m0} [measure_theory.sigma_finite_filtration \u03bc \u2131]\n\t[preorder E] [covariant_class E E has_add.add has_le.le] (hf : measure_theory.submartingale f \u2131 \u03bc)\n\t(hg : measure_theory.martingale g \u2131 \u03bc) :\n\tmeasure_theory.submartingale (f - g) \u2131 \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} {\u03b9 : Type u_3} [_inst_1 : preorder \u03b9] [_inst_2 : measurable_space E] {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : normed_group E] [_inst_4 : normed_space \u211d E] [_inst_5 : complete_space E] [_inst_6 : borel_space E] [_inst_7 : topological_space.second_countable_topology E] {f g : \u03b9 \u2192 \u03b1 \u2192 E} {\u2131 : measure_theory.filtration \u03b9 m0} [_inst_8 : measure_theory.sigma_finite_filtration \u03bc \u2131] [_inst_9 : preorder E] [_inst_10 : covariant_class E E has_add.add has_le.le], measure_theory.submartingale f \u2131 \u03bc \u2192 measure_theory.martingale g \u2131 \u03bc \u2192 measure_theory.submartingale (f - g) \u2131 \u03bc", "decl_nm": "measure_theory.submartingale.sub_martingale", "nl_statement_of_codex": "Let $E$ be a normed group, $f,g:\\mathbb{N}\\times\\Omega\\to E$ be two adapted processes. If $f$ is a submartingale and $g$ is a martingale, then $f-g$ is a submartingale."}
{"formal_statement": "theorem forall_comm {\u03b1 : Sort u} {\u03b2 : Sort v} (p : \u03b1 \u2192 \u03b2 \u2192 Prop) :\n\t(\u2200 (a : \u03b1) (b : \u03b2), p a b) \u2194 \u2200 (b : \u03b2) (a : \u03b1), p a b", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} (p : \u03b1 \u2192 \u03b2 \u2192 Prop), (\u2200 (a : \u03b1) (b : \u03b2), p a b) \u2194 \u2200 (b : \u03b2) (a : \u03b1), p a b", "decl_nm": "forall_comm", "nl_statement_of_codex": "For all propositions $p(a,b)$ with $a$ and $b$ variables, $\\forall a\\forall b p(a,b)$ is equivalent to $\\forall b\\forall a p(a,b)$."}
{"formal_statement": "theorem cast_bit0 {\u03b1 : Type*} [has_one \u03b1] [has_add \u03b1] (n : pos_num) :\n\t\u2191(n.bit0) = bit0 \u2191n", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_one \u03b1] [_inst_2 : has_add \u03b1] (n : pos_num), \u2191(n.bit0) = bit0 \u2191n", "decl_nm": "pos_num.cast_bit0", "nl_statement_of_codex": "The function $f:\\mathbb{N}\\to\\mathbb{N}$ defined by $f(n)=2n$ is a bijection."}
{"formal_statement": "theorem card_pos {\u03b1 : Type*} {s : finset \u03b1} :\n\t0 < s.card \u2194 s.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u_1} {s : finset \u03b1}, 0 < s.card \u2194 s.nonempty", "decl_nm": "finset.card_pos", "nl_statement_of_codex": "The cardinality of a finite set $S$ is positive if and only if $S$ is nonempty."}
{"formal_statement": "theorem imp_iff_right_iff {a b : Prop} [decidable a] :\n\ta \u2192 b \u2194 b \u2194 a \u2228 b", "decl_tp": "\u2200 {a b : Prop} [_inst_1 : decidable a], a \u2192 b \u2194 b \u2194 a \u2228 b", "decl_nm": "decidable.imp_iff_right_iff", "nl_statement_of_codex": "If $a$ is decidable, then $a\\to b$ is equivalent to $b$ if and only if $b$ is equivalent to $a\\lor b$."}
{"formal_statement": "theorem apply_symm_apply {B F Z : Type*} [topological_space B] [topological_space F]\n\t{proj : Z \u2192 B} (e : topological_fiber_bundle.pretrivialization F proj)\n\t{x : B \u00d7 F} (hx : x \u2208 e.to_local_equiv.target) :\n\t\u21d1e (\u21d1(e.to_local_equiv.symm) x) = x", "decl_tp": "\u2200 {B : Type u_2} {F : Type u_3} {Z : Type u_4} [_inst_1 : topological_space B] [_inst_2 : topological_space F] {proj : Z \u2192 B} (e : topological_fiber_bundle.pretrivialization F proj) {x : B \u00d7 F}, x \u2208 e.to_local_equiv.target \u2192 \u21d1e (\u21d1(e.to_local_equiv.symm) x) = x", "decl_nm": "topological_fiber_bundle.pretrivialization.apply_symm_apply", "nl_statement_of_codex": "Let $B$ and $F$ be topological spaces and let $Z$ be a topological space with a projection map $p:Z\\to B$. Let $e$ be a pretrivialization of $p$. Then for any $x\\in e.to\\_local\\_equiv.target$, we have $e(e.to\\_local\\_equiv.symm(x))=x$."}
{"formal_statement": "theorem swap_swap_eq {\u03b1 \u03b2 : Type*} :\n\tprod.swap \u2218 prod.swap = id", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2}, prod.swap \u2218 prod.swap = id", "decl_nm": "prod.swap_swap_eq", "nl_statement_of_codex": "The function $(x,y)\\mapsto (y,x)$ is its own inverse."}
{"formal_statement": "theorem of_norm_right {\u03b1 E F' : Type*} [has_norm E] [normed_group F'] {f : \u03b1 \u2192 E}\n\t{g' : \u03b1 \u2192 F'} {l : filter \u03b1} :\n\tasymptotics.is_O f (\u03bb (x : \u03b1), \u2225g' x\u2225) l \u2192 asymptotics.is_O f g' l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F' : Type u_7} [_inst_1 : has_norm E] [_inst_5 : normed_group F'] {f : \u03b1 \u2192 E} {g' : \u03b1 \u2192 F'} {l : filter \u03b1}, asymptotics.is_O f (\u03bb (x : \u03b1), \u2225g' x\u2225) l \u2192 asymptotics.is_O f g' l", "decl_nm": "asymptotics.is_O.of_norm_right", "nl_statement_of_codex": "Let $E$ and $F'$ be normed groups, let $f,g':\\alpha\\to E$ and $l$ be a filter on $\\alpha$. If $f$ is $O(\\|g'\\|)$ as $l$-asymptotics, then $f$ is $O(g')$ as $l$-asymptotics."}
{"formal_statement": "theorem ne_empty_iff_nonempty {\u03b1 : Type u} {s : set \u03b1} :\n\ts \u2260 \u2205 \u2194 s.nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set \u03b1}, s \u2260 \u2205 \u2194 s.nonempty", "decl_nm": "set.ne_empty_iff_nonempty", "nl_statement_of_codex": "A set $S$ is nonempty if and only if it is not empty."}
{"formal_statement": "theorem to_add_monoid_hom_eq_coe {\u03b1 : Type u} {\u03b2 : Type v} {r\u03b1 : non_assoc_semiring \u03b1}\n\t{r\u03b2 : non_assoc_semiring \u03b2} (f : \u03b1 \u2192+* \u03b2) :\n\tf.to_add_monoid_hom = \u2191f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {r\u03b1 : non_assoc_semiring \u03b1} {r\u03b2 : non_assoc_semiring \u03b2} (f : \u03b1 \u2192+* \u03b2), f.to_add_monoid_hom = \u2191f", "decl_nm": "ring_hom.to_add_monoid_hom_eq_coe", "nl_statement_of_codex": "The map $f:\u03b1\\to \u03b2$ is a monoid homomorphism if and only if $f$ is a semiring homomorphism."}
{"formal_statement": "theorem haar_pos {G : Type*} [group G] [measurable_space G] [topological_space G]\n\t(\u03bc : measure_theory.measure G) [\u03bc.is_haar_measure] {U : set G} (hU : is_open U)\n\t(h'U : U.nonempty) :\n\t0 < \u21d1\u03bc U", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] [_inst_2 : measurable_space G] [_inst_3 : topological_space G] (\u03bc : measure_theory.measure G) [_inst_4 : \u03bc.is_haar_measure] {U : set G}, is_open U \u2192 U.nonempty \u2192 0 < \u21d1\u03bc U", "decl_nm": "is_open.haar_pos", "nl_statement_of_codex": "Let $G$ be a topological group with a Haar measure $\\mu$. Then $\\mu(U)>0$ for any nonempty open set $U$."}
{"formal_statement": "theorem colimit_sound {J : Type u} [category_theory.small_category J] {F : J \u2964 Type u}\n\t{j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j \u27f6 j') (w : F.map f x = x') :\n\tcategory_theory.limits.colimit.\u03b9 F j x = category_theory.limits.colimit.\u03b9 F j' x'", "decl_tp": "\u2200 {J : Type u} [_inst_1 : category_theory.small_category J] {F : J \u2964 Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j \u27f6 j'), F.map f x = x' \u2192 category_theory.limits.colimit.\u03b9 F j x = category_theory.limits.colimit.\u03b9 F j' x'", "decl_nm": "category_theory.limits.types.colimit_sound", "nl_statement_of_codex": "Let $F:J\\to\\mathbf{Set}$ be a functor. Let $j,j'\\in J$ and $x\\in F(j)$, $x'\\in F(j')$. If $f:j\\to j'$ is a morphism in $J$ and $F(f)(x)=x'$, then $\\mathrm{colim}_J F(j)=\\mathrm{colim}_J F(j')$."}
{"formal_statement": "theorem eval_equiv_to_linear_map {K V : Type*} [field K] [add_comm_group V]\n\t[module K V] [finite_dimensional K V] :\n\t(module.eval_equiv K V).to_linear_map = module.dual.eval K V", "decl_tp": "\u2200 {K : Type u_1} {V : Type u_2} [_inst_1 : field K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] [_inst_4 : finite_dimensional K V], (module.eval_equiv K V).to_linear_map = module.dual.eval K V", "decl_nm": "module.eval_equiv_to_linear_map", "nl_statement_of_codex": "The map $V^*\\to \\mathrm{Hom}(V,K)$ given by $f\\mapsto (v\\mapsto f(v))$ is an isomorphism of $K$-vector spaces."}
{"formal_statement": "theorem to_finset_surjective {\u03b1 : Type*} [decidable_eq \u03b1] :\n\tfunction.surjective list.to_finset", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1], function.surjective list.to_finset", "decl_nm": "list.to_finset_surjective", "nl_statement_of_codex": "The function from lists to finite sets is surjective."}
{"formal_statement": "theorem inv_apply (G : Type*) [measurable_space G] [group G] [has_measurable_inv G] :\n\t\u21d1(measurable_equiv.inv G) = has_inv.inv", "decl_tp": "\u2200 (G : Type u_1) [_inst_1 : measurable_space G] [_inst_4 : group G] [_inst_10 : has_measurable_inv G], \u21d1(measurable_equiv.inv G) = has_inv.inv", "decl_nm": "measurable_equiv.inv_apply", "nl_statement_of_codex": "The inverse of a measurable function is measurable."}
{"formal_statement": "theorem degree_X_add_C {R : Type u} [nontrivial R] [semiring R] (a : R) :\n\t(polynomial.X + \u21d1polynomial.C a).degree = 1", "decl_tp": "\u2200 {R : Type u} [_inst_1 : nontrivial R] [_inst_2 : semiring R] (a : R), (polynomial.X + \u21d1polynomial.C a).degree = 1", "decl_nm": "polynomial.degree_X_add_C", "nl_statement_of_codex": "The degree of $x+a$ is $1$."}
{"formal_statement": "theorem Sup_sets_eq {\u03b1 : Type u} {s : set (filter \u03b1)} :\n\t(has_Sup.Sup s).sets = \u22c2 (f : filter \u03b1) (H : f \u2208 s), f.sets", "decl_tp": "\u2200 {\u03b1 : Type u} {s : set (filter \u03b1)}, (has_Sup.Sup s).sets = \u22c2 (f : filter \u03b1) (H : f \u2208 s), f.sets", "decl_nm": "filter.Sup_sets_eq", "nl_statement_of_codex": "The sets of a supremum of filters are the intersection of the sets of the filters."}
{"formal_statement": "theorem to_mul_equiv_apply {M N : Type*} [mul_one_class M] [mul_one_class N]\n\t(f : M \u2192* N) (g : N \u2192* M) (h\u2081 : g.comp f = monoid_hom.id M) (h\u2082 : f.comp g = monoid_hom.id N) :\n\t\u21d1(f.to_mul_equiv g h\u2081 h\u2082) = \u21d1f", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] (f : M \u2192* N) (g : N \u2192* M) (h\u2081 : g.comp f = monoid_hom.id M) (h\u2082 : f.comp g = monoid_hom.id N), \u21d1(f.to_mul_equiv g h\u2081 h\u2082) = \u21d1f", "decl_nm": "monoid_hom.to_mul_equiv_apply", "nl_statement_of_codex": "Let $M$ and $N$ be monoids with identity. Let $f:M\\to N$ and $g:N\\to M$ be monoid homomorphisms such that $g\\circ f=\\mathrm{id}_M$ and $f\\circ g=\\mathrm{id}_N$. Then the map $f$ is a monoid isomorphism."}
{"formal_statement": "theorem mul {R : Type*} {a b : R} [semigroup R] (rra : is_right_regular a)\n\t(rrb : is_right_regular b) :\n\tis_right_regular (a * b)", "decl_tp": "\u2200 {R : Type u_1} {a b : R} [_inst_1 : semigroup R], is_right_regular a \u2192 is_right_regular b \u2192 is_right_regular (a * b)", "decl_nm": "is_right_regular.mul", "nl_statement_of_codex": "If $a$ and $b$ are right regular elements of a semigroup $R$, then $ab$ is right regular."}
{"formal_statement": "theorem eqv_classes_disjoint {\u03b1 : Type*} {c : set (set \u03b1)} :\n\t(\u2200 (a : \u03b1), \u2203! (b : set \u03b1) (H : b \u2208 c), a \u2208 b) \u2192 c.pairwise_disjoint id", "decl_tp": "\u2200 {\u03b1 : Type u_1} {c : set (set \u03b1)}, (\u2200 (a : \u03b1), \u2203! (b : set \u03b1) (H : b \u2208 c), a \u2208 b) \u2192 c.pairwise_disjoint id", "decl_nm": "setoid.eqv_classes_disjoint", "nl_statement_of_codex": "Let $c$ be a set of subsets of $A$. If each element of $A$ is contained in exactly one element of $c$, then the elements of $c$ are pairwise disjoint."}
{"formal_statement": "theorem zip_coe {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2] (c\u2080 : omega_complete_partial_order.chain \u03b1)\n\t(c\u2081 : omega_complete_partial_order.chain \u03b2) (x : \u2115) :\n\t\u21d1(c\u2080.zip c\u2081) x = (\u21d1c\u2080 x, \u21d1c\u2081 x)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] (c\u2080 : omega_complete_partial_order.chain \u03b1) (c\u2081 : omega_complete_partial_order.chain \u03b2) (x : \u2115), \u21d1(c\u2080.zip c\u2081) x = (\u21d1c\u2080 x, \u21d1c\u2081 x)", "decl_nm": "omega_complete_partial_order.chain.zip_coe", "nl_statement_of_codex": "Let $c_0$ and $c_1$ be chains in preordered sets $A$ and $B$. Then the $n$-th element of the chain $c_0\\times c_1$ is $(c_0(n),c_1(n))$."}
{"formal_statement": "theorem le_iff_exists_mul {\u03b1 : Type u} [canonically_ordered_monoid \u03b1] {a b : \u03b1} :\n\ta \u2264 b \u2194 \u2203 (c : \u03b1), b = a * c", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : canonically_ordered_monoid \u03b1] {a b : \u03b1}, a \u2264 b \u2194 \u2203 (c : \u03b1), b = a * c", "decl_nm": "le_iff_exists_mul", "nl_statement_of_codex": "Let $R$ be a commutative monoid with a zero element. Then $a\\leq b$ if and only if there exists $c\\in R$ such that $b=ac$."}
{"formal_statement": "theorem dim_eq_one_iff {F E : Type*} [field F] [field E] [algebra F E]\n\t{S : subalgebra F E} :\n\tmodule.rank F \u21a5S = 1 \u2194 S = \u22a5", "decl_tp": "\u2200 {F : Type u_1} {E : Type u_2} [_inst_6 : field F] [_inst_7 : field E] [_inst_8 : algebra F E] {S : subalgebra F E}, module.rank F \u21a5S = 1 \u2194 S = \u22a5", "decl_nm": "subalgebra.dim_eq_one_iff", "nl_statement_of_codex": "Let $F$ be a field and let $E$ be a field extension of $F$. Let $S$ be a subalgebra of $E$. Then $S$ is trivial if and only if $\\dim_F S=1$."}
{"formal_statement": "theorem bdd_above_range {\u03b2 : Type*} [semilattice_sup \u03b2] {f : \u2115 \u2192 \u03b2} (hf : filter.is_bounded_under has_le.le filter.at_top f) :\n\tbdd_above (set.range f)", "decl_tp": "\u2200 {\u03b2 : Type u_2} [_inst_1 : semilattice_sup \u03b2] {f : \u2115 \u2192 \u03b2}, filter.is_bounded_under has_le.le filter.at_top f \u2192 bdd_above (set.range f)", "decl_nm": "filter.is_bounded_under.bdd_above_range", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\beta$ be a function. If $f$ is bounded above, then the range of $f$ is bounded above."}
{"formal_statement": "theorem map_neg_one {R S : Type*} [ring R] [ring S] (f : R \u2243+* S) :\n\t\u21d1f (-1) = -1", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : ring R] [_inst_2 : ring S] (f : R \u2243+* S), \u21d1f (-1) = -1", "decl_nm": "ring_equiv.map_neg_one", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $f:R\\to S$ be a ring isomorphism. Then $f(-1)=-1$."}
{"formal_statement": "theorem cons_ndunion {\u03b1 : Type*} [decidable_eq \u03b1] (s t : multiset \u03b1) (a : \u03b1) :\n\t(a ::\u2098 s).ndunion t = multiset.ndinsert a (s.ndunion t)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s t : multiset \u03b1) (a : \u03b1), (a ::\u2098 s).ndunion t = multiset.ndinsert a (s.ndunion t)", "decl_nm": "multiset.cons_ndunion", "nl_statement_of_codex": "Let $s$ and $t$ be multisets of elements of a type $\u03b1$ with decidable equality. Then the multiset union of $a::s$ and $t$ is the multiset union of $s$ and $t$ with $a$ inserted."}
{"formal_statement": "theorem ge_iff_le {\u03b1 : Type u} [preorder \u03b1] {a b : \u03b1} :\n\ta \u2265 b \u2194 b \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b : \u03b1}, a \u2265 b \u2194 b \u2264 a", "decl_nm": "ge_iff_le", "nl_statement_of_codex": "Let $a, b$ be elements of a preorder. Then $a\\geq b$ if and only if $b\\leq a$."}
{"formal_statement": "theorem polar_smul_right {R M : Type*} [add_comm_group M] [ring R] [module R M]\n\t{Q : quadratic_form R M} (a : R) (x y : M) :\n\tquadratic_form.polar \u21d1Q x (a \u2022 y) = a * quadratic_form.polar \u21d1Q x y", "decl_tp": "\u2200 {R : Type u_2} {M : Type u_3} [_inst_1 : add_comm_group M] [_inst_2 : ring R] [_inst_4 : module R M] {Q : quadratic_form R M} (a : R) (x y : M), quadratic_form.polar \u21d1Q x (a \u2022 y) = a * quadratic_form.polar \u21d1Q x y", "decl_nm": "quadratic_form.polar_smul_right", "nl_statement_of_codex": "Let $R$ be a ring, $M$ an $R$-module, and $Q$ a quadratic form on $M$. Then for all $a\\in R$ and $x,y\\in M$, we have\n$Q(x,ay)=aQ(x,y)$."}
{"formal_statement": "theorem parallel_pair_functor_obj {C : Type u} [category_theory.category C]\n\t{F : category_theory.limits.walking_parallel_pair \u2964 C} (j : category_theory.limits.walking_parallel_pair) :\n\t(category_theory.limits.parallel_pair (F.map category_theory.limits.walking_parallel_pair_hom.left)\n\t(F.map category_theory.limits.walking_parallel_pair_hom.right)).obj j = F.obj j", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {F : category_theory.limits.walking_parallel_pair \u2964 C} (j : category_theory.limits.walking_parallel_pair), (category_theory.limits.parallel_pair (F.map category_theory.limits.walking_parallel_pair_hom.left) (F.map category_theory.limits.walking_parallel_pair_hom.right)).obj j = F.obj j", "decl_nm": "category_theory.limits.parallel_pair_functor_obj", "nl_statement_of_codex": "Let $C$ be a category and let $F:\\mathbf{W}\\to C$ be a functor. Then $F$ preserves parallel pairs."}
{"formal_statement": "theorem map_bind {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (g : \u03b2 \u2192 list \u03b3)\n\t(f : \u03b1 \u2192 \u03b2) (l : list \u03b1) :\n\t(list.map f l).bind g = l.bind (\u03bb (a : \u03b1), g (f a))", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} (g : \u03b2 \u2192 list \u03b3) (f : \u03b1 \u2192 \u03b2) (l : list \u03b1), (list.map f l).bind g = l.bind (\u03bb (a : \u03b1), g (f a))", "decl_nm": "list.map_bind", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$. Then $g\\circ f:A\\to C$ is the same as $f\\circ g:A\\to C$."}
{"formal_statement": "theorem finset_card_neighbor_set_eq_degree {V : Type u} {G : simple_graph V}\n\t{G' : G.subgraph} {v : V} [fintype \u21a5(G'.neighbor_set v)] :\n\t(G'.neighbor_set v).to_finset.card = G'.degree v", "decl_tp": "\u2200 {V : Type u} {G : simple_graph V} {G' : G.subgraph} {v : V} [_inst_1 : fintype \u21a5(G'.neighbor_set v)], (G'.neighbor_set v).to_finset.card = G'.degree v", "decl_nm": "simple_graph.subgraph.finset_card_neighbor_set_eq_degree", "nl_statement_of_codex": "Let $G$ be a simple graph and let $G'$ be a subgraph of $G$. Let $v$ be a vertex of $G'$. Then the number of neighbors of $v$ in $G'$ is equal to the degree of $v$ in $G'$."}
{"formal_statement": "theorem cons_bag_inter_of_pos {\u03b1 : Type*} {l\u2082 : list \u03b1} {a : \u03b1} [decidable_eq \u03b1]\n\t(l\u2081 : list \u03b1) (h : a \u2208 l\u2082) :\n\t(a :: l\u2081).bag_inter l\u2082 = a :: l\u2081.bag_inter (l\u2082.erase a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {l\u2082 : list \u03b1} {a : \u03b1} [_inst_1 : decidable_eq \u03b1] (l\u2081 : list \u03b1), a \u2208 l\u2082 \u2192 (a :: l\u2081).bag_inter l\u2082 = a :: l\u2081.bag_inter (l\u2082.erase a)", "decl_nm": "list.cons_bag_inter_of_pos", "nl_statement_of_codex": "Let $l_1$ and $l_2$ be lists of elements of a type $\u03b1$ with decidable equality. If $a$ is an element of $l_2$, then the bag intersection of $a::l_1$ and $l_2$ is $a::l_1\\cap l_2$."}
{"formal_statement": "theorem lcm_zero_right (m : \u2115) :\n\tm.lcm 0 = 0", "decl_tp": "\u2200 (m : \u2115), m.lcm 0 = 0", "decl_nm": "nat.lcm_zero_right", "nl_statement_of_codex": "The least common multiple of $m$ and $0$ is $0$."}
{"formal_statement": "theorem directed_on {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [is_refl \u03b1 r] {c : set \u03b1}\n\t(H : zorn.chain r c) :\n\tdirected_on r c", "decl_tp": "\u2200 {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : is_refl \u03b1 r] {c : set \u03b1}, zorn.chain r c \u2192 directed_on r c", "decl_nm": "zorn.chain.directed_on", "nl_statement_of_codex": "Let $r$ be a reflexive relation on a set $A$. If $c$ is a chain with respect to $r$, then $c$ is directed with respect to $r$."}
{"formal_statement": "theorem comp_apply {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03c6 : Sort w} (f : \u03b2 \u2192 \u03c6) (g : \u03b1 \u2192 \u03b2)\n\t(a : \u03b1) :\n\t(f \u2218 g) a = f (g a)", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03c6 : Sort w} (f : \u03b2 \u2192 \u03c6) (g : \u03b1 \u2192 \u03b2) (a : \u03b1), (f \u2218 g) a = f (g a)", "decl_nm": "function.comp_apply", "nl_statement_of_codex": "Let $f:B\\to C$ and $g:A\\to B$. Then $(f\\circ g)(a)=f(g(a))$ for all $a\\in A$."}
{"formal_statement": "theorem cotrident_\u03b9_app_one {J : Type v} {C : Type u} [category_theory.category C]\n\t{X Y : C} (f : J \u2192 (X \u27f6 Y)) [category_theory.limits.has_wide_coequalizer f] :\n\t(category_theory.limits.wide_coequalizer.cotrident f).\u03b9.app category_theory.limits.walking_parallel_family.one = category_theory.limits.wide_coequalizer.\u03c0 f", "decl_tp": "\u2200 {J : Type v} {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} (f : J \u2192 (X \u27f6 Y)) [_inst_2 : category_theory.limits.has_wide_coequalizer f], (category_theory.limits.wide_coequalizer.cotrident f).\u03b9.app category_theory.limits.walking_parallel_family.one = category_theory.limits.wide_coequalizer.\u03c0 f", "decl_nm": "category_theory.limits.wide_coequalizer.cotrident_\u03b9_app_one", "nl_statement_of_codex": "Let $C$ be a category, $X$ and $Y$ objects of $C$, and $f:J\\to (X\\to Y)$ a family of morphisms. Then the coequalizer of $f$ is the equalizer of the family of morphisms $f_j\\circ f_i^{-1}$."}
{"formal_statement": "theorem zpow {G\u2080 : Type*} [group_with_zero G\u2080] [topological_space G\u2080] [has_continuous_inv\u2080 G\u2080]\n\t[has_continuous_mul G\u2080] {X : Type*} [topological_space X] {a : X} {s : set X}\n\t{f : X \u2192 G\u2080} (hf : continuous_within_at f s a) (h : f a \u2260 0 \u2228 0 \u2264 m) :\n\t\u2200 (m : \u2124),  continuous_within_at (\u03bb (x : X), f x ^ m) s a", "decl_tp": "\u2200 {G\u2080 : Type u_3} [_inst_1 : group_with_zero G\u2080] [_inst_2 : topological_space G\u2080] [_inst_3 : has_continuous_inv\u2080 G\u2080] [_inst_4 : has_continuous_mul G\u2080] {X : Type u_4} [_inst_5 : topological_space X] {a : X} {s : set X} {f : X \u2192 G\u2080}, continuous_within_at f s a \u2192 \u2200 (m : \u2124), f a \u2260 0 \u2228 0 \u2264 m \u2192 continuous_within_at (\u03bb (x : X), f x ^ m) s a", "decl_nm": "continuous_within_at.zpow", "nl_statement_of_codex": "Let $G$ be a topological group with continuous inversion and multiplication. Let $X$ be a topological space, $a\\in X$, $s\\subset X$, and $f:X\\to G$. If $f$ is continuous at $a$, then the function $x\\mapsto f(x)^m$ is continuous at $a$ for all $m\\in\\mathbb{Z}$."}
{"formal_statement": "theorem injective {\u03b1 : Sort u} {\u03b2 : Sort v} (e : \u03b1 \u2243 \u03b2) :\n\tfunction.injective \u21d1e", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} (e : \u03b1 \u2243 \u03b2), function.injective \u21d1e", "decl_nm": "equiv.injective", "nl_statement_of_codex": "If $e:\u03b1\\to \u03b2$ is an isomorphism, then $e$ is injective."}
{"formal_statement": "theorem is_greatest_union_iff {\u03b1 : Type u} [preorder \u03b1] {s t : set \u03b1} {a : \u03b1} :\n\tis_greatest (s \u222a t) a \u2194 is_greatest s a \u2227 a \u2208 upper_bounds t \u2228 a \u2208 upper_bounds s \u2227 is_greatest t a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {s t : set \u03b1} {a : \u03b1}, is_greatest (s \u222a t) a \u2194 is_greatest s a \u2227 a \u2208 upper_bounds t \u2228 a \u2208 upper_bounds s \u2227 is_greatest t a", "decl_nm": "is_greatest_union_iff", "nl_statement_of_codex": "Let $s$ and $t$ be sets of a preordered set $X$. Then $a\\in X$ is the greatest element of $s\\cup t$ if and only if $a$ is the greatest element of $s$ and $a$ is an upper bound of $t$, or $a$ is an upper bound of $s$ and $a$ is the greatest element of $t$."}
{"formal_statement": "theorem nonempty_of_not_subset {\u03b1 : Type u} {s t : set \u03b1} (h : \u00acs \u2286 t) :\n\t(s \\ t).nonempty", "decl_tp": "\u2200 {\u03b1 : Type u} {s t : set \u03b1}, \u00acs \u2286 t \u2192 (s \\ t).nonempty", "decl_nm": "set.nonempty_of_not_subset", "nl_statement_of_codex": "If $s$ is not a subset of $t$, then $s\\setminus t$ is nonempty."}
{"formal_statement": "theorem mono_on {\u03b1 \u03b9 : Type*} [semilattice_inf \u03b1] [order_bot \u03b1] {s : set \u03b9}\n\t{f g : \u03b9 \u2192 \u03b1} (hs : s.pairwise_disjoint f) :\n\t(\u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 g i \u2264 f i) \u2192 s.pairwise_disjoint g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {s : set \u03b9} {f g : \u03b9 \u2192 \u03b1}, s.pairwise_disjoint f \u2192 (\u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 g i \u2264 f i) \u2192 s.pairwise_disjoint g", "decl_nm": "set.pairwise_disjoint.mono_on", "nl_statement_of_codex": "Let $s$ be a set of indices and let $f,g:s\\to \\alpha$ be functions. If $f$ is pairwise disjoint and $g(i)\\leq f(i)$ for all $i\\in s$, then $g$ is pairwise disjoint."}
{"formal_statement": "theorem path_extend {X Y : Type*} [topological_space X] [topological_space Y]\n\t{l r : Y \u2192 X} {y : Y} {l\u2081 : filter \u211d} {l\u2082 : filter X} {\u03b3 : \u03a0 (y : Y), path (l y)\n\t(r y)} (h\u03b3 : filter.tendsto \u21bf\u03b3 ((nhds y).prod (filter.map (set.proj_Icc 0 1 zero_le_one) l\u2081)) l\u2082) :\n\tfilter.tendsto \u21bf(\u03bb (x : Y), (\u03b3 x).extend) ((nhds y).prod l\u2081) l\u2082", "decl_tp": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_3 : topological_space X] [_inst_4 : topological_space Y] {l r : Y \u2192 X} {y : Y} {l\u2081 : filter \u211d} {l\u2082 : filter X} {\u03b3 : \u03a0 (y : Y), path (l y) (r y)}, filter.tendsto \u21bf\u03b3 ((nhds y).prod (filter.map (set.proj_Icc 0 1 zero_le_one) l\u2081)) l\u2082 \u2192 filter.tendsto \u21bf(\u03bb (x : Y), (\u03b3 x).extend) ((nhds y).prod l\u2081) l\u2082", "decl_nm": "filter.tendsto.path_extend", "nl_statement_of_codex": "Let $X$ and $Y$ be topological spaces, let $l,r:Y\\to X$, let $y\\in Y$, let $l_1$ and $l_2$ be filters on $X$, and let $\\gamma:Y\\to X$ be a path from $l(y)$ to $r(y)$. If $\\gamma$ tends to $l_2$ along the product of the filter $(y)$ and the filter $l_1$ on $[0,1]$, then the extended path $\\gamma$ tends to $l_2$ along the product of the filter $(y)$ and the filter $l_1$ on"}
{"formal_statement": "theorem lift_mk {M : Type*} [semi_normed_group M] {N : Type*} [semi_normed_group N]\n\t(S : add_subgroup M) (f : normed_group_hom M N) (hf : \u2200 (s : M), s \u2208 S \u2192 \u21d1f s = 0)\n\t(m : M) :\n\t\u21d1(normed_group_hom.lift S f hf) (\u21d1(S.normed_mk) m) = \u21d1f m", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : semi_normed_group M] {N : Type u_2} [_inst_3 : semi_normed_group N] (S : add_subgroup M) (f : normed_group_hom M N) (hf : \u2200 (s : M), s \u2208 S \u2192 \u21d1f s = 0) (m : M), \u21d1(normed_group_hom.lift S f hf) (\u21d1(S.normed_mk) m) = \u21d1f m", "decl_nm": "normed_group_hom.lift_mk", "nl_statement_of_codex": "Let $M$ and $N$ be semi-normed groups and let $S$ be a subgroup of $M$. Let $f:M\\to N$ be a normed group homomorphism. Suppose that $f(s)=0$ for all $s\\in S$. Then the map $f$ induces a normed group homomorphism $f:M/S\\to N$."}
{"formal_statement": "theorem eq_equivalence {\u03b1 : Sort u_1} :\n\tequivalence eq", "decl_tp": "\u2200 {\u03b1 : Sort u_1}, equivalence eq", "decl_nm": "eq_equivalence", "nl_statement_of_codex": "The equality relation on a type $\u03b1$ is an equivalence relation."}
{"formal_statement": "theorem floor_map_map_zero_le (f g : circle_deg1_lift) :\n\t\u230a\u21d1f (\u21d1g 0)\u230b \u2264 \u230a\u21d1f 0\u230b + \u2308\u21d1g 0\u2309", "decl_tp": "\u2200 (f g : circle_deg1_lift), \u230a\u21d1f (\u21d1g 0)\u230b \u2264 \u230a\u21d1f 0\u230b + \u2308\u21d1g 0\u2309", "decl_nm": "circle_deg1_lift.floor_map_map_zero_le", "nl_statement_of_codex": "Let $f,g:S^1\\to\\mathbb{R}$ be continuous functions. Then $\\lfloor f(g(0))\\rfloor\\leq\\lfloor f(0)\\rfloor+\\lceil g(0)\\rceil$."}
{"formal_statement": "theorem gcd_rel_right (a b : \u2115+) :\n\t\u2191(a.gcd_w b) * \u2191b = a.gcd_y b * \u2191a + \u2191(a.gcd b)", "decl_tp": "\u2200 (a b : \u2115+), \u2191(a.gcd_w b) * \u2191b = a.gcd_y b * \u2191a + \u2191(a.gcd b)", "decl_nm": "pnat.gcd_rel_right", "nl_statement_of_codex": "Let $a,b$ be positive integers. Then $a\\cdot gcd(a,b)=gcd(a,b)\\cdot b+gcd(a,b)$."}
{"formal_statement": "theorem eqv_gen_eq {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n\teqv_gen.setoid r = has_Inf.Inf {s : setoid \u03b1 | \u2200 \u2983x y : \u03b1\u2984, r x y \u2192 s.rel x y}", "decl_tp": "\u2200 {\u03b1 : Type u_1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop), eqv_gen.setoid r = has_Inf.Inf {s : setoid \u03b1 | \u2200 \u2983x y : \u03b1\u2984, r x y \u2192 s.rel x y}", "decl_nm": "setoid.eqv_gen_eq", "nl_statement_of_codex": "The equivalence relation generated by $r$ is the intersection of all equivalence relations containing $r$."}
{"formal_statement": "theorem ufm_of_gcd_of_wf_dvd_monoid {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1]\n\t[wf_dvd_monoid \u03b1] [gcd_monoid \u03b1] :\n\tunique_factorization_monoid \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : wf_dvd_monoid \u03b1] [_inst_3 : gcd_monoid \u03b1], unique_factorization_monoid \u03b1", "decl_nm": "ufm_of_gcd_of_wf_dvd_monoid", "nl_statement_of_codex": "If $R$ is a well-founded dvd monoid with gcd, then $R$ is a unique factorization monoid."}
{"formal_statement": "theorem left_inv_of_inv_of_mem_range {\u03b1 \u03b2 : Type*} [fintype \u03b1] [decidable_eq \u03b2]\n\t(f : \u03b1 \u21aa \u03b2) (b : \u21a5(set.range \u21d1f)) :\n\t\u21d1f (f.inv_of_mem_range b) = \u2191b", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b2] (f : \u03b1 \u21aa \u03b2) (b : \u21a5(set.range \u21d1f)), \u21d1f (f.inv_of_mem_range b) = \u2191b", "decl_nm": "function.embedding.left_inv_of_inv_of_mem_range", "nl_statement_of_codex": "Let $f:A\\to B$ be an injective function. Then $f$ has a left inverse."}
{"formal_statement": "theorem continuous_div_right' {G : Type w} [topological_space G] [has_div G]\n\t[has_continuous_div G] (a : G) :\n\tcontinuous (\u03bb (b : G), b / a)", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : has_div G] [_inst_3 : has_continuous_div G] (a : G), continuous (\u03bb (b : G), b / a)", "decl_nm": "continuous_div_right'", "nl_statement_of_codex": "Let $G$ be a topological space with a division operation. Then the function $b\\mapsto b/a$ is continuous."}
{"formal_statement": "theorem exists_eq_left' {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {a' : \u03b1} :\n\t(\u2203 (a : \u03b1), a' = a \u2227 p a) \u2194 p a'", "decl_tp": "\u2200 {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} {a' : \u03b1}, (\u2203 (a : \u03b1), a' = a \u2227 p a) \u2194 p a'", "decl_nm": "exists_eq_left'", "nl_statement_of_codex": "There exists an $a$ such that $a'=a$ and $p(a)$ if and only if $p(a')$."}
{"formal_statement": "theorem nat_abs_neg_of_nat (n : \u2115) :\n\t(int.neg_of_nat n).nat_abs = n", "decl_tp": "\u2200 (n : \u2115), (int.neg_of_nat n).nat_abs = n", "decl_nm": "int.nat_abs_neg_of_nat", "nl_statement_of_codex": "The absolute value of the negative of a natural number is the natural number itself."}
{"formal_statement": "theorem cocone_points_iso_of_equivalence_inv {J : Type u\u2081} [category_theory.category J]\n\t{K : Type u\u2082} [category_theory.category K] {C : Type u\u2083} [category_theory.category C]\n\t{F : J \u2964 C} {s : category_theory.limits.cocone F} {G : K \u2964 C} {t : category_theory.limits.cocone G}\n\t(P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t)\n\t(e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) :\n\t(P.cocone_points_iso_of_equivalence Q e w).inv = Q.desc ((category_theory.limits.cocones.equivalence_of_reindexing e.symm ((category_theory.iso_whisker_left e.inverse w).symm \u226a\u226b e.inv_fun_id_assoc G)).functor.obj s)", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {K : Type u\u2082} [_inst_2 : category_theory.category K] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C} {s : category_theory.limits.cocone F} {G : K \u2964 C} {t : category_theory.limits.cocone G} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F), (P.cocone_points_iso_of_equivalence Q e w).inv = Q.desc ((category_theory.limits.cocones.equivalence_of_reindexing e.symm ((category_theory.iso_whisker_left e.inverse w).symm \u226a\u226b e.inv_fun_id_assoc G)).functor.obj s)", "decl_nm": "category_theory.limits.is_colimit.cocone_points_iso_of_equivalence_inv", "nl_statement_of_codex": "Let $F:J\\to C$ and $G:K\\to C$ be functors. Let $s$ and $t$ be cocones over $F$ and $G$, respectively.\nSuppose that $s$ and $t$ are colimits. Suppose that $e:J\\to K$ is an equivalence of categories and that $w:e\\circ G\\to F$ is an isomorphism of functors. Then the inverse of the isomorphism of cocones induced by $e$ and $w$ is the cocone over $G$ induced by the equivalence of cocones induced by $e$ and $w$."}
{"formal_statement": "theorem btw_cyclic {\u03b1 : Type*} [circular_preorder \u03b1] {a b c : \u03b1} :\n\thas_btw.btw a b c \u2194 has_btw.btw c a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : circular_preorder \u03b1] {a b c : \u03b1}, has_btw.btw a b c \u2194 has_btw.btw c a b", "decl_nm": "btw_cyclic", "nl_statement_of_codex": "Let $a,b,c$ be elements of a circular preorder. Then $a$ is between $b$ and $c$ if and only if $c$ is between $a$ and $b$."}
{"formal_statement": "theorem mem_source_trivialization_at (R : Type*) {B : Type*} (F : Type*)\n\t(E : B \u2192 Type*) [semiring R] [\u03a0 (x : B), add_comm_monoid (E x)] [\u03a0 (x : B), module R (E x)]\n\t[topological_space F] [add_comm_monoid F] [module R F] [topological_space (bundle.total_space E)]\n\t[topological_space B] [\u03a0 (x : B), topological_space (E x)] [topological_vector_bundle R F E]\n\t(z : bundle.total_space E) :\n\tz \u2208 (topological_vector_bundle.trivialization_at R F E z.fst).to_fiber_bundle_trivialization.to_local_homeomorph.to_local_equiv.source", "decl_tp": "\u2200 (R : Type u_1) {B : Type u_2} (F : Type u_3) (E : B \u2192 Type u_4) [_inst_1 : semiring R] [_inst_2 : \u03a0 (x : B), add_comm_monoid (E x)] [_inst_3 : \u03a0 (x : B), module R (E x)] [_inst_4 : topological_space F] [_inst_5 : add_comm_monoid F] [_inst_6 : module R F] [_inst_7 : topological_space (bundle.total_space E)] [_inst_8 : topological_space B] [_inst_9 : \u03a0 (x : B), topological_space (E x)] [_inst_10 : topological_vector_bundle R F E] (z : bundle.total_space E), z \u2208 (topological_vector_bundle.trivialization_at R F E z.fst).to_fiber_bundle_trivialization.to_local_homeomorph.to_local_equiv.source", "decl_nm": "topological_vector_bundle.mem_source_trivialization_at", "nl_statement_of_codex": "Let $R$ be a semiring, $B$ a topological space, $F$ an $R$-module, and $E$ a topological vector bundle over $B$ with fiber $F$. Then the source of the trivialization of $E$ at $z$ is $E_z$."}
{"formal_statement": "theorem inf {L : first_order.language} {M : Type*} [L.Structure M] {n : \u2115}\n\t{f : L.functions n} {s t : set M} (hs : first_order.language.closed_under f s)\n\t(ht : first_order.language.closed_under f t) :\n\tfirst_order.language.closed_under f (s \u2293 t)", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} [_inst_1 : L.Structure M] {n : \u2115} {f : L.functions n} {s t : set M}, first_order.language.closed_under f s \u2192 first_order.language.closed_under f t \u2192 first_order.language.closed_under f (s \u2293 t)", "decl_nm": "first_order.language.closed_under.inf", "nl_statement_of_codex": "Let $L$ be a first-order language, $M$ a model of $L$, $n$ a natural number, $f$ an $n$-ary function symbol of $L$, and $s,t$ subsets of $M$. If $s$ and $t$ are closed under $f$, then $s\\cap t$ is closed under $f$."}
{"formal_statement": "theorem cos_arctan_pos (x : \u211d) :\n\t0 < real.cos (real.arctan x)", "decl_tp": "\u2200 (x : \u211d), 0 < real.cos (real.arctan x)", "decl_nm": "real.cos_arctan_pos", "nl_statement_of_codex": "The cosine of the arctangent of $x$ is positive."}
{"formal_statement": "theorem coe_mul (A : Type*) [add_zero_class A] (f g : add_monoid.End A) :\n\t\u21d1(f * g) = \u21d1f \u2218 \u21d1g", "decl_tp": "\u2200 (A : Type u_7) [_inst_1 : add_zero_class A] (f g : add_monoid.End A), \u21d1(f * g) = \u21d1f \u2218 \u21d1g", "decl_nm": "add_monoid.coe_mul", "nl_statement_of_codex": "Let $A$ be an additive monoid with zero. Then the function $f*g$ is the composition of the functions $f$ and $g$."}
{"formal_statement": "theorem primitive_roots_one {R : Type*} [comm_ring R] [is_domain R] :\n\tprimitive_roots 1 R = {1}", "decl_tp": "\u2200 {R : Type u_5} [_inst_5 : comm_ring R] [_inst_6 : is_domain R], primitive_roots 1 R = {1}", "decl_nm": "is_primitive_root.primitive_roots_one", "nl_statement_of_codex": "The set of primitive roots of $1$ in a domain $R$ is $\\{1\\}$."}
{"formal_statement": "theorem fderiv_within_snd {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{p : E \u00d7 F} {s : set (E \u00d7 F)} (hs : unique_diff_within_at \ud835\udd5c s p) :\n\tfderiv_within \ud835\udd5c prod.snd s p = continuous_linear_map.snd \ud835\udd5c E F", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {p : E \u00d7 F} {s : set (E \u00d7 F)}, unique_diff_within_at \ud835\udd5c s p \u2192 fderiv_within \ud835\udd5c prod.snd s p = continuous_linear_map.snd \ud835\udd5c E F", "decl_nm": "fderiv_within_snd", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over $\\mathbb{K}$ and let $s$ be a subset of $E\\times F$. If $s$ is differentiable at $p$, then the partial derivative of $s$ with respect to the second coordinate is the second coordinate map."}
{"formal_statement": "theorem down_eq_down {\u03b1 : Type*} [encodable \u03b1] {a b : \u03b1} :\n\tulower.down a = ulower.down b \u2194 a = b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : encodable \u03b1] {a b : \u03b1}, ulower.down a = ulower.down b \u2194 a = b", "decl_nm": "ulower.down_eq_down", "nl_statement_of_codex": "Let $a,b$ be elements of a type $\u03b1$ with an encodable structure. Then $a$ and $b$ are equal if and only if their encodings are equal."}
{"formal_statement": "theorem sum_arrow_equiv_prod_arrow_apply_fst {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2295 \u03b2 \u2192 \u03b3)\n\t(a : \u03b1) :\n\t(\u21d1(equiv.sum_arrow_equiv_prod_arrow \u03b1 \u03b2 \u03b3) f).fst a = f (sum.inl a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (f : \u03b1 \u2295 \u03b2 \u2192 \u03b3) (a : \u03b1), (\u21d1(equiv.sum_arrow_equiv_prod_arrow \u03b1 \u03b2 \u03b3) f).fst a = f (sum.inl a)", "decl_nm": "equiv.sum_arrow_equiv_prod_arrow_apply_fst", "nl_statement_of_codex": "Let $f:\\alpha\\oplus\\beta\\to\\gamma$ be a function. Then the function $f$ is equal to the function $f_1$ defined by $f_1(a,b)=f(a)$."}
{"formal_statement": "theorem mem_top {R : Type u} [ring R] (x : R) :\n\tx \u2208 \u22a4", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] (x : R), x \u2208 \u22a4", "decl_nm": "subring.mem_top", "nl_statement_of_codex": "Every element of a ring is in the top ideal."}
{"formal_statement": "theorem is_subgroup {G : Type*} [group G] (s : set G) :\n\tis_subgroup (group.normal_closure s)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] (s : set G), is_subgroup (group.normal_closure s)", "decl_nm": "group.normal_closure.is_subgroup", "nl_statement_of_codex": "The normal closure of a subset $S$ of a group $G$ is a subgroup of $G$."}
{"formal_statement": "theorem times_cont_mdiff_on_pi_space {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {H : Type*} [topological_space H]\n\t{I : model_with_corners \ud835\udd5c E H} {M : Type*} [topological_space M] [charted_space H M]\n\t{s : set M} {n : with_top \u2115} {\u03b9 : Type*4} [fintype \u03b9] {Fi : \u03b9 \u2192 Type*5}\n\t[\u03a0 (i : \u03b9), normed_group (Fi i)] [\u03a0 (i : \u03b9), normed_space \ud835\udd5c (Fi i)] {\u03c6 : M \u2192 \u03a0 (i : \u03b9), Fi i} :\n\ttimes_cont_mdiff_on I (model_with_corners_self \ud835\udd5c (\u03a0 (i : \u03b9), Fi i)) n \u03c6 s \u2194 \u2200 (i : \u03b9), times_cont_mdiff_on I (model_with_corners_self \ud835\udd5c (Fi i)) n (\u03bb (x : M), \u03c6 x i) s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] {s : set M} {n : with_top \u2115} {\u03b9 : Type u_14} [_inst_22 : fintype \u03b9] {Fi : \u03b9 \u2192 Type u_15} [_inst_23 : \u03a0 (i : \u03b9), normed_group (Fi i)] [_inst_24 : \u03a0 (i : \u03b9), normed_space \ud835\udd5c (Fi i)] {\u03c6 : M \u2192 \u03a0 (i : \u03b9), Fi i}, times_cont_mdiff_on I (model_with_corners_self \ud835\udd5c (\u03a0 (i : \u03b9), Fi i)) n \u03c6 s \u2194 \u2200 (i : \u03b9), times_cont_mdiff_on I (model_with_corners_self \ud835\udd5c (Fi i)) n (\u03bb (x : M), \u03c6 x i) s", "decl_nm": "times_cont_mdiff_on_pi_space", "nl_statement_of_codex": "Let $E$ be a normed group, $H$ a topological space, $M$ a topological space, $s$ a subset of $M$, $n$ a natural number, $\\iota$ a finite type, $F_i$ a normed group for each $i\\in\\iota$, and $\\phi:M\\to\\prod_{i\\in\\iota}F_i$. Then $\\phi$ is $n$-times continuously differentiable on $s$ if and only if $\\phi_i$ is $n$-times continuously differentiable on $s$ for each $i\\in\\iota$."}
{"formal_statement": "theorem last_val (n : \u2115) :\n\t(fin.last n).val = n", "decl_tp": "\u2200 (n : \u2115), (fin.last n).val = n", "decl_nm": "fin.last_val", "nl_statement_of_codex": "The value of the last element of the finite set $\\{0,1,\\ldots,n\\}$ is $n$."}
{"formal_statement": "theorem preimage_diff {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s t : set \u03b2) :\n\tf \u207b\u00b9' (s \\ t) = f \u207b\u00b9' s \\ f \u207b\u00b9' t", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s t : set \u03b2), f \u207b\u00b9' (s \\ t) = f \u207b\u00b9' s \\ f \u207b\u00b9' t", "decl_nm": "set.preimage_diff", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function and let $A,B\\subset Y$. Then $f^{-1}(A\\setminus B)=f^{-1}(A)\\setminus f^{-1}(B)$."}
{"formal_statement": "theorem obj_obj {J : Type u\u2081} [category_theory.category J] {C : Type u\u2082}\n\t[category_theory.category C] (X : C) (j : J) :\n\t((category_theory.functor.const J).obj X).obj j = X", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2082} [_inst_2 : category_theory.category C] (X : C) (j : J), ((category_theory.functor.const J).obj X).obj j = X", "decl_nm": "category_theory.functor.const.obj_obj", "nl_statement_of_codex": "Let $J$ and $C$ be categories. Let $X$ be an object of $C$ and let $j$ be an object of $J$. Then the object of the constant functor $C\\to J$ at $X$ is $X$."}
{"formal_statement": "theorem ext {\u03b1 : Sort u} (x y : unique \u03b1) :\n\tx.to_inhabited = y.to_inhabited \u2192 x = y", "decl_tp": "\u2200 {\u03b1 : Sort u} (x y : unique \u03b1), x.to_inhabited = y.to_inhabited \u2192 x = y", "decl_nm": "unique.ext", "nl_statement_of_codex": "Let $x$ and $y$ be elements of a type $\u03b1$ with a unique inhabitant. Then $x=y$ if and only if $x$ and $y$ are inhabited by the same element."}
{"formal_statement": "theorem infix_append {\u03b1 : Type*} (l\u2081 l\u2082 l\u2083 : list \u03b1) :\n\tl\u2082 <:+: l\u2081 ++ l\u2082 ++ l\u2083", "decl_tp": "\u2200 {\u03b1 : Type u_1} (l\u2081 l\u2082 l\u2083 : list \u03b1), l\u2082 <:+: l\u2081 ++ l\u2082 ++ l\u2083", "decl_nm": "list.infix_append", "nl_statement_of_codex": "Let $l_1, l_2, l_3$ be lists. Then $l_2$ is a sublist of $l_1++l_2++l_3$."}
{"formal_statement": "theorem dual_right {\u03b9 \u03b1 \u03b2 : Type*} [preorder \u03b1] [preorder \u03b2] {f : \u03b9 \u2192 \u03b1}\n\t{g : \u03b9 \u2192 \u03b2} (h : monovary f g) :\n\tantivary f (\u21d1order_dual.to_dual \u2218 g)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}, monovary f g \u2192 antivary f (\u21d1order_dual.to_dual \u2218 g)", "decl_nm": "monovary.dual_right", "nl_statement_of_codex": "Let $f,g:\\iota\\to\\alpha$ be monotone functions. Then $f$ is antitone with respect to $g$ if and only if $f$ is antitone with respect to the dual of $g$."}
{"formal_statement": "theorem fst_injective {\u03b1 \u03b2 : Type*} [subsingleton \u03b2] :\n\tfunction.injective prod.fst", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : subsingleton \u03b2], function.injective prod.fst", "decl_nm": "prod.fst_injective", "nl_statement_of_codex": "The function $fst: \\alpha\\times\\beta\\to\\alpha$ is injective."}
{"formal_statement": "theorem mem_iff {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1] {a : \u03b1}\n\t{s : finmap \u03b2} :\n\ta \u2208 s \u2194 \u2203 (b : \u03b2 a), finmap.lookup a s = option.some b", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {s : finmap \u03b2}, a \u2208 s \u2194 \u2203 (b : \u03b2 a), finmap.lookup a s = option.some b", "decl_nm": "finmap.mem_iff", "nl_statement_of_codex": "Let $s$ be a finite map from $A$ to $B$. Then $a\\in s$ if and only if there is a $b\\in B$ such that $s(a)=b$."}
{"formal_statement": "theorem nth_nats (n : \u2115) :\n\tstream.nats.nth n = n", "decl_tp": "\u2200 (n : \u2115), stream.nats.nth n = n", "decl_nm": "stream.nth_nats", "nl_statement_of_codex": "The $n$-th element of the stream of natural numbers is $n$."}
{"formal_statement": "theorem floor_eq_zero {\u03b1 : Type*} [linear_ordered_semiring \u03b1] [floor_semiring \u03b1]\n\t{a : \u03b1} :\n\t\u230aa\u230b\u208a = 0 \u2194 a < 1", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_semiring \u03b1] [_inst_2 : floor_semiring \u03b1] {a : \u03b1}, \u230aa\u230b\u208a = 0 \u2194 a < 1", "decl_nm": "nat.floor_eq_zero", "nl_statement_of_codex": "Let $a$ be an element of a linear ordered semiring $R$. Then $a<1$ if and only if $\\lfloor a\\rfloor=0$."}
{"formal_statement": "theorem apply_symm_apply {R S : Type*} [has_mul R] [has_add R] [has_mul S]\n\t[has_add S] (e : R \u2243+* S) (x : S) :\n\t\u21d1e (\u21d1(e.symm) x) = x", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : has_mul R] [_inst_2 : has_add R] [_inst_3 : has_mul S] [_inst_4 : has_add S] (e : R \u2243+* S) (x : S), \u21d1e (\u21d1(e.symm) x) = x", "decl_nm": "ring_equiv.apply_symm_apply", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $e:R\\to S$ be an isomorphism. Then $e(e^{-1}(x))=x$ for all $x\\in S$."}
{"formal_statement": "theorem support_neg {\u03b1 G : Type*0} [add_group G] (f : \u03b1 \u2192 G) :\n\tfunction.support (\u03bb (x : \u03b1), -f x) = function.support f", "decl_tp": "\u2200 {\u03b1 : Type u_1} {G : Type u_10} [_inst_1 : add_group G] (f : \u03b1 \u2192 G), function.support (\u03bb (x : \u03b1), -f x) = function.support f", "decl_nm": "function.support_neg", "nl_statement_of_codex": "The support of the function $f:\\alpha\\to G$ is equal to the support of the function $x\\mapsto -f(x)$."}
{"formal_statement": "theorem leading_coeff_add_of_degree_eq {R : Type u} [semiring R] {p q : polynomial R}\n\t(h : p.degree = q.degree) (hlc : p.leading_coeff + q.leading_coeff \u2260 0) :\n\t(p + q).leading_coeff = p.leading_coeff + q.leading_coeff", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {p q : polynomial R}, p.degree = q.degree \u2192 p.leading_coeff + q.leading_coeff \u2260 0 \u2192 (p + q).leading_coeff = p.leading_coeff + q.leading_coeff", "decl_nm": "polynomial.leading_coeff_add_of_degree_eq", "nl_statement_of_codex": "Let $p$ and $q$ be polynomials over a semiring $R$ such that $p$ and $q$ have the same degree. If $p$ and $q$ have nonzero leading coefficients, then the leading coefficient of $p+q$ is the sum of the leading coefficients of $p$ and $q$."}
{"formal_statement": "theorem nsmul_nonneg_iff {M : Type*} [add_monoid M] [linear_order M] [covariant_class M M has_add.add has_le.le]\n\t{x : M} {n : \u2115} (hn : n \u2260 0) :\n\t(0 \u2264 n \u2022 x \u2194 0 \u2264 x)", "decl_tp": "\u2200 {M : Type u_3} [_inst_1 : add_monoid M] [_inst_2 : linear_order M] [_inst_3 : covariant_class M M has_add.add has_le.le] {x : M} {n : \u2115}, n \u2260 0 \u2192 (0 \u2264 n \u2022 x \u2194 0 \u2264 x)", "decl_nm": "nsmul_nonneg_iff", "nl_statement_of_codex": "Let $M$ be an additive monoid with a linear order. Let $x\\in M$ and $n\\in\\mathbb{N}$. Then $n\\cdot x\\geq 0$ if and only if $x\\geq 0$."}
{"formal_statement": "theorem prod_finset_product {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [comm_monoid \u03b2]\n\t(r : finset (\u03b3 \u00d7 \u03b1)) (s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b1) (p : \u03b3 \u00d7 \u03b1) :\n\t(\u2200 (p : \u03b3 \u00d7 \u03b1), p \u2208 r \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t p.fst) \u2192 \u2200 {f :  \u03b2}, r.prod (\u03bb (p : \u03b3 \u00d7 \u03b1), f p) = s.prod (\u03bb (c : \u03b3), (t c).prod (\u03bb (a : \u03b1), f (c, a)))", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [_inst_1 : comm_monoid \u03b2] (r : finset (\u03b3 \u00d7 \u03b1)) (s : finset \u03b3) (t : \u03b3 \u2192 finset \u03b1), (\u2200 (p : \u03b3 \u00d7 \u03b1), p \u2208 r \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t p.fst) \u2192 \u2200 {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2}, r.prod (\u03bb (p : \u03b3 \u00d7 \u03b1), f p) = s.prod (\u03bb (c : \u03b3), (t c).prod (\u03bb (a : \u03b1), f (c, a)))", "decl_nm": "finset.prod_finset_product", "nl_statement_of_codex": "Let $r, s, t$ be finite sets and let $f$ be a commutative monoid. Suppose that for each $p\\in r$ there is a unique $c\\in s$ and a unique $a\\in t(c)$ such that $p=(c,a)$. Then $\\prod_{p\\in r}f(p)=\\prod_{c\\in s}\\prod_{a\\in t(c)}f(c,a)$."}
{"formal_statement": "theorem differentiable_on_neg {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t(s : set \ud835\udd5c) :\n\tdifferentiable_on \ud835\udd5c has_neg.neg s", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] (s : set \ud835\udd5c), differentiable_on \ud835\udd5c has_neg.neg s", "decl_nm": "differentiable_on_neg", "nl_statement_of_codex": "The negation function is differentiable on any set."}
{"formal_statement": "theorem symmetric_join {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n\tsymmetric (relation.join r)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}, symmetric (relation.join r)", "decl_nm": "relation.symmetric_join", "nl_statement_of_codex": "The join of two symmetric relations is symmetric."}
{"formal_statement": "theorem map_prod {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [comm_monoid \u03b2]\n\t[comm_monoid \u03b3] (g : \u03b2 \u2243* \u03b3) (f : \u03b1 \u2192 \u03b2) (s : finset \u03b1) :\n\t\u21d1g (s.prod (\u03bb (x : \u03b1), f x)) = s.prod (\u03bb (x : \u03b1), \u21d1g (f x))", "decl_tp": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [_inst_1 : comm_monoid \u03b2] [_inst_2 : comm_monoid \u03b3] (g : \u03b2 \u2243* \u03b3) (f : \u03b1 \u2192 \u03b2) (s : finset \u03b1), \u21d1g (s.prod (\u03bb (x : \u03b1), f x)) = s.prod (\u03bb (x : \u03b1), \u21d1g (f x))", "decl_nm": "mul_equiv.map_prod", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be two functions. Then $g(f(x))=g\\circ f(x)$ for all $x\\in A$."}
{"formal_statement": "theorem iso_mk_inv_f {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t{X Y : category_theory.center C} (f : X \u27f6 Y) [category_theory.is_iso f.f] :\n\t(category_theory.center.iso_mk f).inv.f = category_theory.inv f.f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] {X Y : category_theory.center C} (f : X \u27f6 Y) [_inst_3 : category_theory.is_iso f.f], (category_theory.center.iso_mk f).inv.f = category_theory.inv f.f", "decl_nm": "category_theory.center.iso_mk_inv_f", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X$ and $Y$ be objects of the center of $C$. Let $f:X\\to Y$ be an isomorphism. Then the inverse of the isomorphism $f:X\\to Y$ in the center of $C$ is the inverse of $f$ in $C$."}
{"formal_statement": "theorem rec_on_one {p : \u2115+ \u2192 Sort u_1} (p1 : p 1) (hp : \u03a0 (n : \u2115+), p n \u2192 p (n + 1)) :\n\t1.rec_on p1 hp = p1", "decl_tp": "\u2200 {p : \u2115+ \u2192 Sort u_1} (p1 : p 1) (hp : \u03a0 (n : \u2115+), p n \u2192 p (n + 1)), 1.rec_on p1 hp = p1", "decl_nm": "pnat.rec_on_one", "nl_statement_of_codex": "The recursion on $1$ is the identity."}
{"formal_statement": "theorem abs_mul_cos_add_sin_mul_I (x : \u2102) :\n\t\u2191(complex.abs x) * (complex.cos \u2191(x.arg) + complex.sin \u2191(x.arg) * complex.I) = x", "decl_tp": "\u2200 (x : \u2102), \u2191(complex.abs x) * (complex.cos \u2191(x.arg) + complex.sin \u2191(x.arg) * complex.I) = x", "decl_nm": "complex.abs_mul_cos_add_sin_mul_I", "nl_statement_of_codex": "For any complex number $x$, we have $|x|(\\cos(\\arg(x))+i\\sin(\\arg(x)))=x$."}
{"formal_statement": "theorem prod_le_prod {\u03b9 : Type*} (f g : \u03b9 \u2192 cardinal) :\n\t(\u2200 (i : \u03b9), f i \u2264 g i) \u2192 cardinal.prod f \u2264 cardinal.prod g", "decl_tp": "\u2200 {\u03b9 : Type u_1} (f g : \u03b9 \u2192 cardinal), (\u2200 (i : \u03b9), f i \u2264 g i) \u2192 cardinal.prod f \u2264 cardinal.prod g", "decl_nm": "cardinal.prod_le_prod", "nl_statement_of_codex": "Let $f,g:\\mathcal{I}\\to\\mathrm{Card}$ be two functions. If $f(i)\\leq g(i)$ for all $i\\in\\mathcal{I}$, then $\\prod_{i\\in\\mathcal{I}}f(i)\\leq\\prod_{i\\in\\mathcal{I}}g(i)$."}
{"formal_statement": "theorem lift_unique {\u03b1 \u03b2 : Type*} {r : setoid \u03b1} {f : \u03b1 \u2192 \u03b2} (H : r \u2264 setoid.ker f)\n\t(g : quotient r \u2192 \u03b2) (Hg : f = g \u2218 quotient.mk) :\n\tquotient.lift f H = g", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : setoid \u03b1} {f : \u03b1 \u2192 \u03b2} (H : r \u2264 setoid.ker f) (g : quotient r \u2192 \u03b2), f = g \u2218 quotient.mk \u2192 quotient.lift f H = g", "decl_nm": "setoid.lift_unique", "nl_statement_of_codex": "Let $f:A\\to B$ be a function and let $r$ be an equivalence relation on $A$. If $f$ is constant on the equivalence classes of $r$, then the unique function $g:A/r\\to B$ such that $f=g\\circ q$ is $g=f\\circ q$."}
{"formal_statement": "theorem cast_min {\u03b1 : Type*} [linear_ordered_semiring \u03b1] {a b : \u2115} :\n\t\u2191(linear_order.min a b) = linear_order.min \u2191a \u2191b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_semiring \u03b1] {a b : \u2115}, \u2191(linear_order.min a b) = linear_order.min \u2191a \u2191b", "decl_nm": "nat.cast_min", "nl_statement_of_codex": "The minimum of two natural numbers is the same as the minimum of their casts to a linear ordered semiring."}
{"formal_statement": "theorem union_singleton {\u03b1 : Type u} {a : \u03b1} {s : set \u03b1} :\n\ts \u222a {a} = has_insert.insert a s", "decl_tp": "\u2200 {\u03b1 : Type u} {a : \u03b1} {s : set \u03b1}, s \u222a {a} = has_insert.insert a s", "decl_nm": "set.union_singleton", "nl_statement_of_codex": "For any set $S$ and any element $a$, $S\\cup\\{a\\}=S\\cup\\{a\\}$."}
{"formal_statement": "theorem map_closure {G : Type*} [group G] {N : Type*} [group N] (f : G \u2192* N)\n\t(s : set G) :\n\tsubgroup.map f (subgroup.closure s) = subgroup.closure (\u21d1f '' s)", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {N : Type u_3} [_inst_3 : group N] (f : G \u2192* N) (s : set G), subgroup.map f (subgroup.closure s) = subgroup.closure (\u21d1f '' s)", "decl_nm": "monoid_hom.map_closure", "nl_statement_of_codex": "Let $G$ and $N$ be groups and let $f:G\\to N$ be a homomorphism. Then $f(cl(S))=cl(f(S))$ for any subset $S$ of $G$."}
{"formal_statement": "theorem coe_refl {\u03b1 : Sort u} :\n\t\u21d1(equiv.refl \u03b1) = id", "decl_tp": "\u2200 {\u03b1 : Sort u}, \u21d1(equiv.refl \u03b1) = id", "decl_nm": "equiv.coe_refl", "nl_statement_of_codex": "The identity function on a set $A$ is the same as the identity function on $A$."}
{"formal_statement": "theorem eventually_Sup {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} {fs : set (filter \u03b1)} :\n\t(\u2200\u1da0 (x : \u03b1) in has_Sup.Sup fs, p x) \u2194 \u2200 (f : filter \u03b1), f \u2208 fs \u2192 (\u2200\u1da0 (x : \u03b1) in f, p x)", "decl_tp": "\u2200 {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} {fs : set (filter \u03b1)}, (\u2200\u1da0 (x : \u03b1) in has_Sup.Sup fs, p x) \u2194 \u2200 (f : filter \u03b1), f \u2208 fs \u2192 (\u2200\u1da0 (x : \u03b1) in f, p x)", "decl_nm": "filter.eventually_Sup", "nl_statement_of_codex": "Let $p$ be a property of elements of a set $X$. Then the following are equivalent:\n(1) $p$ holds for all elements of the supremum of a set of filters on $X$.\n(2) $p$ holds for all elements of each filter in the set."}
{"formal_statement": "theorem zero_le_real {x : \u211d} :\n\t0 \u2264 \u2191x \u2194 0 \u2264 x", "decl_tp": "\u2200 {x : \u211d}, 0 \u2264 \u2191x \u2194 0 \u2264 x", "decl_nm": "complex.zero_le_real", "nl_statement_of_codex": "The real number $x$ is nonnegative if and only if the corresponding element of the reals is nonnegative."}
{"formal_statement": "theorem app {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082} [category_theory.category D]\n\t{F G : C \u2964 D} (app' : \u03a0 (X : C), F.obj X \u2245 G.obj X) (naturality : \u2200 {X Y : C}\n\t(f : X \u27f6 Y), F.map f \u226b (app' Y).hom = (app' X).hom \u226b G.map f) (X : C) :\n\t(category_theory.nat_iso.of_components app' naturality).app X = app' X", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {F G : C \u2964 D} (app' : \u03a0 (X : C), F.obj X \u2245 G.obj X) (naturality : \u2200 {X Y : C} (f : X \u27f6 Y), F.map f \u226b (app' Y).hom = (app' X).hom \u226b G.map f) (X : C), (category_theory.nat_iso.of_components app' naturality).app X = app' X", "decl_nm": "category_theory.nat_iso.of_components.app", "nl_statement_of_codex": "Let $F,G:C\\to D$ be functors. Let $app':C\\to D$ be a natural isomorphism from $F$ to $G$. Then $app'$ is the same as the natural isomorphism from $F$ to $G$ given by the components of $app'$."}
{"formal_statement": "theorem pow_lmul_right {R A : Type*} [comm_semiring R] [semiring A] [algebra R A]\n\t(a : A) (n : \u2115) :\n\talgebra.lmul_right R a ^ n = algebra.lmul_right R (a ^ n)", "decl_tp": "\u2200 {R : Type u_1} {A : Type u_2} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] (a : A) (n : \u2115), algebra.lmul_right R a ^ n = algebra.lmul_right R (a ^ n)", "decl_nm": "algebra.pow_lmul_right", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ a semiring, and $R\\to A$ a ring homomorphism. Then for all $a\\in A$ and $n\\in\\mathbb{N}$, $(ra)^n=r^n a^n$."}
{"formal_statement": "theorem cech_conerve_equiv_symm_apply {C : Type u} [category_theory.category C]\n\t[\u2200 (n : \u2115) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (\u03bb (i : ulift (fin (n + 1))), f.right)\n\t(\u03bb (i : ulift (fin (n + 1))), f.hom)] (F : category_theory.arrow C) (X : category_theory.cosimplicial_object.augmented C)\n\t(G : F \u27f6 category_theory.cosimplicial_object.augmented.to_arrow.obj X) :\n\t\u21d1((category_theory.cosimplicial_object.cech_conerve_equiv F X).symm) G = category_theory.cosimplicial_object.equivalence_right_to_left F X G", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : \u2200 (n : \u2115) (f : category_theory.arrow C), category_theory.limits.has_wide_pushout f.left (\u03bb (i : ulift (fin (n + 1))), f.right) (\u03bb (i : ulift (fin (n + 1))), f.hom)] (F : category_theory.arrow C) (X : category_theory.cosimplicial_object.augmented C) (G : F \u27f6 category_theory.cosimplicial_object.augmented.to_arrow.obj X), \u21d1((category_theory.cosimplicial_object.cech_conerve_equiv F X).symm) G = category_theory.cosimplicial_object.equivalence_right_to_left F X G", "decl_nm": "category_theory.cosimplicial_object.cech_conerve_equiv_symm_apply", "nl_statement_of_codex": "Let $C$ be a category with pushouts. Let $F:C\\to C$ be a functor and let $X$ be a cosimplicial object in $C$. Then the right adjoint of the equivalence $F\\simeq X$ is the left adjoint of the equivalence $X\\simeq F$."}
{"formal_statement": "theorem coe_mk' {R : Type u} {A : Type v} {B : Type w} [comm_semiring R]\n\t[semiring A] [semiring B] [algebra R A] [algebra R B] (f : A \u2192+* B) (h : \u2200 (c : R)\n\t(x : A), \u21d1f (c \u2022 x) = c \u2022 \u21d1f x) :\n\t\u21d1(alg_hom.mk' f h) = \u21d1f", "decl_tp": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : semiring B] [_inst_6 : algebra R A] [_inst_7 : algebra R B] (f : A \u2192+* B) (h : \u2200 (c : R) (x : A), \u21d1f (c \u2022 x) = c \u2022 \u21d1f x), \u21d1(alg_hom.mk' f h) = \u21d1f", "decl_nm": "alg_hom.coe_mk'", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ and $B$ be semirings, and $f:A\\to B$ be an $R$-algebra homomorphism. Then the map $f$ is equal to the map $f'$ defined by $f'(cx)=cf(x)$ for all $c\\in R$ and $x\\in A$."}
{"formal_statement": "theorem has_fderiv_at_id {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] (x : E) :\n\thas_fderiv_at id (continuous_linear_map.id \ud835\udd5c E) x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] (x : E), has_fderiv_at id (continuous_linear_map.id \ud835\udd5c E) x", "decl_nm": "has_fderiv_at_id", "nl_statement_of_codex": "The identity function $f:E\\to E$ is differentiable at $x$ with derivative $f'(x)=\\mathrm{id}_E$."}
{"formal_statement": "theorem untrop_trop {R : Type u} (x : R) :\n\ttropical.untrop (tropical.trop x) = x", "decl_tp": "\u2200 {R : Type u} (x : R), tropical.untrop (tropical.trop x) = x", "decl_nm": "tropical.untrop_trop", "nl_statement_of_codex": "The tropicalization of a real number is the real number itself."}
{"formal_statement": "theorem second_countable_topology {\u03b1 : Type u} [t : topological_space \u03b1]\n\t{b : set (set \u03b1)} (hb : topological_space.is_topological_basis b) (hc : b.countable) :\n\ttopological_space.second_countable_topology \u03b1", "decl_tp": "\u2200 {\u03b1 : Type u} [t : topological_space \u03b1] {b : set (set \u03b1)}, topological_space.is_topological_basis b \u2192 b.countable \u2192 topological_space.second_countable_topology \u03b1", "decl_nm": "topological_space.is_topological_basis.second_countable_topology", "nl_statement_of_codex": "Let $X$ be a topological space. If $X$ has a countable basis, then $X$ is second countable."}
{"formal_statement": "theorem to_equiv_add_right {G : Type*} [measurable_space G] [add_group G]\n\t[has_measurable_add G] (g : G) :\n\t(measurable_equiv.add_right g).to_equiv = equiv.add_right g", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : measurable_space G] [_inst_4 : add_group G] [_inst_10 : has_measurable_add G] (g : G), (measurable_equiv.add_right g).to_equiv = equiv.add_right g", "decl_nm": "measurable_equiv.to_equiv_add_right", "nl_statement_of_codex": "The map $x\\mapsto x+g$ is a measurable function."}
{"formal_statement": "theorem lift_equiv_symm_apply_coe {V W V\u2081 : Type*} [semi_normed_group V]\n\t[semi_normed_group W] [semi_normed_group V\u2081] {f g : normed_group_hom V W}\n\t(\u03c8 : normed_group_hom V\u2081 \u21a5(f.equalizer g)) :\n\t\u2191(\u21d1(normed_group_hom.equalizer.lift_equiv.symm) \u03c8) = (normed_group_hom.equalizer.\u03b9 f g).comp \u03c8", "decl_tp": "\u2200 {V : Type u_1} {W : Type u_2} {V\u2081 : Type u_3} [_inst_1 : semi_normed_group V] [_inst_2 : semi_normed_group W] [_inst_3 : semi_normed_group V\u2081] {f g : normed_group_hom V W} (\u03c8 : normed_group_hom V\u2081 \u21a5(f.equalizer g)), \u2191(\u21d1(normed_group_hom.equalizer.lift_equiv.symm) \u03c8) = (normed_group_hom.equalizer.\u03b9 f g).comp \u03c8", "decl_nm": "normed_group_hom.equalizer.lift_equiv_symm_apply_coe", "nl_statement_of_codex": "Let $V, W, V_1$ be semi-normed groups and let $f, g:V\\to W$ be normed group homomorphisms. Let $\\psi:V_1\\to f(V)\\cap g(V)$ be a normed group homomorphism. Then $\\psi$ is equal to the composition of the inclusion map $f(V)\\cap g(V)\\to f(V)$ and the map $\\psi':V_1\\to f(V)$ given by $\\psi'(v)=f(v)$."}
{"formal_statement": "theorem exists_eq_mul {\u03b1 \ud835\udd5c : Type*1} [normed_field \ud835\udd5c] {c : \u211d} {l : filter \u03b1}\n\t{u v : \u03b1 \u2192 \ud835\udd5c} (h : asymptotics.is_O_with c u v l) (hc : 0 \u2264 c) :\n\t(\u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (h\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2225\u03c6 x\u2225 \u2264 c), u =\u1da0[l] \u03c6 * v)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\ud835\udd5c : Type u_11} [_inst_9 : normed_field \ud835\udd5c] {c : \u211d} {l : filter \u03b1} {u v : \u03b1 \u2192 \ud835\udd5c}, asymptotics.is_O_with c u v l \u2192 0 \u2264 c \u2192 (\u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (h\u03c6 : \u2200\u1da0 (x : \u03b1) in l, \u2225\u03c6 x\u2225 \u2264 c), u =\u1da0[l] \u03c6 * v)", "decl_nm": "asymptotics.is_O_with.exists_eq_mul", "nl_statement_of_codex": "Let $u,v:\\alpha\\to\\mathbb{C}$ be functions and let $c\\in\\mathbb{R}$. If $u$ is $O(v)$ with constant $c$, then there is a function $\\phi:\\alpha\\to\\mathbb{C}$ such that $\\|\\phi(x)\\|\\leq c$ for all $x\\in\\alpha$ and $u$ is asymptotically equal to $\\phi\\cdot v$."}
{"formal_statement": "theorem orelse_ret {\u03b1 : Type u} (c\u2081 : computation \u03b1) (a : \u03b1) :\n\t(c\u2081.think <|> computation.return a) = computation.return a", "decl_tp": "\u2200 {\u03b1 : Type u} (c\u2081 : computation \u03b1) (a : \u03b1), (c\u2081.think <|> computation.return a) = computation.return a", "decl_nm": "computation.orelse_ret", "nl_statement_of_codex": "If $c_1$ is a computation, then $(c_1.think \\vee computation.return a) = computation.return a$."}
{"formal_statement": "theorem degree_gcd_le_left {R : Type*} [comm_ring R] [is_domain R] [normalized_gcd_monoid R]\n\t{p : polynomial R} (hp : p \u2260 0) :\n\t\u2200 (q : polynomial R), (gcd_monoid.gcd p q).degree \u2264 p.degree", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : normalized_gcd_monoid R] {p : polynomial R}, p \u2260 0 \u2192 \u2200 (q : polynomial R), (gcd_monoid.gcd p q).degree \u2264 p.degree", "decl_nm": "polynomial.degree_gcd_le_left", "nl_statement_of_codex": "Let $R$ be a domain and let $p, q\\in R[x]$. Then $\\deg(\\gcd(p,q))\\leq \\deg(p)$."}
{"formal_statement": "theorem coe_min (x y : \u211d) :\n\t\u2191(linear_order.min x y) = linear_order.min \u2191x \u2191y", "decl_tp": "\u2200 (x y : \u211d), \u2191(linear_order.min x y) = linear_order.min \u2191x \u2191y", "decl_nm": "hyperreal.coe_min", "nl_statement_of_codex": "The minimum of two real numbers is the same as the minimum of their images under the canonical map from $\\mathbb{R}$ to $\\mathbb{Q}$."}
{"formal_statement": "theorem add_left_cancel {G : Type u} [add_left_cancel_semigroup G] {a b c : G} :\n\ta + b = a + c \u2192 b = c", "decl_tp": "\u2200 {G : Type u} [_inst_1 : add_left_cancel_semigroup G] {a b c : G}, a + b = a + c \u2192 b = c", "decl_nm": "add_left_cancel", "nl_statement_of_codex": "Let $G$ be a group with left cancellation. Then $a+b=a+c$ implies $b=c$."}
{"formal_statement": "theorem factors_eq_nil (n : \u2115) :\n\tn.factors = list.nil \u2194 n = 0 \u2228 n = 1", "decl_tp": "\u2200 (n : \u2115), n.factors = list.nil \u2194 n = 0 \u2228 n = 1", "decl_nm": "nat.factors_eq_nil", "nl_statement_of_codex": "The list of prime factors of $n$ is empty if and only if $n=0$ or $n=1$."}
{"formal_statement": "theorem neg {\u03b1 \u03b2 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[normed_group \u03b2] [measurable_space \u03b2] [borel_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : measure_theory.integrable f \u03bc) :\n\tmeasure_theory.integrable (-f) \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] [_inst_3 : measurable_space \u03b2] [_inst_6 : borel_space \u03b2] {f : \u03b1 \u2192 \u03b2}, measure_theory.integrable f \u03bc \u2192 measure_theory.integrable (-f) \u03bc", "decl_nm": "measure_theory.integrable.neg", "nl_statement_of_codex": "Let $f$ be an integrable function from a measurable space $(X,\\mathcal{A})$ to a normed group $G$. Then $-f$ is integrable."}
{"formal_statement": "theorem join_ret {\u03b1 : Type u} (s : wseq \u03b1) :\n\t(wseq.ret s).join ~ s", "decl_tp": "\u2200 {\u03b1 : Type u} (s : wseq \u03b1), (wseq.ret s).join ~ s", "decl_nm": "wseq.join_ret", "nl_statement_of_codex": "The join of the retraction of a weak sequence $s$ is $s$."}
{"formal_statement": "theorem lfp_le_fixed {\u03b1 : Type u} [complete_lattice \u03b1] (f : \u03b1 \u2192o \u03b1) {a : \u03b1}\n\t(h : \u21d1f a = a) :\n\t\u21d1order_hom.lfp f \u2264 a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : complete_lattice \u03b1] (f : \u03b1 \u2192o \u03b1) {a : \u03b1}, \u21d1f a = a \u2192 \u21d1order_hom.lfp f \u2264 a", "decl_nm": "order_hom.lfp_le_fixed", "nl_statement_of_codex": "Let $f$ be a monotone function on a complete lattice $L$. If $f(a)=a$, then the least fixed point of $f$ is less than or equal to $a$."}
{"formal_statement": "theorem inter_frequently_image_mem_ae_eq {\u03b1 : Type*} [measurable_space \u03b1]\n\t{f : \u03b1 \u2192 \u03b1} {s : set \u03b1} {\u03bc : measure_theory.measure \u03b1} (hf : measure_theory.conservative f \u03bc)\n\t(hs : measurable_set s) :\n\ts \u2229 {x : \u03b1 | \u2203\u1da0 (n : \u2115) in filter.at_top, f^[n] x \u2208 s} =\u1d50[\u03bc] s", "decl_tp": "\u2200 {\u03b1 : Type u_2} [_inst_1 : measurable_space \u03b1] {f : \u03b1 \u2192 \u03b1} {s : set \u03b1} {\u03bc : measure_theory.measure \u03b1}, measure_theory.conservative f \u03bc \u2192 measurable_set s \u2192 s \u2229 {x : \u03b1 | \u2203\u1da0 (n : \u2115) in filter.at_top, f^[n] x \u2208 s} =\u1d50[\u03bc] s", "decl_nm": "measure_theory.conservative.inter_frequently_image_mem_ae_eq", "nl_statement_of_codex": "Let $f:X\\to X$ be a conservative map on a measure space $(X,\\mathcal{A},\\mu)$. Then the set of points $x\\in X$ such that $f^n(x)\\in A$ for infinitely many $n$ is equal to $A$ up to a set of measure zero."}
{"formal_statement": "theorem direct_limit_diagram_obj {R : Type u} [ring R] {\u03b9 : Type v} [directed_order \u03b9]\n\t(G : \u03b9 \u2192 Type v) [\u03a0 (i : \u03b9), add_comm_group (G i)] [\u03a0 (i : \u03b9), module R (G i)]\n\t(f : \u03a0 (i j : \u03b9), i \u2264 j \u2192 (G i \u2192\u2097[R] G j)) [directed_system G (\u03bb (i j : \u03b9)\n\t(h : i \u2264 j), \u21d1(f i j h))] (i : \u03b9) :\n\t(Module.direct_limit_diagram G f).obj i = Module.of R (G i)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R] {\u03b9 : Type v} [_inst_3 : directed_order \u03b9] (G : \u03b9 \u2192 Type v) [_inst_4 : \u03a0 (i : \u03b9), add_comm_group (G i)] [_inst_5 : \u03a0 (i : \u03b9), module R (G i)] (f : \u03a0 (i j : \u03b9), i \u2264 j \u2192 (G i \u2192\u2097[R] G j)) [_inst_6 : directed_system G (\u03bb (i j : \u03b9) (h : i \u2264 j), \u21d1(f i j h))] (i : \u03b9), (Module.direct_limit_diagram G f).obj i = Module.of R (G i)", "decl_nm": "Module.direct_limit_diagram_obj", "nl_statement_of_codex": "Let $R$ be a ring, let $\\{G_i\\}_{i\\in I}$ be a directed system of $R$-modules, and let $f_{ij}:G_i\\to G_j$ be the transition maps. Then the direct limit of the system is the $R$-module $\\varinjlim_{i\\in I} G_i$."}
{"formal_statement": "theorem add {\u03b1 F E' : Type*} [has_norm F] [normed_group E'] {g : \u03b1 \u2192 F}\n\t{l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'} (h\u2081 : asymptotics.is_O f\u2081 g l) (h\u2082 : asymptotics.is_O f\u2082 g l) :\n\tasymptotics.is_O (\u03bb (x : \u03b1), f\u2081 x + f\u2082 x) g l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {g : \u03b1 \u2192 F} {l : filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 E'}, asymptotics.is_O f\u2081 g l \u2192 asymptotics.is_O f\u2082 g l \u2192 asymptotics.is_O (\u03bb (x : \u03b1), f\u2081 x + f\u2082 x) g l", "decl_nm": "asymptotics.is_O.add", "nl_statement_of_codex": "Let $F$ be a normed space, let $E'$ be a normed group, let $g:\\alpha\\to F$ be a function, let $l$ be a filter on $\\alpha$, and let $f_1, f_2:\\alpha\\to E'$ be functions. If $f_1$ and $f_2$ are $O(g)$ with respect to $l$, then $f_1+f_2$ is $O(g)$ with respect to $l$."}
{"formal_statement": "theorem mem_of_mem_even {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1) (_x : a \u2208 s.even) :\n\ta \u2208 s", "decl_tp": "\u2200 {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1), a \u2208 s.even \u2192 a \u2208 s", "decl_nm": "stream.mem_of_mem_even", "nl_statement_of_codex": "If $a$ is an even element of a stream $s$, then $a$ is an element of $s$."}
{"formal_statement": "theorem inv_le_one {a : ennreal} :\n\ta\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a", "decl_tp": "\u2200 {a : ennreal}, a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a", "decl_nm": "ennreal.inv_le_one", "nl_statement_of_codex": "For any extended non-negative real number $a$, $a^{-1}\\leq 1$ if and only if $1\\leq a$."}
{"formal_statement": "theorem transnum_aux_seq_zero (f : circle_deg1_lift) :\n\tf.transnum_aux_seq 0 = \u21d1f 0", "decl_tp": "\u2200 (f : circle_deg1_lift), f.transnum_aux_seq 0 = \u21d1f 0", "decl_nm": "circle_deg1_lift.transnum_aux_seq_zero", "nl_statement_of_codex": "Let $f$ be a circle degree 1 lift. Then the $0$th term of the sequence $f.transnum_aux_seq$ is $f(0)$."}
{"formal_statement": "theorem translate_left {\ud835\udd5c E \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [add_comm_monoid E]\n\t[ordered_add_comm_monoid \u03b2] [module \ud835\udd5c E] [has_scalar \ud835\udd5c \u03b2] {s : set E}\n\t{f : E \u2192 \u03b2} (hf : convex_on \ud835\udd5c s f) :\n\t\u2200 (c : E), convex_on \ud835\udd5c ((\u03bb (z : E), c + z) \u207b\u00b9' s) (f \u2218 \u03bb (z : E), z + c)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : ordered_add_comm_monoid \u03b2] [_inst_5 : module \ud835\udd5c E] [_inst_6 : has_scalar \ud835\udd5c \u03b2] {s : set E} {f : E \u2192 \u03b2}, convex_on \ud835\udd5c s f \u2192 \u2200 (c : E), convex_on \ud835\udd5c ((\u03bb (z : E), c + z) \u207b\u00b9' s) (f \u2218 \u03bb (z : E), z + c)", "decl_nm": "convex_on.translate_left", "nl_statement_of_codex": "Let $E$ be an ordered semiring, $E$ be an add commutative monoid, $\u03b2$ be an ordered add commutative monoid, $\ud835\udd5c$ be a module over $E$, and $\ud835\udd5c$ be a scalar over $\u03b2$. Let $s$ be a set and $f:E\\to \u03b2$. If $f$ is convex on $s$, then $f$ is convex on $c+s$ for all $c\\in E$."}
{"formal_statement": "theorem presheaf_iso_inv_app {C : Type*} [category_theory.category C] {D : Type*}\n\t[category_theory.category D] {K : category_theory.grothendieck_topology D}\n\t{G : C \u2964 D} (H : category_theory.cover_dense K G) [category_theory.full G]\n\t{\u2131 \u2131' : category_theory.SheafOfTypes K} (i : G.op \u22d9 \u2131.val \u2245 G.op \u22d9 \u2131'.val)\n\t(X : D\u1d52\u1d56) (\u1fb0 : \u2131'.val.obj X) :\n\t(category_theory.cover_dense.types.presheaf_iso H i).inv.app X \u1fb0 = category_theory.cover_dense.types.app_hom H i.inv (opposite.unop X) \u1fb0", "decl_tp": "\u2200 {C : Type u_1} [_inst_1 : category_theory.category C] {D : Type u_3} [_inst_2 : category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C \u2964 D} (H : category_theory.cover_dense K G) [_inst_5 : category_theory.full G] {\u2131 \u2131' : category_theory.SheafOfTypes K} (i : G.op \u22d9 \u2131.val \u2245 G.op \u22d9 \u2131'.val) (X : D\u1d52\u1d56) (\u1fb0 : \u2131'.val.obj X), (category_theory.cover_dense.types.presheaf_iso H i).inv.app X \u1fb0 = category_theory.cover_dense.types.app_hom H i.inv (opposite.unop X) \u1fb0", "decl_nm": "category_theory.cover_dense.types.presheaf_iso_inv_app", "nl_statement_of_codex": "Let $C$ and $D$ be categories, let $K$ be a Grothendieck topology on $D$, let $G:C\\to D$ be a functor, and let $H$ be a cover dense functor. Let $\\mathcal{F}$ and $\\mathcal{F}'$ be sheaves on $K$, and let $i:\\mathcal{F}\\to\\mathcal{F}'$ be an isomorphism. Then the inverse of the induced isomorphism $G^{\\mathrm{op}}\\circ\\mathcal{F}\\to G^{\\mathrm{op}}\\circ\\mathcal{F}'$ is"}
{"formal_statement": "theorem unique_mdiff_within_at {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {s : set E} {x : E} :\n\tunique_diff_within_at \ud835\udd5c s x \u2192 unique_mdiff_within_at (model_with_corners_self \ud835\udd5c E) s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {s : set E} {x : E}, unique_diff_within_at \ud835\udd5c s x \u2192 unique_mdiff_within_at (model_with_corners_self \ud835\udd5c E) s x", "decl_nm": "unique_diff_within_at.unique_mdiff_within_at", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$. If $f:E\\to K$ is differentiable at $x\\in E$ and $f$ has a unique derivative at $x$, then $f$ is differentiable at $x$ and $f$ has a unique derivative at $x$."}
{"formal_statement": "theorem image_open_of_open' {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t(e : local_homeomorph \u03b1 \u03b2) {s : set \u03b1} (hs : is_open s) :\n\tis_open (\u21d1e '' (e.to_local_equiv.source \u2229 s))", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (e : local_homeomorph \u03b1 \u03b2) {s : set \u03b1}, is_open s \u2192 is_open (\u21d1e '' (e.to_local_equiv.source \u2229 s))", "decl_nm": "local_homeomorph.image_open_of_open'", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. If $s$ is open in $X$, then $e(s)$ is open in $Y$."}
{"formal_statement": "theorem point_reflection_fixed_iff_of_module (k : Type*) {P\u2081 V\u2081 : Type*}\n\t[ring k] [add_comm_group V\u2081] [module k V\u2081] [add_torsor V\u2081 P\u2081] [invertible 2]\n\t{x y : P\u2081} :\n\t\u21d1(affine_equiv.point_reflection k x) y = y \u2194 y = x", "decl_tp": "\u2200 (k : Type u_1) {P\u2081 : Type u_2} {V\u2081 : Type u_6} [_inst_1 : ring k] [_inst_2 : add_comm_group V\u2081] [_inst_3 : module k V\u2081] [_inst_4 : add_torsor V\u2081 P\u2081] [_inst_14 : invertible 2] {x y : P\u2081}, \u21d1(affine_equiv.point_reflection k x) y = y \u2194 y = x", "decl_nm": "affine_equiv.point_reflection_fixed_iff_of_module", "nl_statement_of_codex": "Let $k$ be a ring, $V$ a $k$-module, and $P$ an affine space over $V$. Let $x\\in P$. Then the point reflection $y\\mapsto 2x-y$ fixes $y$ if and only if $y=x$."}
{"formal_statement": "theorem mul_left {\u03b1 \u03b2 : Type*} [semiring \u03b1] [topological_space \u03b1] [topological_ring \u03b1]\n\t{f : \u03b2 \u2192 \u03b1} (a : \u03b1) (hf : summable f) :\n\tsummable (\u03bb (b : \u03b2), a * f b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semiring \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : topological_ring \u03b1] {f : \u03b2 \u2192 \u03b1} (a : \u03b1), summable f \u2192 summable (\u03bb (b : \u03b2), a * f b)", "decl_nm": "summable.mul_left", "nl_statement_of_codex": "Let $f:B\\to A$ be a summable function. Then the function $g:B\\to A$ defined by $g(b)=a\\cdot f(b)$ is also summable."}
{"formal_statement": "theorem sheaf_iso_inv_val {C : Type*} [category_theory.category C] {D : Type*}\n\t[category_theory.category D] {K : category_theory.grothendieck_topology D}\n\t{A : Type*} [category_theory.category A] {G : C \u2964 D} (H : category_theory.cover_dense K G)\n\t[category_theory.full G] {\u2131 \u2131' : category_theory.Sheaf K A} (i : G.op \u22d9 \u2131.val \u2245 G.op \u22d9 \u2131'.val) :\n\t(H.sheaf_iso i).inv.val = (H.presheaf_iso i).inv", "decl_tp": "\u2200 {C : Type u_1} [_inst_1 : category_theory.category C] {D : Type u_3} [_inst_2 : category_theory.category D] {K : category_theory.grothendieck_topology D} {A : Type u_7} [_inst_4 : category_theory.category A] {G : C \u2964 D} (H : category_theory.cover_dense K G) [_inst_5 : category_theory.full G] {\u2131 \u2131' : category_theory.Sheaf K A} (i : G.op \u22d9 \u2131.val \u2245 G.op \u22d9 \u2131'.val), (H.sheaf_iso i).inv.val = (H.presheaf_iso i).inv", "decl_nm": "category_theory.cover_dense.sheaf_iso_inv_val", "nl_statement_of_codex": "Let $C, D, A$ be categories, $K$ a Grothendieck topology on $D$, $G:C\\to D$ a functor, $H$ a cover dense functor,\n$\\mathcal{F}, \\mathcal{F}'$ sheaves on $K$, and $i:\\mathcal{F}\\to \\mathcal{F}'$ an isomorphism. Then the inverse of the\nsheaf isomorphism induced by $i$ is the inverse of the presheaf isomorphism induced by $i$."}
{"formal_statement": "theorem lookup_kinsert_ne {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [decidable_eq \u03b1]\n\t{a a' : \u03b1} {b' : \u03b2 a'} {l : list (sigma \u03b2)} (h : a \u2260 a') :\n\tlist.lookup a (list.kinsert a' b' l) = list.lookup a l", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] {a a' : \u03b1} {b' : \u03b2 a'} {l : list (sigma \u03b2)}, a \u2260 a' \u2192 list.lookup a (list.kinsert a' b' l) = list.lookup a l", "decl_nm": "list.lookup_kinsert_ne", "nl_statement_of_codex": "Let $a,a'$ be elements of a type $\u03b1$ with decidable equality. Let $b'$ be an element of $\u03b2(a')$. Let $l$ be a list of elements of the type $\\sigma \u03b2$. If $a\\neq a'$, then the $a$-th element of the list $l$ with $a'$-th element $b'$ is the same as the $a$-th element of $l$."}
{"formal_statement": "theorem pre_\u03c0 {J : Type u\u2081} [category_theory.category J] {K : Type u\u2082}\n\t[category_theory.category K] {C : Type u} [category_theory.category C]\n\t(F : J \u2964 C) [category_theory.limits.has_limit F] (E : K \u2964 J) [category_theory.limits.has_limit (E \u22d9 F)]\n\t(k : K) :\n\tcategory_theory.limits.limit.pre F E \u226b category_theory.limits.limit.\u03c0 (E \u22d9 F) k = category_theory.limits.limit.\u03c0 F (E.obj k)", "decl_tp": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {K : Type u\u2082} [_inst_2 : category_theory.category K] {C : Type u} [_inst_3 : category_theory.category C] (F : J \u2964 C) [_inst_4 : category_theory.limits.has_limit F] (E : K \u2964 J) [_inst_5 : category_theory.limits.has_limit (E \u22d9 F)] (k : K), category_theory.limits.limit.pre F E \u226b category_theory.limits.limit.\u03c0 (E \u22d9 F) k = category_theory.limits.limit.\u03c0 F (E.obj k)", "decl_nm": "category_theory.limits.limit.pre_\u03c0", "nl_statement_of_codex": "Let $F:J\\to C$ and $E:K\\to J$ be functors. If $F$ has a limit and $E\\circ F$ has a limit, then the pre-limit of $F$ is the limit of $E\\circ F$."}
{"formal_statement": "theorem mul_lt_mul_of_pos_left {\u03b1 : Type u} [ordered_semiring \u03b1] {a b c : \u03b1}\n\t(h\u2081 : a < b) (h\u2082 : 0 < c) :\n\tc * a < c * b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : ordered_semiring \u03b1] {a b c : \u03b1}, a < b \u2192 0 < c \u2192 c * a < c * b", "decl_nm": "mul_lt_mul_of_pos_left", "nl_statement_of_codex": "Let $R$ be an ordered semiring. If $a<b$ and $c>0$, then $ca<cb$."}
{"formal_statement": "theorem snorm_congr_ae {\u03b1 F : Type*} {m0 : measurable_space \u03b1} {p : ennreal}\n\t{\u03bc : measure_theory.measure \u03b1} [normed_group F] {f g : \u03b1 \u2192 F} (hfg : f =\u1d50[\u03bc] g) :\n\tmeasure_theory.snorm f p \u03bc = measure_theory.snorm g p \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {F : Type u_3} {m0 : measurable_space \u03b1} {p : ennreal} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : normed_group F] {f g : \u03b1 \u2192 F}, f =\u1d50[\u03bc] g \u2192 measure_theory.snorm f p \u03bc = measure_theory.snorm g p \u03bc", "decl_nm": "measure_theory.snorm_congr_ae", "nl_statement_of_codex": "Let $f,g:\\alpha\\to F$ be measurable functions. If $f$ and $g$ are equal almost everywhere, then $\\|f\\|_p=\\|g\\|_p$."}
{"formal_statement": "theorem kronecker_map_add_left {\u03b1 \u03b2 \u03b3 l m n : Type*0} {p : Type*1} [has_add \u03b1]\n\t[has_add \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n\t(\u2200 (a\u2081 a\u2082 : \u03b1) (b : \u03b2), f (a\u2081 + a\u2082) b = f a\u2081 b + f a\u2082 b) \u2192 \u2200 (A\u2081 A\u2082 : matrix l m \u03b1)\n\t(B : matrix n p \u03b2), matrix.kronecker_map f (A\u2081 + A\u2082) B = matrix.kronecker_map f A\u2081 B + matrix.kronecker_map f A\u2082 B", "decl_tp": "\u2200 {\u03b1 : Type u_2} {\u03b2 : Type u_4} {\u03b3 : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11} [_inst_1 : has_add \u03b1] [_inst_2 : has_add \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3), (\u2200 (a\u2081 a\u2082 : \u03b1) (b : \u03b2), f (a\u2081 + a\u2082) b = f a\u2081 b + f a\u2082 b) \u2192 \u2200 (A\u2081 A\u2082 : matrix l m \u03b1) (B : matrix n p \u03b2), matrix.kronecker_map f (A\u2081 + A\u2082) B = matrix.kronecker_map f A\u2081 B + matrix.kronecker_map f A\u2082 B", "decl_nm": "matrix.kronecker_map_add_left", "nl_statement_of_codex": "Let $f:A\\times B\\to C$ be a function. If $f$ is additive in the first variable, then the Kronecker product $f\\otimes g$ is additive in the first variable."}
{"formal_statement": "theorem inf_mem_iff {P : Type*} [semilattice_inf P] {x y : P} {F : order.pfilter P} :\n\tx \u2293 y \u2208 F \u2194 x \u2208 F \u2227 y \u2208 F", "decl_tp": "\u2200 {P : Type u_1} [_inst_1 : semilattice_inf P] {x y : P} {F : order.pfilter P}, x \u2293 y \u2208 F \u2194 x \u2208 F \u2227 y \u2208 F", "decl_nm": "order.pfilter.inf_mem_iff", "nl_statement_of_codex": "Let $P$ be a semilattice with infimum. Then $x\\wedge y\\in F$ if and only if $x\\in F$ and $y\\in F$."}
{"formal_statement": "theorem smul_mem_iff {S : Type u'} {R : Type u} {M : Type v} [division_ring S]\n\t[semiring R] [mul_action R M] [has_scalar S R] [mul_action S M] [is_scalar_tower S R M]\n\t(p : sub_mul_action R M) {s : S} {x : M} (s0 : s \u2260 0) :\n\t(s \u2022 x \u2208 p \u2194 x \u2208 p)", "decl_tp": "\u2200 {S : Type u'} {R : Type u} {M : Type v} [_inst_1 : division_ring S] [_inst_2 : semiring R] [_inst_3 : mul_action R M] [_inst_4 : has_scalar S R] [_inst_5 : mul_action S M] [_inst_6 : is_scalar_tower S R M] (p : sub_mul_action R M) {s : S} {x : M}, s \u2260 0 \u2192 (s \u2022 x \u2208 p \u2194 x \u2208 p)", "decl_nm": "sub_mul_action.smul_mem_iff", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ an $R$-module, $S$ a division ring, and $p$ a submodule of $M$. Then $s\\cdot x\\in p$ if and only if $x\\in p$ for all $s\\in S$ and $x\\in M$."}
{"formal_statement": "theorem Inf_insert {\u03b1 : Type*} [complete_lattice \u03b1] {a : \u03b1} {s : set \u03b1} :\n\thas_Inf.Inf (has_insert.insert a s) = a \u2293 has_Inf.Inf s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : complete_lattice \u03b1] {a : \u03b1} {s : set \u03b1}, has_Inf.Inf (has_insert.insert a s) = a \u2293 has_Inf.Inf s", "decl_nm": "Inf_insert", "nl_statement_of_codex": "Let $X$ be a complete lattice and let $a\\in X$. Then $\\inf(a\\cup S)=a\\wedge\\inf S$."}
{"formal_statement": "theorem Ioo_union_Ioi {\u03b1 : Type u} [linear_order \u03b1] {a b c : \u03b1} (h : c < linear_order.max a b) :\n\tset.Ioo a b \u222a set.Ioi c = set.Ioi (linear_order.min a c)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, c < linear_order.max a b \u2192 set.Ioo a b \u222a set.Ioi c = set.Ioi (linear_order.min a c)", "decl_nm": "set.Ioo_union_Ioi", "nl_statement_of_codex": "Let $a,b,c$ be real numbers such that $c<\\max\\{a,b\\}$. Then $\\{x\\in\\mathbb{R}\\mid a<x<b\\}\\cup\\{x\\in\\mathbb{R}\\mid x>c\\}=\\{x\\in\\mathbb{R}\\mid \\min\\{a,c\\}<x\\}$."}
{"formal_statement": "theorem sub {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {H : Type*} [topological_space H]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {I : model_with_corners \ud835\udd5c E H}\n\t{G : Type*} [topological_space G] [charted_space H G] [add_group G] [lie_add_group I G]\n\t{E' : Type*} [normed_group E'] [normed_space \ud835\udd5c E'] {H' : Type*} [topological_space H']\n\t{I' : model_with_corners \ud835\udd5c E' H'} {M : Type*} [topological_space M] [charted_space H' M]\n\t{f g : M \u2192 G} (hf : smooth I' I f) (hg : smooth I' I g) :\n\tsmooth I' I (f - g)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {H : Type u_2} [_inst_2 : topological_space H] {E : Type u_3} [_inst_3 : normed_group E] [_inst_4 : normed_space \ud835\udd5c E] {I : model_with_corners \ud835\udd5c E H} {G : Type u_5} [_inst_7 : topological_space G] [_inst_8 : charted_space H G] [_inst_9 : add_group G] [_inst_10 : lie_add_group I G] {E' : Type u_6} [_inst_11 : normed_group E'] [_inst_12 : normed_space \ud835\udd5c E'] {H' : Type u_7} [_inst_13 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M : Type u_8} [_inst_14 : topological_space M] [_inst_15 : charted_space H' M] {f g : M \u2192 G}, smooth I' I f \u2192 smooth I' I g \u2192 smooth I' I (f - g)", "decl_nm": "smooth.sub", "nl_statement_of_codex": "Let $I$ and $I'$ be models with corners, $G$ and $M$ be smooth manifolds, and $f,g:M\\to G$ be smooth maps. Then $f-g:M\\to G$ is smooth."}
{"formal_statement": "theorem coe_strict_mono {A B : Type*} [i : set_like A B] :\n\tstrict_mono coe", "decl_tp": "\u2200 {A : Type u_1} {B : Type u_2} [i : set_like A B], strict_mono coe", "decl_nm": "set_like.coe_strict_mono", "nl_statement_of_codex": "The function $f:A\\to B$ is a strict injection."}
{"formal_statement": "theorem compl_univ {\u03b1 : Type u} :\n\tset.univ\u1d9c = \u2205", "decl_tp": "\u2200 {\u03b1 : Type u}, set.univ\u1d9c = \u2205", "decl_nm": "set.compl_univ", "nl_statement_of_codex": "The complement of the universal set is the empty set."}
{"formal_statement": "theorem coe_mk {X Y : UniformSpace} (f : \u21a5X \u2192 \u21a5Y) (hf : uniform_continuous f) :\n\t\u21d1\u27e8f, hf\u27e9 = f", "decl_tp": "\u2200 {X Y : UniformSpace} (f : \u21a5X \u2192 \u21a5Y) (hf : uniform_continuous f), \u21d1\u27e8f, hf\u27e9 = f", "decl_nm": "UniformSpace.coe_mk", "nl_statement_of_codex": "Let $X$ and $Y$ be uniform spaces and let $f:X\\to Y$. Then the function $f$ is equal to the function $\u21d1\u27e8f, hf\u27e9$."}
{"formal_statement": "theorem coe_le_coe {\u03b1 : Type u} [partial_order \u03b1] {a b : \u03b1} :\n\t\u2191a \u2264 \u2191b \u2194 a \u2264 b", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] {a b : \u03b1}, \u2191a \u2264 \u2191b \u2194 a \u2264 b", "decl_nm": "with_zero.coe_le_coe", "nl_statement_of_codex": "Let $\u03b1$ be a partially ordered set. Then $a\\leq b$ if and only if $\u2191a\\leq \u2191b$."}
{"formal_statement": "theorem quot_add {R : Type v} [ring R] {J : Type v} [category_theory.small_category J]\n\t(F : J \u2964 Module R) (x y : Module.colimits.prequotient F) :\n\tquot.mk setoid.r (x.add y) = quot.mk setoid.r x + quot.mk setoid.r y", "decl_tp": "\u2200 {R : Type v} [_inst_1 : ring R] {J : Type v} [_inst_2 : category_theory.small_category J] (F : J \u2964 Module R) (x y : Module.colimits.prequotient F), quot.mk setoid.r (x.add y) = quot.mk setoid.r x + quot.mk setoid.r y", "decl_nm": "Module.colimits.quot_add", "nl_statement_of_codex": "Let $R$ be a ring and let $F:J\\to R$ be a functor. Then the quotient of the colimit of $F$ is an $R$-module."}
{"formal_statement": "theorem of_dual_min_eq_max_of_dual {\u03b1 : Type*} [linear_order \u03b1] {a b : \u03b1} :\n\t\u21d1order_dual.of_dual (linear_order.min a b) = linear_order.max (\u21d1order_dual.of_dual a)\n\t(\u21d1order_dual.of_dual b)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_order \u03b1] {a b : \u03b1}, \u21d1order_dual.of_dual (linear_order.min a b) = linear_order.max (\u21d1order_dual.of_dual a) (\u21d1order_dual.of_dual b)", "decl_nm": "finset.of_dual_min_eq_max_of_dual", "nl_statement_of_codex": "Let $a,b$ be elements of a linear order $L$. Then the dual of the minimum of $a$ and $b$ is the maximum of the duals of $a$ and $b$."}
{"formal_statement": "theorem bit1_im (z : \u2102) :\n\t(bit1 z).im = bit0 z.im", "decl_tp": "\u2200 (z : \u2102), (bit1 z).im = bit0 z.im", "decl_nm": "complex.bit1_im", "nl_statement_of_codex": "The imaginary part of $2z$ is twice the imaginary part of $z$."}
{"formal_statement": "theorem strict_convex_Ioc {\ud835\udd5c \u03b2 : Type*} [ordered_semiring \ud835\udd5c] [topological_space \u03b2]\n\t[linear_ordered_cancel_add_comm_monoid \u03b2] [order_topology \u03b2] [module \ud835\udd5c \u03b2]\n\t[ordered_smul \ud835\udd5c \u03b2] (r s : \u03b2) :\n\tstrict_convex \ud835\udd5c (set.Ioc r s)", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_8 : topological_space \u03b2] [_inst_9 : linear_ordered_cancel_add_comm_monoid \u03b2] [_inst_10 : order_topology \u03b2] [_inst_11 : module \ud835\udd5c \u03b2] [_inst_12 : ordered_smul \ud835\udd5c \u03b2] (r s : \u03b2), strict_convex \ud835\udd5c (set.Ioc r s)", "decl_nm": "strict_convex_Ioc", "nl_statement_of_codex": "The set $\\{x\\in\\mathbb{R}^n:r<x<s\\}$ is strictly convex."}
{"formal_statement": "theorem move_left_le {x : pgame} (o : x.numeric) :\n\t\u2200 (i : x.left_moves), x.move_left i \u2264 x", "decl_tp": "\u2200 {x : pgame}, x.numeric \u2192 \u2200 (i : x.left_moves), x.move_left i \u2264 x", "decl_nm": "pgame.numeric.move_left_le", "nl_statement_of_codex": "Let $x$ be a position in the game Nim. Then for each move $i$ of the left player, the position $x.move_left i$ is dominated by $x$."}
{"formal_statement": "theorem max_bot_right {\u03b1 : Type u} [linear_order \u03b1] [order_bot \u03b1] (a : \u03b1) :\n\tlinear_order.max a \u22a5 = a", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] [_inst_2 : order_bot \u03b1] (a : \u03b1), linear_order.max a \u22a5 = a", "decl_nm": "max_bot_right", "nl_statement_of_codex": "For any linear order $\u03b1$ with a bottom element, $\\max(a,\\bot)=a$."}
{"formal_statement": "theorem attach_map_val {\u03b1 : Type*} (s : multiset \u03b1) :\n\tmultiset.map subtype.val s.attach = s", "decl_tp": "\u2200 {\u03b1 : Type u_1} (s : multiset \u03b1), multiset.map subtype.val s.attach = s", "decl_nm": "multiset.attach_map_val", "nl_statement_of_codex": "The map $s\\mapsto s.attach$ is a bijection between multisets of $\u03b1$ and multisets of $\u03b1$ with multiplicity."}
{"formal_statement": "theorem comap {R \u0393\u2080 \u0393'\u2080 : Type*} [ring R] [linear_ordered_comm_monoid_with_zero \u0393\u2080]\n\t[linear_ordered_comm_monoid_with_zero \u0393'\u2080] {v\u2081 : valuation R \u0393\u2080} {v\u2082 : valuation R \u0393'\u2080}\n\t{S : Type*} [ring S] (f : S \u2192+* R) (h : v\u2081.is_equiv v\u2082) :\n\t(valuation.comap f v\u2081).is_equiv (valuation.comap f v\u2082)", "decl_tp": "\u2200 {R : Type u_1} {\u0393\u2080 : Type u_2} {\u0393'\u2080 : Type u_3} [_inst_2 : ring R] [_inst_3 : linear_ordered_comm_monoid_with_zero \u0393\u2080] [_inst_4 : linear_ordered_comm_monoid_with_zero \u0393'\u2080] {v\u2081 : valuation R \u0393\u2080} {v\u2082 : valuation R \u0393'\u2080} {S : Type u_4} [_inst_5 : ring S] (f : S \u2192+* R), v\u2081.is_equiv v\u2082 \u2192 (valuation.comap f v\u2081).is_equiv (valuation.comap f v\u2082)", "decl_nm": "valuation.is_equiv.comap", "nl_statement_of_codex": "Let $R$ be a ring, let $\\Gamma_0$ and $\\Gamma_0'$ be linearly ordered commutative monoids with zero, let $v_1$ and $v_2$ be valuations on $R$ with values in $\\Gamma_0$ and $\\Gamma_0'$, respectively. Let $S$ be a ring and let $f:S\\to R$ be a ring homomorphism. If $v_1$ and $v_2$ are equivalent, then the valuations $v_1\\circ f$ and $v_2\\circ f$ are equivalent."}
{"formal_statement": "theorem comp_hom'_apply_apply {M : Type uM} {N : Type uN} {P : Type uP}\n\t[add_zero_class M] [add_zero_class N] [add_comm_monoid P] (f : M \u2192+ N)\n\t(y : N \u2192+ P) (x : M) :\n\t\u21d1(\u21d1(f.comp_hom') y) x = \u21d1y (\u21d1f x)", "decl_tp": "\u2200 {M : Type uM} {N : Type uN} {P : Type uP} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] [_inst_3 : add_comm_monoid P] (f : M \u2192+ N) (y : N \u2192+ P) (x : M), \u21d1(\u21d1(f.comp_hom') y) x = \u21d1y (\u21d1f x)", "decl_nm": "add_monoid_hom.comp_hom'_apply_apply", "nl_statement_of_codex": "Let $M, N, P$ be abelian groups and let $f:M\\to N$ and $y:N\\to P$ be group homomorphisms. Then $(y\\circ f)(x)=y(f(x))$."}
{"formal_statement": "theorem eqv_gen_mono {\u03b1 : Type*} {r s : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n\t(\u2200 (x y : \u03b1), r x y \u2192 s x y) \u2192 eqv_gen.setoid r \u2264 eqv_gen.setoid s", "decl_tp": "\u2200 {\u03b1 : Type u_1} {r s : \u03b1 \u2192 \u03b1 \u2192 Prop}, (\u2200 (x y : \u03b1), r x y \u2192 s x y) \u2192 eqv_gen.setoid r \u2264 eqv_gen.setoid s", "decl_nm": "setoid.eqv_gen_mono", "nl_statement_of_codex": "Let $r$ and $s$ be relations on a set $X$. If $r$ is a subset of $s$, then the equivalence relation generated by $r$ is a subset of the equivalence relation generated by $s$."}
{"formal_statement": "theorem val_add {v : \u2115 \u2192 \u2124} {is js : list \u2124} :\n\tomega.coeffs.val v (list.func.add is js) = omega.coeffs.val v is + omega.coeffs.val v js", "decl_tp": "\u2200 {v : \u2115 \u2192 \u2124} {is js : list \u2124}, omega.coeffs.val v (list.func.add is js) = omega.coeffs.val v is + omega.coeffs.val v js", "decl_nm": "omega.coeffs.val_add", "nl_statement_of_codex": "Let $v$ be a function from $\\mathbb{N}$ to $\\mathbb{Z}$. Let $i$ and $j$ be lists of integers. Then the value of $v$ on the list $i+j$ is the sum of the values of $v$ on $i$ and $j$."}
{"formal_statement": "theorem sub_mem {R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M}\n\t(p : submodule R M) {x y : M} :\n\tx \u2208 p \u2192 y \u2208 p \u2192 x - y \u2208 p", "decl_tp": "\u2200 {R : Type u} {M : Type v} [_inst_1 : ring R] [_inst_2 : add_comm_group M] {module_M : module R M} (p : submodule R M) {x y : M}, x \u2208 p \u2192 y \u2208 p \u2192 x - y \u2208 p", "decl_nm": "submodule.sub_mem", "nl_statement_of_codex": "Let $R$ be a ring and $M$ be an $R$-module. Let $p$ be a submodule of $M$. Then $x-y\\in p$ if $x,y\\in p$."}
{"formal_statement": "theorem lhom_ext {\u03b1 M N R : Type*} [semiring R] [add_comm_monoid M] [module R M]\n\t[add_comm_monoid N] [module R N] \u2983\u03c6 \u03c8 : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] N\u2984 :\n\t(\u2200 (a : \u03b1) (b : M), \u21d1\u03c6 (finsupp.single a b) = \u21d1\u03c8 (finsupp.single a b)) \u2192 \u03c6 = \u03c8", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_2} {N : Type u_3} {R : Type u_5} [_inst_1 : semiring R] [_inst_3 : add_comm_monoid M] [_inst_4 : module R M] [_inst_5 : add_comm_monoid N] [_inst_6 : module R N] \u2983\u03c6 \u03c8 : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] N\u2984, (\u2200 (a : \u03b1) (b : M), \u21d1\u03c6 (finsupp.single a b) = \u21d1\u03c8 (finsupp.single a b)) \u2192 \u03c6 = \u03c8", "decl_nm": "finsupp.lhom_ext", "nl_statement_of_codex": "Let $R$ be a semiring, $M$ and $N$ be $R$-modules. Let $\\phi, \\psi:M\\to N$ be $R$-linear maps. Then $\\phi=\\psi$ if and only if $\\phi(a)=\\psi(a)$ for all $a\\in M$."}
{"formal_statement": "theorem add_const {\u03b1 \u03b2 : Type*} [has_add \u03b1] [preorder \u03b1] [preorder \u03b2] {f : \u03b2 \u2192 \u03b1}\n\t[covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt] (hf : strict_mono f) :\n\t\u2200 (c : \u03b1), strict_mono (\u03bb (x : \u03b2), f x + c)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_add \u03b1] [_inst_2 : preorder \u03b1] [_inst_3 : preorder \u03b2] {f : \u03b2 \u2192 \u03b1} [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_lt.lt], strict_mono f \u2192 \u2200 (c : \u03b1), strict_mono (\u03bb (x : \u03b2), f x + c)", "decl_nm": "strict_mono.add_const", "nl_statement_of_codex": "Let $f:X\\to Y$ be a strictly monotone function. Then $f+c:X\\to Y$ is strictly monotone for any constant $c\\in Y$."}
{"formal_statement": "theorem is_closed_Iic {\u03b1 : Type u} [topological_space \u03b1] [preorder \u03b1] [t : order_closed_topology \u03b1]\n\t{a : \u03b1} :\n\tis_closed (set.Iic a)", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b1] [t : order_closed_topology \u03b1] {a : \u03b1}, is_closed (set.Iic a)", "decl_nm": "is_closed_Iic", "nl_statement_of_codex": "Let $X$ be a topological space and let $a\\in X$. Then the set $\\{x\\in X:x\\leq a\\}$ is closed in $X$."}
{"formal_statement": "theorem code_supp'_self (c : turing.to_partrec.code) (k : turing.partrec_to_TM2.cont') :\n\tturing.partrec_to_TM2.tr_stmts\u2081 (turing.partrec_to_TM2.tr_normal c k) \u2286 turing.partrec_to_TM2.code_supp' c k", "decl_tp": "\u2200 (c : turing.to_partrec.code) (k : turing.partrec_to_TM2.cont'), turing.partrec_to_TM2.tr_stmts\u2081 (turing.partrec_to_TM2.tr_normal c k) \u2286 turing.partrec_to_TM2.code_supp' c k", "decl_nm": "turing.partrec_to_TM2.code_supp'_self", "nl_statement_of_codex": "Let $c$ be a code and $k$ be a continuation. Then the set of statements in the translation of the normal form of $c$ with continuation $k$ is a subset of the code support of $c$ with continuation $k$."}
{"formal_statement": "theorem subset_convex_hull (\ud835\udd5c : Type*) {E : Type*} [ordered_semiring \ud835\udd5c]\n\t[add_comm_monoid E] [module \ud835\udd5c E] (s : set E) :\n\ts \u2286 \u21d1(convex_hull \ud835\udd5c) s", "decl_tp": "\u2200 (\ud835\udd5c : Type u_1) {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : module \ud835\udd5c E] (s : set E), s \u2286 \u21d1(convex_hull \ud835\udd5c) s", "decl_nm": "subset_convex_hull", "nl_statement_of_codex": "Let $E$ be a vector space over a field $K$ and let $s$ be a subset of $E$. Then $s$ is contained in the convex hull of $s$."}
{"formal_statement": "theorem single_apply {I : Type u} (f : I \u2192 Type v) [decidable_eq I] [\u03a0 (i : I), has_zero (f i)]\n\t(i : I) (x : f i) (i_1 : I) :\n\t\u21d1(zero_hom.single f i) x i_1 = pi.single i x i_1", "decl_tp": "\u2200 {I : Type u} (f : I \u2192 Type v) [_inst_1 : decidable_eq I] [_inst_2 : \u03a0 (i : I), has_zero (f i)] (i : I) (x : f i) (i_1 : I), \u21d1(zero_hom.single f i) x i_1 = pi.single i x i_1", "decl_nm": "zero_hom.single_apply", "nl_statement_of_codex": "Let $f:I\\to\\mathbb{R}$ be a function. Then $f(i)=0$ if and only if $f(i)=0$."}
{"formal_statement": "theorem maps_to_smul_orbit {\u03b1 : Type u} {\u03b2 : Type v} [monoid \u03b1] [mul_action \u03b1 \u03b2]\n\t(a : \u03b1) (b : \u03b2) :\n\tset.maps_to (has_scalar.smul a) (mul_action.orbit \u03b1 b) (mul_action.orbit \u03b1 b)", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : monoid \u03b1] [_inst_2 : mul_action \u03b1 \u03b2] (a : \u03b1) (b : \u03b2), set.maps_to (has_scalar.smul a) (mul_action.orbit \u03b1 b) (mul_action.orbit \u03b1 b)", "decl_nm": "mul_action.maps_to_smul_orbit", "nl_statement_of_codex": "Let $G$ be a monoid acting on a set $X$. Then for each $g\\in G$ and $x\\in X$, the map $g$ maps the orbit of $x$ to the orbit of $gx$."}
{"formal_statement": "theorem pullback_obj {C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C]\n\t{X Y : C} (f : X \u27f6 Y) (g : category_theory.over Y) :\n\t(category_theory.over.pullback f).obj g = category_theory.over.mk category_theory.limits.pullback.snd", "decl_tp": "\u2200 {C : Type u} [_inst_2 : category_theory.category C] [_inst_3 : category_theory.limits.has_pullbacks C] {X Y : C} (f : X \u27f6 Y) (g : category_theory.over Y), (category_theory.over.pullback f).obj g = category_theory.over.mk category_theory.limits.pullback.snd", "decl_nm": "category_theory.over.pullback_obj", "nl_statement_of_codex": "Let $C$ be a category with pullbacks. Let $X, Y$ be objects of $C$ and let $f:X\\to Y$. Let $g:Y\\to 1$. Then the pullback of $f$ and $g$ is the object $X$."}
{"formal_statement": "theorem coe_one {R : Type*} [comm_ring R] :\n\t\u21911 = 1", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R], \u21911 = 1", "decl_nm": "quaternion.coe_one", "nl_statement_of_codex": "The canonical map from $\\mathbb{Z}$ to $R$ sends $1$ to $1$."}
{"formal_statement": "theorem basis_repr_apply {R M \u03b9 : Type*} [comm_ring R] [add_comm_group M]\n\t[module R M] {e : \u03b9 \u2192 M} {\u03b5 : \u03b9 \u2192 module.dual R M} [decidable_eq \u03b9] (h : dual_pair e \u03b5)\n\t(m : M) :\n\t\u21d1(h.basis.repr) m = h.coeffs m", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_2} {\u03b9 : Type u_3} [_inst_1 : comm_ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] {e : \u03b9 \u2192 M} {\u03b5 : \u03b9 \u2192 module.dual R M} [_inst_4 : decidable_eq \u03b9] (h : dual_pair e \u03b5) (m : M), \u21d1(h.basis.repr) m = h.coeffs m", "decl_nm": "dual_pair.basis_repr_apply", "nl_statement_of_codex": "Let $R$ be a commutative ring, $M$ an $R$-module, and $e,\\epsilon$ a dual pair of bases for $M$. Then the representation of $m\\in M$ with respect to the dual pair is the same as the representation of $m$ with respect to the basis $e$."}
{"formal_statement": "theorem open_iff_image_open {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : open_embedding f) :\n\t\u2200 {s : set \u03b1}, is_open s \u2194 is_open (f '' s)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, open_embedding f \u2192 \u2200 {s : set \u03b1}, is_open s \u2194 is_open (f '' s)", "decl_nm": "open_embedding.open_iff_image_open", "nl_statement_of_codex": "Let $f:X\\to Y$ be an open embedding. Then $f$ is an open map."}
{"formal_statement": "theorem lintegral_lintegral_mul {\u03b1 : Type*} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{\u03b2 : Type*} [measurable_space \u03b2] {\u03bd : measure_theory.measure \u03b2} {f : \u03b1 \u2192 ennreal}\n\t{g : \u03b2 \u2192 ennreal} (hf : ae_measurable f \u03bc) (hg : ae_measurable g \u03bd) :\n\t\u222b\u207b (x : \u03b1), \u222b\u207b (y : \u03b2), f x * g y \u2202\u03bd \u2202\u03bc = \u222b\u207b (x : \u03b1), f x \u2202\u03bc * \u222b\u207b (y : \u03b2), g y \u2202\u03bd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {\u03b2 : Type u_2} [_inst_1 : measurable_space \u03b2] {\u03bd : measure_theory.measure \u03b2} {f : \u03b1 \u2192 ennreal} {g : \u03b2 \u2192 ennreal}, ae_measurable f \u03bc \u2192 ae_measurable g \u03bd \u2192 \u222b\u207b (x : \u03b1), \u222b\u207b (y : \u03b2), f x * g y \u2202\u03bd \u2202\u03bc = \u222b\u207b (x : \u03b1), f x \u2202\u03bc * \u222b\u207b (y : \u03b2), g y \u2202\u03bd", "decl_nm": "measure_theory.lintegral_lintegral_mul", "nl_statement_of_codex": "Let $f:X\\to [0,\\infty]$ and $g:Y\\to [0,\\infty]$ be measurable functions. Then\n$$\\int_X\\int_Y f(x)g(y)dydx=\\int_Xf(x)dx\\int_Yg(y)dy.$$"}
{"formal_statement": "theorem encode_list_nil {\u03b1 : Type*} [encodable \u03b1] :\n\tencodable.encode list.nil = 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : encodable \u03b1], encodable.encode list.nil = 0", "decl_nm": "encodable.encode_list_nil", "nl_statement_of_codex": "The encoding of the empty list is $0$."}
{"formal_statement": "theorem tensor_hom_f {C : Type u\u2081} [category_theory.category C] [category_theory.monoidal_category C]\n\t{X\u2081 Y\u2081 X\u2082 Y\u2082 : category_theory.center C} (f : X\u2081 \u27f6 Y\u2081) (g : X\u2082 \u27f6 Y\u2082) :\n\t(category_theory.center.tensor_hom f g).f = f.f \u2297 g.f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] {X\u2081 Y\u2081 X\u2082 Y\u2082 : category_theory.center C} (f : X\u2081 \u27f6 Y\u2081) (g : X\u2082 \u27f6 Y\u2082), (category_theory.center.tensor_hom f g).f = f.f \u2297 g.f", "decl_nm": "category_theory.center.tensor_hom_f", "nl_statement_of_codex": "Let $C$ be a monoidal category. Let $X_1, Y_1, X_2, Y_2$ be objects in the center of $C$. Let $f:X_1\\to Y_1$ and $g:X_2\\to Y_2$ be morphisms in $C$. Then the morphism $f\\otimes g:X_1\\otimes X_2\\to Y_1\\otimes Y_2$ is equal to the morphism $f\\otimes g:X_1\\otimes X_2\\to Y_1\\otimes Y_2$."}
{"formal_statement": "theorem zero_tprod_coeff' {\u03b9 : Type*} [decidable_eq \u03b9] {R : Type*} [comm_semiring R]\n\t{s : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), add_comm_monoid (s i)] [\u03a0 (i : \u03b9), module R (s i)]\n\t(z : R) (f : \u03a0 (i : \u03b9), s i) (i : \u03b9) (hf : f i = 0) :\n\tpi_tensor_product.tprod_coeff R z f = 0", "decl_tp": "\u2200 {\u03b9 : Type u_1} [_inst_1 : decidable_eq \u03b9] {R : Type u_4} [_inst_4 : comm_semiring R] {s : \u03b9 \u2192 Type u_7} [_inst_5 : \u03a0 (i : \u03b9), add_comm_monoid (s i)] [_inst_6 : \u03a0 (i : \u03b9), module R (s i)] (z : R) (f : \u03a0 (i : \u03b9), s i) (i : \u03b9), f i = 0 \u2192 pi_tensor_product.tprod_coeff R z f = 0", "decl_nm": "pi_tensor_product.zero_tprod_coeff'", "nl_statement_of_codex": "Let $R$ be a commutative semiring, let $s$ be a family of $R$-modules, and let $f$ be a family of elements of $s$.\nIf $f_i=0$ for some $i$, then the tensor product of $f$ is zero."}
{"formal_statement": "theorem nhds_translation_add_neg {G : Type w} [topological_space G] [add_group G]\n\t[topological_add_group G] (x : G) :\n\tfilter.comap (\u03bb (y : G), y + -x) (nhds 0) = nhds x", "decl_tp": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : add_group G] [_inst_3 : topological_add_group G] (x : G), filter.comap (\u03bb (y : G), y + -x) (nhds 0) = nhds x", "decl_nm": "nhds_translation_add_neg", "nl_statement_of_codex": "The filter of neighborhoods of $x$ is equal to the filter of neighborhoods of $0$ under the map $y\\mapsto y-x$."}
{"formal_statement": "theorem coe_sub (x y : \u211d) :\n\t\u2191(x - y) = \u2191x - \u2191y", "decl_tp": "\u2200 (x y : \u211d), \u2191(x - y) = \u2191x - \u2191y", "decl_nm": "hyperreal.coe_sub", "nl_statement_of_codex": "The map $\\mathbb{R}\\to\\mathbb{Q}$ given by $x\\mapsto x$ is a group homomorphism."}
{"formal_statement": "theorem const_apply (\u03b1 : Type u) {\u03b2 : Type v} [topological_space \u03b1] [metric_space \u03b2]\n\t(b : \u03b2) :\n\t\u21d1(bounded_continuous_function.const \u03b1 b) = \u03bb (x : \u03b1), b", "decl_tp": "\u2200 (\u03b1 : Type u) {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : metric_space \u03b2] (b : \u03b2), \u21d1(bounded_continuous_function.const \u03b1 b) = \u03bb (x : \u03b1), b", "decl_nm": "bounded_continuous_function.const_apply", "nl_statement_of_codex": "The function $f:\\alpha\\to\\beta$ defined by $f(x)=b$ for all $x\\in\\alpha$ is continuous."}
{"formal_statement": "theorem monotone_intro {\u03b1 : Type u} {\u03b2 : Type v} [preorder \u03b1] [preorder \u03b2]\n\t{l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (hu : monotone u) (hl : monotone l) :\n\t(\u2200 (a : \u03b1), a \u2264 u (l a)) \u2192 (\u2200 (a : \u03b2), l (u a) \u2264 a) \u2192 galois_connection l u", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}, monotone u \u2192 monotone l \u2192 (\u2200 (a : \u03b1), a \u2264 u (l a)) \u2192 (\u2200 (a : \u03b2), l (u a) \u2264 a) \u2192 galois_connection l u", "decl_nm": "galois_connection.monotone_intro", "nl_statement_of_codex": "Let $l$ and $u$ be monotone functions between preordered sets. If $a\\leq u(l(a))$ for all $a$ and $l(u(a))\\leq a$ for all $a$, then $l$ and $u$ form a Galois connection."}
{"formal_statement": "theorem ae_smul_measure {\u03b1 : Type*} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t{p : \u03b1 \u2192 Prop} :\n\t(\u2200\u1d50 (x : \u03b1) \u2202\u03bc, p x) \u2192 \u2200 (c : ennreal), \u2200\u1d50 (x : \u03b1) \u2202c \u2022 \u03bc, p x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {p : \u03b1 \u2192 Prop}, (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, p x) \u2192 \u2200 (c : ennreal), \u2200\u1d50 (x : \u03b1) \u2202c \u2022 \u03bc, p x", "decl_nm": "measure_theory.ae_smul_measure", "nl_statement_of_codex": "Let $p$ be a property of elements of a measurable space $(X,\\mathcal{A})$. If $p$ holds almost everywhere, then $p$ holds almost everywhere with respect to any multiple of the measure."}
{"formal_statement": "theorem min_add_max {\u03b1 : Type u} [linear_order \u03b1] [add_comm_semigroup \u03b1]\n\t(n m : \u03b1) :\n\tlinear_order.min n m + linear_order.max n m = n + m", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] [_inst_2 : add_comm_semigroup \u03b1] (n m : \u03b1), linear_order.min n m + linear_order.max n m = n + m", "decl_nm": "min_add_max", "nl_statement_of_codex": "Let $n,m$ be elements of a linearly ordered commutative semigroup. Then $min(n,m)+max(n,m)=n+m$."}
{"formal_statement": "theorem floor_ring_ceil_eq :\n\tfloor_ring.ceil = int.ceil", "decl_tp": "floor_ring.ceil = int.ceil", "decl_nm": "int.floor_ring_ceil_eq", "nl_statement_of_codex": "The ceiling function on the floor ring is the same as the ceiling function on the integers."}
{"formal_statement": "theorem adjoin_insert_adjoin (F : Type*) [field F] {E : Type*} [field E]\n\t[algebra F E] (S : set E) (x : E) :\n\tintermediate_field.adjoin F (has_insert.insert x \u2191(intermediate_field.adjoin F S)) = intermediate_field.adjoin F (has_insert.insert x S)", "decl_tp": "\u2200 (F : Type u_1) [_inst_1 : field F] {E : Type u_2} [_inst_2 : field E] [_inst_3 : algebra F E] (S : set E) (x : E), intermediate_field.adjoin F (has_insert.insert x \u2191(intermediate_field.adjoin F S)) = intermediate_field.adjoin F (has_insert.insert x S)", "decl_nm": "intermediate_field.adjoin_insert_adjoin", "nl_statement_of_codex": "Let $F$ be a field, let $E$ be a field extension of $F$, and let $S$ be a subset of $E$. Then the field extension of $F$ generated by $S$ is the same as the field extension of $F$ generated by $S\\cup\\{x\\}$."}
{"formal_statement": "theorem le_of_add_le_left {a b c : \u2115} (h : a + b \u2264 c) :\n\ta \u2264 c", "decl_tp": "\u2200 {a b c : \u2115}, a + b \u2264 c \u2192 a \u2264 c", "decl_nm": "nat.le_of_add_le_left", "nl_statement_of_codex": "If $a+b\\leq c$, then $a\\leq c$."}
{"formal_statement": "theorem refl_to_linear_map {R M : Type*} [semiring R] [add_comm_monoid M]\n\t[module R M] :\n\t\u2191(linear_equiv.refl R M) = linear_map.id", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_7} [_inst_1 : semiring R] [_inst_6 : add_comm_monoid M] [_inst_17 : module R M], \u2191(linear_equiv.refl R M) = linear_map.id", "decl_nm": "linear_equiv.refl_to_linear_map", "nl_statement_of_codex": "The identity map on a module $M$ is a linear map."}
{"formal_statement": "theorem pred_one_add (n : \u2115) :\n\t(1 + n).pred = n", "decl_tp": "\u2200 (n : \u2115), (1 + n).pred = n", "decl_nm": "nat.pred_one_add", "nl_statement_of_codex": "$1+n-1=n$."}
{"formal_statement": "theorem denom_eq_conts_b {K : Type*} {g : generalized_continued_fraction K}\n\t{n : \u2115} [division_ring K] :\n\tg.denominators n = (g.continuants n).b", "decl_tp": "\u2200 {K : Type u_1} {g : generalized_continued_fraction K} {n : \u2115} [_inst_1 : division_ring K], g.denominators n = (g.continuants n).b", "decl_nm": "generalized_continued_fraction.denom_eq_conts_b", "nl_statement_of_codex": "The denominator of the $n$th convergent of a generalized continued fraction is equal to the $b$-value of the $n$th continuant."}
{"formal_statement": "theorem to_subsemiring_mono {R : Type u} [ring R] :\n\tmonotone subring.to_subsemiring", "decl_tp": "\u2200 {R : Type u} [_inst_1 : ring R], monotone subring.to_subsemiring", "decl_nm": "subring.to_subsemiring_mono", "nl_statement_of_codex": "The map from subrings of $R$ to subsemirings of $R$ is monotone."}
{"formal_statement": "theorem ball_subset {\u03b1 : Type u} [pseudo_emetric_space \u03b1] {x y : \u03b1} {\u03b5\u2081 \u03b5\u2082 : ennreal}\n\t(h : has_edist.edist x y + \u03b5\u2081 \u2264 \u03b5\u2082) (h' : has_edist.edist x y \u2260 \u22a4) :\n\temetric.ball x \u03b5\u2081 \u2286 emetric.ball y \u03b5\u2082", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] {x y : \u03b1} {\u03b5\u2081 \u03b5\u2082 : ennreal}, has_edist.edist x y + \u03b5\u2081 \u2264 \u03b5\u2082 \u2192 has_edist.edist x y \u2260 \u22a4 \u2192 emetric.ball x \u03b5\u2081 \u2286 emetric.ball y \u03b5\u2082", "decl_nm": "emetric.ball_subset", "nl_statement_of_codex": "Let $X$ be a pseudo-metric space. Let $x,y\\in X$ and let $\\epsilon_1,\\epsilon_2\\in\\mathbb{R}^+\\cup\\{\\infty\\}$.\nIf $\\epsilon_1+d(x,y)\\leq\\epsilon_2$ and $d(x,y)<\\infty$, then $B(x,\\epsilon_1)\\subset B(y,\\epsilon_2)$."}
{"formal_statement": "theorem next_coeff_up_of_pos_nat_trailing_degree {R : Type u} [semiring R]\n\t(p : polynomial R) (hp : 0 < p.nat_trailing_degree) :\n\tp.next_coeff_up = p.coeff (p.nat_trailing_degree + 1)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] (p : polynomial R), 0 < p.nat_trailing_degree \u2192 p.next_coeff_up = p.coeff (p.nat_trailing_degree + 1)", "decl_nm": "polynomial.next_coeff_up_of_pos_nat_trailing_degree", "nl_statement_of_codex": "Let $p$ be a polynomial with positive natural trailing degree. Then the next coefficient up of $p$ is the coefficient of $p$ at the degree of the natural trailing degree of $p$ plus one."}
{"formal_statement": "theorem lt_def {\u03b1 : Type*} [has_lt \u03b1] (A B : finset \u03b1) :\n\tA.to_colex < B.to_colex \u2194 \u2203 (k : \u03b1), (\u2200 {x : \u03b1}, k < x \u2192 (x \u2208 A \u2194 x \u2208 B)) \u2227 k \u2209 A \u2227 k \u2208 B", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_lt \u03b1] (A B : finset \u03b1), A.to_colex < B.to_colex \u2194 \u2203 (k : \u03b1), (\u2200 {x : \u03b1}, k < x \u2192 (x \u2208 A \u2194 x \u2208 B)) \u2227 k \u2209 A \u2227 k \u2208 B", "decl_nm": "colex.lt_def", "nl_statement_of_codex": "Let $A$ and $B$ be finite sets. Then $A<B$ if and only if there is an element $k$ such that $k$ is in $B$ but not in $A$ and $k$ is less than every element of $A$ and $B$."}
{"formal_statement": "theorem forall_congr_left' {\u03b1 : Sort u} {\u03b2 : Sort v} {p : \u03b1 \u2192 Prop} (f : \u03b1 \u2243 \u03b2) :\n\t(\u2200 (x : \u03b1), p x) \u2194 \u2200 (y : \u03b2), p (\u21d1(f.symm) y)", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} {p : \u03b1 \u2192 Prop} (f : \u03b1 \u2243 \u03b2), (\u2200 (x : \u03b1), p x) \u2194 \u2200 (y : \u03b2), p (\u21d1(f.symm) y)", "decl_nm": "equiv.forall_congr_left'", "nl_statement_of_codex": "Let $f:A\\to B$ be a bijection. Then $\\forall x\\in A, P(x)$ is equivalent to $\\forall y\\in B, P(f^{-1}(y))$."}
{"formal_statement": "theorem mk_\u03c0_app {\u03b2 : Type w} {C : Type u} [category_theory.category C]\n\t{f : \u03b2 \u2192 C} (P : C) (p : \u03a0 (b : \u03b2), P \u27f6 f b) (b : \u03b2) :\n\t(category_theory.limits.fan.mk P p).\u03c0.app b = p b", "decl_tp": "\u2200 {\u03b2 : Type w} {C : Type u} [_inst_1 : category_theory.category C] {f : \u03b2 \u2192 C} (P : C) (p : \u03a0 (b : \u03b2), P \u27f6 f b) (b : \u03b2), (category_theory.limits.fan.mk P p).\u03c0.app b = p b", "decl_nm": "category_theory.limits.fan.mk_\u03c0_app", "nl_statement_of_codex": "Let $C$ be a category and let $P$ be an object of $C$. Let $f:B\\to C$ be a functor. Let $p:P\\to f(b)$ be a natural transformation. Then the $b$-th component of the natural transformation $\\pi:P\\to \\lim f$ is $p(b)$."}
{"formal_statement": "theorem is_id {R : Type u} {\u03c3 : Type*} [comm_semiring R] (f : mv_polynomial \u03c3 R \u2192+* mv_polynomial \u03c3 R)\n\t(hC : f.comp mv_polynomial.C = mv_polynomial.C) :\n\t(\u2200 (n : \u03c3), \u21d1f (mv_polynomial.X n) = mv_polynomial.X n) \u2192 \u2200 (p : mv_polynomial \u03c3 R), \u21d1f p = p", "decl_tp": "\u2200 {R : Type u} {\u03c3 : Type u_1} [_inst_1 : comm_semiring R] (f : mv_polynomial \u03c3 R \u2192+* mv_polynomial \u03c3 R), f.comp mv_polynomial.C = mv_polynomial.C \u2192 (\u2200 (n : \u03c3), \u21d1f (mv_polynomial.X n) = mv_polynomial.X n) \u2192 \u2200 (p : mv_polynomial \u03c3 R), \u21d1f p = p", "decl_nm": "mv_polynomial.is_id", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $f:R[x_1,\\ldots,x_n]\\to R[x_1,\\ldots,x_n]$ be a ring homomorphism. If $f$ fixes the constant polynomials and fixes the variables, then $f$ is the identity."}
{"formal_statement": "theorem has_strict_deriv_at_sqrt {x : \u211d} (hx : x \u2260 0) :\n\thas_strict_deriv_at real.sqrt (1 / (2 * real.sqrt x)) x", "decl_tp": "\u2200 {x : \u211d}, x \u2260 0 \u2192 has_strict_deriv_at real.sqrt (1 / (2 * real.sqrt x)) x", "decl_nm": "real.has_strict_deriv_at_sqrt", "nl_statement_of_codex": "The function $f(x)=\\sqrt{x}$ has derivative $f'(x)=\\frac{1}{2\\sqrt{x}}$ at $x$."}
{"formal_statement": "theorem normal_closure_closure_eq_normal_closure {G : Type*} [group G]\n\t{s : set G} :\n\tsubgroup.normal_closure \u2191(subgroup.closure s) = subgroup.normal_closure s", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G] {s : set G}, subgroup.normal_closure \u2191(subgroup.closure s) = subgroup.normal_closure s", "decl_nm": "subgroup.normal_closure_closure_eq_normal_closure", "nl_statement_of_codex": "The normal closure of the closure of a set $s$ is equal to the normal closure of $s$."}
{"formal_statement": "theorem lt_rpow_iff_log_lt {x y z : \u211d} (hx : 0 < x) (hy : 0 < y) :\n\t(x < y ^ z \u2194 real.log x < z * real.log y)", "decl_tp": "\u2200 {x y z : \u211d}, 0 < x \u2192 0 < y \u2192 (x < y ^ z \u2194 real.log x < z * real.log y)", "decl_nm": "real.lt_rpow_iff_log_lt", "nl_statement_of_codex": "Let $x,y,z$ be positive real numbers. Then $x<y^z$ if and only if $\\log x<z\\log y$."}
{"formal_statement": "theorem eq_C_of_nat_degree_eq_zero {R : Type u} [semiring R] {p : polynomial R}\n\t(h : p.nat_degree = 0) :\n\tp = \u21d1polynomial.C (p.coeff 0)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : semiring R] {p : polynomial R}, p.nat_degree = 0 \u2192 p = \u21d1polynomial.C (p.coeff 0)", "decl_nm": "polynomial.eq_C_of_nat_degree_eq_zero", "nl_statement_of_codex": "If the natural degree of a polynomial $p$ is zero, then $p$ is a constant polynomial."}
{"formal_statement": "theorem gcd_le_left {m : \u2115} (n : \u2115) (h : 0 < m) :\n\tm.gcd n \u2264 m", "decl_tp": "\u2200 {m : \u2115} (n : \u2115), 0 < m \u2192 m.gcd n \u2264 m", "decl_nm": "nat.gcd_le_left", "nl_statement_of_codex": "The greatest common divisor of $m$ and $n$ is less than or equal to $m$."}
{"formal_statement": "theorem const_sub {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c] {E : Type*}\n\t[normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F] [normed_space \ud835\udd5c F]\n\t{f : E \u2192 F} {s : set E} (hf : differentiable_on \ud835\udd5c f s) :\n\t\u2200 (c : F), differentiable_on \ud835\udd5c (\u03bb (y : E), c - f y) s", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {s : set E}, differentiable_on \ud835\udd5c f s \u2192 \u2200 (c : F), differentiable_on \ud835\udd5c (\u03bb (y : E), c - f y) s", "decl_nm": "differentiable_on.const_sub", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be differentiable on $S$. Then the function $g:E\\to F$ defined by $g(x)=c-f(x)$ is differentiable on $S$ for any $c\\in F$."}
{"formal_statement": "theorem ball_eq_empty {\u03b1 : Type u} [pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d} :\n\tmetric.ball x \u03b5 = \u2205 \u2194 \u03b5 \u2264 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d}, metric.ball x \u03b5 = \u2205 \u2194 \u03b5 \u2264 0", "decl_nm": "metric.ball_eq_empty", "nl_statement_of_codex": "The ball of radius $\\epsilon$ around $x$ is empty if and only if $\\epsilon\\leq 0$."}
{"formal_statement": "theorem eq_bot_of_disjoint_absorbs {\u03b1 : Type u} [lattice \u03b1] [bounded_order \u03b1]\n\t{a b : \u03b1} (w : disjoint a b) (h : a \u2294 b = a) :\n\tb = \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : bounded_order \u03b1] {a b : \u03b1}, disjoint a b \u2192 a \u2294 b = a \u2192 b = \u22a5", "decl_nm": "eq_bot_of_disjoint_absorbs", "nl_statement_of_codex": "Let $a$ and $b$ be disjoint elements of a bounded lattice. If $a\\vee b=a$, then $b=\\bot$."}
{"formal_statement": "theorem \u0393_def {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] :\n\talgebraic_geometry.SheafedSpace.\u0393 = algebraic_geometry.SheafedSpace.forget_to_PresheafedSpace.op \u22d9 algebraic_geometry.PresheafedSpace.\u0393", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_products C], algebraic_geometry.SheafedSpace.\u0393 = algebraic_geometry.SheafedSpace.forget_to_PresheafedSpace.op \u22d9 algebraic_geometry.PresheafedSpace.\u0393", "decl_nm": "algebraic_geometry.SheafedSpace.\u0393_def", "nl_statement_of_codex": "The functor $\\Gamma$ from sheaves to sets is the composition of the forgetful functor from sheaves to presheaves and the functor $\\Gamma$ from presheaves to sets."}
{"formal_statement": "theorem coe_smul\u2080 {G\u2080 \u03b1 : Type*} [measurable_space G\u2080] [measurable_space \u03b1]\n\t[group_with_zero G\u2080] [mul_action G\u2080 \u03b1] [has_measurable_smul G\u2080 \u03b1] {c : G\u2080}\n\t(hc : c \u2260 0) :\n\t\u21d1(measurable_equiv.smul\u2080 c hc) = has_scalar.smul c", "decl_tp": "\u2200 {G\u2080 : Type u_2} {\u03b1 : Type u_3} [_inst_2 : measurable_space G\u2080] [_inst_3 : measurable_space \u03b1] [_inst_5 : group_with_zero G\u2080] [_inst_7 : mul_action G\u2080 \u03b1] [_inst_9 : has_measurable_smul G\u2080 \u03b1] {c : G\u2080} (hc : c \u2260 0), \u21d1(measurable_equiv.smul\u2080 c hc) = has_scalar.smul c", "decl_nm": "measurable_equiv.coe_smul\u2080", "nl_statement_of_codex": "Let $G$ be a group with zero and let $G$ act on a measurable space $X$. Then the map $x\\mapsto c\\cdot x$ is measurable if and only if $c\\neq 0$."}
{"formal_statement": "theorem inv_lt_of_neg {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1} (ha : a < 0)\n\t(hb : b < 0) :\n\t(a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b : \u03b1}, a < 0 \u2192 b < 0 \u2192 (a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a)", "decl_nm": "inv_lt_of_neg", "nl_statement_of_codex": "Let $a, b$ be negative real numbers. Then $a^{-1}<b$ if and only if $b^{-1}<a$."}
{"formal_statement": "theorem coe_id (X : Profinite) :\n\t\u21d1(\ud835\udfd9 X) = id", "decl_tp": "\u2200 (X : Profinite), \u21d1(\ud835\udfd9 X) = id", "decl_nm": "Profinite.coe_id", "nl_statement_of_codex": "The map $X\\to X$ given by $x\\mapsto x$ is continuous."}
{"formal_statement": "theorem one_div_le {\u03b1 : Type*} [linear_ordered_field \u03b1] {a b : \u03b1} (ha : 0 < a)\n\t(hb : 0 < b) :\n\t(1 / a \u2264 b \u2194 1 / b \u2264 a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b : \u03b1}, 0 < a \u2192 0 < b \u2192 (1 / a \u2264 b \u2194 1 / b \u2264 a)", "decl_nm": "one_div_le", "nl_statement_of_codex": "Let $a, b$ be positive real numbers. Then $1/a\\leq b$ if and only if $1/b\\leq a$."}
{"formal_statement": "theorem subtype_equiv_symm {\u03b1 : Sort u} {\u03b2 : Sort v} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop}\n\t(e : \u03b1 \u2243 \u03b2) (h : \u2200 (a : \u03b1), p a \u2194 q (\u21d1e a)) :\n\t(e.subtype_equiv h).symm = e.symm.subtype_equiv _", "decl_tp": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) (h : \u2200 (a : \u03b1), p a \u2194 q (\u21d1e a)), (e.subtype_equiv h).symm = e.symm.subtype_equiv _", "decl_nm": "equiv.subtype_equiv_symm", "nl_statement_of_codex": "Let $e:A\\to B$ be an equivalence. Let $p:A\\to\\mathbb{B}$ and $q:B\\to\\mathbb{B}$ be predicates. If $p(a)\\iff q(e(a))$ for all $a\\in A$, then the equivalence $e':A'\\to B'$ induced by $e$ is equivalent to the equivalence $e'':B'\\to A'$ induced by $e^{-1}$."}
{"formal_statement": "theorem and_then_eq_bind {\u03b1 \u03b2 : Type} {m : Type \u2192 Type} [monad m] (a : m \u03b1)\n\t(b : m \u03b2) :\n\ta >> b = a >>= \u03bb (_x : \u03b1), b", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type} {m : Type \u2192 Type} [_inst_1 : monad m] (a : m \u03b1) (b : m \u03b2), a >> b = a >>= \u03bb (_x : \u03b1), b", "decl_nm": "parser.and_then_eq_bind", "nl_statement_of_codex": "For any monad $m$, $a >> b = a >>= \\lambda (_x : \\alpha), b$."}
{"formal_statement": "theorem refl_trans {R R\u2082 E E\u2082 : Type*} [semiring R] [semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n\t{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n\t[semi_normed_group E] [semi_normed_group E\u2082] [module R E] [module R\u2082 E\u2082]\n\t(e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n\t(linear_isometry_equiv.refl R E).trans e = e", "decl_tp": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_5 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_6 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082), (linear_isometry_equiv.refl R E).trans e = e", "decl_nm": "linear_isometry_equiv.refl_trans", "nl_statement_of_codex": "Let $R$ and $R'$ be semirings, let $E$ and $E'$ be semi-normed groups over $R$ and $R'$, respectively, and let $\\sigma:R\\to R'$ and $\\sigma':R'\\to R$ be ring homomorphisms such that $\\sigma'\\circ\\sigma=\\mathrm{id}_R$ and $\\sigma\\circ\\sigma'=\\mathrm{id}_{R'}$. Then the identity map on $E$ is a linear isometry from $E$ to $E'$."}
{"formal_statement": "theorem coe_mono :\n\tmonotone coe", "decl_tp": "monotone coe", "decl_nm": "nnreal.coe_mono", "nl_statement_of_codex": "The function $f:\\mathbb{N}\\to\\mathbb{Z}$ defined by $f(n)=n$ is monotone."}
{"formal_statement": "theorem integral_const_mul (a : \u2102) (f : \u2102 \u2192 \u2102) (c : \u2102) (R : \u211d) :\n\t\u222e (z : \u2102) in C(c, R), a * f z = a * \u222e (z : \u2102) in C(c, R), f z", "decl_tp": "\u2200 (a : \u2102) (f : \u2102 \u2192 \u2102) (c : \u2102) (R : \u211d), \u222e (z : \u2102) in C(c, R), a * f z = a * \u222e (z : \u2102) in C(c, R), f z", "decl_nm": "circle_integral.integral_const_mul", "nl_statement_of_codex": "Let $f$ be a complex-valued function on the circle $C(c,R)$. Then $\\int_{C(c,R)} af=a\\int_{C(c,R)} f$."}
{"formal_statement": "theorem of_list_to_list' {X : Type u} [lattice X] [jordan_holder_lattice X]\n\t(s : composition_series X) :\n\tcomposition_series.of_list s.to_list _ _ = s", "decl_tp": "\u2200 {X : Type u} [_inst_1 : lattice X] [_inst_2 : jordan_holder_lattice X] (s : composition_series X), composition_series.of_list s.to_list _ _ = s", "decl_nm": "composition_series.of_list_to_list'", "nl_statement_of_codex": "Let $X$ be a lattice with a Jordan-Holder composition series $s$. Then $s$ is equal to the composition series\nobtained by applying the Jordan-Holder theorem to the list of factors of $s$."}
{"formal_statement": "theorem is_complement'_top_bot {G : Type*} [group G] :\n\t\u22a4.is_complement' \u22a5", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : group G], \u22a4.is_complement' \u22a5", "decl_nm": "subgroup.is_complement'_top_bot", "nl_statement_of_codex": "The trivial subgroup is a complement of the trivial subgroup."}
{"formal_statement": "theorem units_neg_right {M : Type*} [add_monoid M] {a : M} {u : add_units M} :\n\tadd_commute a \u2191u \u2192 add_commute a (\u2191-u)", "decl_tp": "\u2200 {M : Type u_1} [_inst_1 : add_monoid M] {a : M} {u : add_units M}, add_commute a \u2191u \u2192 add_commute a (\u2191-u)", "decl_nm": "add_commute.units_neg_right", "nl_statement_of_codex": "Let $M$ be an additive monoid and let $a, u\\in M$ be such that $u$ is an additive unit. If $a$ commutes with $u$, then $a$ commutes with $-u$."}
{"formal_statement": "theorem mem_closure {G : Type*} [add_group G] {s : set G} {a : G} :\n\ta \u2208 s \u2192 a \u2208 add_group.closure s", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {s : set G} {a : G}, a \u2208 s \u2192 a \u2208 add_group.closure s", "decl_nm": "add_group.mem_closure", "nl_statement_of_codex": "Let $G$ be an additive group and let $s$ be a subset of $G$. If $a\\in s$, then $a$ is in the closure of $s$."}
{"formal_statement": "theorem to_cone_X {C : Type u\u2081} [category_theory.category C] {D : Type u\u2082}\n\t[category_theory.category D] {J : Type v\u2081} [category_theory.small_category J]\n\t{K : J \u2964 C} (F : C \u2964 D) (c : category_theory.limits.cone K) {X : D} (f : X \u27f6 F.obj c.X) :\n\t(category_theory.structured_arrow_cone.to_cone F c f).X = category_theory.structured_arrow.mk f", "decl_tp": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {J : Type v\u2081} [_inst_3 : category_theory.small_category J] {K : J \u2964 C} (F : C \u2964 D) (c : category_theory.limits.cone K) {X : D} (f : X \u27f6 F.obj c.X), (category_theory.structured_arrow_cone.to_cone F c f).X = category_theory.structured_arrow.mk f", "decl_nm": "category_theory.structured_arrow_cone.to_cone_X", "nl_statement_of_codex": "Let $C$ and $D$ be categories, let $J$ be a small category, let $K:J\\to C$ be a functor, let $F:C\\to D$ be a functor, let $c$ be a cone over $K$, and let $X$ be an object of $D$. Then the object of the cone over $F$ induced by $c$ and a morphism $f:X\\to F(c.X)$ is $f$."}
{"formal_statement": "theorem times_cont_diff_at_of_subsingleton {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {F : Type*} [normed_group F]\n\t[normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} [subsingleton F] {n : with_top \u2115} :\n\ttimes_cont_diff_at \ud835\udd5c n f x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {x : E} [_inst_8 : subsingleton F] {n : with_top \u2115}, times_cont_diff_at \ud835\udd5c n f x", "decl_nm": "times_cont_diff_at_of_subsingleton", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces over a nondiscrete normed field $K$. Let $f:E\\to F$ be a function. If $F$ is a singleton, then $f$ is $n$-times continuously differentiable at $x$."}
{"formal_statement": "theorem inf_apply {\u03b9 : Type*} {\u03b1' : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), has_inf (\u03b1' i)]\n\t(f g : \u03a0 (i : \u03b9), \u03b1' i) (i : \u03b9) :\n\t(f \u2293 g) i = f i \u2293 g i", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1' : \u03b9 \u2192 Type u_2} [_inst_1 : \u03a0 (i : \u03b9), has_inf (\u03b1' i)] (f g : \u03a0 (i : \u03b9), \u03b1' i) (i : \u03b9), (f \u2293 g) i = f i \u2293 g i", "decl_nm": "pi.inf_apply", "nl_statement_of_codex": "Let $f,g:\\mathbb{N}\\to R$ be two functions. Then $(f\\wedge g)(n)=f(n)\\wedge g(n)$ for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem pow {X M : Type*} [topological_space X] [topological_space M] [monoid M]\n\t[has_continuous_mul M] {f : X \u2192 M} {s : set X} (hf : continuous_on f s) :\n\t\u2200 (n : \u2115), continuous_on (\u03bb (x : X), f x ^ n) s", "decl_tp": "\u2200 {X : Type u_3} {M : Type u_4} [_inst_1 : topological_space X] [_inst_2 : topological_space M] [_inst_3 : monoid M] [_inst_4 : has_continuous_mul M] {f : X \u2192 M} {s : set X}, continuous_on f s \u2192 \u2200 (n : \u2115), continuous_on (\u03bb (x : X), f x ^ n) s", "decl_nm": "continuous_on.pow", "nl_statement_of_codex": "Let $X$ and $M$ be topological spaces and let $f:X\\to M$ be a continuous function. Then the function $x\\mapsto f(x)^n$ is continuous for all $n\\in\\mathbb{N}$."}
{"formal_statement": "theorem neg_pos_part {\u03b1 : Type*} [measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1) :\n\t(-j).pos_part = j.neg_part", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] (j : measure_theory.jordan_decomposition \u03b1), (-j).pos_part = j.neg_part", "decl_nm": "measure_theory.jordan_decomposition.neg_pos_part", "nl_statement_of_codex": "Let $X$ be a measurable space and let $j$ be a Jordan decomposition of $X$. Then the positive part of $-j$ is equal to the negative part of $j$."}
{"formal_statement": "theorem coe_to_mul_hom {M N : Type*} [has_mul M] [has_mul N] {f : M \u2243* N} :\n\t\u21d1(f.to_mul_hom) = \u21d1f", "decl_tp": "\u2200 {M : Type u_3} {N : Type u_4} [_inst_1 : has_mul M] [_inst_2 : has_mul N] {f : M \u2243* N}, \u21d1(f.to_mul_hom) = \u21d1f", "decl_nm": "mul_equiv.coe_to_mul_hom", "nl_statement_of_codex": "The map $f:M\\to N$ is a group isomorphism if and only if $f$ is a ring isomorphism."}
{"formal_statement": "theorem one_iff_ker_inv {G H : Type*} [group G] [group H] {f : G \u2192 H} (hf : is_group_hom f) :\n\t\u2200 (a b : G), f a = f b \u2194 f (a * b\u207b\u00b9) = 1", "decl_tp": "\u2200 {G : Type u_1} {H : Type u_2} [_inst_1 : group G] [_inst_2 : group H] {f : G \u2192 H}, is_group_hom f \u2192 \u2200 (a b : G), f a = f b \u2194 f (a * b\u207b\u00b9) = 1", "decl_nm": "is_group_hom.one_iff_ker_inv", "nl_statement_of_codex": "Let $G$ and $H$ be groups and let $f:G\\to H$ be a group homomorphism. Then $f(a)=f(b)$ if and only if $f(ab^{-1})=1$."}
{"formal_statement": "theorem add {\u03b1 : Type*} [topological_space \u03b1] {s : set \u03b1} {\u03b3 : Type*} [linear_ordered_add_comm_monoid \u03b3]\n\t[topological_space \u03b3] [order_topology \u03b3] [has_continuous_add \u03b3] {f g : \u03b1 \u2192 \u03b3}\n\t(hf : lower_semicontinuous_on f s) (hg : lower_semicontinuous_on g s) :\n\tlower_semicontinuous_on (\u03bb (z : \u03b1), f z + g z) s", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {s : set \u03b1} {\u03b3 : Type u_4} [_inst_3 : linear_ordered_add_comm_monoid \u03b3] [_inst_4 : topological_space \u03b3] [_inst_5 : order_topology \u03b3] [_inst_6 : has_continuous_add \u03b3] {f g : \u03b1 \u2192 \u03b3}, lower_semicontinuous_on f s \u2192 lower_semicontinuous_on g s \u2192 lower_semicontinuous_on (\u03bb (z : \u03b1), f z + g z) s", "decl_nm": "lower_semicontinuous_on.add", "nl_statement_of_codex": "Let $X$ be a topological space and let $Y$ be a topological space with a linear order and a continuous addition.\nLet $f,g:X\\to Y$ be functions. If $f$ and $g$ are lower semicontinuous, then $f+g$ is lower semicontinuous."}
{"formal_statement": "theorem sdiff_def {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u03a0 (i : \u03b9), has_sdiff (\u03b1 i)]\n\t(x y : \u03a0 (i : \u03b9), \u03b1 i) :\n\tx \\ y = \u03bb (i : \u03b9), x i \\ y i", "decl_tp": "\u2200 {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [_inst_1 : \u03a0 (i : \u03b9), has_sdiff (\u03b1 i)] (x y : \u03a0 (i : \u03b9), \u03b1 i), x \\ y = \u03bb (i : \u03b9), x i \\ y i", "decl_nm": "pi.sdiff_def", "nl_statement_of_codex": "Let $x,y:\\mathbb{R}^n\\to\\mathbb{R}^m$ be two functions. Then $x\\ominus y$ is the function $z:\\mathbb{R}^n\\to\\mathbb{R}^m$ defined by $z(x)=x(x)\\ominus y(x)$."}
{"formal_statement": "theorem of_equiv {\u03b1 : Type*} [primcodable \u03b1] {\u03b2 : Type*} {e : \u03b2 \u2243 \u03b1} :\n\tprimrec \u21d1e", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1] {\u03b2 : Type u_2} {e : \u03b2 \u2243 \u03b1}, primrec \u21d1e", "decl_nm": "primrec.of_equiv", "nl_statement_of_codex": "The primitive recursive function corresponding to an equivalence $e:\u03b2\\to \u03b1$ is the inverse of $e$."}
{"formal_statement": "theorem ess_sup_trim {\u03b1 : Type*} {m m0 : measurable_space \u03b1} {\u03bd : measure_theory.measure \u03b1}\n\t(hm : m \u2264 m0) {f : \u03b1 \u2192 ennreal} (hf : measurable f) :\n\tess_sup f (\u03bd.trim hm) = ess_sup f \u03bd", "decl_tp": "\u2200 {\u03b1 : Type u_1} {m m0 : measurable_space \u03b1} {\u03bd : measure_theory.measure \u03b1} (hm : m \u2264 m0) {f : \u03b1 \u2192 ennreal}, measurable f \u2192 ess_sup f (\u03bd.trim hm) = ess_sup f \u03bd", "decl_nm": "measure_theory.ess_sup_trim", "nl_statement_of_codex": "Let $f$ be a measurable function on a measurable space $(X,\\mathcal{M})$. Let $\\nu$ be a measure on $\\mathcal{M}$. Let $\\mathcal{M}_0$ be a sub-$\\sigma$-algebra of $\\mathcal{M}$. Then the essential supremum of $f$ with respect to the measure $\\nu$ restricted to $\\mathcal{M}_0$ is equal to the essential supremum of $f$ with respect to $\\nu$."}
{"formal_statement": "theorem pbind_map {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2) (x : option \u03b1) (g : \u03a0 (b : \u03b2), b \u2208 option.map f x \u2192 option \u03b3) :\n\t(option.map f x).pbind g = x.pbind (\u03bb (a : \u03b1) (h : a \u2208 x), g (f a) _)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} (f : \u03b1 \u2192 \u03b2) (x : option \u03b1) (g : \u03a0 (b : \u03b2), b \u2208 option.map f x \u2192 option \u03b3), (option.map f x).pbind g = x.pbind (\u03bb (a : \u03b1) (h : a \u2208 x), g (f a) _)", "decl_nm": "option.pbind_map", "nl_statement_of_codex": "Let $f:A\\to B$ and $g:B\\to C$ be functions. Then $(f\\circ g)^{-1}(C)=g^{-1}(f^{-1}(C))$."}
{"formal_statement": "theorem tan_nat_mul_pi (n : \u2115) :\n\treal.tan (\u2191n * real.pi) = 0", "decl_tp": "\u2200 (n : \u2115), real.tan (\u2191n * real.pi) = 0", "decl_nm": "real.tan_nat_mul_pi", "nl_statement_of_codex": "For all $n\\in\\mathbb{N}$, $\\tan(n\\pi)=0$."}
{"formal_statement": "theorem ae_eq_mk {\u03b1 \u03b2 : Type*} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t[measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hfm : measure_theory.ae_measurable' m f \u03bc) :\n\tf =\u1d50[\u03bc] measure_theory.ae_measurable'.mk f hfm", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : measurable_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hfm : measure_theory.ae_measurable' m f \u03bc), f =\u1d50[\u03bc] measure_theory.ae_measurable'.mk f hfm", "decl_nm": "measure_theory.ae_measurable'.ae_eq_mk", "nl_statement_of_codex": "Let $f:X\\to Y$ be a measurable function. Then $f$ is equal to the measurable function $g:X\\to Y$ defined by $g(x)=f(x)$ for all $x\\in X$."}
{"formal_statement": "theorem mem_sections_length {\u03b1 : Type*} {L : list (list \u03b1)} {f : list \u03b1}\n\t(h : f \u2208 L.sections) :\n\tf.length = L.length", "decl_tp": "\u2200 {\u03b1 : Type u_1} {L : list (list \u03b1)} {f : list \u03b1}, f \u2208 L.sections \u2192 f.length = L.length", "decl_nm": "list.mem_sections_length", "nl_statement_of_codex": "Let $L$ be a list of lists of elements of type $\\alpha$. If $f$ is a section of $L$, then $f$ has the same length as $L$."}
{"formal_statement": "theorem closure_eq {G : Type*} [add_group G] (K : add_subgroup G) :\n\tadd_subgroup.closure \u2191K = K", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] (K : add_subgroup G), add_subgroup.closure \u2191K = K", "decl_nm": "add_subgroup.closure_eq", "nl_statement_of_codex": "The closure of a subgroup $K$ of an additive group $G$ is equal to $K$."}
{"formal_statement": "theorem pi_mem_pi_iff {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {f : \u03a0 (i : \u03b9), filter (\u03b1 i)}\n\t{s : \u03a0 (i : \u03b9), set (\u03b1 i)} [\u2200 (i : \u03b9), (f i).ne_bot] {I : set \u03b9} (hI : I.finite) :\n\t(I.pi s \u2208 filter.pi f \u2194 \u2200 (i : \u03b9), i \u2208 I \u2192 s i \u2208 f i)", "decl_tp": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} {f : \u03a0 (i : \u03b9), filter (\u03b1 i)} {s : \u03a0 (i : \u03b9), set (\u03b1 i)} [_inst_1 : \u2200 (i : \u03b9), (f i).ne_bot] {I : set \u03b9}, I.finite \u2192 (I.pi s \u2208 filter.pi f \u2194 \u2200 (i : \u03b9), i \u2208 I \u2192 s i \u2208 f i)", "decl_nm": "filter.pi_mem_pi_iff", "nl_statement_of_codex": "Let $I$ be a finite set and let $\\{f_i\\}_{i\\in I}$ be a family of filters on sets $\\{A_i\\}_{i\\in I}$. Then $A_I\\in\\prod_{i\\in I}f_i$ if and only if $A_i\\in f_i$ for all $i\\in I$."}
{"formal_statement": "theorem unop_surjective {\u03b1 : Type u} :\n\tfunction.surjective mul_opposite.unop", "decl_tp": "\u2200 {\u03b1 : Type u}, function.surjective mul_opposite.unop", "decl_nm": "mul_opposite.unop_surjective", "nl_statement_of_codex": "The function $x\\mapsto -x$ is surjective."}
{"formal_statement": "theorem frontier_Ico {\u03b1 : Type u} [topological_space \u03b1] [linear_order \u03b1]\n\t[order_topology \u03b1] [densely_ordered \u03b1] [no_bot_order \u03b1] {a b : \u03b1} (h : a < b) :\n\tfrontier (set.Ico a b) = {a, b}", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_topology \u03b1] [_inst_4 : densely_ordered \u03b1] [_inst_5 : no_bot_order \u03b1] {a b : \u03b1}, a < b \u2192 frontier (set.Ico a b) = {a, b}", "decl_nm": "frontier_Ico", "nl_statement_of_codex": "Let $a<b$ be real numbers. Then the frontier of the interval $[a,b]$ is $\\{a,b\\}$."}
{"formal_statement": "theorem forget_enrichment_id' {C : Type u\u2081} (W : Type (v+1)) [category_theory.category W]\n\t[category_theory.monoidal_category W] [category_theory.enriched_category W C]\n\t(X : C) :\n\tcategory_theory.forget_enrichment.hom_of W (category_theory.e_id W X) = \ud835\udfd9 (category_theory.forget_enrichment.of W X)", "decl_tp": "\u2200 {C : Type u\u2081} (W : Type (v+1)) [_inst_4 : category_theory.category W] [_inst_5 : category_theory.monoidal_category W] [_inst_6 : category_theory.enriched_category W C] (X : C), category_theory.forget_enrichment.hom_of W (category_theory.e_id W X) = \ud835\udfd9 (category_theory.forget_enrichment.of W X)", "decl_nm": "category_theory.forget_enrichment_id'", "nl_statement_of_codex": "Let $W$ be a monoidal category enriched over $C$. Then the identity morphism of $X$ in $W$ is equal to the identity morphism of $X$ in the forgetful category."}
{"formal_statement": "theorem closure_image_mem_nhds {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{i : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1} (di : dense_inducing i) (hs : s \u2208 nhds a) :\n\tclosure (i '' s) \u2208 nhds (i a)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {i : \u03b1 \u2192 \u03b2} {s : set \u03b1} {a : \u03b1}, dense_inducing i \u2192 s \u2208 nhds a \u2192 closure (i '' s) \u2208 nhds (i a)", "decl_nm": "dense_inducing.closure_image_mem_nhds", "nl_statement_of_codex": "Let $i:X\\to Y$ be a dense inducing map. Let $s\\in\\mathcal{N}(a)$. Then $\\overline{i(s)}\\in\\mathcal{N}(i(a))$."}
{"formal_statement": "theorem mem_bind' {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b2} {f : filter \u03b1}\n\t{m : \u03b1 \u2192 filter \u03b2} :\n\ts \u2208 f.bind m \u2194 {a : \u03b1 | s \u2208 m a} \u2208 f", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : set \u03b2} {f : filter \u03b1} {m : \u03b1 \u2192 filter \u03b2}, s \u2208 f.bind m \u2194 {a : \u03b1 | s \u2208 m a} \u2208 f", "decl_nm": "filter.mem_bind'", "nl_statement_of_codex": "Let $f$ be a filter on a set $A$ and let $m:A\\to \\mathcal{P}(B)$ be a function. Then $s\\in f\\ast m$ if and only if $\\{a\\in A\\mid s\\in m(a)\\}\\in f$."}
{"formal_statement": "theorem mono_set_ae {\u03b1 E : Type*} [measurable_space \u03b1] [normed_group E]\n\t[measurable_space E] {f : \u03b1 \u2192 E} {s t : set \u03b1} {\u03bc : measure_theory.measure \u03b1}\n\t(h : measure_theory.integrable_on f t \u03bc) (hst : s \u2264\u1d50[\u03bc] t) :\n\tmeasure_theory.integrable_on f s \u03bc", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : normed_group E] [_inst_3 : measurable_space E] {f : \u03b1 \u2192 E} {s t : set \u03b1} {\u03bc : measure_theory.measure \u03b1}, measure_theory.integrable_on f t \u03bc \u2192 s \u2264\u1d50[\u03bc] t \u2192 measure_theory.integrable_on f s \u03bc", "decl_nm": "measure_theory.integrable_on.mono_set_ae", "nl_statement_of_codex": "Let $f:X\\to E$ be a measurable function on a measure space $(X,\\mathcal{A},\\mu)$. If $f$ is integrable on $t$ and $s\\subset t$, then $f$ is integrable on $s$."}
{"formal_statement": "theorem cast_id' {n : \u2115} :\n\tcoe = id", "decl_tp": "\u2200 {n : \u2115}, coe = id", "decl_nm": "zmod.cast_id'", "nl_statement_of_codex": "The cast function from $\\mathbb{N}$ to $\\mathbb{Z}$ is the identity function."}
{"formal_statement": "theorem minimal_period_pos_of_mem_periodic_pts {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1}\n\t{x : \u03b1} (hx : x \u2208 function.periodic_pts f) :\n\t0 < function.minimal_period f x", "decl_tp": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1}, x \u2208 function.periodic_pts f \u2192 0 < function.minimal_period f x", "decl_nm": "function.minimal_period_pos_of_mem_periodic_pts", "nl_statement_of_codex": "If $x$ is a periodic point of $f$, then the minimal period of $x$ is positive."}
{"formal_statement": "theorem sequence_mono {\u03b1 \u03b2 : Type*} [encodable \u03b1] [inhabited \u03b1] [preorder \u03b2]\n\t{f : \u03b1 \u2192 \u03b2} (hf : directed has_le.le f) :\n\tmonotone (f \u2218 directed.sequence f hf)", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : encodable \u03b1] [_inst_2 : inhabited \u03b1] [_inst_3 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : directed has_le.le f), monotone (f \u2218 directed.sequence f hf)", "decl_nm": "directed.sequence_mono", "nl_statement_of_codex": "Let $f:\\mathbb{N}\\to\\beta$ be a directed sequence. Then the sequence $f(n_i)$ is monotone."}
{"formal_statement": "theorem foldr_rec_on_nil {\u03b1 : Type u} {\u03b2 : Type v} {C : \u03b2 \u2192 Sort u_1} (op : \u03b1 \u2192 \u03b2 \u2192 \u03b2)\n\t(b : \u03b2) (hb : C b) (hl : \u03a0 (b : \u03b2), C b \u2192 \u03a0 (a : \u03b1), a \u2208 list.nil \u2192 C (op a b)) :\n\tlist.nil.foldr_rec_on op b hb hl = hb", "decl_tp": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {C : \u03b2 \u2192 Sort u_1} (op : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (hb : C b) (hl : \u03a0 (b : \u03b2), C b \u2192 \u03a0 (a : \u03b1), a \u2208 list.nil \u2192 C (op a b)), list.nil.foldr_rec_on op b hb hl = hb", "decl_nm": "list.foldr_rec_on_nil", "nl_statement_of_codex": "The foldr function on the empty list is the identity function."}
{"formal_statement": "theorem coe_map {G : Type*} [add_group G] {N : Type*} [add_group N] (f : G \u2192+ N)\n\t(K : add_subgroup G) :\n\t\u2191(add_subgroup.map f K) = \u21d1f '' \u2191K", "decl_tp": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {N : Type u_3} [_inst_3 : add_group N] (f : G \u2192+ N) (K : add_subgroup G), \u2191(add_subgroup.map f K) = \u21d1f '' \u2191K", "decl_nm": "add_subgroup.coe_map", "nl_statement_of_codex": "Let $G$ and $N$ be abelian groups and let $f:G\\to N$ be a group homomorphism. Let $K$ be a subgroup of $G$. Then $f(K)$ is a subgroup of $N$ and $f(K)=f(G)\\cap N$."}
{"formal_statement": "theorem closed_of_finite_dimensional {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type v} [normed_group E] [normed_space \ud835\udd5c E] [complete_space \ud835\udd5c] (s : submodule \ud835\udd5c E)\n\t[finite_dimensional \ud835\udd5c \u21a5s] :\n\tis_closed \u2191s", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type v} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] [_inst_11 : complete_space \ud835\udd5c] (s : submodule \ud835\udd5c E) [_inst_13 : finite_dimensional \ud835\udd5c \u21a5s], is_closed \u2191s", "decl_nm": "submodule.closed_of_finite_dimensional", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$. If $s$ is a finite dimensional subspace of $E$, then $s$ is closed."}
{"formal_statement": "theorem aeval_sum {R : Type u} {S : Type v} [comm_semiring R] [comm_semiring S]\n\t{\u03b9 : Type*} [algebra R S] (s : finset \u03b9) (f : \u03b9 \u2192 polynomial R) (g : S) :\n\t\u21d1(polynomial.aeval g) (s.sum (\u03bb (i : \u03b9), f i)) = s.sum (\u03bb (i : \u03b9), \u21d1(polynomial.aeval g)\n\t(f i))", "decl_tp": "\u2200 {R : Type u} {S : Type v} [_inst_3 : comm_semiring R] [_inst_8 : comm_semiring S] {\u03b9 : Type u_1} [_inst_9 : algebra R S] (s : finset \u03b9) (f : \u03b9 \u2192 polynomial R) (g : S), \u21d1(polynomial.aeval g) (s.sum (\u03bb (i : \u03b9), f i)) = s.sum (\u03bb (i : \u03b9), \u21d1(polynomial.aeval g) (f i))", "decl_nm": "polynomial.aeval_sum", "nl_statement_of_codex": "Let $R$ and $S$ be commutative rings, let $S$ be an $R$-algebra, and let $f_i:R\\to S$ be polynomials. Then\n$\\sum_{i\\in I}f_i$ is the polynomial $R\\to S$ given by $r\\mapsto \\sum_{i\\in I}f_i(r)$."}
{"formal_statement": "theorem star {R : Type u} [monoid R] [star_monoid R] {a : R} (\u1fb0 : is_unit a) :\n\tis_unit (has_star.star a)", "decl_tp": "\u2200 {R : Type u} [_inst_1 : monoid R] [_inst_2 : star_monoid R] {a : R}, is_unit a \u2192 is_unit (has_star.star a)", "decl_nm": "is_unit.star", "nl_statement_of_codex": "If $a$ is a unit in a star monoid $R$, then $a^*$ is a unit in $R$."}
{"formal_statement": "theorem mono_of_is_limit_parallel_pair {C : Type u} [category_theory.category C]\n\t{X Y : C} {f g : X \u27f6 Y} {c : category_theory.limits.cone (category_theory.limits.parallel_pair f g)}\n\t(i : category_theory.limits.is_limit c) :\n\tcategory_theory.mono (category_theory.limits.fork.\u03b9 c)", "decl_tp": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} {f g : X \u27f6 Y} {c : category_theory.limits.cone (category_theory.limits.parallel_pair f g)}, category_theory.limits.is_limit c \u2192 category_theory.mono (category_theory.limits.fork.\u03b9 c)", "decl_nm": "category_theory.limits.mono_of_is_limit_parallel_pair", "nl_statement_of_codex": "Let $C$ be a category, let $X, Y$ be objects of $C$, let $f, g:X\\to Y$ be morphisms, and let $c$ be a cone over the parallel pair $(f, g)$. If $c$ is a limit cone, then the morphism $c_X\\to c_Y$ is a monomorphism."}
{"formal_statement": "theorem algebra_map_eq_C {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] :\n\talgebra_map K (ratfunc K) = ratfunc.C", "decl_tp": "\u2200 {K : Type u} [hring : comm_ring K] [hdomain : is_domain K], algebra_map K (ratfunc K) = ratfunc.C", "decl_nm": "ratfunc.algebra_map_eq_C", "nl_statement_of_codex": "The algebra map from $K$ to the rational functions over $K$ is the constant function."}
{"formal_statement": "theorem not_lt_bot {\u03b1 : Type u} [preorder \u03b1] [order_bot \u03b1] {a : \u03b1} :\n\t\u00aca < \u22a5", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_3 : preorder \u03b1] [_inst_4 : order_bot \u03b1] {a : \u03b1}, \u00aca < \u22a5", "decl_nm": "not_lt_bot", "nl_statement_of_codex": "Let $\u03b1$ be a preorder with a bottom element. Then $a<\\bot$ is false for all $a\\in \u03b1$."}
{"formal_statement": "theorem closure_Union {L : first_order.language} {M : Type*} [L.Structure M]\n\t{\u03b9 : Sort u_4} (s : \u03b9 \u2192 set M) :\n\t\u21d1(first_order.language.substructure.closure L) (\u22c3 (i : \u03b9), s i) = \u2a06 (i : \u03b9), \u21d1(first_order.language.substructure.closure L)\n\t(s i)", "decl_tp": "\u2200 {L : first_order.language} {M : Type u_3} [_inst_1 : L.Structure M] {\u03b9 : Sort u_4} (s : \u03b9 \u2192 set M), \u21d1(first_order.language.substructure.closure L) (\u22c3 (i : \u03b9), s i) = \u2a06 (i : \u03b9), \u21d1(first_order.language.substructure.closure L) (s i)", "decl_nm": "first_order.language.substructure.closure_Union", "nl_statement_of_codex": "Let $L$ be a first-order language and let $M$ be a $L$-structure. Let $\\{s_i\\}_{i\\in I}$ be a family of subsets of $M$. Then the closure of $\\bigcup_{i\\in I}s_i$ is the union of the closures of the $s_i$."}
{"formal_statement": "theorem rec_heq {\u03b1 : Type uu} {\u03b2 : list \u03b1 \u2192 Sort u_1} {f : \u03a0 (a : \u03b1) (l : list \u03b1), \u03b2 l \u2192 \u03b2 (a :: l)}\n\t{b : \u03b2 list.nil} {l l' : list \u03b1} (hl : l ~ l') :\n\t(\u2200 {a : \u03b1} {l l' : list \u03b1} {b : \u03b2 l} {b' : \u03b2 l'},  b == b' \u2192 f a l b == f a l' b') \u2192 (\u2200 {a a' : \u03b1}\n\t{l : list \u03b1} {b : \u03b2 l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b)) \u2192 list.rec b f l == list.rec b f l'", "decl_tp": "\u2200 {\u03b1 : Type uu} {\u03b2 : list \u03b1 \u2192 Sort u_1} {f : \u03a0 (a : \u03b1) (l : list \u03b1), \u03b2 l \u2192 \u03b2 (a :: l)} {b : \u03b2 list.nil} {l l' : list \u03b1}, l ~ l' \u2192 (\u2200 {a : \u03b1} {l l' : list \u03b1} {b : \u03b2 l} {b' : \u03b2 l'}, l ~ l' \u2192 b == b' \u2192 f a l b == f a l' b') \u2192 (\u2200 {a a' : \u03b1} {l : list \u03b1} {b : \u03b2 l}, f a (a' :: l) (f a' l b) == f a' (a :: l) (f a l b)) \u2192 list.rec b f l == list.rec b f l'", "decl_nm": "list.perm.rec_heq", "nl_statement_of_codex": "Let $f$ be a function from $\\alpha\\times\\mathbb{N}$ to $\\beta$. Let $b$ be a function from $\\mathbb{N}$ to $\\beta$.\nThen $f(a,n)=b(n)$ if and only if $f(a,n)=b(n)$."}
{"formal_statement": "theorem ker_iff_mem_preimage {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} :\n\t(setoid.ker f).rel x y \u2194 x \u2208 f \u207b\u00b9' {f y}", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1}, (setoid.ker f).rel x y \u2194 x \u2208 f \u207b\u00b9' {f y}", "decl_nm": "setoid.ker_iff_mem_preimage", "nl_statement_of_codex": "Let $f:X\\to Y$ be a function. Then $x\\sim y$ if and only if $x\\in f^{-1}(f(y))$."}
{"formal_statement": "theorem has_fderiv_within_at_pi' {\ud835\udd5c : Type*} [nondiscrete_normed_field \ud835\udd5c]\n\t{E : Type*} [normed_group E] [normed_space \ud835\udd5c E] {x : E} {s : set E} {\u03b9 : Type*}\n\t[fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u03a0 (i : \u03b9), normed_group (F' i)] [\u03a0 (i : \u03b9), normed_space \ud835\udd5c (F' i)]\n\t{\u03a6 : E \u2192 \u03a0 (i : \u03b9), F' i} {\u03a6' : E \u2192L[\ud835\udd5c] \u03a0 (i : \u03b9), F' i} :\n\thas_fderiv_within_at \u03a6 \u03a6' s x \u2194 \u2200 (i : \u03b9), has_fderiv_within_at (\u03bb (x : E), \u03a6 x i)\n\t((continuous_linear_map.proj i).comp \u03a6') s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {x : E} {s : set E} {\u03b9 : Type u_6} [_inst_10 : fintype \u03b9] {F' : \u03b9 \u2192 Type u_7} [_inst_11 : \u03a0 (i : \u03b9), normed_group (F' i)] [_inst_12 : \u03a0 (i : \u03b9), normed_space \ud835\udd5c (F' i)] {\u03a6 : E \u2192 \u03a0 (i : \u03b9), F' i} {\u03a6' : E \u2192L[\ud835\udd5c] \u03a0 (i : \u03b9), F' i}, has_fderiv_within_at \u03a6 \u03a6' s x \u2194 \u2200 (i : \u03b9), has_fderiv_within_at (\u03bb (x : E), \u03a6 x i) ((continuous_linear_map.proj i).comp \u03a6') s x", "decl_nm": "has_fderiv_within_at_pi'", "nl_statement_of_codex": "Let $E$ be a normed space over a nondiscrete normed field $K$, let $F'$ be a family of normed spaces over $K$, and let $\\Phi:E\\to\\prod_{i\\in I}F'_i$ be a function. Then $\\Phi$ is differentiable at $x\\in E$ if and only if each component function $\\Phi_i:E\\to F'_i$ is differentiable at $x$."}
{"formal_statement": "theorem trim_apply {\u03b1 M : Type*} [add_comm_monoid M] [topological_space M]\n\t{m n : measurable_space \u03b1} (v : measure_theory.vector_measure \u03b1 M) (hle : m \u2264 n)\n\t(i : set \u03b1) :\n\t\u21d1(v.trim hle) i = ite (measurable_set i) (\u21d1v i) 0", "decl_tp": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_3 : add_comm_monoid M] [_inst_4 : topological_space M] {m n : measurable_space \u03b1} (v : measure_theory.vector_measure \u03b1 M) (hle : m \u2264 n) (i : set \u03b1), \u21d1(v.trim hle) i = ite (measurable_set i) (\u21d1v i) 0", "decl_nm": "measure_theory.vector_measure.trim_apply", "nl_statement_of_codex": "Let $v$ be a vector measure on a measurable space $(X,\\mathcal{M})$. Then for any $i\\in\\mathcal{M}$,\n$(v\\upharpoonright\\mathcal{M}_n)(i)=v(i)$ if $i\\in\\mathcal{M}_n$ and $(v\\upharpoonright\\mathcal{M}_n)(i)=0$ otherwise."}
{"formal_statement": "theorem coe_copy {R : Type u} {A : Type v} [comm_semiring R] [semiring A]\n\t[algebra R A] (S : subalgebra R A) (s : set A) (hs : s = \u2191S) :\n\t\u2191(S.copy s hs) = s", "decl_tp": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] (S : subalgebra R A) (s : set A) (hs : s = \u2191S), \u2191(S.copy s hs) = s", "decl_nm": "subalgebra.coe_copy", "nl_statement_of_codex": "Let $R$ be a commutative semiring, $A$ be a semiring, and $R\\to A$ be a ring homomorphism. Let $S$ be a subalgebra of $A$. Then the copy of $S$ in $A$ is equal to $S$."}
{"formal_statement": "theorem const_cpow {f : \u2102 \u2192 \u2102} {f' x c : \u2102} (hf : has_deriv_at f f' x)\n\t(h0 : c \u2260 0 \u2228 f x \u2260 0) :\n\thas_deriv_at (\u03bb (x : \u2102), c ^ f x) (c ^ f x * complex.log c * f') x", "decl_tp": "\u2200 {f : \u2102 \u2192 \u2102} {f' x c : \u2102}, has_deriv_at f f' x \u2192 c \u2260 0 \u2228 f x \u2260 0 \u2192 has_deriv_at (\u03bb (x : \u2102), c ^ f x) (c ^ f x * complex.log c * f') x", "decl_nm": "has_deriv_at.const_cpow", "nl_statement_of_codex": "Let $f$ be a complex function with derivative $f'$ at $x$. If $c\\neq 0$ or $f(x)\\neq 0$, then the function $g(x)=c^{f(x)}$ has derivative $g'(x)=c^{f(x)}f'(x)\\log(c)$ at $x$."}
{"formal_statement": "theorem pow_p_pf_zero {\u03b1 : Type u} [comm_semiring \u03b1] {ps : \u03b1} {qs qs' : \u2115}\n\t(ps_pf : ps = 0) (qs_pf : qs = qs'.succ) :\n\tps ^ qs = 0", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : comm_semiring \u03b1] {ps : \u03b1} {qs qs' : \u2115}, ps = 0 \u2192 qs = qs'.succ \u2192 ps ^ qs = 0", "decl_nm": "tactic.ring_exp.pow_p_pf_zero", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $p, q, q'\\in\\mathbb{N}$. If $p=0$ and $q=q'+1$, then $p^q=0$."}
{"formal_statement": "theorem ext {\u03b1 : Type*} [measurable_space \u03b1] {\u03bc\u2081 \u03bc\u2082 : measure_theory.measure \u03b1} :\n\t(\u2200 (s : set \u03b1), measurable_set s \u2192 \u21d1\u03bc\u2081 s = \u21d1\u03bc\u2082 s) \u2192 \u03bc\u2081 = \u03bc\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc\u2081 \u03bc\u2082 : measure_theory.measure \u03b1}, (\u2200 (s : set \u03b1), measurable_set s \u2192 \u21d1\u03bc\u2081 s = \u21d1\u03bc\u2082 s) \u2192 \u03bc\u2081 = \u03bc\u2082", "decl_nm": "measure_theory.measure.ext", "nl_statement_of_codex": "Let $\\mu_1$ and $\\mu_2$ be measures on a measurable space $(X,\\mathcal{S})$. Then $\\mu_1=\\mu_2$ if and only if $\\mu_1(A)=\\mu_2(A)$ for all $A\\in\\mathcal{S}$."}
{"formal_statement": "theorem Union_def {\u03b9 : Type*} {I : box_integral.box \u03b9} (\u03c0 : box_integral.tagged_prepartition I) :\n\t\u03c0.Union = \u22c3 (J : box_integral.box \u03b9) (H : J \u2208 \u03c0), \u2191J", "decl_tp": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} (\u03c0 : box_integral.tagged_prepartition I), \u03c0.Union = \u22c3 (J : box_integral.box \u03b9) (H : J \u2208 \u03c0), \u2191J", "decl_nm": "box_integral.tagged_prepartition.Union_def", "nl_statement_of_codex": "Let $I$ be a box in $\\mathbb{R}^n$ and let $\\pi$ be a tagged prepartition of $I$. Then $\\pi$ is the union of the boxes in $\\pi$."}
{"formal_statement": "theorem inv_neg {K : Type u} [division_ring K] {a : K} :\n\t(-a)\u207b\u00b9 = -a\u207b\u00b9", "decl_tp": "\u2200 {K : Type u} [_inst_1 : division_ring K] {a : K}, (-a)\u207b\u00b9 = -a\u207b\u00b9", "decl_nm": "inv_neg", "nl_statement_of_codex": "In a division ring, $(-a)^{-1}=-a^{-1}$."}
{"formal_statement": "theorem copy_eq {R : Type u} [non_assoc_semiring R] (S : subsemiring R)\n\t(s : set R) (hs : s = \u2191S) :\n\tS.copy s hs = S", "decl_tp": "\u2200 {R : Type u} [_inst_1 : non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = \u2191S), S.copy s hs = S", "decl_nm": "subsemiring.copy_eq", "nl_statement_of_codex": "Let $R$ be a non-associative semiring and let $S$ be a subsemiring of $R$. Let $s$ be a subset of $R$ such that $s=S$. Then $S$ is equal to the copy of $S$ in $s$."}
{"formal_statement": "theorem is_closed_univ {\u03b1 : Type u} [topological_space \u03b1] :\n\tis_closed set.univ", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1], is_closed set.univ", "decl_nm": "is_closed_univ", "nl_statement_of_codex": "The whole space $\\alpha$ is closed."}
{"formal_statement": "theorem braiding_inv_apply {X Y : Type u} {x : X} {y : Y} :\n\t(\u03b2_ X Y).inv (y, x) = (x, y)", "decl_tp": "\u2200 {X Y : Type u} {x : X} {y : Y}, (\u03b2_ X Y).inv (y, x) = (x, y)", "decl_nm": "category_theory.braiding_inv_apply", "nl_statement_of_codex": "The inverse of the braiding $\\beta_{X,Y}$ is given by $\\beta_{X,Y}^{-1}(y,x)=(x,y)$."}
{"formal_statement": "theorem type_fintype {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [is_well_order \u03b1 r]\n\t[fintype \u03b1] :\n\tordinal.type r = \u2191(fintype.card \u03b1)", "decl_tp": "\u2200 {\u03b1 : Type u_1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [_inst_1 : is_well_order \u03b1 r] [_inst_2 : fintype \u03b1], ordinal.type r = \u2191(fintype.card \u03b1)", "decl_nm": "ordinal.type_fintype", "nl_statement_of_codex": "If $r$ is a well-order on a finite set $A$, then the order type of $r$ is equal to the cardinality of $A$."}
{"formal_statement": "theorem app_hom_valid_glue {C : Type*} [category_theory.category C] {D : Type*}\n\t[category_theory.category D] {K : category_theory.grothendieck_topology D}\n\t{G : C \u2964 D} (H : category_theory.cover_dense K G) [category_theory.full G]\n\t{\u2131 : D\u1d52\u1d56 \u2964 Type v} {\u2131' : category_theory.SheafOfTypes K} (\u03b1 : G.op \u22d9 \u2131 \u27f6 G.op \u22d9 \u2131'.val)\n\t{X : D} {Y : C} (f : opposite.op X \u27f6 opposite.op (G.obj Y)) :\n\tcategory_theory.cover_dense.types.app_hom H \u03b1 X \u226b \u2131'.val.map f = \u2131.map f \u226b \u03b1.app (opposite.op Y)", "decl_tp": "\u2200 {C : Type u_1} [_inst_1 : category_theory.category C] {D : Type u_3} [_inst_2 : category_theory.category D] {K : category_theory.grothendieck_topology D} {G : C \u2964 D} (H : category_theory.cover_dense K G) [_inst_5 : category_theory.full G] {\u2131 : D\u1d52\u1d56 \u2964 Type v} {\u2131' : category_theory.SheafOfTypes K} (\u03b1 : G.op \u22d9 \u2131 \u27f6 G.op \u22d9 \u2131'.val) {X : D} {Y : C} (f : opposite.op X \u27f6 opposite.op (G.obj Y)), category_theory.cover_dense.types.app_hom H \u03b1 X \u226b \u2131'.val.map f = \u2131.map f \u226b \u03b1.app (opposite.op Y)", "decl_nm": "category_theory.cover_dense.types.app_hom_valid_glue", "nl_statement_of_codex": "Let $C$ and $D$ be categories, let $K$ be a Grothendieck topology on $D$, let $G:C\\to D$ be a functor, and let $H$ be a cover dense functor. Let $\\mathcal{F}$ be a sheaf of types on $D$ and let $\\mathcal{F}'$ be a sheaf of types on $K$. Let $\\alpha:\\mathcal{F}\\to\\mathcal{F}'$ be a natural transformation. Let $X$ be an object of $D$ and let $Y$ be an object of $C$. Then the following diagram commutes:\n$$\\begin"}
{"formal_statement": "theorem inter {\u03b1 \u03b2 : Type*} [topological_space \u03b1] [topological_space \u03b2]\n\t{e : local_homeomorph \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2} {s' : set \u03b1} {t' : set \u03b2}\n\t(h : e.is_image s t) (h' : e.is_image s' t') :\n\te.is_image (s \u2229 s') (t \u2229 t')", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {e : local_homeomorph \u03b1 \u03b2} {s : set \u03b1} {t : set \u03b2} {s' : set \u03b1} {t' : set \u03b2}, e.is_image s t \u2192 e.is_image s' t' \u2192 e.is_image (s \u2229 s') (t \u2229 t')", "decl_nm": "local_homeomorph.is_image.inter", "nl_statement_of_codex": "Let $e:X\\to Y$ be a local homeomorphism. If $e(s)=t$ and $e(s')=t'$, then $e(s\\cap s')=t\\cap t'$."}
{"formal_statement": "theorem sub {\u03b1 : Type u} {G : Type w} [topological_space G] [has_sub G]\n\t[has_continuous_sub G] {f g : \u03b1 \u2192 G} {l : filter \u03b1} {a b : G} (hf : filter.tendsto f l (nhds a))\n\t(hg : filter.tendsto g l (nhds b)) :\n\tfilter.tendsto (\u03bb (x : \u03b1), f x - g x) l (nhds (a - b))", "decl_tp": "\u2200 {\u03b1 : Type u} {G : Type w} [_inst_1 : topological_space G] [_inst_2 : has_sub G] [_inst_3 : has_continuous_sub G] {f g : \u03b1 \u2192 G} {l : filter \u03b1} {a b : G}, filter.tendsto f l (nhds a) \u2192 filter.tendsto g l (nhds b) \u2192 filter.tendsto (\u03bb (x : \u03b1), f x - g x) l (nhds (a - b))", "decl_nm": "filter.tendsto.sub", "nl_statement_of_codex": "Let $G$ be a topological group and let $f,g:\\alpha\\to G$ be functions. If $f$ and $g$ converge to $a$ and $b$ respectively, then $f-g$ converges to $a-b$."}
{"formal_statement": "theorem integral_has_deriv_at_left {E : Type*} [measurable_space E] [normed_group E]\n\t[topological_space.second_countable_topology E] [complete_space E] [normed_space \u211d E]\n\t[borel_space E] {f : \u211d \u2192 E} {a b : \u211d} (hf : interval_integrable f measure_theory.measure_space.volume a b)\n\t(hmeas : measurable_at_filter f (nhds a) measure_theory.measure_space.volume)\n\t(ha : continuous_at f a) :\n\thas_deriv_at (\u03bb (u : \u211d), \u222b (x : \u211d) in u..b, f x) (-f a) a", "decl_tp": "\u2200 {E : Type u_4} [_inst_3 : measurable_space E] [_inst_4 : normed_group E] [_inst_5 : topological_space.second_countable_topology E] [_inst_6 : complete_space E] [_inst_7 : normed_space \u211d E] [_inst_8 : borel_space E] {f : \u211d \u2192 E} {a b : \u211d}, interval_integrable f measure_theory.measure_space.volume a b \u2192 measurable_at_filter f (nhds a) measure_theory.measure_space.volume \u2192 continuous_at f a \u2192 has_deriv_at (\u03bb (u : \u211d), \u222b (x : \u211d) in u..b, f x) (-f a) a", "decl_nm": "interval_integral.integral_has_deriv_at_left", "nl_statement_of_codex": "Let $f: \\mathbb{R}\\to E$ be a measurable function. If $f$ is integrable on $[a,b]$ and continuous at $a$, then the function $g(u)=\\int_u^b f(x)dx$ has a derivative at $a$."}
{"formal_statement": "theorem neg_coe {R M : Type*} [ring R] [add_comm_group M] [module R M]\n\t(p : submodule R M) :\n\t-\u2191p = \u2191p", "decl_tp": "\u2200 {R : Type u_1} {M : Type u_9} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_5 : module R M] (p : submodule R M), -\u2191p = \u2191p", "decl_nm": "submodule.neg_coe", "nl_statement_of_codex": "Let $R$ be a ring and $M$ be an $R$-module. Then $-p=p$ for any submodule $p$ of $M$."}
{"formal_statement": "theorem deriv_const {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v}\n\t[normed_group F] [normed_space \ud835\udd5c F] (x : \ud835\udd5c) (c : F) :\n\tderiv (\u03bb (x : \ud835\udd5c), c) x = 0", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] (x : \ud835\udd5c) (c : F), deriv (\u03bb (x : \ud835\udd5c), c) x = 0", "decl_nm": "deriv_const", "nl_statement_of_codex": "The derivative of the constant function $f(x)=c$ is $0$."}
{"formal_statement": "theorem normalize_lcm {\u03b1 : Type*} [cancel_comm_monoid_with_zero \u03b1] [normalized_gcd_monoid \u03b1]\n\t(a b : \u03b1) :\n\t\u21d1normalize (gcd_monoid.lcm a b) = gcd_monoid.lcm a b", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] (a b : \u03b1), \u21d1normalize (gcd_monoid.lcm a b) = gcd_monoid.lcm a b", "decl_nm": "normalize_lcm", "nl_statement_of_codex": "Let $R$ be a commutative monoid with zero and let $R^*$ be the set of nonzero elements of $R$.\nThen the normalization map $R^*\\to R^*$ is the identity map."}
{"formal_statement": "theorem forall\u2082_cons {\u03b1 \u03b2 : Type*} {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {a : \u03b1} {b : \u03b2} {l\u2081 : list \u03b1}\n\t{l\u2082 : list \u03b2} :\n\tlist.forall\u2082 R (a :: l\u2081) (b :: l\u2082) \u2194 R a b \u2227 list.forall\u2082 R l\u2081 l\u2082", "decl_tp": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {a : \u03b1} {b : \u03b2} {l\u2081 : list \u03b1} {l\u2082 : list \u03b2}, list.forall\u2082 R (a :: l\u2081) (b :: l\u2082) \u2194 R a b \u2227 list.forall\u2082 R l\u2081 l\u2082", "decl_nm": "list.forall\u2082_cons", "nl_statement_of_codex": "Let $R$ be a relation on $A\\times B$. Then $(a_1,b_1),\\ldots,(a_n,b_n)\\in R$ if and only if $(a_1,b_1)\\in R$ and $(a_i,b_i)\\in R$ for $i=2,\\ldots,n$."}
{"formal_statement": "theorem map_add {R S : Type*} [has_mul R] [has_add R] [has_mul S] [has_add S]\n\t(e : R \u2243+* S) (x y : R) :\n\t\u21d1e (x + y) = \u21d1e x + \u21d1e y", "decl_tp": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : has_mul R] [_inst_2 : has_add R] [_inst_3 : has_mul S] [_inst_4 : has_add S] (e : R \u2243+* S) (x y : R), \u21d1e (x + y) = \u21d1e x + \u21d1e y", "decl_nm": "ring_equiv.map_add", "nl_statement_of_codex": "Let $R$ and $S$ be rings and let $e:R\\to S$ be an additive isomorphism. Then $e(x+y)=e(x)+e(y)$ for all $x,y\\in R$."}
{"formal_statement": "theorem union_comm {\u03b1 : Type*} [decidable_eq \u03b1] (s\u2081 s\u2082 : finset \u03b1) :\n\ts\u2081 \u222a s\u2082 = s\u2082 \u222a s\u2081", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s\u2081 s\u2082 : finset \u03b1), s\u2081 \u222a s\u2082 = s\u2082 \u222a s\u2081", "decl_nm": "finset.union_comm", "nl_statement_of_codex": "The union of two finite sets is commutative."}
{"formal_statement": "theorem add_eq_top {a b : ennreal} :\n\ta + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4", "decl_tp": "\u2200 {a b : ennreal}, a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4", "decl_nm": "ennreal.add_eq_top", "nl_statement_of_codex": "$a+b=\\infty$ if and only if $a=\\infty$ or $b=\\infty$."}
{"formal_statement": "theorem mul {M \u03b1 : Type*} [measurable_space M] [has_mul M] [measurable_space \u03b1]\n\t[has_measurable_mul\u2082 M] {f g : \u03b1 \u2192 M} (hf : measurable f) (hg : measurable g) :\n\tmeasurable (\u03bb (a : \u03b1), f a * g a)", "decl_tp": "\u2200 {M : Type u_1} {\u03b1 : Type u_2} [_inst_1 : measurable_space M] [_inst_2 : has_mul M] [_inst_3 : measurable_space \u03b1] [_inst_4 : has_measurable_mul\u2082 M] {f g : \u03b1 \u2192 M}, measurable f \u2192 measurable g \u2192 measurable (\u03bb (a : \u03b1), f a * g a)", "decl_nm": "measurable.mul", "nl_statement_of_codex": "Let $M$ be a measurable space and let $f,g:X\\to M$ be measurable functions. Then the function $h:X\\to M$ defined by $h(x)=f(x)g(x)$ is measurable."}
{"formal_statement": "theorem prim_part_ne_zero {R : Type*} [comm_ring R] [is_domain R] [normalized_gcd_monoid R]\n\t(p : polynomial R) :\n\tp.prim_part \u2260 0", "decl_tp": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : normalized_gcd_monoid R] (p : polynomial R), p.prim_part \u2260 0", "decl_nm": "polynomial.prim_part_ne_zero", "nl_statement_of_codex": "The primitive part of a polynomial is nonzero."}
{"formal_statement": "theorem t0_space_of_injective_of_continuous {\u03b1 \u03b2 : Type u} [topological_space \u03b1]\n\t[topological_space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : function.injective f) (hf' : continuous f) :\n\t\u2200 [t0_space \u03b2], t0_space \u03b1", "decl_tp": "\u2200 {\u03b1 \u03b2 : Type u} [_inst_2 : topological_space \u03b1] [_inst_3 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, function.injective f \u2192 continuous f \u2192 \u2200 [_inst_4 : t0_space \u03b2], t0_space \u03b1", "decl_nm": "t0_space_of_injective_of_continuous", "nl_statement_of_codex": "Let $f:X\\to Y$ be a continuous injective function. Then $X$ is a $T_0$ space if and only if $Y$ is a $T_0$ space."}
{"formal_statement": "theorem mul_left_self_sup {R : Type u} [comm_semiring R] {I J : ideal R} :\n\tJ * I \u2294 I = I", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {I J : ideal R}, J * I \u2294 I = I", "decl_nm": "ideal.mul_left_self_sup", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $I$ and $J$ be ideals of $R$. Then $JI+I=I$."}
{"formal_statement": "theorem top_sub_coe {r : nnreal} :\n\t\u22a4 - \u2191r = \u22a4", "decl_tp": "\u2200 {r : nnreal}, \u22a4 - \u2191r = \u22a4", "decl_nm": "ennreal.top_sub_coe", "nl_statement_of_codex": "For any nonnegative real number $r$, $\\infty-r=\\infty$."}
{"formal_statement": "theorem to_pequiv_mul_matrix {m n : Type*} {\u03b1 : Type v} [fintype m] [decidable_eq m]\n\t[semiring \u03b1] (f : m \u2243 m) (M : matrix m n \u03b1) :\n\tf.to_pequiv.to_matrix.mul M = \u03bb (i : m), M (\u21d1f i)", "decl_tp": "\u2200 {m : Type u_3} {n : Type u_4} {\u03b1 : Type v} [_inst_1 : fintype m] [_inst_2 : decidable_eq m] [_inst_3 : semiring \u03b1] (f : m \u2243 m) (M : matrix m n \u03b1), f.to_pequiv.to_matrix.mul M = \u03bb (i : m), M (\u21d1f i)", "decl_nm": "pequiv.to_pequiv_mul_matrix", "nl_statement_of_codex": "Let $f:m\\to m$ be a bijection. Then the matrix of $f$ is the matrix of the linear map $M\\mapsto M\\circ f$."}
{"formal_statement": "theorem card_filter_gt {n : \u2115} (a : fin n) :\n\t(finset.filter (\u03bb (j : fin n), j < a) finset.univ).card = \u2191a", "decl_tp": "\u2200 {n : \u2115} (a : fin n), (finset.filter (\u03bb (j : fin n), j < a) finset.univ).card = \u2191a", "decl_nm": "fin.card_filter_gt", "nl_statement_of_codex": "The cardinality of the set of all $j\\in\\{1,\\ldots,n\\}$ such that $j<a$ is $a$."}
{"formal_statement": "theorem nat_degree_C_mul_eq_of_mul_ne_zero {R : Type u} {a : R} [semiring R]\n\t{p : polynomial R} (h : a * p.leading_coeff \u2260 0) :\n\t(\u21d1polynomial.C a * p).nat_degree = p.nat_degree", "decl_tp": "\u2200 {R : Type u} {a : R} [_inst_1 : semiring R] {p : polynomial R}, a * p.leading_coeff \u2260 0 \u2192 (\u21d1polynomial.C a * p).nat_degree = p.nat_degree", "decl_nm": "polynomial.nat_degree_C_mul_eq_of_mul_ne_zero", "nl_statement_of_codex": "Let $R$ be a semiring, $a\\in R$, and $p\\in R[x]$. If $ap_n\\neq 0$, then $\\deg(ap)=\\deg(p)$."}
{"formal_statement": "theorem exp_le_exp {x y : \u211d} :\n\treal.exp x \u2264 real.exp y \u2194 x \u2264 y", "decl_tp": "\u2200 {x y : \u211d}, real.exp x \u2264 real.exp y \u2194 x \u2264 y", "decl_nm": "real.exp_le_exp", "nl_statement_of_codex": "For all $x,y\\in\\mathbb{R}$, $e^x\\leq e^y$ if and only if $x\\leq y$."}
{"formal_statement": "theorem default_coe_singleton {\u03b1 : Type u} (x : \u03b1) :\n\tinhabited.default \u21a5{x} = \u27e8x, _\u27e9", "decl_tp": "\u2200 {\u03b1 : Type u} (x : \u03b1), inhabited.default \u21a5{x} = \u27e8x, _\u27e9", "decl_nm": "set.default_coe_singleton", "nl_statement_of_codex": "The default element of the singleton set $\\{x\\}$ is $x$."}
{"formal_statement": "theorem map_mul {\u03b1 : Type u} [add_group \u03b1] {x y : free_group \u03b1} :\n\t(x * y).sum = x.sum + y.sum", "decl_tp": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] {x y : free_group \u03b1}, (x * y).sum = x.sum + y.sum", "decl_nm": "free_group.sum.map_mul", "nl_statement_of_codex": "Let $x,y$ be elements of the free group on $\u03b1$. Then the sum of $x$ and $y$ is the sum of $x*y$."}
{"formal_statement": "theorem first_loses_of_equiv {G H : pgame} (h : G.equiv H) (hGp : G.first_loses) :\n\tH.first_loses", "decl_tp": "\u2200 {G H : pgame}, G.equiv H \u2192 G.first_loses \u2192 H.first_loses", "decl_nm": "pgame.first_loses_of_equiv", "nl_statement_of_codex": "If $G$ and $H$ are equivalent games and $G$ is a first player win, then $H$ is a first player win."}
{"formal_statement": "theorem one_one_reducible_refl {\u03b1 : Type*} [primcodable \u03b1] (p : \u03b1 \u2192 Prop) :\n\tp \u2264\u2081 p", "decl_tp": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1] (p : \u03b1 \u2192 Prop), p \u2264\u2081 p", "decl_nm": "one_one_reducible_refl", "nl_statement_of_codex": "The relation $p$ is reducible to itself."}
{"formal_statement": "theorem sum {\ud835\udd5c : Type u} [nondiscrete_normed_field \ud835\udd5c] {F : Type v} [normed_group F]\n\t[normed_space \ud835\udd5c F] {x : \ud835\udd5c} {s : set \ud835\udd5c} {\u03b9 : Type*} {u : finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F}\n\t{A' : \u03b9 \u2192 F} :\n\t(\u2200 (i : \u03b9), i \u2208 u \u2192 has_deriv_within_at (A i) (A' i) s x) \u2192 has_deriv_within_at (\u03bb (y : \ud835\udd5c), u.sum (\u03bb (i : \u03b9), A i y))\n\t(u.sum (\u03bb (i : \u03b9), A' i)) s x", "decl_tp": "\u2200 {\ud835\udd5c : Type u} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {F : Type v} [_inst_2 : normed_group F] [_inst_3 : normed_space \ud835\udd5c F] {x : \ud835\udd5c} {s : set \ud835\udd5c} {\u03b9 : Type u_1} {u : finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}, (\u2200 (i : \u03b9), i \u2208 u \u2192 has_deriv_within_at (A i) (A' i) s x) \u2192 has_deriv_within_at (\u03bb (y : \ud835\udd5c), u.sum (\u03bb (i : \u03b9), A i y)) (u.sum (\u03bb (i : \u03b9), A' i)) s x", "decl_nm": "has_deriv_within_at.sum", "nl_statement_of_codex": "Let $F$ be a normed group and let $A_i: \\mathbb{R}\\to F$ be differentiable functions. Then the function $A: \\mathbb{R}\\to F$ defined by $A(x)=\\sum_{i\\in I} A_i(x)$ is differentiable."}
{"formal_statement": "theorem mul_le_inf {R : Type u} [comm_semiring R] {I J : ideal R} :\n\tI * J \u2264 I \u2293 J", "decl_tp": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {I J : ideal R}, I * J \u2264 I \u2293 J", "decl_nm": "ideal.mul_le_inf", "nl_statement_of_codex": "Let $R$ be a commutative semiring and let $I$ and $J$ be ideals of $R$. Then $IJ\\subseteq I\\cap J$."}
{"formal_statement": "theorem congr {\u03b1 E F : Type*} [has_norm E] [has_norm F] {f\u2081 f\u2082 : \u03b1 \u2192 E}\n\t{g\u2081 g\u2082 : \u03b1 \u2192 F} {l : filter \u03b1} (h : asymptotics.is_o f\u2081 g\u2081 l) :\n\t(\u2200 (x : \u03b1), f\u2081 x = f\u2082 x) \u2192 (\u2200 (x : \u03b1), g\u2081 x = g\u2082 x) \u2192  asymptotics.is_o f\u2082 g\u2082 l", "decl_tp": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {f\u2081 f\u2082 : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F} {l : filter \u03b1}, (\u2200 (x : \u03b1), f\u2081 x = f\u2082 x) \u2192 (\u2200 (x : \u03b1), g\u2081 x = g\u2082 x) \u2192 asymptotics.is_o f\u2081 g\u2081 l \u2192 asymptotics.is_o f\u2082 g\u2082 l", "decl_nm": "asymptotics.is_o.congr", "nl_statement_of_codex": "Let $E$ and $F$ be normed spaces, let $f_1, f_2: \\alpha \\to E$ and $g_1, g_2: \\alpha \\to F$. If $f_1$ is asymptotically equal to $g_1$ with respect to the filter $l$, then $f_2$ is asymptotically equal to $g_2$ with respect to the filter $l$ if $f_1=f_2$ and $g_1=g_2$."}
{"formal_statement": "theorem const_sub {G \u03b1 : Type*} [measurable_space G] [has_sub G] [measurable_space \u03b1]\n\t[has_measurable_sub G] {f : \u03b1 \u2192 G} {\u03bc : measure_theory.measure \u03b1} (hf : ae_measurable f \u03bc) :\n\t\u2200 (c : G), ae_measurable (\u03bb (x : \u03b1), c - f x) \u03bc", "decl_tp": "\u2200 {G : Type u_1} {\u03b1 : Type u_2} [_inst_1 : measurable_space G] [_inst_2 : has_sub G] [_inst_3 : measurable_space \u03b1] [_inst_4 : has_measurable_sub G] {f : \u03b1 \u2192 G} {\u03bc : measure_theory.measure \u03b1}, ae_measurable f \u03bc \u2192 \u2200 (c : G), ae_measurable (\u03bb (x : \u03b1), c - f x) \u03bc", "decl_nm": "ae_measurable.const_sub", "nl_statement_of_codex": "Let $G$ be a measurable space with a measurable subtraction operation. Let $f:X\\to G$ be a measurable function. Then the function $g:X\\to G$ defined by $g(x)=c-f(x)$ is measurable for any $c\\in G$."}
{"formal_statement": "theorem single_neg {\u03b9 : Type u} [dec : decidable_eq \u03b9] {\u03b2 : \u03b9 \u2192 Type v}\n\t[\u03a0 (i : \u03b9), add_group (\u03b2 i)] (i : \u03b9) (x : \u03b2 i) :\n\tdfinsupp.single i (-x) = -dfinsupp.single i x", "decl_tp": "\u2200 {\u03b9 : Type u} [dec : decidable_eq \u03b9] {\u03b2 : \u03b9 \u2192 Type v} [_inst_2 : \u03a0 (i : \u03b9), add_group (\u03b2 i)] (i : \u03b9) (x : \u03b2 i), dfinsupp.single i (-x) = -dfinsupp.single i x", "decl_nm": "dfinsupp.single_neg", "nl_statement_of_codex": "Let $i$ be an index and $x$ an element of the additive group indexed by $i$. Then the singleton indexed by $i$ with value $-x$ is equal to the additive inverse of the singleton indexed by $i$ with value $x$."}
{"formal_statement": "theorem inv_int_cast_smul_eq {E : Type*} (R S : Type*) [add_comm_group E]\n\t[division_ring R] [division_ring S] [module R E] [module S E] (n : \u2124)\n\t(x : E) :\n\t(\u2191n)\u207b\u00b9 \u2022 x = (\u2191n)\u207b\u00b9 \u2022 x", "decl_tp": "\u2200 {E : Type u_1} (R : Type u_2) (S : Type u_3) [_inst_1 : add_comm_group E] [_inst_2 : division_ring R] [_inst_3 : division_ring S] [_inst_4 : module R E] [_inst_5 : module S E] (n : \u2124) (x : E), (\u2191n)\u207b\u00b9 \u2022 x = (\u2191n)\u207b\u00b9 \u2022 x", "decl_nm": "inv_int_cast_smul_eq", "nl_statement_of_codex": "Let $E$ be an abelian group, let $R$ and $S$ be division rings, and let $E$ be a module over $R$ and $S$. Then $(n^{-1})\\cdot x = (n^{-1})\\cdot x$ for all $n\\in\\mathbb{Z}$ and $x\\in E$."}
